focal_method,test_prefix,docstring
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test011() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<DeserializationFeature> class0 = DeserializationFeature.class;
    typeFactory0.constructType((Type) class0, (Class<?>) class0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test022() throws Throwable {
    TypeFactory.rawClass((Type) null);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"/*
    /**********************************************************
    /* Static methods for non-instance-specific functionality
    /**********************************************************
     */
/**
 * Method for constructing a marker type that indicates missing generic
 * type information, which is handled same as simple type for
 * <code>java.lang.Object</code>.
 */
public static JavaType unknownType() {
    return defaultInstance()._unknownType();
}","public void test033() throws Throwable {
    TypeFactory.unknownType();
}",""
"public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {
    return constructCollectionLikeType(collectionClass, unknownType());
}","public void test044() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    typeFactory0.constructRawCollectionLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Collection-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public TypeFactory withCache(LRUMap<Object, JavaType> cache) {
    return new TypeFactory(cache, _parser, _modifiers, _classLoader);
}","public void test077() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.withCache((LRUMap<Object, JavaType>) null);
}","/**
 * Mutant factory method that will construct new {@link TypeFactory} with
 * identical settings except for different cache; most likely one with
 * bigger maximum size.
 *
 * @since 2.8
 */"
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test088() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructFromCanonical("">&En7*n.]1-wrU,"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test099() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    typeFactory0.constructType((Type) class0, (Class<?>) class0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {
    JavaType match = type.findSuperType(expType);
    if (match == null) {
        return NO_TYPES;
    }
    return match.getBindings().typeParameterArray();
}","public void test1111() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    Class<MapperFeature> class0 = MapperFeature.class;
    typeFactory0.findTypeParameters((JavaType) simpleType0, (Class<?>) class0);
}","/**
 * Method that is to figure out actual type parameters that given
 * class binds to generic types defined by given (generic)
 * interface or class.
 * This could mean, for example, trying to figure out
 * key and value types for Map implementations.
 *
 * @param type Sub-type (leaf type) that implements <code>expType</code>
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test1212() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    TypeFactory typeFactory1 = typeFactory0.withClassLoader(classLoader0);
    typeFactory1.findClass(""5&7$IuY"");
}",""
"@Override
public ArrayType withStaticTyping() {
    if (_asStatic) {
        return this;
    }
    return new ArrayType(_componentType.withStaticTyping(), _bindings, _emptyArray, _valueHandler, _typeHandler, true);
}","public void test1313() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    ArrayType arrayType0 = typeFactory0.constructArrayType((JavaType) simpleType0);
    arrayType0.withStaticTyping();
}",""
"// since 2.8
@Deprecated
public JavaType uncheckedSimpleType(Class<?> cls) {
    // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
    return _constructSimple(cls, EMPTY_BINDINGS, null, null);
}","public void test1414() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    typeFactory0.uncheckedSimpleType(class0);
}","/**
 *  Method that use by core Databind functionality, and that should NOT be called
 *  by application code outside databind package.
 * <p>
 *  Unchecked here not only means that no checks are made as to whether given class
 *  might be non-simple type (like {@link CollectionType}) but also that most of supertype
 *  information is not gathered. This means that unless called on primitive types or
 *  {@link java.lang.String}, results are probably not what you want to use.
 *
 *  @deprecated Since 2.8, to indicate users should never call this method.
 */"
"// since 2.8
@Deprecated
public JavaType uncheckedSimpleType(Class<?> cls) {
    // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
    return _constructSimple(cls, EMPTY_BINDINGS, null, null);
}","public void test1515() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Object> class0 = Object.class;
    typeFactory0.uncheckedSimpleType(class0);
}","/**
 *  Method that use by core Databind functionality, and that should NOT be called
 *  by application code outside databind package.
 * <p>
 *  Unchecked here not only means that no checks are made as to whether given class
 *  might be non-simple type (like {@link CollectionType}) but also that most of supertype
 *  information is not gathered. This means that unless called on primitive types or
 *  {@link java.lang.String}, results are probably not what you want to use.
 *
 *  @deprecated Since 2.8, to indicate users should never call this method.
 */"
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test1717() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    TypeFactory.rawClass(simpleType0);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"@Deprecated
public JavaType constructType(Type type, JavaType contextType) {
    TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings();
    return _fromAny(null, type, bindings);
}","public void test1818() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    JavaType javaType0 = TypeFactory.unknownType();
    typeFactory0.constructType((Type) javaType0, javaType0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test1919() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LinkedList> class0 = LinkedList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    typeFactory0.constructType((Type) collectionType0, (Class<?>) class0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public MapType constructRawMapType(Class<? extends Map> mapClass) {
    return constructMapType(mapClass, unknownType(), unknownType());
}","public void test2020() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    // Undeclared exception!
    try {
        typeFactory0.constructRawMapType(class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class java.util.Properties with 2 type parameters: class expects 0
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}","/**
 *  Method that can be used to construct ""raw"" Map type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test2121() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.constructFromCanonical(""char"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"protected Class<?> _findPrimitive(String className) {
    if (""int"".equals(className))
        return Integer.TYPE;
    if (""long"".equals(className))
        return Long.TYPE;
    if (""float"".equals(className))
        return Float.TYPE;
    if (""double"".equals(className))
        return Double.TYPE;
    if (""boolean"".equals(className))
        return Boolean.TYPE;
    if (""byte"".equals(className))
        return Byte.TYPE;
    if (""char"".equals(className))
        return Character.TYPE;
    if (""short"".equals(className))
        return Short.TYPE;
    if (""void"".equals(className))
        return Void.TYPE;
    return null;
}","public void test2626() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0._findPrimitive(""HmG"");
}",""
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test2727() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    TypeModifier typeModifier0 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    doReturn((JavaType) null).when(typeModifier0).modifyType(any(com.fasterxml.jackson.databind.JavaType.class), any(java.lang.reflect.Type.class), any(com.fasterxml.jackson.databind.type.TypeBindings.class), any(com.fasterxml.jackson.databind.type.TypeFactory.class));
    doReturn((String) null).when(typeModifier0).toString();
    TypeFactory typeFactory1 = typeFactory0.withModifier(typeModifier0);
    TypeModifier typeModifier1 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    typeFactory1.withModifier(typeModifier1);
    Class<Integer> class0 = Integer.TYPE;
    // Undeclared exception!
    try {
        typeFactory1.constructType((Type) class0, (Class<?>) class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // TypeModifier Mock for TypeModifier, hashCode: 2021360630 (of type com.fasterxml.jackson.databind.type.TypeModifier$MockitoMock$1846850338) return null for type [simple type, class int]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test2929() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Integer> class0 = Integer.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public TypeFactory withModifier(TypeModifier mod) {
    LRUMap<Object, JavaType> typeCache = _typeCache;
    TypeModifier[] mods;
    if (mod == null) {
        // mostly for unit tests
        mods = null;
        // 30-Jun-2016, tatu: for some reason expected semantics are to clear cache
        //    in this case; can't recall why, but keeping the same
        typeCache = null;
    } else if (_modifiers == null) {
        mods = new TypeModifier[] { mod };
    } else {
        mods = ArrayBuilders.insertInListNoDup(_modifiers, mod);
    }
    return new TypeFactory(typeCache, _parser, mods, _classLoader);
}","public void test3030() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.withModifier((TypeModifier) null);
}",""
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test3131() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<CollectionType> class0 = CollectionType.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"@Deprecated
public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget, JavaType[] parameterTypes) {
    return constructSimpleType(rawType, parameterTypes);
}","public void test3232() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Object> class0 = Object.class;
    JavaType[] javaTypeArray0 = new JavaType[0];
    typeFactory0.constructSimpleType(class0, class0, javaTypeArray0);
}","/**
 * Method for constructing a type instance with specified parameterization.
 *
 * @since 2.6
 *
 * @deprecated Since 2.7
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test3434() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Properties> class0 = Properties.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test3535() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.constructFromCanonical(""com.fasterxml.jackson.databind.ser.std.AtomicReferenceSerializer"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {
    return // no bindings
    ReferenceType.// no bindings
    construct(// no bindings
    rawType, // no bindings
    null, // or super-class, interfaces?
    null, // or super-class, interfaces?
    null, referredType);
}","public void test3838() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    Class<Object> class0 = Object.class;
    typeFactory0.constructReferenceType(class0, simpleType0);
}","/**
 * @since 2.6
 */"
"public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test3939() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<String> class0 = String.class;
    // Undeclared exception!
    try {
        typeFactory0.constructGeneralizedType(simpleType0, class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Class java.lang.String not a super-type of [simple type, class long]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test4141() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ArrayList<MapperFeature> arrayList0 = new ArrayList<MapperFeature>();
    objectMapper0.readerForUpdating(arrayList0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test4242() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""float"");
}",""
"public JavaType constructType(TypeReference<?> typeRef) {
    // 19-Oct-2015, tatu: Simpler variant like so should work
    return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);
    // but if not, due to funky sub-classing, type variables, what follows
    // is a more complete processing a la Java ClassMate.
    /*
        final Class<?> refdRawType = typeRef.getClass();
        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);
        JavaType genType = type.findSuperType(TypeReference.class);
        if (genType == null) { // sanity check; shouldn't occur
            throw new IllegalArgumentException(""Unparameterized GenericType instance (""+refdRawType.getName()+"")"");
        }
        TypeBindings b = genType.getBindings();
        JavaType[] params = b.typeParameterArray();
        if (params.length == 0) {
            throw new IllegalArgumentException(""Unparameterized GenericType instance (""+refdRawType.getName()+"")"");
        }
        return params[0];
        */
}","public void test4343() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.constructType((TypeReference<?>) null);
}",""
"public void clearCache() {
    _typeCache.clear();
}","public void test4444() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.clearCache();
}","/**
 * Method that will clear up any cached type definitions that may
 * be cached by this {@link TypeFactory} instance.
 * This method should not be commonly used, that is, only use it
 * if you know there is a problem with retention of type definitions;
 * the most likely (and currently only known) problem is retention
 * of {@link Class} instances via {@link JavaType} reference.
 *
 * @since 2.4.1
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test4545() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""com.fasterxml.jackson.databind.ser.impl.IndexedStringListSerializer"");
}",""
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            newType = _fromClass(null, subclass, tb);
        }
    } while (false);
    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get
    //   copied as well
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test4646() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<String> class0 = String.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    // Undeclared exception!
    try {
        typeFactory0.constructSpecializedType(simpleType0, class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Class java.lang.String not subtype of [simple type, class long]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test4747() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    typeFactory0.moreSpecificType(simpleType0, simpleType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test4949() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    SimpleType simpleType1 = TypeFactory.CORE_TYPE_LONG;
    typeFactory0.moreSpecificType(simpleType1, simpleType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test5050() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<String> class0 = String.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test5151() throws Throwable {
    Class<Properties> class0 = Properties.class;
    TypeFactory.rawClass(class0);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            newType = _fromClass(null, subclass, tb);
        }
    } while (false);
    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get
    //   copied as well
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test5252() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    JavaType javaType0 = typeFactory0.uncheckedSimpleType(class0);
    typeFactory0.constructSpecializedType(javaType0, class0);
}",""
"@Deprecated
public JavaType constructType(Type type, JavaType contextType) {
    TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings();
    return _fromAny(null, type, bindings);
}","public void test5353() throws Throwable {
    Class<Properties> class0 = Properties.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructType((Type) class0, (JavaType) null);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test5454() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Integer> class0 = Integer.TYPE;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test5555() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructFromCanonical(""boolean"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test5656() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<POJONode> class0 = POJONode.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test5757() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""short"");
}",""
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test5858() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<LinkedList> class0 = LinkedList.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    typeFactory0.constructCollectionType((Class<? extends Collection>) class0, (JavaType) collectionLikeType0);
    Class<Properties> class1 = Properties.class;
    typeFactory0.constructType((Type) class1, (Class<?>) class1);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test5959() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<DeserializationFeature> class0 = DeserializationFeature.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (List<JavaType>) null);
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    typeFactory0.constructGeneralizedType(resolvedRecursiveType0, class0);
}","/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */"
"public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test6060() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ObjectMapper.DefaultTyping> class0 = ObjectMapper.DefaultTyping.class;
    Class<LinkedList> class1 = LinkedList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_ENUM;
    CollectionType collectionType0 = typeFactory0.constructCollectionType((Class<? extends Collection>) class1, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType0 = collectionType0.withStaticTyping();
    collectionLikeType0.findTypeParameters(class1);
    MapLikeType mapLikeType0 = new MapLikeType(collectionLikeType0, simpleType0, collectionType0);
    CollectionLikeType collectionLikeType1 = typeFactory0.constructCollectionLikeType((Class<?>) class0, (JavaType) mapLikeType0);
    SimpleType simpleType1 = TypeFactory.CORE_TYPE_ENUM;
    Properties properties0 = new Properties();
    properties0.put(typeFactory0, simpleType1);
    Class<Object> class2 = Object.class;
    typeFactory0.constructArrayType(class2);
    typeFactory0.constructRawMapLikeType(class2);
    Class<Object> class3 = Object.class;
    // Undeclared exception!
    try {
        typeFactory0.constructGeneralizedType(collectionLikeType1, class3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Internal error: class java.lang.Object not included as super-type for [collection-like type; class com.fasterxml.jackson.databind.ObjectMapper$DefaultTyping, contains [map-like type; class java.util.LinkedList, [simple type, class java.lang.Enum] -> [collection type; class java.util.LinkedList, contains [simple type, class java.lang.Enum]]]]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6161() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""int"");
}",""
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            newType = _fromClass(null, subclass, tb);
        }
    } while (false);
    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get
    //   copied as well
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test6262() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    Class<MapType> class0 = MapType.class;
    typeFactory0.constructSpecializedType(simpleType0, class0);
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6363() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""long"");
}",""
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test6464() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    LRUMap<Object, JavaType> lRUMap0 = new LRUMap<Object, JavaType>(3, 5247);
    TypeParser typeParser0 = new TypeParser(typeFactory0);
    TypeModifier[] typeModifierArray0 = new TypeModifier[0];
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassLoader classLoader1 = classLoader0.getParent();
    TypeFactory typeFactory1 = new TypeFactory(lRUMap0, typeParser0, typeModifierArray0, classLoader1);
    typeFactory1.constructType((Type) class0, (Class<?>) class0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public TypeFactory withModifier(TypeModifier mod) {
    LRUMap<Object, JavaType> typeCache = _typeCache;
    TypeModifier[] mods;
    if (mod == null) {
        // mostly for unit tests
        mods = null;
        // 30-Jun-2016, tatu: for some reason expected semantics are to clear cache
        //    in this case; can't recall why, but keeping the same
        typeCache = null;
    } else if (_modifiers == null) {
        mods = new TypeModifier[] { mod };
    } else {
        mods = ArrayBuilders.insertInListNoDup(_modifiers, mod);
    }
    return new TypeFactory(typeCache, _parser, mods, _classLoader);
}","public void test6565() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = new TypeFactory((LRUMap<Object, JavaType>) null);
    TypeParser typeParser0 = new TypeParser(typeFactory0);
    TypeParser typeParser1 = typeParser0.withFactory(typeFactory0);
    TypeModifier[] typeModifierArray0 = new TypeModifier[7];
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassLoader classLoader1 = classLoader0.getParent();
    TypeFactory typeFactory1 = new TypeFactory((LRUMap<Object, JavaType>) null, typeParser1, typeModifierArray0, classLoader1);
    Class<LinkedList> class0 = LinkedList.class;
    typeFactory1.constructRawCollectionType(class0);
    typeFactory1.withModifier(typeModifierArray0[2]);
}",""
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test6666() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    TypeModifier typeModifier0 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    doReturn((JavaType) null).when(typeModifier0).modifyType(any(com.fasterxml.jackson.databind.JavaType.class), any(java.lang.reflect.Type.class), any(com.fasterxml.jackson.databind.type.TypeBindings.class), any(com.fasterxml.jackson.databind.type.TypeFactory.class));
    doReturn((String) null).when(typeModifier0).toString();
    TypeFactory typeFactory1 = typeFactory0.withModifier(typeModifier0);
    Class<RuntimeException> class0 = RuntimeException.class;
    // Undeclared exception!
    try {
        typeFactory1.constructRawMapLikeType(class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // TypeModifier Mock for TypeModifier, hashCode: 1765330408 (of type com.fasterxml.jackson.databind.type.TypeModifier$MockitoMock$1846850338) return null for type [simple type, class java.lang.Object]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test6868() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.moreSpecificType((JavaType) null, (JavaType) null);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6969() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""void"");
}",""
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test7070() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    SimpleType simpleType1 = TypeFactory.CORE_TYPE_LONG;
    typeFactory0.moreSpecificType(simpleType0, (JavaType) null);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test7171() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    TypeModifier typeModifier0 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    doReturn(simpleType0).when(typeModifier0).modifyType(any(com.fasterxml.jackson.databind.JavaType.class), any(java.lang.reflect.Type.class), any(com.fasterxml.jackson.databind.type.TypeBindings.class), any(com.fasterxml.jackson.databind.type.TypeFactory.class));
    TypeFactory typeFactory1 = typeFactory0.withModifier(typeModifier0);
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    typeFactory1.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7272() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayList> class0 = ArrayList.class;
    CollectionType collectionType0 = (CollectionType) typeFactory0.constructCollectionLikeType(class0, class0);
    CollectionType collectionType1 = (CollectionType) collectionType0.withTypeHandler(class0);
    typeFactory0.constructCollectionType((Class<? extends Collection>) class0, (JavaType) collectionType1);
    Class<Properties> class1 = Properties.class;
    typeFactory0.constructType((Type) class1, (Class<?>) class1);
    typeFactory0.findClass(""p"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7373() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""byte"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7474() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""double"");
}",""
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test7676() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    Class<SerializationFeature> class1 = SerializationFeature.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class1, (TypeBindings) null, (JavaType) simpleType0, (JavaType[]) null, (JavaType) simpleType0);
    CollectionType collectionType0 = CollectionType.construct((Class<?>) class0, (TypeBindings) null, (JavaType) collectionLikeType0, (JavaType[]) null, (JavaType) simpleType0);
    CollectionType collectionType1 = collectionType0.withTypeHandler((Object) null);
    ReferenceType referenceType0 = new ReferenceType(collectionType1, collectionLikeType0);
    SimpleType simpleType1 = referenceType0.withValueHandler(collectionType1);
    typeFactory0.constructGeneralizedType(simpleType1, class1);
    typeFactory0.constructFromCanonical(""com.fasterxml.jackson.databind.ser.std.AtomicReferenceSerializer"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException {
    return _parser.parse(canonical);
}","public void test7878() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructFromCanonical(""long"");
}","/**
 * Factory method for constructing a {@link JavaType} out of its canonical
 * representation (see {@link JavaType#toCanonical()}).
 *
 * @param canonical Canonical string representation of a type
 *
 * @throws IllegalArgumentException If canonical representation is malformed,
 *   or class that type represents (including its generic parameters) is
 *   not found
 */"
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test7979() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    typeFactory0.constructType((Type) class0, (Class<?>) null);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test8080() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    ArrayType arrayType0 = typeFactory0.constructArrayType((JavaType) simpleType0);
    typeFactory0.moreSpecificType(simpleType0, arrayType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test8181() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""boolean"");
}",""
"protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {
    if (bindings.isEmpty()) {
        JavaType result = _findWellKnownSimple(raw);
        if (result != null) {
            return result;
        }
    }
    return _newSimpleType(raw, bindings, superClass, superInterfaces);
}","public void test8282() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<EnumSet> class0 = EnumSet.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) collectionType0);
    JavaType[] javaTypeArray0 = new JavaType[7];
    javaTypeArray0[0] = (JavaType) collectionType0;
    javaTypeArray0[2] = (JavaType) collectionType0;
    javaTypeArray0[6] = (JavaType) collectionType0;
    typeFactory0._constructSimple(class0, typeBindings0, collectionType0, javaTypeArray0);
}","/**
 * Factory method to call when no special {@link JavaType} is needed,
 * no generic parameters are passed. Default implementation may check
 * pre-constructed values for ""well-known"" types, but if none found
 * will simply call {@link #_newSimpleType}
 *
 * @since 2.7
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test8383() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    typeFactory0.constructSpecializedType(simpleType0, class0);
    typeFactory0.findClass("""");
}",""
