focal_method,test_prefix,docstring
"public String getErasedSignature() {
    StringBuilder sb = new StringBuilder(40);
    getErasedSignature(sb);
    return sb.toString();
}","public void test000() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(simpleType0, simpleType0);
    String string0 = collectionLikeType0.getErasedSignature();
    assertEquals(""Ljava/lang/Object;"", string0);
}","/**
 * Method for accessing signature without generic
 * type information, in form compatible with all versions
 * of JVM, and specifically used for type descriptions
 * when generating byte code.
 */"
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test022() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<ReferenceType> class0 = ReferenceType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withContentTypeHandler(collectionLikeType0);
    assertTrue(collectionLikeType1.equals((Object) collectionLikeType0));
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test023() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<ReferenceType> class0 = ReferenceType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withContentTypeHandler(collectionLikeType0);
    assertTrue(collectionLikeType1.hasHandlers());
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test024() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<ReferenceType> class0 = ReferenceType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withContentTypeHandler(collectionLikeType0);
    assertFalse(collectionLikeType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test035() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<LinkedList> class0 = LinkedList.class;
    Class<CollectionType> class1 = CollectionType.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, (TypeBindings) null);
    CollectionType collectionType0 = typeFactory0.constructCollectionType((Class<? extends Collection>) class0, (JavaType) resolvedRecursiveType0);
    collectionType0.getContentValueHandler();
    assertFalse(collectionType0.hasHandlers());
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test046() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class0 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    Class<Integer> class1 = Integer.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class1, (JavaType) mapType0);
    collectionLikeType0.getContentTypeHandler();
    assertFalse(collectionLikeType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test057() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    Class<ObjectIdGenerators.IntSequenceGenerator> class0 = ObjectIdGenerators.IntSequenceGenerator.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    Class<MapLikeType> class1 = MapLikeType.class;
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    JavaType javaType0 = collectionLikeType0.refine(class1, typeBindings0, simpleType0, (JavaType[]) null);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Support for producing signatures
    /**********************************************************
     */
//public abstract String toCanonical();
/**
 * Method for accessing signature that contains generic
 * type information, in form compatible with JVM 1.5
 * as per JLS. It is a superset of {@link #getErasedSignature},
 * in that generic information can be automatically removed
 * if necessary (just remove outermost
 * angle brackets along with content inside)
 */
public String getGenericSignature() {
    StringBuilder sb = new StringBuilder(40);
    getGenericSignature(sb);
    return sb.toString();
}","public void test079() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(simpleType0, simpleType0);
    String string0 = collectionLikeType0.getGenericSignature();
    assertEquals(""Ljava/lang/Object<Ljava/lang/Object;>;"", string0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test0810() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withTypeHandler(simpleType0);
    assertTrue(collectionLikeType1.equals((Object) collectionLikeType0));
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test0811() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withTypeHandler(simpleType0);
    assertFalse(collectionLikeType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test0912() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withValueHandler(simpleType0);
    assertTrue(collectionLikeType1.equals((Object) collectionLikeType0));
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test0913() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withValueHandler(simpleType0);
    assertFalse(collectionLikeType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1014() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    Class<MapLikeType> class0 = MapLikeType.class;
    JavaType[] javaTypeArray0 = new JavaType[0];
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (TypeBindings) null, (JavaType) simpleType0, javaTypeArray0, (JavaType) simpleType0);
    assertFalse(collectionLikeType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test1115() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    CollectionLikeType collectionLikeType0 = new CollectionLikeType(simpleType0, simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withContentValueHandler(simpleType0);
    assertTrue(collectionLikeType1.equals((Object) collectionLikeType0));
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1216() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_CLASS;
    Class<Object> class0 = Object.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0._narrow(class0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public int containedTypeCount() {
    return _bindings.size();
}","public void test1317() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<JsonDeserializer> class0 = JsonDeserializer.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    assertEquals(1, collectionLikeType0.containedTypeCount());
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1318() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    Class<JsonDeserializer> class0 = JsonDeserializer.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    assertFalse(collectionLikeType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {
    // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
    //    will cross that bridge if and when need be
    if (baseType instanceof TypeBase) {
        return new CollectionLikeType((TypeBase) baseType, elementType);
    }
    throw new IllegalArgumentException(""Can not upgrade from an instance of "" + baseType.getClass());
}","public void test1419() throws Throwable {
    // Undeclared exception!
    try {
        CollectionLikeType.upgradeFrom((JavaType) null, (JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.CollectionLikeType"", e);
    }
}","/**
 * Factory method that can be used to ""upgrade"" a basic type into collection-like
 * one; usually done via {@link TypeModifier}
 *
 * @since 2.7
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1520() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0.withContentType(collectionLikeType0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public JavaType withContentType(JavaType contentType) {
    if (_elementType == contentType) {
        return this;
    }
    return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, contentType, _valueHandler, _typeHandler, _asStatic);
}","public void test1521() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0.withContentType(collectionLikeType0);
    assertNotSame(javaType0, collectionLikeType0);
}",""
"@Override
public abstract boolean equals(Object o);","public void test1522() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0.withContentType(collectionLikeType0);
    assertFalse(javaType0.equals((Object) collectionLikeType0));
}",""
"@Override
public JavaType withContentType(JavaType contentType) {
    if (_elementType == contentType) {
        return this;
    }
    return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, contentType, _valueHandler, _typeHandler, _asStatic);
}","public void test1623() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0.withContentType(simpleType0);
    assertSame(javaType0, collectionLikeType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1624() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    JavaType javaType0 = collectionLikeType0.withContentType(simpleType0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public CollectionLikeType withStaticTyping() {
    if (_asStatic) {
        return this;
    }
    return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces, _elementType.withStaticTyping(), _valueHandler, _typeHandler, true);
}","public void test1725() throws Throwable {
    Class<MapType> class0 = MapType.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    MapLikeType mapLikeType0 = new MapLikeType(resolvedRecursiveType0, simpleType0, resolvedRecursiveType0);
    CollectionType collectionType0 = CollectionType.construct((Class<?>) class0, (TypeBindings) null, (JavaType) simpleType0, (JavaType[]) null, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType0 = new CollectionLikeType(class0, (TypeBindings) null, mapLikeType0, (JavaType[]) null, simpleType0, simpleType0, collectionType0, true);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withStaticTyping();
    assertSame(collectionLikeType1, collectionLikeType0);
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test1826() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    Class<String> class0 = String.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    JavaType[] javaTypeArray0 = new JavaType[0];
    TypeFactory typeFactory0 = new TypeFactory((LRUMap<Object, JavaType>) null);
    Class<HashMap> class1 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class1);
    CollectionLikeType collectionLikeType0 = new CollectionLikeType(class0, typeBindings0, simpleType0, javaTypeArray0, simpleType0, typeBindings0, mapType0, true);
    boolean boolean0 = collectionLikeType0.hasHandlers();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test1927() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<LinkedList> class0 = LinkedList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    CollectionLikeType collectionLikeType0 = collectionType0.withContentValueHandler(class0);
    boolean boolean0 = collectionLikeType0.hasHandlers();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test1928() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<LinkedList> class0 = LinkedList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    CollectionLikeType collectionLikeType0 = collectionType0.withContentValueHandler(class0);
    boolean boolean0 = collectionLikeType0.hasHandlers();
    assertFalse(collectionType0.hasHandlers());
}",""
"@Override
protected String buildCanonicalName() {
    StringBuilder sb = new StringBuilder();
    sb.append(_class.getName());
    if (_elementType != null) {
        sb.append('<');
        sb.append(_elementType.toCanonical());
        sb.append('>');
    }
    return sb.toString();
}","public void test2029() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    JavaType[] javaTypeArray0 = new JavaType[8];
    CollectionType collectionType0 = new CollectionType(simpleType0, javaTypeArray0[1]);
    String string0 = collectionType0.buildCanonicalName();
    assertEquals(""java.lang.String"", string0);
}",""
"@Override
protected String buildCanonicalName() {
    StringBuilder sb = new StringBuilder();
    sb.append(_class.getName());
    if (_elementType != null) {
        sb.append('<');
        sb.append(_elementType.toCanonical());
        sb.append('>');
    }
    return sb.toString();
}","public void test2130() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(simpleType0, simpleType0);
    String string0 = collectionLikeType0.buildCanonicalName();
    assertEquals(""java.lang.Object<java.lang.Object>"", string0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test2231() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    CollectionLikeType collectionLikeType0 = new CollectionLikeType(simpleType0, simpleType0);
    boolean boolean0 = collectionLikeType0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2332() throws Throwable {
    Class<ObjectReader> class0 = ObjectReader.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withStaticTyping();
    boolean boolean0 = collectionLikeType1.equals(collectionLikeType0);
    assertTrue(collectionLikeType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test2333() throws Throwable {
    Class<ObjectReader> class0 = ObjectReader.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = collectionLikeType0.withStaticTyping();
    boolean boolean0 = collectionLikeType1.equals(collectionLikeType0);
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test2435() throws Throwable {
    Class<ObjectReader> class0 = ObjectReader.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = CollectionLikeType.construct((Class<?>) class0, (JavaType) collectionLikeType0);
    boolean boolean0 = collectionLikeType1.equals(collectionLikeType0);
    assertFalse(collectionLikeType0.equals((Object) collectionLikeType1));
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    CollectionLikeType other = (CollectionLikeType) o;
    return (_class == other._class) && _elementType.equals(other._elementType);
}","public void test2436() throws Throwable {
    Class<ObjectReader> class0 = ObjectReader.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = CollectionLikeType.construct((Class<?>) class0, (JavaType) collectionLikeType0);
    boolean boolean0 = collectionLikeType1.equals(collectionLikeType0);
    assertFalse(boolean0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2437() throws Throwable {
    Class<ObjectReader> class0 = ObjectReader.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    CollectionLikeType collectionLikeType0 = CollectionLikeType.construct((Class<?>) class0, (JavaType) simpleType0);
    CollectionLikeType collectionLikeType1 = CollectionLikeType.construct((Class<?>) class0, (JavaType) collectionLikeType0);
    boolean boolean0 = collectionLikeType1.equals(collectionLikeType0);
    assertFalse(collectionLikeType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
