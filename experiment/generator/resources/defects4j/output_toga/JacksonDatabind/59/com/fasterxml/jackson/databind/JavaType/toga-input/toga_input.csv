focal_method,test_prefix,docstring
"public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {
    // 19-Oct-2015, tatu: Not sure if and how other types could be used as
    // base;
    // will cross that bridge if and when need be
    if (baseType instanceof TypeBase) {
        return new MapLikeType((TypeBase) baseType, keyT, valueT);
    }
    throw new IllegalArgumentException(""Can not upgrade from an instance of "" + baseType.getClass());
}","public void test000() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    MapLikeType.upgradeFrom(resolvedRecursiveType0, resolvedRecursiveType0, resolvedRecursiveType0);
}","/**
 * Factory method that can be used to ""upgrade"" a basic type into
 * collection-like one; usually done via {@link TypeModifier}
 *
 * @since 2.7
 */"
"@Override
public Object getContentValueHandler() {
    return _componentType.getValueHandler();
}","public void test011() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<JsonInclude.Include> class0 = JsonInclude.Include.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    arrayType0.getContentValueHandler();
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _elementType.hasHandlers();
}","public void test022() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LinkedList> class0 = LinkedList.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType(class0, class0);
    collectionType0.hasHandlers();
}",""
"@Deprecated
public JavaType forcedNarrowBy(Class<?> subclass) {
    if (subclass == _class) {
        // can still optimize for simple case
        return this;
    }
    JavaType result = _narrow(subclass);
    // TODO: these checks should NOT actually be needed; above should suffice:
    if (_valueHandler != result.<Object>getValueHandler()) {
        result = result.withValueHandler(_valueHandler);
    }
    if (_typeHandler != result.<Object>getTypeHandler()) {
        result = result.withTypeHandler(_typeHandler);
    }
    return result;
}","public void test033() throws Throwable {
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    Class<Integer> class1 = Integer.class;
    resolvedRecursiveType0.forcedNarrowBy(class1);
}","/**
 * Legacy method used for forcing sub-typing of this type into
 * type specified by specific type erasure.
 * Deprecated as of 2.7 as such specializations really ought to
 * go through {@link TypeFactory}, not directly via {@link JavaType}.
 *
 * @since 2.7
 */"
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _componentType.hasHandlers();
}","public void test044() throws Throwable {
    Class<String> class0 = String.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    TypeBindings typeBindings0 = resolvedRecursiveType0.getBindings();
    resolvedRecursiveType0.containedTypeName(309);
    ArrayType arrayType0 = ArrayType.construct((JavaType) resolvedRecursiveType0, typeBindings0, (Object) null, (Object) class0);
    arrayType0.withContentTypeHandler(class0);
    ArrayType arrayType1 = arrayType0.withStaticTyping();
    arrayType1.hasHandlers();
}",""
"/*
    /**********************************************************
    /* Extended API beyond ResolvedType
    /**********************************************************
     */
// NOTE: not defined in Resolved type
/**
 *  Convenience method that is functionally same as:
 * <code>
 *  JavaType t = containedType(index);
 *  if (t == null) {
 *     t = TypeFactory.unknownType();
 *  }
 * </code>
 *  and typically used to eliminate need for null checks for common case
 *  where we just want to check if containedType is available first; and
 *  if not, use ""unknown type"" (which translates to <code>java.lang.Object</code>
 *  basically).
 *
 *  @since 2.5
 */
public JavaType containedTypeOrUnknown(int index) {
    JavaType t = containedType(index);
    return (t == null) ? TypeFactory.unknownType() : t;
}","public void test066() throws Throwable {
    Class<Throwable> class0 = Throwable.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.containedTypeOrUnknown(183);
}",""
"/*
    /**********************************************************
    /* Support for producing signatures
    /**********************************************************
     */
//public abstract String toCanonical();
/**
 * Method for accessing signature that contains generic
 * type information, in form compatible with JVM 1.5
 * as per JLS. It is a superset of {@link #getErasedSignature},
 * in that generic information can be automatically removed
 * if necessary (just remove outermost
 * angle brackets along with content inside)
 */
public String getGenericSignature() {
    StringBuilder sb = new StringBuilder(40);
    getGenericSignature(sb);
    return sb.toString();
}","public void test077() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    // Undeclared exception!
    try {
        resolvedRecursiveType0.getGenericSignature();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.ResolvedRecursiveType"", e);
    }
}",""
"public boolean hasValueHandler() {
    return _valueHandler != null;
}","public void test088() throws Throwable {
    Class<Throwable> class0 = Throwable.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.hasGenericTypes();
    resolvedRecursiveType0.hasValueHandler();
}","/**
 * @since 2.6
 */"
"@Override
public boolean isConcrete() {
    int mod = _class.getModifiers();
    if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {
        return true;
    }
    /* 19-Feb-2010, tatus: Holy mackarel; primitive types
         *    have 'abstract' flag set...
         */
    return _class.isPrimitive();
}","public void test099() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.isConcrete();
}","/**
 * Convenience method for checking whether underlying Java type
 * is a concrete class or not: abstract classes and interfaces
 * are not.
 */"
"@Override
public final boolean isPrimitive() {
    return _class.isPrimitive();
}","public void test1010() throws Throwable {
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.isPrimitive();
}",""
"@Override
public boolean isThrowable() {
    return Throwable.class.isAssignableFrom(_class);
}","public void test1212() throws Throwable {
    Class<String> class0 = String.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.isThrowable();
}",""
"public final boolean isTypeOrSubTypeOf(Class<?> clz) {
    return (_class == clz) || (clz.isAssignableFrom(_class));
}","public void test1313() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<String> class0 = String.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.isTypeOrSubTypeOf(class0);
}","/**
 * @since 2.6
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ArrayType other = (ArrayType) o;
    return _componentType.equals(other._componentType);
}","public void test1414() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    TypeFactory typeFactory1 = typeFactory0.withClassLoader(classLoader0);
    Class<String> class0 = String.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructCollectionLikeType(class0, class0);
    Class<LinkedList> class1 = LinkedList.class;
    CollectionType collectionType0 = typeFactory1.constructCollectionType(class1, class1);
    collectionType0.hasGenericTypes();
    collectionType0.withContentTypeHandler(classLoader0);
    TypeFactory typeFactory2 = TypeFactory.defaultInstance();
    ArrayType arrayType0 = typeFactory2.constructArrayType((JavaType) collectionLikeType0);
    Object object0 = new Object();
    ArrayType arrayType1 = arrayType0.withContentTypeHandler(object0);
    arrayType1.equals("""");
}",""
"@Override
public boolean hasHandlers() {
    return super.hasHandlers() || _componentType.hasHandlers();
}","public void test1515() throws Throwable {
    Class<Integer> class0 = Integer.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    ArrayType arrayType0 = ArrayType.construct((JavaType) resolvedRecursiveType0, (TypeBindings) null);
    ArrayType arrayType1 = arrayType0.withContentTypeHandler(resolvedRecursiveType0);
    Object object0 = new Object();
    ArrayType arrayType2 = arrayType1.withValueHandler(object0);
    arrayType2.hasHandlers();
}",""
"@Override
public boolean isConcrete() {
    int mod = _class.getModifiers();
    if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {
        return true;
    }
    /* 19-Feb-2010, tatus: Holy mackarel; primitive types
         *    have 'abstract' flag set...
         */
    return _class.isPrimitive();
}","public void test1616() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<Integer> class0 = Integer.TYPE;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    Class<String> class1 = String.class;
    resolvedRecursiveType0.isTypeOrSubTypeOf(class1);
    resolvedRecursiveType0.isConcrete();
}","/**
 * Convenience method for checking whether underlying Java type
 * is a concrete class or not: abstract classes and interfaces
 * are not.
 */"
"public boolean hasContentType() {
    return true;
}","public void test1717() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.hasContentType();
}","/**
 * Accessor that allows determining whether {@link #getContentType()} should
 * return a non-null value (that is, there is a ""content type"") or not.
 * True if {@link #isContainerType()} or {@link #isReferenceType()} return true.
 *
 * @since 2.8
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1818() throws Throwable {
    Class<Integer> class0 = Integer.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.useStaticType();
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public boolean hasValueHandler() {
    return _valueHandler != null;
}","public void test1919() throws Throwable {
    Class<Throwable> class0 = Throwable.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    Class<Object> class1 = Object.class;
    resolvedRecursiveType0.isTypeOrSubTypeOf(class1);
    resolvedRecursiveType0.hasValueHandler();
}","/**
 * @since 2.6
 */"
"public Object getContentTypeHandler() {
    return null;
}","public void test2020() throws Throwable {
    Class<Object> class0 = Object.class;
    Stack<JavaType> stack0 = new Stack<JavaType>();
    TypeBindings typeBindings0 = TypeBindings.create((Class<?>) class0, (List<JavaType>) stack0);
    Class<String> class1 = String.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
    JavaType[] javaTypeArray0 = new JavaType[2];
    javaTypeArray0[0] = (JavaType) resolvedRecursiveType0;
    javaTypeArray0[1] = (JavaType) resolvedRecursiveType0;
    javaTypeArray0[0].containedTypeOrUnknown((-2831));
    Object object0 = new Object();
    Class<Object> class2 = Object.class;
    javaTypeArray0[1].isTypeOrSubTypeOf(class2);
    Integer integer0 = new Integer(1585);
    Class<Integer> class3 = Integer.TYPE;
    resolvedRecursiveType0.forcedNarrowBy(class3);
    resolvedRecursiveType0.getContentTypeHandler();
}","/**
 * @since 2.7
 */"
"@Deprecated
public JavaType forcedNarrowBy(Class<?> subclass) {
    if (subclass == _class) {
        // can still optimize for simple case
        return this;
    }
    JavaType result = _narrow(subclass);
    // TODO: these checks should NOT actually be needed; above should suffice:
    if (_valueHandler != result.<Object>getValueHandler()) {
        result = result.withValueHandler(_valueHandler);
    }
    if (_typeHandler != result.<Object>getTypeHandler()) {
        result = result.withTypeHandler(_typeHandler);
    }
    return result;
}","public void test2121() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.forcedNarrowBy(class0);
}","/**
 * Legacy method used for forcing sub-typing of this type into
 * type specified by specific type erasure.
 * Deprecated as of 2.7 as such specializations really ought to
 * go through {@link TypeFactory}, not directly via {@link JavaType}.
 *
 * @since 2.7
 */"
"public boolean hasValueHandler() {
    return _valueHandler != null;
}","public void test2222() throws Throwable {
    Class<JsonInclude.Include> class0 = JsonInclude.Include.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.getErasedSignature();
    // Undeclared exception!
    try {
        resolvedRecursiveType0.hasValueHandler();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.ResolvedRecursiveType"", e);
    }
}","/**
 * @since 2.6
 */"
"// since 2.7
@Deprecated
@Override
public Class<?> getParameterSource() {
    return null;
}","public void test2323() throws Throwable {
    Class<Object> class0 = Object.class;
    Stack<JavaType> stack0 = new Stack<JavaType>();
    TypeBindings typeBindings0 = TypeBindings.create((Class<?>) class0, (List<JavaType>) stack0);
    typeBindings0.toString();
    Class<String> class1 = String.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
    ResolvedRecursiveType resolvedRecursiveType1 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType1.isContainerType();
    resolvedRecursiveType0.getParameterSource();
}",""
"@Override
public JavaType getKeyType() {
    return null;
}","public void test2424() throws Throwable {
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    FileSystemHandling.shouldAllThrowIOExceptions();
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(resolvedRecursiveType0, resolvedRecursiveType0);
    Class<Integer> class1 = Integer.class;
    referenceType0.forcedNarrowBy(class1);
    referenceType0.withContentType(resolvedRecursiveType0);
    referenceType0.getKeyType();
}",""
"public final boolean isJavaLangObject() {
    return _class == Object.class;
}","public void test2525() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.isContainerType();
    resolvedRecursiveType0.isJavaLangObject();
}","/**
 *  Convenience method, short-hand for
 * <code>
 *    getRawClass() == Object.class
 * </code>
 *  and used to figure if we basically have ""untyped"" type object.
 *
 *  @since 2.5
 */"
"@Override
public final boolean isFinal() {
    return Modifier.isFinal(_class.getModifiers());
}","public void test2626() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<Object> class0 = Object.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    objectReader0.getTypeFactory();
    Stack<JavaType> stack0 = new Stack<JavaType>();
    Class<Throwable> class1 = Throwable.class;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded(class1, (JavaType) null);
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.isFinal();
}",""
"public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {
    // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
    //    will cross that bridge if and when need be
    if (baseType instanceof TypeBase) {
        return new CollectionLikeType((TypeBase) baseType, elementType);
    }
    throw new IllegalArgumentException(""Can not upgrade from an instance of "" + baseType.getClass());
}","public void test2828() throws Throwable {
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.getContentValueHandler();
    CollectionLikeType.upgradeFrom(resolvedRecursiveType0, resolvedRecursiveType0);
}","/**
 * Factory method that can be used to ""upgrade"" a basic type into collection-like
 * one; usually done via {@link TypeModifier}
 *
 * @since 2.7
 */"
"@Override
public boolean isConcrete() {
    int mod = _class.getModifiers();
    if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {
        return true;
    }
    /* 19-Feb-2010, tatus: Holy mackarel; primitive types
         *    have 'abstract' flag set...
         */
    return _class.isPrimitive();
}","public void test2929() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<Integer> class0 = Integer.TYPE;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    resolvedRecursiveType0.isConcrete();
}","/**
 * Convenience method for checking whether underlying Java type
 * is a concrete class or not: abstract classes and interfaces
 * are not.
 */"
"public boolean hasValueHandler() {
    return _valueHandler != null;
}","public void test3030() throws Throwable {
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    resolvedRecursiveType0.hasValueHandler();
}","/**
 * @since 2.6
 */"
