focal_method,test_prefix,docstring
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test011() throws Throwable {
    Class<Currency> class0 = Currency.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test022() throws Throwable {
    Class<TimeZone> class0 = TimeZone.class;
    FromStringDeserializer.findDeserializer(class0);
    FileSystemHandling.appendStringToFile((EvoSuiteFile) null, """");
    UUIDDeserializer uUIDDeserializer0 = new UUIDDeserializer();
    FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 8);
    fromStringDeserializer_Std0._deserializeFromEmptyString();
    Class<MissingNode> class1 = MissingNode.class;
    FromStringDeserializer.findDeserializer(class1);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Class<?>[] types() {
    return new Class<?>[] { File.class, URL.class, URI.class, Class.class, JavaType.class, Currency.class, Pattern.class, Locale.class, Charset.class, TimeZone.class, InetAddress.class, InetSocketAddress.class };
}","public void test044() throws Throwable {
    FromStringDeserializer.types();
}",""
"protected T _deserializeFromEmptyString() throws IOException {
    return null;
}","public void test055() throws Throwable {
    Class<Locale> class0 = Locale.class;
    FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, (-131072));
    fromStringDeserializer_Std0._deserializeFromEmptyString();
}",""
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test088() throws Throwable {
    Class<URI> class0 = URI.class;
    FromStringDeserializer.Std fromStringDeserializer_Std0 = FromStringDeserializer.findDeserializer(class0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    FromStringDeserializer.Std fromStringDeserializer_Std1 = new FromStringDeserializer.Std(class0, 5);
    fromStringDeserializer_Std0._deserializeFromEmptyString();
    Class<Locale> class1 = Locale.class;
    FromStringDeserializer.findDeserializer(class1);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test099() throws Throwable {
    Class<Locale> class0 = Locale.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test1010() throws Throwable {
    Class<InetSocketAddress> class0 = InetSocketAddress.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"@Override
protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {
    if (ob instanceof byte[]) {
        return _fromBytes((byte[]) ob, ctxt);
    }
    super._deserializeEmbedded(ob, ctxt);
    // never gets here
    return null;
}","public void test1111() throws Throwable {
    Class<Currency> class0 = Currency.class;
    UUIDDeserializer uUIDDeserializer0 = new UUIDDeserializer();
    uUIDDeserializer0._deserializeEmbedded(class0, (DeserializationContext) null);
}",""
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test1212() throws Throwable {
    Class<Pattern> class0 = Pattern.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test1616() throws Throwable {
    Class<InetAddress> class0 = InetAddress.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"/*
    /**********************************************************
    /* Deserializer implementations
    /**********************************************************
     */
@SuppressWarnings(""unchecked"")
@Override
public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    // Issue#381
    if (p.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
        p.nextToken();
        final T value = deserialize(p, ctxt);
        if (p.nextToken() != JsonToken.END_ARRAY) {
            throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, ""Attempted to unwrap single value array for single '"" + _valueClass.getName() + ""' value but there was more than a single value in the array"");
        }
        return value;
    }
    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:
    String text = p.getValueAsString();
    if (text != null) {
        // has String representation
        if (text.length() == 0 || (text = text.trim()).length() == 0) {
            // 04-Feb-2013, tatu: Usually should become null; but not always
            return _deserializeFromEmptyString();
        }
        Exception cause = null;
        try {
            T result = _deserialize(text, ctxt);
            if (result != null) {
                return result;
            }
        } catch (IllegalArgumentException iae) {
            cause = iae;
        }
        String msg = ""not a valid textual representation"";
        if (cause != null) {
            String m2 = cause.getMessage();
            if (m2 != null) {
                msg = msg + "", problem: "" + m2;
            }
        }
        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);
        if (cause != null) {
            e.initCause(cause);
        }
        throw e;
        // nothing to do here, yet? We'll fail anyway
    }
    if (p.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
        // Trivial cases; null to null, instance of type itself returned as is
        Object ob = p.getEmbeddedObject();
        if (ob == null) {
            return null;
        }
        if (_valueClass.isAssignableFrom(ob.getClass())) {
            return (T) ob;
        }
        return _deserializeEmbedded(ob, ctxt);
    }
    throw ctxt.mappingException(_valueClass);
}","public void test1717() throws Throwable {
    Class<Object> class0 = Object.class;
    FromStringDeserializer.findDeserializer(class0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    JsonFactory jsonFactory0 = new JsonFactory();
    File file0 = MockFile.createTempFile(""JSON"", ""JSON"");
    JsonParser jsonParser0 = jsonFactory0.createParser(file0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 7);
    // Undeclared exception!
    try {
        fromStringDeserializer_Std0.deserialize(jsonParser0, (DeserializationContext) defaultDeserializationContext_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test1919() throws Throwable {
    Class<URL> class0 = URL.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test2121() throws Throwable {
    Class<Charset> class0 = Charset.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test2222() throws Throwable {
    Class<File> class0 = File.class;
    FromStringDeserializer.findDeserializer(class0);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
"@Override
protected UUID _deserialize(String id, DeserializationContext ctxt) throws IOException {
    // Adapted from java-uuid-generator (https://github.com/cowtowncoder/java-uuid-generator)
    // which is 5x faster than UUID.fromString(value), as oper ""ManualReadPerfWithUUID""
    if (id.length() != 36) {
        /* 14-Sep-2013, tatu: One trick we do allow, Base64-encoding, since we know
             *   length it must have...
             */
        if (id.length() == 24) {
            byte[] stuff = Base64Variants.getDefaultVariant().decode(id);
            return _fromBytes(stuff, ctxt);
        }
        _badFormat(id, ctxt);
    }
    // verify hyphens first:
    if ((id.charAt(8) != '-') || (id.charAt(13) != '-') || (id.charAt(18) != '-') || (id.charAt(23) != '-')) {
        _badFormat(id, ctxt);
    }
    long l1 = intFromChars(id, 0, ctxt);
    l1 <<= 32;
    long l2 = ((long) shortFromChars(id, 9, ctxt)) << 16;
    l2 |= shortFromChars(id, 14, ctxt);
    long hi = l1 + l2;
    int i1 = (shortFromChars(id, 19, ctxt) << 16) | shortFromChars(id, 24, ctxt);
    l1 = i1;
    l1 <<= 32;
    l2 = intFromChars(id, 28, ctxt);
    // sign removal, Java-style. Ugh.
    l2 = (l2 << 32) >>> 32;
    long lo = l1 | l2;
    return new UUID(hi, lo);
}","public void test2929() throws Throwable {
    Class<Object> class0 = Object.class;
    FromStringDeserializer.findDeserializer(class0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 8);
    fromStringDeserializer_Std0._deserialize(""EloQ|qJz4=Dl_"", defaultDeserializationContext_Impl0);
    UUIDDeserializer uUIDDeserializer0 = new UUIDDeserializer();
    uUIDDeserializer0._deserialize(""[3"", defaultDeserializationContext_Impl0);
}",""
"public static Std findDeserializer(Class<?> rawType) {
    int kind = 0;
    if (rawType == File.class) {
        kind = Std.STD_FILE;
    } else if (rawType == URL.class) {
        kind = Std.STD_URL;
    } else if (rawType == URI.class) {
        kind = Std.STD_URI;
    } else if (rawType == Class.class) {
        kind = Std.STD_CLASS;
    } else if (rawType == JavaType.class) {
        kind = Std.STD_JAVA_TYPE;
    } else if (rawType == Currency.class) {
        kind = Std.STD_CURRENCY;
    } else if (rawType == Pattern.class) {
        kind = Std.STD_PATTERN;
    } else if (rawType == Locale.class) {
        kind = Std.STD_LOCALE;
    } else if (rawType == Charset.class) {
        kind = Std.STD_CHARSET;
    } else if (rawType == TimeZone.class) {
        kind = Std.STD_TIME_ZONE;
    } else if (rawType == InetAddress.class) {
        kind = Std.STD_INET_ADDRESS;
    } else if (rawType == InetSocketAddress.class) {
        kind = Std.STD_INET_SOCKET_ADDRESS;
    } else {
        return null;
    }
    return new Std(rawType, kind);
}","public void test3030() throws Throwable {
    Class<TimeZone> class0 = TimeZone.class;
    FromStringDeserializer.findDeserializer(class0);
    Class<Integer> class1 = Integer.class;
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.copy();
    FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class1, 8);
    FromStringDeserializer.Std fromStringDeserializer_Std1 = new FromStringDeserializer.Std(class1, 8);
    fromStringDeserializer_Std0._deserialize(""WRITEDATES_AS_TIMESAMPS"", defaultDeserializationContext_Impl0);
    FromStringDeserializer.findDeserializer(class1);
}","/**
 * Factory method for trying to find a deserializer for one of supported
 * types that have simple from-String serialization.
 */"
