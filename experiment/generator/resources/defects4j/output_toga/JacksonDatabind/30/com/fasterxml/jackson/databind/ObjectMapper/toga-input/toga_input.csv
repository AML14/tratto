focal_method,test_prefix,docstring
"public ObjectMapper setNodeFactory(JsonNodeFactory f) {
    _deserializationConfig = _deserializationConfig.with(f);
    return this;
}","public void test0000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(false);
    ObjectMapper objectMapper1 = objectMapper0.setNodeFactory(jsonNodeFactory0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for specifying {@link JsonNodeFactory} to use for
 * constructing root level tree nodes (via method
 * {@link #createObjectNode}
 */"
"@Deprecated
public ObjectReader reader(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test0011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((JavaType) null);
    assertNotNull(objectReader0);
}","/**
 * @deprecated Since 2.5, use {@link #readerFor(JavaType)} instead
 */"
"public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, cause);
}","public void test0022() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayDeque> class0 = ArrayDeque.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    AtomicReference<Throwable> atomicReference0 = new AtomicReference<Throwable>();
    boolean boolean0 = objectMapper0.canDeserialize((JavaType) collectionType0, atomicReference0);
    assertTrue(boolean0);
}","/**
 * Method similar to {@link #canDeserialize(JavaType)} but that can return
 * actual {@link Throwable} that was thrown when trying to construct
 * serializer: this may be useful in figuring out what the actual problem is.
 *
 * @since 2.3
 */"
"@Deprecated
public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {
    addMixIn(target, mixinSource);
}","public void test0033() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<MockFileReader> class0 = MockFileReader.class;
    objectMapper0.addMixInAnnotations(class0, class0);
}","/**
 * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.
 */"
"public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {
    _serializationConfig = _serializationConfig.with(first, f);
    return this;
}","public void test0044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS;
    // Undeclared exception!
    try {
        objectMapper0.enable(serializationFeature0, (SerializationFeature[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean canDeserialize(JavaType type) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null);
}","public void test0055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    boolean boolean0 = objectMapper0.canDeserialize(javaType0);
    assertTrue(boolean0);
}","/**
 *  Method that can be called to check whether mapper thinks
 *  it could deserialize an Object of given type.
 *  Check is done by checking whether a registered deserializer can
 *  be found or built for the type; if not (either by no mapping being
 *  found, or through an <code>Exception</code> being thrown, false
 *  is returned.
 * <p>
 *  <b>NOTE</b>: in case an exception is thrown during course of trying
 *  co construct matching deserializer, it will be effectively swallowed.
 *  If you want access to that exception, call
 *  {@link #canDeserialize(JavaType, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */"
"public ObjectMapper enable(DeserializationFeature feature) {
    _deserializationConfig = _deserializationConfig.with(feature);
    return this;
}","public void test0066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY;
    ObjectMapper objectMapper1 = objectMapper0.enable(deserializationFeature0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public ObjectReader readerWithView(Class<?> view) {
    return _newReader(getDeserializationConfig().withView(view));
}","public void test0077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<PipedOutputStream> class0 = PipedOutputStream.class;
    ObjectReader objectReader0 = objectMapper0.readerWithView(class0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * deserialize objects using specified JSON View (filter).
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test0088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[5];
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<CollectionLikeType> class0 = CollectionLikeType.class;
    JavaType javaType0 = typeFactory0.uncheckedSimpleType(class0);
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, javaType0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""com.fasterxml.jackson.core.io.UTF32Reader"", e);
    }
}",""
"public ObjectReader reader(ContextAttributes attrs) {
    return _newReader(getDeserializationConfig().with(attrs));
}","public void test0099() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ContextAttributes contextAttributes0 = ContextAttributes.Impl.getEmpty();
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified default attributes.
 *
 * @since 2.3
 */"
"public ObjectMapper setDateFormat(DateFormat dateFormat) {
    _deserializationConfig = _deserializationConfig.with(dateFormat);
    _serializationConfig = _serializationConfig.with(dateFormat);
    return this;
}","public void test01010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DateFormat dateFormat0 = MockDateFormat.getDateTimeInstance();
    ObjectMapper objectMapper1 = objectMapper0.setDateFormat(dateFormat0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for configuring the default {@link DateFormat} to use when serializing time
 * values as Strings, and deserializing from JSON Strings.
 * This is preferably to directly modifying {@link SerializationConfig} and
 * {@link DeserializationConfig} instances.
 * If you need per-request configuration, use {@link #writer(DateFormat)} to
 * create properly configured {@link ObjectWriter} and use that; this because
 * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only
 * thread-safe when configuring methods (such as this one) are NOT called.
 */"
"public ObjectMapper setLocale(Locale l) {
    _deserializationConfig = _deserializationConfig.with(l);
    _serializationConfig = _serializationConfig.with(l);
    return this;
}","public void test01111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Locale locale0 = Locale.US;
    ObjectMapper objectMapper1 = objectMapper0.setLocale(locale0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for overriding default locale to use for formatting.
 * Default value used is {@link Locale#getDefault()}.
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test01515() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectReader objectReader0 = objectMapper0.reader(jsonNodeFactory0);
    TypeFactory typeFactory0 = objectReader0.getTypeFactory();
    Class<FloatNode> class0 = FloatNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    ObjectReader objectReader1 = objectMapper0.readerFor((JavaType) collectionLikeType0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Methods sub-classes MUST override
    /**********************************************************
     */
/**
 *  Method for creating a new {@link ObjectMapper} instance that
 *  has same initial configuration as this instance. Note that this
 *  also requires making a copy of the underlying {@link JsonFactory}
 *  instance.
 * <p>
 *  Method is typically
 *  used when multiple, differently configured mappers are needed.
 *  Although configuration is shared, cached serializers and deserializers
 *  are NOT shared, which means that the new instance may be re-configured
 *  before use; meaning that it behaves the same way as if an instance
 *  was constructed from scratch.
 *
 *  @since 2.1
 */
public ObjectMapper copy() {
    _checkInvalidCopy(ObjectMapper.class);
    return new ObjectMapper(this);
}","public void test01616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.copy();
    assertNotSame(objectMapper1, objectMapper0);
}",""
"public ObjectWriter writer(SerializationFeature first, SerializationFeature... other) {
    return _newWriter(getSerializationConfig().with(first, other));
}","public void test01818() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_WITH_ZONE_ID;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[2];
    // Undeclared exception!
    try {
        objectMapper0.writer(serializationFeature0, serializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializationConfig"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectWriter} with
 * specified features enabled (compared to settings that this
 * mapper instance has).
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test01919() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, (TypeReference) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"public ObjectMapper setTimeZone(TimeZone tz) {
    _deserializationConfig = _deserializationConfig.with(tz);
    _serializationConfig = _serializationConfig.with(tz);
    return this;
}","public void test02121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TimeZone timeZone0 = TimeZone.getDefault();
    ObjectMapper objectMapper1 = objectMapper0.setTimeZone(timeZone0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for overriding default TimeZone to use for formatting.
 * Default value used is UTC (NOT local timezone).
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonGenerator.Feature
    /**********************************************************
     */
public boolean isEnabled(JsonGenerator.Feature f) {
    return _serializationConfig.isEnabled(f, _jsonFactory);
}","public void test02222() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM;
    boolean boolean0 = objectMapper0.isEnabled(jsonGenerator_Feature0);
    assertTrue(boolean0);
}",""
"public ObjectReader readerFor(TypeReference<?> type) {
    return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues);
}","public void test02323() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.readerFor((TypeReference<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectMapper findAndRegisterModules() {
    return registerModules(findModules());
}","public void test02424() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.findAndRegisterModules();
    assertSame(objectMapper1, objectMapper0);
}","/**
 *  Convenience method that is functionally equivalent to:
 * <code>
 *    mapper.registerModules(mapper.findModules());
 * </code>
 * <p>
 *  As with {@link #findModules()}, no caching is done for modules, so care
 *  needs to be taken to either create and share a single mapper instance;
 *  or to cache introspected set of modules.
 *
 *  @since 2.2
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test02626() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory.Feature jsonFactory_Feature0 = JsonFactory.Feature.INTERN_FIELD_NAMES;
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(jsonFactory_Feature0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test02727() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DateFormat dateFormat0 = MockDateFormat.getTimeInstance();
    ObjectWriter objectWriter0 = objectMapper0.writer(dateFormat0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);
}","public void test02828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SimpleModule> class0 = SimpleModule.class;
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"public ObjectMapper setConfig(DeserializationConfig config) {
    _deserializationConfig = config;
    return this;
}","public void test02929() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setConfig((DeserializationConfig) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method that allows overriding of the underlying {@link DeserializationConfig}
 *  object.
 *  It is added as a fallback method that may be used if no other configuration
 *  modifier method works: it should not be used if there are alternatives,
 *  and its use is generally discouraged.
 * <p>
 *  <b>NOTE</b>: only use this method if you know what you are doing -- it allows
 *  by-passing some of checks applied to other configuration methods.
 *  Also keep in mind that as with all configuration of {@link ObjectMapper},
 *  this is only thread-safe if done before calling any deserialization methods.
 *
 *  @since 2.4
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03030() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider();
    ObjectWriter objectWriter0 = objectMapper0.writer((FilterProvider) simpleFilterProvider0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);
}","public void test03131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    try {
        objectMapper0.readValue(""E"", (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'E': was expecting ('true', 'false' or 'null')
        //  at [Source: java.lang.String@0000000048; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method to deserialize JSON content from given JSON content String.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public boolean willFailOnUnknownId() {
    return _cfgFailOnUnknownId;
}","public void test03232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider();
    objectMapper0.setFilters(simpleFilterProvider0);
    assertTrue(simpleFilterProvider0.willFailOnUnknownId());
}",""
"public ObjectReader reader(DeserializationFeature feature) {
    return _newReader(getDeserializationConfig().with(feature));
}","public void test03333() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_LONG_FOR_INTS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} with
 * specified feature enabled (compared to settings that this
 * mapper instance has).
 * Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test03434() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"", ""JSON"");
    objectMapper0.writeValue((File) mockFile0, (Object) jsonFactory0);
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(mockFile0);
    // Undeclared exception!
    try {
        objectMapper0.readValue((InputStream) mockFileInputStream0, (JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03535() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectWriter objectWriter0 = objectMapper0.writerWithType(javaType0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03636() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<PipedInputStream> class0 = PipedInputStream.class;
    ObjectWriter objectWriter0 = objectMapper0.writerWithView(class0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03737() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.enableDefaultTyping();
    Class<BufferedInputStream> class0 = BufferedInputStream.class;
    ObjectWriter objectWriter0 = objectMapper0.writerWithType(class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));
}","public void test03838() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[1];
    TypeReference<FilterInputStream> typeReference0 = (TypeReference<FilterInputStream>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, (int) 51, 3, (TypeReference) typeReference0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 51
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}",""
"@Override
@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));
}","public void test03939() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    JsonParser jsonParser0 = objectMapper0.treeAsTokens(objectNode0);
    TypeReference<OutputStreamWriter> typeReference0 = (TypeReference<OutputStreamWriter>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue(jsonParser0, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method to deserialize JSON content into a Java type, reference
 * to which is passed as argument. Type is passed using so-called
 * ""super type token"" (see )
 * and specifically needs to be used if the root type is a
 * parameterized (generic) container type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test04040() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    char[] charArray0 = new char[4];
    CharArrayReader charArrayReader0 = new CharArrayReader(charArray0);
    PushbackReader pushbackReader0 = new PushbackReader(charArrayReader0);
    Class<SimpleType> class0 = SimpleType.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    try {
        objectMapper0.readValue((Reader) pushbackReader0, (JavaType) simpleType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: java.io.PushbackReader@0000000049; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}",""
"public ObjectReader reader(FormatSchema schema) {
    _verifySchemaType(schema);
    return _newReader(getDeserializationConfig(), null, null, schema, _injectableValues);
}","public void test04242() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * pass specific schema object to {@link JsonParser} used for
 * reading content.
 *
 * @param schema Schema to pass to parser
 */"
"/*
    /**********************************************************
    /* Configuration, introspection
    /**********************************************************
     */
/**
 * Method for accessing currently configured visibility checker;
 * object used for determining whether given property element
 * (method, field, constructor) can be auto-detected or not.
 */
public VisibilityChecker<?> getVisibilityChecker() {
    return _serializationConfig.getDefaultVisibilityChecker();
}","public void test04545() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    VisibilityChecker<?> visibilityChecker0 = objectMapper0.getVisibilityChecker();
    assertNotNull(visibilityChecker0);
}",""
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test04646() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    Float float0 = new Float(0.0F);
    ValueNode valueNode0 = jsonNodeFactory0.numberNode(float0);
    Class<Object> class0 = Object.class;
    Object object0 = objectMapper0.treeToValue((TreeNode) valueNode0, class0);
    assertEquals(0.0, object0);
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"public ObjectMapper enable(SerializationFeature f) {
    _serializationConfig = _serializationConfig.with(f);
    return this;
}","public void test04747() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRAP_ROOT_VALUE;
    ObjectMapper objectMapper1 = objectMapper0.enable(serializationFeature0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for enabling specified {@link DeserializationConfig} feature.
 * Modifies and returns this instance; no new object is created.
 */"
"public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {
    _deserializationConfig = _deserializationConfig.with(first, f);
    return this;
}","public void test04848() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[3];
    // Undeclared exception!
    try {
        objectMapper0.enable(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test05050() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFile mockFile0 = new MockFile(""MIME-NO-LINEFEEDS"", ""MIME-NO-LINEFEEDS"");
    URL uRL0 = mockFile0.toURL();
    try {
        objectMapper0.readValue(uRL0, (JavaType) null);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test05151() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayDeque> class0 = ArrayDeque.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFile mockFile0 = new MockFile("" / 0x"");
    try {
        objectMapper0.readValue((File) mockFile0, (JavaType) collectionType0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Method to deserialize JSON content from given file into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"/*
    /**********************************************************
    /* Configuration: ser/deser factory, provider access
    /**********************************************************
     */
/**
 * Method for setting specific {@link SerializerFactory} to use
 * for constructing (bean) serializers.
 */
public ObjectMapper setSerializerFactory(SerializerFactory f) {
    _serializerFactory = f;
    return this;
}","public void test05252() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    ObjectMapper objectMapper1 = objectMapper0.setSerializerFactory(beanSerializerFactory0);
    assertSame(objectMapper1, objectMapper0);
}",""
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test05353() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""`7Q"");
    try {
        objectMapper0.writeValueAsBytes(mockFileOutputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class java.io.FileDescriptor and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) ) (through reference chain: org.evosuite.runtime.mock.java.io.MockFileOutputStream[\""fd\""])
        //
        verifyException(""com.fasterxml.jackson.databind.ser.impl.UnknownSerializer"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonParser.Feature
    /**********************************************************
     */
public boolean isEnabled(JsonParser.Feature f) {
    return _deserializationConfig.isEnabled(f, _jsonFactory);
}","public void test05454() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES;
    boolean boolean0 = objectMapper0.isEnabled(jsonParser_Feature0);
    assertFalse(boolean0);
}",""
"@Override
public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {
    return readValues(jp, _typeFactory.constructType(valueTypeRef));
}","public void test05555() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    char[] charArray0 = new char[7];
    JsonParser jsonParser0 = jsonFactory0.createParser(charArray0);
    // Undeclared exception!
    try {
        objectMapper0.readValues(jsonParser0, (TypeReference<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method for reading sequence of Objects from parser stream.
 */"
"public PropertyNamingStrategy getPropertyNamingStrategy() {
    // arbitrary choice but let's do:
    return _serializationConfig.getPropertyNamingStrategy();
}","public void test05656() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyNamingStrategy propertyNamingStrategy0 = objectMapper0.getPropertyNamingStrategy();
    assertNull(propertyNamingStrategy0);
}","/**
 * @since 2.5
 */"
"public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);
}","public void test05757() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""bWmU>&~cFa+>Q("");
    try {
        objectMapper0.writeValue((OutputStream) mockPrintStream0, (Object) mockPrintStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class org.evosuite.runtime.mock.java.io.MockPrintStream and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )
        //
        verifyException(""com.fasterxml.jackson.databind.ser.impl.UnknownSerializer"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  JSON output, using output stream provided (using encoding
 *  {@link JsonEncoding#UTF8}).
 * <p>
 *  Note: method does not close the underlying stream explicitly
 *  here; however, {@link JsonFactory} this mapper uses may choose
 *  to close the stream depending on its settings (by default,
 *  it will try to close it when {@link JsonGenerator} we construct
 *  is closed).
 */"
"public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(w), value);
}","public void test05858() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    StringWriter stringWriter0 = new StringWriter();
    objectMapper0.writeValue((Writer) stringWriter0, (Object) stringWriter0);
}","/**
 *  Method that can be used to serialize any Java value as
 *  JSON output, using Writer provided.
 * <p>
 *  Note: method does not close the underlying stream explicitly
 *  here; however, {@link JsonFactory} this mapper uses may choose
 *  to close the stream depending on its settings (by default,
 *  it will try to close it when {@link JsonGenerator} we construct
 *  is closed).
 */"
"public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {
    _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);
    return this;
}","public void test05959() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MinimalPrettyPrinter minimalPrettyPrinter0 = new MinimalPrettyPrinter(""=M>yjm3=#pVGc"");
    ObjectMapper objectMapper1 = objectMapper0.setDefaultPrettyPrinter(minimalPrettyPrinter0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for specifying {@link PrettyPrinter} to use when ""default pretty-printing""
 * is enabled (by enabling {@link SerializationFeature#INDENT_OUTPUT})
 *
 * @param pp Pretty printer to use by default.
 *
 * @return This mapper, useful for call-chaining
 *
 * @since 2.6
 */"
"public ObjectMapper configure(JsonParser.Feature f, boolean state) {
    _jsonFactory.configure(f, state);
    return this;
}","public void test06060() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS;
    ObjectMapper objectMapper1 = objectMapper0.configure(jsonParser_Feature0, true);
    assertSame(objectMapper1, objectMapper0);
}","/**
 *  Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s
 *  for parser instances this object mapper creates.
 * <p>
 *  Note that this is equivalent to directly calling same method
 *  on {@link #getFactory}.
 */"
"@Override
@SuppressWarnings(""unchecked"")
public final <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);
}","public void test06161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""com.fasterxml.jakson.databind.ObjectMapper$2"");
    Class<MockPrintWriter> class0 = MockPrintWriter.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    try {
        objectMapper0.readValue(jsonParser0, (ResolvedType) simpleType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'com': was expecting ('true', 'false' or 'null')
        //  at [Source: java.lang.String@0000000050; line: 1, column: 4]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method to deserialize JSON content into a Java type, reference
 * to which is passed as argument. Type is passed using
 * Jackson specific type; instance of which can be constructed using
 * {@link TypeFactory}.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"/*
    /**********************************************************
    /* Configuration, deserialization
    /**********************************************************
     */
/**
 *  Method that can be used to get hold of {@link JsonNodeFactory}
 *  that this mapper will use when directly constructing
 *  root {@link JsonNode} instances for Trees.
 * <p>
 *  Note: this is just a shortcut for calling
 * <pre>
 *    getDeserializationConfig().getNodeFactory()
 * </pre>
 */
public JsonNodeFactory getNodeFactory() {
    return _deserializationConfig.getNodeFactory();
}","public void test06262() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory((ObjectCodec) null);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    JsonNodeFactory jsonNodeFactory0 = objectMapper0.getNodeFactory();
    assertNotNull(jsonNodeFactory0);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test06363() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer();
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test06464() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    assertEquals(0, deserializationContext0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {
    _serializationConfig = _serializationConfig.with(ai);
    _deserializationConfig = _deserializationConfig.with(ai);
    return this;
}","public void test06565() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    ObjectMapper objectMapper1 = objectMapper0.setAnnotationIntrospector(annotationIntrospector0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting {@link AnnotationIntrospector} used by this
 * mapper instance for both serialization and deserialization.
 * Note that doing this will replace the current introspector, which
 * may lead to unavailability of core Jackson annotations.
 * If you want to combine handling of multiple introspectors,
 * have a look at {@link com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair}.
 *
 * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
 */"
"public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {
    _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);
    _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);
    return this;
}","public void test06666() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyAccessor propertyAccessor0 = PropertyAccessor.IS_GETTER;
    JsonAutoDetect.Visibility jsonAutoDetect_Visibility0 = JsonAutoDetect.Visibility.NON_PRIVATE;
    ObjectMapper objectMapper1 = objectMapper0.setVisibility(propertyAccessor0, jsonAutoDetect_Visibility0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Convenience method that allows changing configuration for
 *  underlying {@link VisibilityChecker}s, to change details of what kinds of
 *  properties are auto-detected.
 *  Basically short cut for doing:
 * <pre>
 *   mapper.setVisibilityChecker(
 *      mapper.getVisibilityChecker().withVisibility(forMethod, visibility)
 *   );
 * </pre>
 *  one common use case would be to do:
 * <pre>
 *   mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
 * </pre>
 *  which would make all member fields serializable without further annotations,
 *  instead of just public fields (default setting).
 *
 *  @param forMethod Type of property descriptor affected (field, getter/isGetter,
 *      setter, creator)
 *  @param visibility Minimum visibility to require for the property descriptors of type
 *
 *  @return Modified mapper instance (that is, ""this""), to allow chaining
 *     of configuration calls
 */"
"public ObjectMapper setSubtypeResolver(SubtypeResolver str) {
    _subtypeResolver = str;
    _deserializationConfig = _deserializationConfig.with(str);
    _serializationConfig = _serializationConfig.with(str);
    return this;
}","public void test06767() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper1 = objectMapper0.setSubtypeResolver(stdSubtypeResolver0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting custom subtype resolver to use.
 */"
"public ObjectMapper setInjectableValues(InjectableValues injectableValues) {
    _injectableValues = injectableValues;
    return this;
}","public void test06868() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectMapper objectMapper1 = objectMapper0.setInjectableValues(injectableValues_Std0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for configuring {@link InjectableValues} which used to find
 * values to inject.
 */"
"public SerializerProvider getSerializerProvider() {
    return _serializerProvider;
}","public void test06969() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProvider();
    assertSame(defaultSerializerProvider_Impl0, serializerProvider0);
}",""
"public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {
    _serializationConfig = _serializationConfig.with(s);
    _deserializationConfig = _deserializationConfig.with(s);
    return this;
}","public void test07070() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy propertyNamingStrategy_LowerCaseWithUnderscoresStrategy0 = (PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy) PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES;
    ObjectMapper objectMapper1 = objectMapper0.setPropertyNamingStrategy(propertyNamingStrategy_LowerCaseWithUnderscoresStrategy0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for setting custom property naming strategy to use.
 */"
"public Object setHandlerInstantiator(HandlerInstantiator hi) {
    _deserializationConfig = _deserializationConfig.with(hi);
    _serializationConfig = _serializationConfig.with(hi);
    return this;
}","public void test07272() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    HandlerInstantiator handlerInstantiator0 = mock(HandlerInstantiator.class, new ViolatedAssumptionAnswer());
    Object object0 = objectMapper0.setHandlerInstantiator(handlerInstantiator0);
    assertSame(objectMapper0, object0);
}","/**
 * Method for configuring {@link HandlerInstantiator} to use for creating
 * instances of handlers (such as serializers, deserializers, type and type
 * id resolvers), given a class.
 *
 * @param hi Instantiator to use; if null, use the default implementation
 */"
"/*
    /**********************************************************
    /* Extended Public API, accessors
    /**********************************************************
     */
/**
 *  Method that can be called to check whether mapper thinks
 *  it could serialize an instance of given Class.
 *  Check is done
 *  by checking whether a serializer can be found for the type.
 * <p>
 *  NOTE: since this method does NOT throw exceptions, but internal
 *  processing may, caller usually has little information as to why
 *  serialization would fail. If you want access to internal {@link Exception},
 *  call {@link #canSerialize(Class, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */
public boolean canSerialize(Class<?> type) {
    return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);
}","public void test07373() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<AbstractDeserializer> class0 = AbstractDeserializer.class;
    boolean boolean0 = objectMapper0.canSerialize(class0);
    assertTrue(boolean0);
}",""
"public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {
    TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);
    // we'll always use full class name, when using defaulting
    typer = typer.init(JsonTypeInfo.Id.CLASS, null);
    typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);
    typer = typer.typeProperty(propertyName);
    return setDefaultTyping(typer);
}","public void test07474() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, (String) null);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling automatic inclusion of type information -- needed
 * for proper deserialization of polymorphic types (unless types
 * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --
 * using ""As.PROPERTY"" inclusion mechanism and specified property name
 * to use for inclusion (default being ""@class"" since default type information
 * always uses class name as type identifier)
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test07676() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((CharacterEscapes) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Extended Public API: constructing ObjectReaders
    /* for more advanced configuration
    /**********************************************************
     */
/**
 * Factory method for constructing {@link ObjectReader} with
 * default settings. Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */
public ObjectReader reader() {
    return _newReader(getDeserializationConfig()).with(_injectableValues);
}","public void test07777() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    assertNotNull(objectReader0);
}",""
"public DateFormat getDateFormat() {
    // arbitrary choice but let's do:
    return _serializationConfig.getDateFormat();
}","public void test07878() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DateFormat dateFormat0 = objectMapper0.getDateFormat();
    assertNotNull(dateFormat0);
}","/**
 * @since 2.5
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), jp, valueType);
}","public void test07979() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    byte[] byteArray0 = new byte[8];
    JsonParser jsonParser0 = jsonFactory0.createParser(byteArray0);
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate(jsonParser0);
    Class<Throwable> class0 = Throwable.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Object> class1 = Object.class;
    MapLikeType mapLikeType0 = typeFactory0.constructRawMapLikeType(class1);
    MapType mapType0 = MapType.construct(class0, mapLikeType0, mapLikeType0);
    try {
        objectMapper0.readValue((JsonParser) jsonParserDelegate0, (JavaType) mapType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: [B@0000000051; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(jp, (JavaType) valueType);
}","public void test08080() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate((JsonParser) null);
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParserDelegate0, (JsonParser) null);
    // Undeclared exception!
    try {
        objectMapper0.readValues((JsonParser) jsonParserSequence0, (ResolvedType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} must point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather
 *  to the token following it.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {
    return _newReader(getDeserializationConfig().with(first, other));
}","public void test08181() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} with
 * specified features enabled (compared to settings that this
 * mapper instance has).
 * Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */"
"public ObjectReader reader(InjectableValues injectableValues) {
    return _newReader(getDeserializationConfig(), null, null, null, injectableValues);
}","public void test08282() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.reader((InjectableValues) null);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified injectable values.
 *
 * @param injectableValues Injectable values to use
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonFactory.Feature
    /**********************************************************
     */
/**
 *  Convenience method, equivalent to:
 * <pre>
 *   getJsonFactory().isEnabled(f);
 * </pre>
 */
public boolean isEnabled(JsonFactory.Feature f) {
    return _jsonFactory.isEnabled(f);
}","public void test08383() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory.Feature jsonFactory_Feature0 = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES;
    boolean boolean0 = objectMapper0.isEnabled(jsonFactory_Feature0);
    assertTrue(boolean0);
}",""
"// For testing only:
public int mixInCount() {
    return _mixIns.localSize();
}","public void test08484() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    int int0 = objectMapper0.mixInCount();
    assertEquals(0, int0);
}",""
"public boolean isFloat() {
    return false;
}","public void test08585() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectNode objectNode0 = objectMapper0.createObjectNode();
    assertFalse(objectNode0.isFloat());
}","/**
 * @since 2.2
 */"
"public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {
    return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);
}","public void test08686() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<FloatNode> class0 = FloatNode.class;
    AtomicReference<Throwable> atomicReference0 = new AtomicReference<Throwable>();
    boolean boolean0 = objectMapper0.canSerialize(class0, atomicReference0);
    assertTrue(boolean0);
}","/**
 * Method similar to {@link #canSerialize(Class)} but that can return
 * actual {@link Throwable} that was thrown when trying to construct
 * serializer: this may be useful in figuring out what the actual problem is.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: SerializationFeature
    /**********************************************************
     */
/**
 * Method for checking whether given serialization-specific
 * feature is enabled.
 */
public boolean isEnabled(SerializationFeature f) {
    return _serializationConfig.isEnabled(f);
}","public void test08787() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS;
    boolean boolean0 = objectMapper0.isEnabled(serializationFeature0);
    assertFalse(boolean0);
}",""
"public SerializerFactory getSerializerFactory() {
    return _serializerFactory;
}","public void test08888() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerFactory serializerFactory0 = objectMapper0.getSerializerFactory();
    assertNotNull(serializerFactory0);
}","/**
 *  Method for getting current {@link SerializerFactory}.
 * <p>
 *  Note that since instances are immutable, you can NOT change settings
 *  by accessing an instance and calling methods: this will simply create
 *  new instance of factory object.
 */"
"public ObjectMapper clearProblemHandlers() {
    _deserializationConfig = _deserializationConfig.withNoProblemHandlers();
    return this;
}","public void test08989() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.clearProblemHandlers();
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for removing all registered {@link DeserializationProblemHandler}s
 * instances from this mapper.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test09090() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFile mockFile0 = new MockFile(""&"");
    URL uRL0 = mockFile0.toURL();
    try {
        objectMapper0.readValue(uRL0, (TypeReference) null);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Method to deserialize JSON content from given resource into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public ObjectMapper setBase64Variant(Base64Variant v) {
    _serializationConfig = _serializationConfig.with(v);
    _deserializationConfig = _deserializationConfig.with(v);
    return this;
}","public void test09191() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setBase64Variant((Base64Variant) null);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method that will configure default {@link Base64Variant} that
 * <code>byte[]</code> serializers and deserializers will use.
 *
 * @param v Base64 variant to use
 *
 * @return This mapper, for convenience to allow chaining
 *
 * @since 2.1
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test09292() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerWithDefaultPrettyPrinter();
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@Deprecated
protected PrettyPrinter _defaultPrettyPrinter() {
    return _serializationConfig.constructDefaultPrettyPrinter();
}","public void test09393() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PrettyPrinter prettyPrinter0 = objectMapper0._defaultPrettyPrinter();
    assertNotNull(prettyPrinter0);
}","/**
 * @deprecated Since 2.6, use {@link SerializationConfig#constructDefaultPrettyPrinter()} directly
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);
}","public void test09494() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[8];
    Class<PipedWriter> class0 = PipedWriter.class;
    JavaType javaType0 = TypeFactory.unknownType();
    CollectionType collectionType0 = CollectionType.construct(class0, javaType0);
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, 580, 2, (JavaType) collectionType0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 580
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}",""
"public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
    _serializationConfig = _serializationConfig.withSerializationInclusion(incl);
    return this;
}","public void test09595() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.NON_ABSENT;
    ObjectMapper objectMapper1 = objectMapper0.setSerializationInclusion(jsonInclude_Include0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting default POJO property inclusion strategy for serialization.
 */"
"public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {
    _serializationConfig = _serializationConfig.without(first, f);
    return this;
}","public void test09696() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_WITH_ZONE_ID;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[4];
    // Undeclared exception!
    try {
        objectMapper0.disable(serializationFeature0, serializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public InjectableValues getInjectableValues() {
    return _injectableValues;
}","public void test09797() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    InjectableValues injectableValues0 = objectMapper0.getInjectableValues();
    assertNull(injectableValues0);
}","/**
 * @since 2.6
 */"
"public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {
    _deserializationConfig = _deserializationConfig.without(first, f);
    return this;
}","public void test09898() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_INTEGER_FOR_INTS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[2];
    // Undeclared exception!
    try {
        objectMapper0.disable(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public Class<?> findMixInClassFor(Class<?> cls) {
    return _mixIns.findMixInClassFor(cls);
}","public void test101101() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BigIntegerNode> class0 = BigIntegerNode.class;
    Class<?> class1 = objectMapper0.findMixInClassFor(class0);
    assertNull(class1);
}",""
"public ObjectMapper setConfig(SerializationConfig config) {
    _serializationConfig = config;
    return this;
}","public void test103103() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    SerializationConfig serializationConfig0 = new SerializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    ObjectMapper objectMapper1 = objectMapper0.setConfig(serializationConfig0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method that allows overriding of the underlying {@link SerializationConfig}
 *  object, which contains serialization-specific configuration settings.
 *  It is added as a fallback method that may be used if no other configuration
 *  modifier method works: it should not be used if there are alternatives,
 *  and its use is generally discouraged.
 * <p>
 *  <b>NOTE</b>: only use this method if you know what you are doing -- it allows
 *  by-passing some of checks applied to other configuration methods.
 *  Also keep in mind that as with all configuration of {@link ObjectMapper},
 *  this is only thread-safe if done before calling any serialization methods.
 *
 *  @since 2.4
 */"
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test104104() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<Throwable>[] classArray0 = (Class<Throwable>[]) Array.newInstance(Class.class, 2);
    Class<Throwable> class0 = Throwable.class;
    classArray0[0] = class0;
    classArray0[1] = class0;
    simpleModule0.registerSubtypes(classArray0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper1, objectMapper0);
}",""
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test105105() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeReference<POJONode> typeReference0 = (TypeReference<POJONode>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        objectMapper0.readValue((File) null, (TypeReference) typeReference0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Method to deserialize JSON content from given file into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public JavaType constructType(Type t) {
    return _typeFactory.constructType(t);
}","public void test106106() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.constructType((Type) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Convenience method for constructing {@link JavaType} out of given
 * type (typically <code>java.lang.Class</code>), but without explicit
 * context.
 */"
"public ObjectMapper disable(SerializationFeature f) {
    _serializationConfig = _serializationConfig.without(f);
    return this;
}","public void test107107() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS;
    ObjectMapper objectMapper1 = objectMapper0.disable(serializationFeature0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test108108() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((Base64Variant) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test109109() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    char[] charArray0 = new char[0];
    CharArrayReader charArrayReader0 = new CharArrayReader(charArray0);
    TypeReference<ObjectOutputStream> typeReference0 = (TypeReference<ObjectOutputStream>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue((Reader) charArrayReader0, (TypeReference) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"public ObjectMapper setFilterProvider(FilterProvider filterProvider) {
    _serializationConfig = _serializationConfig.withFilters(filterProvider);
    return this;
}","public void test110110() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    HashMap<String, AbstractDeserializer> hashMap0 = new HashMap<String, AbstractDeserializer>();
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider(hashMap0);
    ObjectMapper objectMapper1 = objectMapper0.setFilterProvider(simpleFilterProvider0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method for configuring this mapper to use specified {@link FilterProvider} for
 *  mapping Filter Ids to actual filter instances.
 * <p>
 *  Note that usually it is better to use method {@link #writer(FilterProvider)};
 *  however, sometimes
 *  this method is more convenient. For example, some frameworks only allow configuring
 *  of ObjectMapper instances and not {@link ObjectWriter}s.
 *
 *  @since 2.6
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {
    return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));
}","public void test111111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeReference<ByteArrayInputStream> typeReference0 = (TypeReference<ByteArrayInputStream>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    try {
        objectMapper0.convertValue((Object) null, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test112112() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ContextAttributes contextAttributes0 = ContextAttributes.Impl.getEmpty();
    ObjectWriter objectWriter0 = objectMapper0.writer(contextAttributes0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectMapper addHandler(DeserializationProblemHandler h) {
    _deserializationConfig = _deserializationConfig.withHandler(h);
    return this;
}","public void test113113() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    ObjectMapper objectMapper1 = objectMapper0.addHandler(deserializationProblemHandler0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for adding specified {@link DeserializationProblemHandler}
 * to be used for handling specific problems during deserialization.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test114114() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PipedInputStream pipedInputStream0 = new PipedInputStream(5);
    TypeReference<TextNode> typeReference0 = (TypeReference<TextNode>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    try {
        objectMapper0.readValue((InputStream) pipedInputStream0, (TypeReference) typeReference0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"/*
    /**********************************************************
    /* Configuration, basic type handling
    /**********************************************************
     */
/**
 * Accessor for getting currently configured {@link TypeFactory} instance.
 */
public TypeFactory getTypeFactory() {
    return _typeFactory;
}","public void test115115() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    TypeFactory typeFactory0 = objectMapper0.getTypeFactory();
    assertNotNull(typeFactory0);
}",""
"public ObjectMapper disable(DeserializationFeature feature) {
    _deserializationConfig = _deserializationConfig.without(feature);
    return this;
}","public void test116116() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS;
    ObjectMapper objectMapper1 = objectMapper0.disable(deserializationFeature0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test117117() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    Class<BinaryNode> class0 = BinaryNode.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    ObjectWriter objectWriter0 = objectMapper0.writerFor((JavaType) simpleType0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {
    _jsonFactory.configure(f, state);
    return this;
}","public void test118118() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    ObjectMapper objectMapper1 = objectMapper0.configure(jsonGenerator_Feature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method for changing state of an on/off {@link JsonGenerator} feature for
 *  generator instances this object mapper creates.
 * <p>
 *  Note that this is equivalent to directly calling same method
 *  on {@link #getFactory}.
 */"
"public ObjectMapper disableDefaultTyping() {
    return setDefaultTyping(null);
}","public void test119119() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.disableDefaultTyping();
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for disabling automatic inclusion of type information; if so, only
 * explicitly annotated types (ones with
 * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have
 * additional embedded type information.
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: DeserializationFeature
    /**********************************************************
     */
/**
 * Method for checking whether given deserialization-specific
 * feature is enabled.
 */
public boolean isEnabled(DeserializationFeature f) {
    return _deserializationConfig.isEnabled(f);
}","public void test120120() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, (DefaultDeserializationContext) null);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.UNWRAP_ROOT_VALUE;
    boolean boolean0 = objectMapper0.isEnabled(deserializationFeature0);
    assertFalse(boolean0);
}",""
"public ObjectMapper setTypeFactory(TypeFactory f) {
    _typeFactory = f;
    _deserializationConfig = _deserializationConfig.with(f);
    _serializationConfig = _serializationConfig.with(f);
    return this;
}","public void test121121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setTypeFactory((TypeFactory) null);
    assertSame(objectMapper1, objectMapper0);
}","/**
 *  Method that can be used to override {@link TypeFactory} instance
 *  used by this mapper.
 * <p>
 *  Note: will also set {@link TypeFactory} that deserialization and
 *  serialization config objects use.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));
}","public void test122122() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeReference<ByteArrayOutputStream> typeReference0 = (TypeReference<ByteArrayOutputStream>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue(""1nu8\""C"", (TypeReference) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method to deserialize JSON content from given JSON content String.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {
    _serializerProvider = p;
    return this;
}","public void test123123() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    ObjectMapper objectMapper1 = objectMapper0.setSerializerProvider(defaultSerializerProvider_Impl0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for setting specific {@link SerializerProvider} to use
 * for handling caching of {@link JsonSerializer} instances.
 */"
"public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {
    _serializationConfig = _serializationConfig.with(serializerAI);
    _deserializationConfig = _deserializationConfig.with(deserializerAI);
    return this;
}","public void test124124() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setAnnotationIntrospectors((AnnotationIntrospector) null, (AnnotationIntrospector) null);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for changing {@link AnnotationIntrospector} instances used
 * by this mapper instance for serialization and deserialization,
 * specifying them separately so that different introspection can be
 * used for different aspects
 *
 * @since 2.1
 *
 * @param serializerAI {@link AnnotationIntrospector} to use for configuring
 *    serialization
 * @param deserializerAI {@link AnnotationIntrospector} to use for configuring
 *    deserialization
 *
 * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
 */"
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test125125() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<StringReader> class0 = StringReader.class;
    JsonSerializer<StringReader> jsonSerializer0 = (JsonSerializer<StringReader>) mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
    simpleModule0.addKeySerializer((Class<? extends StringReader>) class0, jsonSerializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test127127() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Version version0 = new Version((-1633), 24, (-1633), (String) null, ""null"", (String) null);
    SimpleModule simpleModule0 = new SimpleModule(version0);
    Class<SimpleModule> class0 = SimpleModule.class;
    JsonDeserializer<SimpleModule> jsonDeserializer0 = (JsonDeserializer<SimpleModule>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    simpleModule0.addDeserializer(class0, (JsonDeserializer<? extends SimpleModule>) jsonDeserializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test128128() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Version version0 = new Version((-1633), 24, (-1633), (String) null, ""null"", (String) null);
    SimpleModule simpleModule0 = new SimpleModule(version0);
    Class<FloatNode> class0 = FloatNode.class;
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    SimpleModule simpleModule1 = simpleModule0.addValueInstantiator(class0, jsonLocationInstantiator0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper1, objectMapper0);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test129129() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Version version0 = new Version((-1633), 24, (-1633), (String) null, ""null"", (String) null);
    SimpleModule simpleModule0 = new SimpleModule(version0);
    Class<DataInputStream> class0 = DataInputStream.class;
    JsonSerializer<FilterInputStream> jsonSerializer0 = (JsonSerializer<FilterInputStream>) mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
    SimpleModule simpleModule1 = simpleModule0.addSerializer((Class<? extends FilterInputStream>) class0, jsonSerializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test130130() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Version version0 = new Version((-1633), 24, (-1633), (String) null, ""null"", (String) null);
    SimpleModule simpleModule0 = new SimpleModule(version0);
    Class<FloatNode> class0 = FloatNode.class;
    Class<DataInputStream> class1 = DataInputStream.class;
    SimpleModule simpleModule1 = simpleModule0.setMixInAnnotation(class0, class1);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test131131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    BeanSerializerModifier beanSerializerModifier0 = mock(BeanSerializerModifier.class, new ViolatedAssumptionAnswer());
    simpleModule0.setSerializerModifier(beanSerializerModifier0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper0, objectMapper1);
}",""
"@SuppressWarnings(""resource"")
public String writeValueAsString(Object value) throws JsonProcessingException {
    // alas, we have to pull the recycler directly here...
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public void test133133() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTyping();
    try {
        objectMapper0.writeValueAsString(objectMapper1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Infinite recursion (StackOverflowError) (through reference chain: com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""]->com.fasterxml.jackson.databind.ObjectMapper[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""])
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a String. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
 *  and constructing String, but more efficient.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"public boolean isShort() {
    return false;
}","public void test137137() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS;
    ObjectMapper.DefaultTypeResolverBuilder objectMapper_DefaultTypeResolverBuilder0 = new ObjectMapper.DefaultTypeResolverBuilder(objectMapper_DefaultTyping0);
    JsonFactory jsonFactory0 = new JsonFactory();
    BufferRecycler bufferRecycler0 = jsonFactory0._getBufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, objectMapper_DefaultTypeResolverBuilder0, false);
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 2, objectMapper0, mockPrintStream0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringGeneratorDelegate filteringGeneratorDelegate0 = new FilteringGeneratorDelegate(uTF8JsonGenerator0, tokenFilter0, true, true);
    IntNode intNode0 = IntNode.valueOf(68);
    objectMapper0.writeTree((JsonGenerator) filteringGeneratorDelegate0, (TreeNode) intNode0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.PROPERTY;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0, jsonTypeInfo_As0);
    JsonNode jsonNode0 = objectMapper1.readTree((File) mockFile0);
    assertFalse(jsonNode0.isShort());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>short</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java short
 */"
"protected void _checkInvalidCopy(Class<?> exp) {
    if (getClass() != exp) {
        throw new IllegalStateException(""Failed copy(): "" + getClass().getName() + "" (version: "" + version() + "") does not override copy(); it has to"");
    }
}","public void test141141() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SimpleModule> class0 = SimpleModule.class;
    // Undeclared exception!
    try {
        objectMapper0._checkInvalidCopy(class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Failed copy(): com.fasterxml.jackson.databind.ObjectMapper (version: 2.6.3-SNAPSHOT) does not override copy(); it has to
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 * @since 2.1
 */"
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test142142() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule((String) null, (Version) null);
    // Undeclared exception!
    try {
        objectMapper0.registerModule(simpleModule0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Module without defined name
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test143143() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule(""w{bsF%"", (Version) null);
    // Undeclared exception!
    try {
        objectMapper0.registerModule(simpleModule0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Module without defined version
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}",""
"public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {
    SimpleMixInResolver r = _mixIns.withOverrides(resolver);
    if (r != _mixIns) {
        _mixIns = r;
        _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);
        _serializationConfig = new SerializationConfig(_serializationConfig, r);
    }
    return this;
}","public void test147147() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    ObjectMapper objectMapper1 = objectMapper0.setMixInResolver(simpleMixInResolver0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method that can be called to specify given resolver for locating
 * mix-in classes to use, overriding directly added mappings.
 * Note that direct mappings are not cleared, but they are only applied
 * if resolver does not provide mix-in matches.
 *
 * @since 2.6
 */"
"public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {
    /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to
         *   use ""As.EXTERNAL_PROPERTY"", since that will not work (with 2.5+)
         */
    if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
        throw new IllegalArgumentException(""Can not use includeAs of "" + includeAs);
    }
    TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);
    // we'll always use full class name, when using defaulting
    typer = typer.init(JsonTypeInfo.Id.CLASS, null);
    typer = typer.inclusion(includeAs);
    return setDefaultTyping(typer);
}","public void test148148() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS;
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXTERNAL_PROPERTY;
    // Undeclared exception!
    try {
        objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0, jsonTypeInfo_As0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not use includeAs of EXTERNAL_PROPERTY
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 *  Method for enabling automatic inclusion of type information, needed
 *  for proper deserialization of polymorphic types (unless types
 *  have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).
 * <P>
 *  NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;
 *  and attempts of do so will throw an {@link IllegalArgumentException} to make
 *  this limitation explicit.
 *
 *  @param applicability Defines kinds of types for which additional type information
 *     is added; see {@link DefaultTyping} for more information.
 */"
"public ObjectMapper configure(MapperFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test149149() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, false);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off mapper feature for
 * this mapper instance.
 */"
"public ObjectMapper configure(MapperFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test150150() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.USE_STD_BEAN_NAMING;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off mapper feature for
 * this mapper instance.
 */"
"public ObjectMapper configure(SerializationFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    return this;
}","public void test151151() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_ENUMS_USING_INDEX;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, false);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for changing state of an on/off serialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(SerializationFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    return this;
}","public void test152152() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off serialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(DeserializationFeature f, boolean state) {
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test153153() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES;
    ObjectMapper objectMapper1 = objectMapper0.configure(deserializationFeature0, false);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for changing state of an on/off deserialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(DeserializationFeature f, boolean state) {
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test154154() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL;
    ObjectMapper objectMapper1 = objectMapper0.configure(deserializationFeature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off deserialization feature for
 * this object mapper.
 */"
"@Override
public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {
    /* 02-Mar-2009, tatu: One twist; deserialization provider
         *   will map JSON null straight into Java null. But what
         *   we want to return is the ""null node"" instead.
         */
    /* 05-Aug-2011, tatu: Also, must check for EOF here before
         *   calling readValue(), since that'll choke on it otherwise
         */
    DeserializationConfig cfg = getDeserializationConfig();
    JsonToken t = jp.getCurrentToken();
    if (t == null) {
        t = jp.nextToken();
        if (t == null) {
            return null;
        }
    }
    JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);
    if (n == null) {
        n = getNodeFactory().nullNode();
    }
    @SuppressWarnings(""unchecked"")
    T result = (T) n;
    return result;
}","public void test160160() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DoubleNode doubleNode0 = DoubleNode.valueOf(2);
    JsonParser jsonParser0 = objectMapper0.treeAsTokens(doubleNode0);
    DoubleNode doubleNode1 = objectMapper0.readTree(jsonParser0);
    assertNotNull(doubleNode1);
}","/**
 * Method to deserialize JSON content as tree expressed
 * using set of {@link JsonNode} instances. Returns
 * root of the resulting tree (where root can consist
 * of just a single node if the current event is a
 * value event, not container).
 *
 * @return a {@link JsonNode}, if valid JSON content found; null
 *   if input has no content to bind -- note, however, that if
 *   JSON <code>null</code> token is found, it will be represented
 *   as a non-null {@link JsonNode} (one that returns <code>true</code>
 *   for {@link JsonNode#isNull()}
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 */"
"@Override
public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {
    /* 02-Mar-2009, tatu: One twist; deserialization provider
         *   will map JSON null straight into Java null. But what
         *   we want to return is the ""null node"" instead.
         */
    /* 05-Aug-2011, tatu: Also, must check for EOF here before
         *   calling readValue(), since that'll choke on it otherwise
         */
    DeserializationConfig cfg = getDeserializationConfig();
    JsonToken t = jp.getCurrentToken();
    if (t == null) {
        t = jp.nextToken();
        if (t == null) {
            return null;
        }
    }
    JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);
    if (n == null) {
        n = getNodeFactory().nullNode();
    }
    @SuppressWarnings(""unchecked"")
    T result = (T) n;
    return result;
}","public void test161162() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    char[] charArray0 = new char[0];
    JsonParser jsonParser0 = jsonFactory0.createParser(charArray0);
    ObjectNode objectNode0 = objectMapper0.readTree(jsonParser0);
    assertNull(objectNode0);
}","/**
 * Method to deserialize JSON content as tree expressed
 * using set of {@link JsonNode} instances. Returns
 * root of the resulting tree (where root can consist
 * of just a single node if the current event is a
 * value event, not container).
 *
 * @return a {@link JsonNode}, if valid JSON content found; null
 *   if input has no content to bind -- note, however, that if
 *   JSON <code>null</code> token is found, it will be represented
 *   as a non-null {@link JsonNode} (one that returns <code>true</code>
 *   for {@link JsonNode#isNull()}
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 */"
"public double doubleValue() {
    return 0.0;
}","public void test162163() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[6];
    byteArray0[5] = (byte) 54;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 5, (byte) 5);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(byteArrayInputStream0, (byte) 54);
    JsonNode jsonNode0 = objectMapper0.readTree((InputStream) bufferedInputStream0);
    assertEquals(6.0, jsonNode0.doubleValue(), 0.01);
}","/**
 * Returns 64-bit floating point (double) value for this node, <b>if and only if</b>
 * this node is numeric ({@link #isNumber} returns true). For other
 * types returns 0.0.
 * For integer values, conversion is done using coercion; this may result
 * in overflows with {@link BigInteger} values.
 *
 * @return 64-bit double value this node contains, if any; 0.0 for non-number nodes.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Public API, type introspection
    /**********************************************************
     */
// // First high-level division between values, containers and ""missing""
/**
 * Return the type of this node
 *
 * @return the node type as a {@link JsonNodeType} enum value
 *
 * @since 2.2
 */
public abstract JsonNodeType getNodeType();","public void test163164() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 51;
    JsonNode jsonNode0 = objectMapper0.readTree(byteArray0);
    assertEquals(JsonNodeType.NUMBER, jsonNode0.getNodeType());
}",""
"/*
    /**********************************************************
    /* Public API, value access with conversion(s)/coercion(s)
    /**********************************************************
     */
/**
 * Method that will return a valid String representation of
 * the container value, if the node is a value node
 * (method {@link #isValueNode} returns true),
 * otherwise empty String.
 */
public abstract String asText();","public void test164165() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"", ""JSON"");
    objectMapper0.writeValue((File) mockFile0, (Object) jsonFactory0);
    URL uRL0 = mockFile0.toURL();
    JsonNode jsonNode0 = objectMapper0.readTree(uRL0);
    assertEquals("""", jsonNode0.asText());
}",""
"@SuppressWarnings(""resource"")
public String writeValueAsString(Object value) throws JsonProcessingException {
    // alas, we have to pull the recycler directly here...
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public void test165166() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    POJONode pOJONode0 = new POJONode(""(eom6`,9TR7}y<V~Lj"");
    String string0 = objectMapper0.writeValueAsString(pOJONode0);
    assertEquals(""\""(eom6`,9TR7}y<V~Lj\"""", string0);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a String. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
 *  and constructing String, but more efficient.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test167168() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    IntNode intNode0 = new IntNode(2);
    Class<MockFileReader> class0 = MockFileReader.class;
    try {
        objectMapper0.treeToValue((TreeNode) intNode0, class0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not instantiate value of type [simple type, class org.evosuite.runtime.mock.java.io.MockFileReader] from Integral number (2); no single-int-arg constructor/factory method
        //  at [Source: java.lang.String@0000000052; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test168169() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ObjectNode> class0 = ObjectNode.class;
    ArrayNode arrayNode0 = objectMapper0.createArrayNode();
    ObjectNode objectNode0 = arrayNode0.objectNode();
    ObjectNode objectNode1 = objectMapper0.treeToValue((TreeNode) objectNode0, class0);
    assertSame(objectNode1, objectNode0);
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {
    if (fromValue == null)
        return null;
    TokenBuffer buf = new TokenBuffer(this, false);
    JsonNode result;
    try {
        writeValue(buf, fromValue);
        JsonParser jp = buf.asParser();
        result = readTree(jp);
        jp.close();
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
    return (T) result;
}","public void test169170() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.FLUSH_AFTER_WRITE_VALUE;
    ObjectWriter objectWriter0 = objectMapper0.writer(serializationFeature0);
    try {
        objectMapper0.valueToTree((Object) objectWriter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Loop has been executed more times than the allowed 10000 (through reference chain: com.fasterxml.jackson.databind.ObjectWriter[\""factory\""]->com.fasterxml.jackson.databind.MappingJsonFactory[\""codec\""])
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 *  Reverse of {@link #treeToValue}; given a value (usually bean), will
 *  construct equivalent JSON Tree representation. Functionally similar
 *  to serializing value into JSON and parsing JSON as tree, but
 *  more efficient.
 * <p>
 *  NOTE: while results are usually identical to that of serialization followed
 *  by deserialization, this is not always the case. In some cases serialization
 *  into intermediate representation will retain encapsulation of things like
 *  raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
 *  node identity ({@link JsonNode}). If so, result is a valid tree, but values
 *  are not re-constructed through actual JSON representation. So if transformation
 *  requires actual materialization of JSON (or other data format that this mapper
 *  produces), it will be necessary to do actual serialization.
 *
 *  @param <T> Actual node type; usually either basic {@link JsonNode} or
 *   {@link com.fasterxml.jackson.databind.node.ObjectNode}
 *  @param fromValue Bean value to convert
 *  @return Root node of the resulting JSON tree
 */"
"@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {
    if (fromValue == null)
        return null;
    TokenBuffer buf = new TokenBuffer(this, false);
    JsonNode result;
    try {
        writeValue(buf, fromValue);
        JsonParser jp = buf.asParser();
        result = readTree(jp);
        jp.close();
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
    return (T) result;
}","public void test170171() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    LongNode longNode0 = objectMapper0.valueToTree((Object) null);
    assertNull(longNode0);
}","/**
 *  Reverse of {@link #treeToValue}; given a value (usually bean), will
 *  construct equivalent JSON Tree representation. Functionally similar
 *  to serializing value into JSON and parsing JSON as tree, but
 *  more efficient.
 * <p>
 *  NOTE: while results are usually identical to that of serialization followed
 *  by deserialization, this is not always the case. In some cases serialization
 *  into intermediate representation will retain encapsulation of things like
 *  raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
 *  node identity ({@link JsonNode}). If so, result is a valid tree, but values
 *  are not re-constructed through actual JSON representation. So if transformation
 *  requires actual materialization of JSON (or other data format that this mapper
 *  produces), it will be necessary to do actual serialization.
 *
 *  @param <T> Actual node type; usually either basic {@link JsonNode} or
 *   {@link com.fasterxml.jackson.databind.node.ObjectNode}
 *  @param fromValue Bean value to convert
 *  @return Root node of the resulting JSON tree
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test171172() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BeanDeserializer> class0 = BeanDeserializer.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor(class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test172173() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test174175() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerFor((TypeReference<?>) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test175176() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultPrettyPrinter defaultPrettyPrinter0 = (DefaultPrettyPrinter) ObjectMapper._defaultPrettyPrinter;
    ObjectWriter objectWriter0 = objectMapper0.writer((PrettyPrinter) defaultPrettyPrinter0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test176177() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((PrettyPrinter) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test177178() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerWithType((Class<?>) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test179180() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerWithType((TypeReference<?>) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // sanity check for null first:
    if (fromValue == null)
        return null;
    return (T) _convert(fromValue, toValueType);
}","public void test182183() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayDeque> class0 = ArrayDeque.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    ArrayType arrayType0 = typeFactory0.constructArrayType((JavaType) collectionType0);
    try {
        objectMapper0.convertValue((Object) arrayType0, (JavaType) collectionType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not deserialize instance of java.util.ArrayDeque out of VALUE_STRING token
        //  at [Source: java.lang.String@0000000170; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // sanity check for null first:
    if (fromValue == null)
        return null;
    return (T) _convert(fromValue, toValueType);
}","public void test183184() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TextNode textNode0 = objectMapper0.convertValue((Object) null, (JavaType) null);
    assertNull(textNode0);
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"@SuppressWarnings(""resource"")
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // also, as per [Issue-11], consider case for simple cast
    /* But with caveats: one is that while everything is Object.class, we don't
         * want to ""optimize"" that out; and the other is that we also do not want
         * to lose conversions of generic types.
         */
    Class<?> targetType = toValueType.getRawClass();
    if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) {
        return fromValue;
    }
    // Then use TokenBuffer, which is a JsonGenerator:
    TokenBuffer buf = new TokenBuffer(this, false);
    try {
        // inlined 'writeValue' with minor changes:
        // first: disable wrapping when writing
        SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
        // no need to check for closing of TokenBuffer
        _serializerProvider(config).serializeValue(buf, fromValue);
        // then matching read, inlined 'readValue' with minor mods:
        final JsonParser jp = buf.asParser();
        Object result;
        // ok to pass in existing feature flags; unwrapping handled by mapper
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(jp);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            // pointing to event other than null
            DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            // note: no handling of unwarpping
            result = deser.deserialize(jp, ctxt);
        }
        jp.close();
        return result;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test184185() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    NullNode nullNode0 = NullNode.getInstance();
    Object object0 = objectMapper0._convert(nullNode0, javaType0);
    assertNull(object0);
}","/**
 * Actual conversion implementation: instead of using existing read
 * and write methods, much of code is inlined. Reason for this is
 * that we must avoid root value wrapping/unwrapping both for efficiency and
 * for correctness. If root value wrapping/unwrapping is actually desired,
 * caller must use explicit <code>writeValue</code> and
 * <code>readValue</code> methods.
 */"
"public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    if (type == null) {
        throw new IllegalArgumentException(""type must be provided"");
    }
    _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);
}","public void test185186() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    // Undeclared exception!
    try {
        objectMapper0.acceptJsonFormatVisitor((JavaType) null, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // type must be provided
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 *  Visitation uses <code>Serializer</code> hierarchy and related properties
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"/*
    /**********************************************************
    /* Extended Public API: serialization
    /* (mapping from Java types to JSON)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, written to File provided.
 */
public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);
}","public void test186187() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    FileSystemHandling.shouldAllThrowIOExceptions();
    MockFile mockFile0 = new MockFile(""$y-.Pzp$(cRkC("", ""$y-.Pzp$(cRkC("");
    try {
        objectMapper0.writeValue((File) mockFile0, (Object) ""$y-.Pzp$(cRkC("");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Simulated IOException
        //
        verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
    }
}",""
"protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException {
    SerializationConfig cfg = getSerializationConfig().withView(viewClass);
    // since 2.5
    cfg.initialize(g);
    // [JACKSON-282]: consider Closeable
    if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _configAndWriteCloseable(g, value, cfg);
        return;
    }
    boolean closed = false;
    try {
        _serializerProvider(cfg).serializeValue(g, value);
        closed = true;
        g.close();
    } finally {
        if (!closed) {
            // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of
            //    structures, which typically causes more damage.
            g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
            try {
                g.close();
            } catch (IOException ioe) {
            }
        }
    }
}","public void test188189() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    BooleanNode booleanNode0 = jsonNodeFactory0.booleanNode(true);
    IOContext iOContext0 = new IOContext(bufferRecycler0, booleanNode0, false);
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, objectMapper0, pipedOutputStream0);
    Class<DoubleNode> class0 = DoubleNode.class;
    try {
        objectMapper0._configAndWriteValue(uTF8JsonGenerator0, booleanNode0, class0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedOutputStream"", e);
    }
}",""
"protected final void _configAndWriteValue(JsonGenerator g, Object value, Class<?> viewClass) throws IOException {
    SerializationConfig cfg = getSerializationConfig().withView(viewClass);
    // since 2.5
    cfg.initialize(g);
    // [JACKSON-282]: consider Closeable
    if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _configAndWriteCloseable(g, value, cfg);
        return;
    }
    boolean closed = false;
    try {
        _serializerProvider(cfg).serializeValue(g, value);
        closed = true;
        g.close();
    } finally {
        if (!closed) {
            // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of
            //    structures, which typically causes more damage.
            g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
            try {
                g.close();
            } catch (IOException ioe) {
            }
        }
    }
}","public void test189190() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<NullNode> class0 = NullNode.class;
    // Undeclared exception!
    try {
        objectMapper0._configAndWriteValue((JsonGenerator) null, class0, class0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test190191() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(true);
    ConcurrentHashMap<String, JsonNode> concurrentHashMap0 = new ConcurrentHashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, concurrentHashMap0);
    ArrayNode arrayNode0 = objectNode0.withArray("".Cn@>7tVp;jkX+ws"");
    NullNode nullNode0 = arrayNode0.nullNode();
    Class<ObjectNode> class0 = ObjectNode.class;
    ObjectNode objectNode1 = objectMapper0.treeToValue((TreeNode) nullNode0, class0);
    assertNull(objectNode1);
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"public boolean isFloat() {
    return false;
}","public void test191192() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFile mockFile0 = new MockFile(""JSON"");
    objectMapper0.writeValue((File) mockFile0, (Object) null);
    objectMapper0.readTree((File) mockFile0);
    JsonNode jsonNode0 = objectMapper0.readTree((File) mockFile0);
    assertFalse(jsonNode0.isFloat());
}","/**
 * @since 2.2
 */"
