focal_method,test_prefix,docstring
"public int size();","public void test00() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig0, simpleType0, serializationConfig0);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    Annotations annotations0 = propertyBuilder0.getClassAnnotations();
    assertEquals(0, annotations0.size());
}","/**
 * Returns number of annotation entries in this collection.
 */"
"// since 2.8.5
@Deprecated
protected Object getPropertyDefaultValue(String name, AnnotatedMember member, JavaType type) {
    Object defaultBean = getDefaultBean();
    if (defaultBean == null) {
        return getDefaultValue(type);
    }
    try {
        return member.getValue(defaultBean);
    } catch (Exception e) {
        return _throwWrapped(e, name, defaultBean);
    }
}","public void test11() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, (ClassIntrospector.MixInResolver) null);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    propertyBuilder0._defaultBean = (Object) stdSubtypeResolver0;
    // Undeclared exception!
    try {
        propertyBuilder0.getPropertyDefaultValue(""fRo,#t^"", (AnnotatedMember) null, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.PropertyBuilder"", e);
    }
}","/**
 *  Accessor used to find out ""default value"" for given property, to use for
 *  comparing values to serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 *  This method is called when we specifically want to know default value within context
 *  of a POJO, when annotation is within containing class, and not for property or
 *  defined as global baseline.
 * <p>
 *  Note that returning of pseudo-type
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY} requires special handling.
 *
 *  @since 2.7
 *  @deprecated Since 2.8.5 since this will not allow determining difference between ""no default instance""
 *     case and default being `null`.
 */"
"/*
    /**********************************************************
    /* Helper methods for default value handling
    /**********************************************************
     */
protected Object getDefaultBean() {
    Object def = _defaultBean;
    if (def == null) {
        /* If we can fix access rights, we should; otherwise non-public
             * classes or default constructor will prevent instantiation
             */
        def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());
        if (def == null) {
            // 06-Nov-2015, tatu: As per [databind#998], do not fail.
            /*
                Class<?> cls = _beanDesc.getClassInfo().getAnnotated();
                throw new IllegalArgumentException(""Class ""+cls.getName()+"" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation"");
                 */
            // And use a marker
            def = NO_DEFAULT_MARKER;
        }
        _defaultBean = def;
    }
    return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;
}","public void test22() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, (ClassIntrospector.MixInResolver) null);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    // Undeclared exception!
    try {
        propertyBuilder0.getDefaultBean();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.introspect.AnnotatedClass"", e);
    }
}",""
"protected Object getDefaultValue(JavaType type) {
    // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
    //   handling for primitives since they are never passed as nulls.
    Class<?> cls = type.getRawClass();
    Class<?> prim = ClassUtil.primitiveType(cls);
    if (prim != null) {
        return ClassUtil.defaultValue(prim);
    }
    if (type.isContainerType() || type.isReferenceType()) {
        return JsonInclude.Include.NON_EMPTY;
    }
    if (cls == String.class) {
        return """";
    }
    return null;
}","public void test33() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<String> class0 = String.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[2];
    mapperFeatureArray0[0] = mapperFeature0;
    mapperFeatureArray0[1] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, serializationConfig0);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    Object object0 = propertyBuilder0.getDefaultValue(simpleType0);
    assertNotNull(object0);
}","/**
 *  Accessor used to find out ""default value"" to use for comparing values to
 *  serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 * <p>
 *  Default logic is such that for primitives and wrapper types for primitives, expected
 *  defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
 *  and for structured (Maps, Collections, arrays) and reference types, criteria
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
 *  is used.
 *
 *  @since 2.7
 */"
"protected Object getDefaultValue(JavaType type) {
    // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
    //   handling for primitives since they are never passed as nulls.
    Class<?> cls = type.getRawClass();
    Class<?> prim = ClassUtil.primitiveType(cls);
    if (prim != null) {
        return ClassUtil.defaultValue(prim);
    }
    if (type.isContainerType() || type.isReferenceType()) {
        return JsonInclude.Include.NON_EMPTY;
    }
    if (cls == String.class) {
        return """";
    }
    return null;
}","public void test45() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig0, simpleType0, serializationConfig0);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    Object object0 = propertyBuilder0.getDefaultValue(simpleType0);
    assertEquals(0, object0);
}","/**
 *  Accessor used to find out ""default value"" to use for comparing values to
 *  serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 * <p>
 *  Default logic is such that for primitives and wrapper types for primitives, expected
 *  defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
 *  and for structured (Maps, Collections, arrays) and reference types, criteria
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
 *  is used.
 *
 *  @since 2.7
 */"
"protected Object getDefaultValue(JavaType type) {
    // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
    //   handling for primitives since they are never passed as nulls.
    Class<?> cls = type.getRawClass();
    Class<?> prim = ClassUtil.primitiveType(cls);
    if (prim != null) {
        return ClassUtil.defaultValue(prim);
    }
    if (type.isContainerType() || type.isReferenceType()) {
        return JsonInclude.Include.NON_EMPTY;
    }
    if (cls == String.class) {
        return """";
    }
    return null;
}","public void test56() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, (ClassIntrospector.MixInResolver) null);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class1 = HashMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class1, class1, class0);
    Object object0 = propertyBuilder0.getDefaultValue(mapType0);
    assertEquals(JsonInclude.Include.NON_EMPTY, object0);
}","/**
 *  Accessor used to find out ""default value"" to use for comparing values to
 *  serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 * <p>
 *  Default logic is such that for primitives and wrapper types for primitives, expected
 *  defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
 *  and for structured (Maps, Collections, arrays) and reference types, criteria
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
 *  is used.
 *
 *  @since 2.7
 */"
"protected Object getDefaultValue(JavaType type) {
    // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
    //   handling for primitives since they are never passed as nulls.
    Class<?> cls = type.getRawClass();
    Class<?> prim = ClassUtil.primitiveType(cls);
    if (prim != null) {
        return ClassUtil.defaultValue(prim);
    }
    if (type.isContainerType() || type.isReferenceType()) {
        return JsonInclude.Include.NON_EMPTY;
    }
    if (cls == String.class) {
        return """";
    }
    return null;
}","public void test67() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, serializationConfig1);
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    PropertyBuilder propertyBuilder0 = beanSerializerFactory0.constructPropertyBuilder(serializationConfig1, basicBeanDescription0);
    Class<ChronoLocalDate> class1 = ChronoLocalDate.class;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class1, (JavaType) simpleType0);
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class1, typeBindings0, (JavaType) simpleType0, (JavaType[]) null, (JavaType) simpleType0);
    Object object0 = propertyBuilder0.getDefaultValue(referenceType0);
    assertEquals(JsonInclude.Include.NON_EMPTY, object0);
}","/**
 *  Accessor used to find out ""default value"" to use for comparing values to
 *  serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 * <p>
 *  Default logic is such that for primitives and wrapper types for primitives, expected
 *  defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
 *  and for structured (Maps, Collections, arrays) and reference types, criteria
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
 *  is used.
 *
 *  @since 2.7
 */"
"protected Object getDefaultValue(JavaType type) {
    // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
    //   handling for primitives since they are never passed as nulls.
    Class<?> cls = type.getRawClass();
    Class<?> prim = ClassUtil.primitiveType(cls);
    if (prim != null) {
        return ClassUtil.defaultValue(prim);
    }
    if (type.isContainerType() || type.isReferenceType()) {
        return JsonInclude.Include.NON_EMPTY;
    }
    if (cls == String.class) {
        return """";
    }
    return null;
}","public void test78() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    Class<ClassNameIdResolver> class1 = ClassNameIdResolver.class;
    SimpleType simpleType1 = SimpleType.constructUnsafe(class1);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, simpleMixInResolver0);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    Object object0 = propertyBuilder0.getDefaultValue(simpleType1);
    assertNull(object0);
}","/**
 *  Accessor used to find out ""default value"" to use for comparing values to
 *  serialize, to determine whether to exclude value from serialization with
 *  inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
 * <p>
 *  Default logic is such that for primitives and wrapper types for primitives, expected
 *  defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
 *  and for structured (Maps, Collections, arrays) and reference types, criteria
 *  {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
 *  is used.
 *
 *  @since 2.7
 */"
"/*
    /**********************************************************
    /* Helper methods for exception handling
    /**********************************************************
     */
protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {
    Throwable t = e;
    while (t.getCause() != null) {
        t = t.getCause();
    }
    if (t instanceof Error)
        throw (Error) t;
    if (t instanceof RuntimeException)
        throw (RuntimeException) t;
    throw new IllegalArgumentException(""Failed to get property '"" + propName + ""' of default "" + defaultBean.getClass().getName() + "" instance"");
}","public void test89() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, (ClassIntrospector.MixInResolver) null);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    SQLDataException sQLDataException0 = new SQLDataException(""Unexpected JSON value(s); expected at most %d properties (in JSON Array)"", ""Unexpected JSON value(s); expected at most %d properties (in JSON Array)"");
    SQLFeatureNotSupportedException sQLFeatureNotSupportedException0 = new SQLFeatureNotSupportedException(sQLDataException0);
    // Undeclared exception!
    try {
        propertyBuilder0._throwWrapped(sQLFeatureNotSupportedException0, ""Unexpected JSON value(s); expected at most %d properties (in JSON Array)"", basicBeanDescription0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Failed to get property 'Unexpected JSON value(s); expected at most %d properties (in JSON Array)' of default com.fasterxml.jackson.databind.introspect.BasicBeanDescription instance
        //
        verifyException(""com.fasterxml.jackson.databind.ser.PropertyBuilder"", e);
    }
}",""
"/*
    /**********************************************************
    /* Helper methods for exception handling
    /**********************************************************
     */
protected Object _throwWrapped(Exception e, String propName, Object defaultBean) {
    Throwable t = e;
    while (t.getCause() != null) {
        t = t.getCause();
    }
    if (t instanceof Error)
        throw (Error) t;
    if (t instanceof RuntimeException)
        throw (RuntimeException) t;
    throw new IllegalArgumentException(""Failed to get property '"" + propName + ""' of default "" + defaultBean.getClass().getName() + "" instance"");
}","public void test910() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    SerializationConfig serializationConfig0 = new SerializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0, configOverrides0);
    Class<Integer> class0 = Integer.TYPE;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[1];
    mapperFeatureArray0[0] = mapperFeature0;
    SerializationConfig serializationConfig1 = serializationConfig0.without(mapperFeatureArray0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BasicBeanDescription basicBeanDescription0 = basicClassIntrospector0.forDirectClassAnnotations(serializationConfig1, simpleType0, (ClassIntrospector.MixInResolver) null);
    PropertyBuilder propertyBuilder0 = new PropertyBuilder(serializationConfig1, basicBeanDescription0);
    MockError mockError0 = new MockError();
    SQLTransientException sQLTransientException0 = new SQLTransientException("""", """", 1, mockError0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""GuM$\""a(Ut:9"", ""GuM$\""a(Ut:9"", 1, sQLTransientException0);
    // Undeclared exception!
    try {
        propertyBuilder0._throwWrapped(sQLTransientConnectionException0, ""GuM$\""a(Ut:9"", (Object) null);
        fail(""Expecting exception: Error"");
    } catch (Error e) {
    }
}",""
