focal_method,test_prefix,docstring
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test011() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    StdDateFormat stdDateFormat1 = stdDateFormat0.clone();
    boolean boolean0 = stdDateFormat1.equals(stdDateFormat0);
    assertFalse(stdDateFormat1.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"// since 2.7[.2], as per [databind#1130]
@Override
public boolean equals(Object o) {
    return (o == this);
}","public void test012() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    StdDateFormat stdDateFormat1 = stdDateFormat0.clone();
    boolean boolean0 = stdDateFormat1.equals(stdDateFormat0);
    assertFalse(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test034() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parse(""0000-00-00"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Std overrides
    /**********************************************************
     */
@Override
public String toString() {
    return String.format(""DateFormat %s: (timezone: %s, locale: %s, lenient: %s)"", getClass().getName(), _timezone, _locale, _lenient);
}","public void test045() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    String string0 = stdDateFormat0.instance.toString();
    assertEquals(""DateFormat com.fasterxml.jackson.databind.util.StdDateFormat: (timezone: null, locale: en_US, lenient: null)"", string0);
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test046() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    String string0 = stdDateFormat0.instance.toString();
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test057() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.ITALIAN;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0);
    TimeZone timeZone1 = stdDateFormat0.getTimeZone();
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"/*
    /**********************************************************
    /* Public API, configuration
    /**********************************************************
     */
// since 2.6
@Override
public TimeZone getTimeZone() {
    return _timezone;
}","public void test058() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.ITALIAN;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0);
    TimeZone timeZone1 = stdDateFormat0.getTimeZone();
    assertNotNull(timeZone1);
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test0811() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    Boolean boolean0 = Boolean.TRUE;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0, boolean0);
    stdDateFormat0.hashCode();
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1013() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    boolean boolean0 = stdDateFormat0.isColonIncludedInTimeZone();
    assertFalse(boolean0);
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"protected Date _parseAsISO8601(String dateStr, ParsePosition bogus) throws IllegalArgumentException, ParseException {
    final int totalLen = dateStr.length();
    // actually, one short-cut: if we end with ""Z"", must be UTC
    TimeZone tz = DEFAULT_TIMEZONE;
    if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen - 1))) {
        tz = _timezone;
    }
    Calendar cal = _getCalendar(tz);
    cal.clear();
    String formatStr;
    if (totalLen <= 10) {
        Matcher m = PATTERN_PLAIN.matcher(dateStr);
        if (m.matches()) {
            int year = _parse4D(dateStr, 0);
            int month = _parse2D(dateStr, 5) - 1;
            int day = _parse2D(dateStr, 8);
            cal.set(year, month, day, 0, 0, 0);
            cal.set(Calendar.MILLISECOND, 0);
            return cal.getTime();
        }
        formatStr = DATE_FORMAT_STR_PLAIN;
    } else {
        Matcher m = PATTERN_ISO8601.matcher(dateStr);
        if (m.matches()) {
            // Important! START with optional time zone; otherwise Calendar will explode
            int start = m.start(2);
            int end = m.end(2);
            int len = end - start;
            if (len > 1) {
                // 0 -> none, 1 -> 'Z'
                // NOTE: first char is sign; then 2 digits, then optional colon, optional 2 digits
                // hours
                int offsetSecs = _parse2D(dateStr, start + 1) * 3600;
                if (len >= 5) {
                    // minutes
                    offsetSecs += _parse2D(dateStr, end - 2) * 60;
                }
                if (dateStr.charAt(start) == '-') {
                    offsetSecs *= -1000;
                } else {
                    offsetSecs *= 1000;
                }
                cal.set(Calendar.ZONE_OFFSET, offsetSecs);
                // 23-Jun-2017, tatu: Not sure why, but this appears to be needed too:
                cal.set(Calendar.DST_OFFSET, 0);
            }
            int year = _parse4D(dateStr, 0);
            int month = _parse2D(dateStr, 5) - 1;
            int day = _parse2D(dateStr, 8);
            // So: 10 chars for date, then `T`, so starts at 11
            int hour = _parse2D(dateStr, 11);
            int minute = _parse2D(dateStr, 14);
            // Seconds are actually optional... so
            int seconds;
            if ((totalLen > 16) && dateStr.charAt(16) == ':') {
                seconds = _parse2D(dateStr, 17);
            } else {
                seconds = 0;
            }
            cal.set(year, month, day, hour, minute, seconds);
            // Optional milliseconds
            start = m.start(1) + 1;
            end = m.end(1);
            int msecs = 0;
            if (start >= end) {
                // no fractional
                cal.set(Calendar.MILLISECOND, 0);
            } else {
                // first char is '.', but rest....
                msecs = 0;
                final int fractLen = end - start;
                switch(fractLen) {
                    default:
                        // [databind#1745] Allow longer fractions... for now, cap at nanoseconds tho
                        if (fractLen > 9) {
                            // only allow up to nanos
                            throw new ParseException(String.format(""Cannot parse date \""%s\"": invalid fractional seconds '%s'; can use at most 9 digits"", dateStr, m.group(1).substring(1)), start);
                        }
                    // fall through
                    case 3:
                        msecs += (dateStr.charAt(start + 2) - '0');
                    case 2:
                        msecs += 10 * (dateStr.charAt(start + 1) - '0');
                    case 1:
                        msecs += 100 * (dateStr.charAt(start) - '0');
                        break;
                    case 0:
                        break;
                }
                cal.set(Calendar.MILLISECOND, msecs);
            }
            return cal.getTime();
        }
        formatStr = DATE_FORMAT_STR_ISO8601;
    }
    throw new ParseException(String.format(""Cannot parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), // [databind#1742]: Might be able to give actual location, some day, but for now
    //  we can't give anything more indicative
    0);
}","public void test1114() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ZoneInfo zoneInfo0 = (ZoneInfo) StdDateFormat.DEFAULT_TIMEZONE;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(zoneInfo0);
    try {
        stdDateFormat1._parseAsISO8601(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"", (ParsePosition) null);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"": while it seems to fit format 'yyyy-MM-dd'T'HH:mm:ss.SSSZ', parsing fails (leniency? null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1215() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone((TimeZone) null);
    StdDateFormat stdDateFormat2 = stdDateFormat1.withTimeZone((TimeZone) null);
    assertFalse(stdDateFormat2.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if ((tz == _timezone) || tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon);
}","public void test1216() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone((TimeZone) null);
    StdDateFormat stdDateFormat2 = stdDateFormat1.withTimeZone((TimeZone) null);
    assertNotSame(stdDateFormat2, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if ((tz == _timezone) || tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon);
}","public void test1318() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    TimeZone timeZone0 = TimeZone.getTimeZone(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(timeZone0);
    TimeZone timeZone1 = TimeZone.getDefault();
    StdDateFormat stdDateFormat2 = stdDateFormat1.withTimeZone(timeZone1);
    assertSame(stdDateFormat2, stdDateFormat1);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1320() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    TimeZone timeZone0 = TimeZone.getTimeZone(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(timeZone0);
    TimeZone timeZone1 = TimeZone.getDefault();
    StdDateFormat stdDateFormat2 = stdDateFormat1.withTimeZone(timeZone1);
    assertFalse(stdDateFormat2.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1421() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Locale locale0 = Locale.JAPAN;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    try {
        stdDateFormat1.parse(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"public StdDateFormat withLocale(Locale loc) {
    if (loc.equals(_locale)) {
        return this;
    }
    return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon);
}","public void test1522() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    Locale locale0 = Locale.US;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    assertSame(stdDateFormat1, stdDateFormat0);
}","/**
 * ""Mutant factory"" method that will return an instance that uses specified
 * {@code Locale}:
 * either {@code this} instance (if setting would not change), or newly
 * constructed instance with different {@code Locale} to use.
 */"
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1523() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    Locale locale0 = Locale.US;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    assertFalse(stdDateFormat1.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"// since 2.7
@Override
public boolean isLenient() {
    // default is, I believe, true
    return (_lenient == null) || _lenient.booleanValue();
}","public void test1624() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Boolean boolean0 = Boolean.valueOf(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLenient(boolean0);
    assertFalse(stdDateFormat1.isLenient());
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1625() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Boolean boolean0 = Boolean.valueOf(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLenient(boolean0);
    assertFalse(stdDateFormat1.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"public StdDateFormat withColonInTimeZone(boolean b) {
    if (_tzSerializedWithColon == b) {
        return this;
    }
    return new StdDateFormat(_timezone, _locale, _lenient, b);
}","public void test1828() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withColonInTimeZone(false);
    assertSame(stdDateFormat1, stdDateFormat0);
}","/**
 *  ""Mutant factory"" method that will return an instance that has specified
 *  handling of colon when serializing timezone (timezone either written
 *  like {@code +0500} or {@code +05:00}):
 *  either {@code this} instance (if setting would not change), or newly
 *  constructed instance with desired setting for colon inclusion.
 * <p>
 *  NOTE: does NOT affect deserialization as colon is optional accepted
 *  but not required -- put another way, either serialization is accepted
 *  by this class.
 *
 *  @since 2.9.1
 */"
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test1929() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.TAIWAN;
    Boolean boolean0 = Boolean.FALSE;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0, boolean0);
    stdDateFormat0.setTimeZone(timeZone0);
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"// since 2.7
@Override
public boolean isLenient() {
    // default is, I believe, true
    return (_lenient == null) || _lenient.booleanValue();
}","public void test1930() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.TAIWAN;
    Boolean boolean0 = Boolean.FALSE;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0, boolean0);
    stdDateFormat0.setTimeZone(timeZone0);
    assertFalse(stdDateFormat0.isLenient());
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test2031() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    TimeZone timeZone0 = TimeZone.getTimeZone(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
    stdDateFormat0.instance.setTimeZone(timeZone0);
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"// since 2.7
@Override
public boolean isLenient() {
    // default is, I believe, true
    return (_lenient == null) || _lenient.booleanValue();
}","public void test2132() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    stdDateFormat0.setLenient(false);
    assertFalse(stdDateFormat0.isLenient());
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2233() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parse(""0000-00-00T00:00"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No match available
        //
        verifyException(""java.util.regex.Matcher"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2334() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""="");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""=\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"public String toPattern() {
    // same as SimpleDateFormat
    StringBuilder sb = new StringBuilder(100);
    sb.append(""[one of: '"").append(DATE_FORMAT_STR_ISO8601).append(""', '"").append(DATE_FORMAT_STR_RFC1123).append(""' ("");
    sb.append(Boolean.FALSE.equals(_lenient) ? ""strict"" : ""lenient"").append("")]"");
    return sb.toString();
}","public void test2839() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    String string0 = stdDateFormat0.instance.toPattern();
    assertEquals(""[one of: 'yyyy-MM-dd'T'HH:mm:ss.SSSZ', 'EEE, dd MMM yyyy HH:mm:ss zzz' (lenient)]"", string0);
}",""
"public boolean isColonIncludedInTimeZone() {
    return _tzSerializedWithColon;
}","public void test2940() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    boolean boolean0 = stdDateFormat0.equals(stdDateFormat0);
    assertFalse(stdDateFormat0.isColonIncludedInTimeZone());
}","/**
 *  Accessor for checking whether this instance would include colon
 *  within timezone serialization or not: if {code true}, timezone offset
 *  is serialized like {@code -06:00}; if {code false} as {@code -0600}.
 * <p>
 *  NOTE: only relevant for serialization (formatting), as deserialization
 *  (parsing) always accepts optional colon but does not require it, regardless
 *  of this setting.
 *
 *  @return {@code true} if a colon is to be inserted between the hours and minutes
 *  of the TZ offset when serializing as String; otherwise {@code false}
 *
 *  @since 2.9.1
 */"
"// since 2.7[.2], as per [databind#1130]
@Override
public boolean equals(Object o) {
    return (o == this);
}","public void test2941() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    boolean boolean0 = stdDateFormat0.equals(stdDateFormat0);
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test3042() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""00,G-00-00T00:W0"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""00,G-00-00T00:W0\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test3143() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""2.2250738585072012e-308"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""2.2250738585072012e-308\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test3244() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""0000-u00-00T00:00"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""0000-u00-00T00:00\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test3345() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""00=0-00-00"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""00=0-00-00\"": while it seems to fit format 'yyyy-MM-dd', parsing fails (leniency? null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt = _parseDate(dateStr, pos);
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Cannot parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test3446() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Locale locale0 = Locale.JAPAN;
    try {
        stdDateFormat0.parse(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Cannot parse date \""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected static <T> boolean _equals(T value1, T value2) {
    if (value1 == value2) {
        return true;
    }
    return (value1 != null) && value1.equals(value2);
}","public void test3547() throws Throwable {
    Integer integer0 = new Integer(5);
    boolean boolean0 = StdDateFormat._equals((Integer) null, integer0);
    assertFalse(boolean0);
}",""
