focal_method,test_prefix,docstring
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test000() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonSerializer<?> jsonSerializer0 = sqlDateSerializer0.createContextual(defaultSerializerProvider_Impl0, (BeanProperty) null);
    assertFalse(jsonSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
"@Override
public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {
    _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));
}","public void test011() throws Throwable {
    CalendarSerializer calendarSerializer0 = new CalendarSerializer();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    // Undeclared exception!
    try {
        calendarSerializer0.acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, (JavaType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null SerializerProvider passed for java.util.Calendar
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase"", e);
    }
}",""
"@Override
public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {
    if (property == null) {
        return this;
    }
    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
    if (format == null) {
        return this;
    }
    // Simple case first: serialize as numeric timestamp?
    JsonFormat.Shape shape = format.getShape();
    if (shape.isNumeric()) {
        return withFormat(Boolean.TRUE, null);
    }
    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
    // First: custom pattern will override things
    if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {
        TimeZone tz = format.getTimeZone();
        final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601;
        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
        SimpleDateFormat df = new SimpleDateFormat(pattern, loc);
        if (tz == null) {
            tz = serializers.getTimeZone();
        }
        df.setTimeZone(tz);
        return withFormat(Boolean.FALSE, df);
    }
    // Otherwise, need one of these changes:
    // Jackson's own `StdDateFormat` is quite easy to deal with...
    // 08-Jun-2017, tatu: Unfortunately there's no generally usable
    //    mechanism for changing `DateFormat` instances (or even clone()ing)
    //    So: require it be `SimpleDateFormat`; can't config other types
    //            serializers.reportBadDefinition(handledType(), String.format(
    // Ugh. No way to change `Locale`, create copy; must re-crete completely:
    return this;
}","public void test022() throws Throwable {
    PropertyName propertyName0 = PropertyName.NO_NAME;
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    BeanProperty.Std beanProperty_Std0 = new BeanProperty.Std(propertyName0, simpleType0, propertyName0, annotationMap0, (AnnotatedMember) null, propertyMetadata0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    JsonSerializer<?> jsonSerializer0 = sqlDateSerializer0.createContextual(serializerProvider0, beanProperty_Std0);
    assertSame(sqlDateSerializer0, jsonSerializer0);
}",""
"@Deprecated
public boolean isEmpty(T value) {
    return isEmpty(null, value);
}","public void test033() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    boolean boolean0 = sqlDateSerializer0.isEmpty((Date) null);
    assertTrue(boolean0);
}","/**
 *  Method called to check whether given serializable value is
 *  considered ""empty"" value (for purposes of suppressing serialization
 *  of empty values).
 * <p>
 *  Default implementation will consider only null values to be empty.
 *
 *  @deprecated Since 2.5 Use {@link #isEmpty(SerializerProvider, Object)} instead;
 *    will be removed from 2.9
 */"
"@Deprecated
public boolean isEmpty(T value) {
    return isEmpty(null, value);
}","public void test044() throws Throwable {
    Boolean boolean0 = new Boolean(true);
    CalendarSerializer calendarSerializer0 = new CalendarSerializer(boolean0, (DateFormat) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1486), (-2036), (-2036), (-65), (-65));
    boolean boolean1 = calendarSerializer0.isEmpty((Calendar) mockGregorianCalendar0);
    assertTrue(boolean1);
}","/**
 *  Method called to check whether given serializable value is
 *  considered ""empty"" value (for purposes of suppressing serialization
 *  of empty values).
 * <p>
 *  Default implementation will consider only null values to be empty.
 *
 *  @deprecated Since 2.5 Use {@link #isEmpty(SerializerProvider, Object)} instead;
 *    will be removed from 2.9
 */"
"@Deprecated
public boolean isEmpty(T value) {
    return isEmpty(null, value);
}","public void test055() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    Date date0 = new Date((-2171L));
    boolean boolean0 = sqlDateSerializer0.isEmpty(date0);
    assertFalse(boolean0);
}","/**
 *  Method called to check whether given serializable value is
 *  considered ""empty"" value (for purposes of suppressing serialization
 *  of empty values).
 * <p>
 *  Default implementation will consider only null values to be empty.
 *
 *  @deprecated Since 2.5 Use {@link #isEmpty(SerializerProvider, Object)} instead;
 *    will be removed from 2.9
 */"
"@Override
public boolean isEmpty(SerializerProvider serializers, T value) {
    // let's assume ""null date"" (timestamp 0) qualifies for empty
    return (value == null) || (_timestamp(value) == 0L);
}","public void test066() throws Throwable {
    CalendarSerializer calendarSerializer0 = new CalendarSerializer();
    boolean boolean0 = calendarSerializer0.isEmpty((SerializerProvider) null, (Calendar) null);
    assertTrue(boolean0);
}",""
"@Override
public boolean isEmpty(SerializerProvider serializers, T value) {
    // let's assume ""null date"" (timestamp 0) qualifies for empty
    return (value == null) || (_timestamp(value) == 0L);
}","public void test077() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Date date0 = new Date((-2164L));
    boolean boolean0 = sqlDateSerializer0.isEmpty((SerializerProvider) defaultSerializerProvider_Impl0, date0);
    assertFalse(boolean0);
}",""
"@Override
public boolean isEmpty(SerializerProvider serializers, T value) {
    // let's assume ""null date"" (timestamp 0) qualifies for empty
    return (value == null) || (_timestamp(value) == 0L);
}","public void test088() throws Throwable {
    CalendarSerializer calendarSerializer0 = CalendarSerializer.instance;
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(108, 108, 108, 108, 108, 4961);
    boolean boolean0 = calendarSerializer0.isEmpty((SerializerProvider) defaultSerializerProvider_Impl0, (Calendar) mockGregorianCalendar0);
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* TreeNode implementation
    /**********************************************************
     */
//  public abstract JsonToken asToken();
//  public abstract JsonToken traverse();
//  public abstract JsonToken traverse(ObjectCodec codec);
//  public abstract JsonParser.NumberType numberType();
@Override
public int size() {
    return 0;
}","public void test099() throws Throwable {
    CalendarSerializer calendarSerializer0 = CalendarSerializer.instance;
    Boolean boolean0 = Boolean.valueOf(false);
    Locale locale0 = Locale.JAPANESE;
    DateFormat dateFormat0 = MockDateFormat.getDateTimeInstance(0, 0, locale0);
    CalendarSerializer calendarSerializer1 = calendarSerializer0.withFormat(boolean0, dateFormat0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonNode jsonNode0 = calendarSerializer1.getSchema((SerializerProvider) defaultSerializerProvider_Impl0, (Type) null);
    assertEquals(1, jsonNode0.size());
}",""
"/*
    /**********************************************************
    /* TreeNode implementation
    /**********************************************************
     */
//  public abstract JsonToken asToken();
//  public abstract JsonToken traverse();
//  public abstract JsonToken traverse(ObjectCodec codec);
//  public abstract JsonParser.NumberType numberType();
@Override
public int size() {
    return 0;
}","public void test1010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    DateSerializer dateSerializer0 = new DateSerializer();
    JsonNode jsonNode0 = dateSerializer0.getSchema(serializerProvider0, (Type) null);
    assertEquals(1, jsonNode0.size());
}",""
"@Override
public void serialize(Date value, JsonGenerator gen, SerializerProvider provider) throws IOException {
    if (_asTimestamp(provider)) {
        gen.writeNumber(_timestamp(value));
    } else if (_customFormat != null) {
        // 21-Feb-2011, tatu: not optimal, but better than alternatives:
        synchronized (_customFormat) {
            gen.writeString(_customFormat.format(value));
        }
    } else {
        provider.defaultSerializeDateValue(value, gen);
    }
}","public void test1111() throws Throwable {
    DateSerializer dateSerializer0 = new DateSerializer();
    DateFormat dateFormat0 = MockDateFormat.getDateTimeInstance();
    DateSerializer dateSerializer1 = dateSerializer0.withFormat((Boolean) null, dateFormat0);
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Object object0 = new Object();
    IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, (ObjectCodec) null, (OutputStream) null);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        dateSerializer1.serialize((java.util.Date) null, (JsonGenerator) uTF8JsonGenerator0, (SerializerProvider) defaultSerializerProvider_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}",""
"@Override
public int containedTypeCount() {
    return _bindings.size();
}","public void test1212() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    Class<JavaType> class0 = JavaType.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, (TypeBindings) null);
    sqlDateSerializer0.acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, resolvedRecursiveType0);
    assertEquals(0, resolvedRecursiveType0.containedTypeCount());
}",""
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test1313() throws Throwable {
    Boolean boolean0 = Boolean.valueOf(true);
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer(boolean0);
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    sqlDateSerializer0.acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, (JavaType) null);
    assertFalse(sqlDateSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
