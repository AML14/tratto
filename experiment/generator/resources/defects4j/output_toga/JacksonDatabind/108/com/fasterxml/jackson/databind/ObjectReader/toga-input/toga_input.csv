focal_method,test_prefix,docstring
"public boolean isEnabled(MapperFeature f) {
    return _config.isEnabled(f);
}","public void test000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    MapperFeature mapperFeature0 = MapperFeature.USE_GETTERS_AS_SETTERS;
    boolean boolean0 = objectReader0.isEnabled(mapperFeature0);
    assertTrue(boolean0);
}",""
"// since 2.6
@Deprecated
public final String getRootName() {
    return (_rootName == null) ? null : _rootName.getSimpleName();
}","public void test011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationConfig deserializationConfig0 = objectReader0.getConfig();
    assertNull(deserializationConfig0.getRootName());
}","/**
 * @deprecated Since 2.6 use {@link #getFullRootName} instead.
 */"
"@Override
public void writeTree(JsonGenerator g, TreeNode rootNode) {
    throw new UnsupportedOperationException();
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[5];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF32_LE;
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((DataOutput) null, jsonEncoding0);
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ArrayNode arrayNode0 = objectNode0.withArray(""JSON"");
    TextNode textNode0 = arrayNode0.textNode(""Strange Reference type "");
    // Undeclared exception!
    try {
        objectReader0.writeTree(jsonGenerator0, textNode0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"@Override
public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {
    return readValues(p, (JavaType) valueType);
}","public void test044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[5];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    JsonFactory jsonFactory0 = new JsonFactory();
    File file0 = MockFile.createTempFile(""Root name '%s' does not match expected ('%s') for type %s"", ""JSON"");
    JsonParser jsonParser0 = jsonFactory0.createParser(file0);
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParser0, tokenFilter0, false, true);
    try {
        objectReader0.readValues((JsonParser) filteringParserDelegate0, (ResolvedType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //  at [Source: (org.evosuite.runtime.mock.java.io.MockFile); line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 *  Convenience method that is equivalent to:
 * <pre>
 *    withType(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method reads a sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    JsonFactory jsonFactory0 = new JsonFactory(objectReader0);
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader withView(Class<?> activeView) {
    return _with(_config.withView(activeView));
}","public void test066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Class<SimpleType> class0 = SimpleType.class;
    ObjectReader objectReader1 = objectReader0.withView(class0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  uses specified View for filtering.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withAttributes(Map<?, ?> attrs) {
    return _with(_config.withAttributes(attrs));
}","public void test077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ConcurrentHashMap<CollectionType, Module> concurrentHashMap0 = new ConcurrentHashMap<CollectionType, Module>();
    ObjectReader objectReader1 = objectReader0.withAttributes(concurrentHashMap0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public final <T> MappingIterator<T> readValues(byte[] src) throws IOException {
    return readValues(src, 0, src.length);
}","public void test088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    byte[] byteArray0 = new byte[16];
    try {
        objectReader0.readValues(byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: (byte[])\""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\""; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"@SuppressWarnings(""resource"")
public <T> MappingIterator<T> readValues(String json) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(json);
    }
    JsonParser p = _considerFilter(_parserFactory.createParser(json), true);
    DeserializationContext ctxt = createDeserializationContext(p);
    _initForMultiRead(ctxt, p);
    p.nextToken();
    return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
}","public void test099() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BigIntegerNode> class0 = BigIntegerNode.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    MappingIterator<MapLikeType> mappingIterator0 = objectReader0.readValues("""");
    assertNotNull(mappingIterator0);
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 *
 * @param json String that contains JSON content to parse
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test1010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    // Undeclared exception!
    try {
        objectMapper0.writeValueAsBytes(objectReader0);
        fail(""Expecting exception: NoClassDefFoundError"");
    } catch (NoClassDefFoundError e) {
        //
        // com/fasterxml/jackson/databind/JsonMappingException$Reference
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"public boolean isShort() {
    return false;
}","public void test1111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    ObjectReader objectReader1 = new ObjectReader(objectReader0, tokenFilter0);
    JsonNode jsonNode0 = objectReader1.readTree((InputStream) null);
    assertFalse(jsonNode0.isShort());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>short</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java short
 */"
"protected void _reportUndetectableSource(Object src) throws JsonProcessingException {
    // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:
    throw new JsonParseException(null, ""Cannot use source of type "" + src.getClass().getName() + "" with format auto-detection: must be byte- not char-based"");
}","public void test1212() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0._reportUndetectableSource((Object) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods for JsonParser.Features
    /**********************************************************
     */
/**
 * Method for constructing a new reader instance that is configured
 * with specified feature enabled.
 */
public ObjectReader with(JsonParser.Feature feature) {
    return _with(_config.with(feature));
}","public void test1313() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    ObjectReader objectReader1 = objectReader0.with(jsonParser_Feature0);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader without(JsonParser.Feature feature) {
    return _with(_config.without(feature));
}","public void test1414() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_SINGLE_QUOTES;
    ObjectReader objectReader1 = objectReader0.without(jsonParser_Feature0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified feature disabled.
 */"
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods for FormatFeature (2.7)
    /**********************************************************
     */
/**
 * Method for constructing a new reader instance that is configured
 * with specified feature enabled.
 *
 * @since 2.7
 */
public ObjectReader with(FormatFeature feature) {
    return _with(_config.with(feature));
}","public void test1616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonReadFeature jsonReadFeature0 = JsonReadFeature.ALLOW_JAVA_COMMENTS;
    ObjectReader objectReader1 = objectReader0.with((FormatFeature) jsonReadFeature0);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader withoutRootName() {
    return _with(_config.withRootName(PropertyName.NO_NAME));
}","public void test1717() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withoutRootName();
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Convenience method that is same as calling:
 * <code>
 *    withRootName("""")
 * </code>
 *  which will forcibly prevent use of root name wrapping when writing
 *  values with this {@link ObjectReader}.
 *
 *  @since 2.6
 */"
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods for DeserializationFeatures
    /**********************************************************
     */
/**
 * Method for constructing a new reader instance that is configured
 * with specified feature enabled.
 */
public ObjectReader with(DeserializationFeature feature) {
    return _with(_config.with(feature));
}","public void test1818() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;
    ObjectReader objectReader1 = objectReader0.with(deserializationFeature0);
    assertNotSame(objectReader1, objectReader0);
}",""
"@SuppressWarnings({ ""resource"" })
protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {
    if (!match.hasMatch()) {
        _reportUnkownFormat(_dataFormatReaders, match);
    }
    JsonParser p = match.createParserWithMatch();
    // One more thing: we Own the input stream now; and while it's
    // not super clean way to do it, we must ensure closure so:
    if (forceClosing) {
        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    }
    // important: use matching ObjectReader (may not be 'this')
    return match.getReader()._bindAndClose(p);
}","public void test1919() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    LinkedList<ObjectReader> linkedList0 = new LinkedList<ObjectReader>();
    DataFormatReaders dataFormatReaders0 = new DataFormatReaders(linkedList0);
    DataFormatReaders.Match dataFormatReaders_Match0 = dataFormatReaders0.findFormat((byte[]) null, 1, (-794));
    // Undeclared exception!
    try {
        objectReader0._detectBindAndClose(dataFormatReaders_Match0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"public ObjectReader withRootName(PropertyName rootName) {
    return _with(_config.withRootName(rootName));
}","public void test2121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    PropertyName propertyName0 = PropertyName.USE_DEFAULT;
    ObjectReader objectReader1 = objectReader0.withRootName(propertyName0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @since 2.6
 */"
"public ObjectReader withRootName(String rootName) {
    return _with(_config.withRootName(rootName));
}","public void test2222() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withRootName(""=KX)S"");
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  specifies what root name to expect for ""root name unwrapping"".
 *  See {@link DeserializationConfig#withRootName(String)} for
 *  details.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withHandler(DeserializationProblemHandler h) {
    return _with(_config.withHandler(h));
}","public void test2323() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    ObjectReader objectReader1 = objectReader0.withHandler(deserializationProblemHandler0);
    assertNotSame(objectReader1, objectReader0);
}",""
"@Override
@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException {
    return (T) forType((JavaType) valueType).readValue(p);
}","public void test2424() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    ContextAttributes contextAttributes0 = ContextAttributes.Impl.getEmpty();
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes0);
    TypeFactory typeFactory0 = objectReader0.getTypeFactory();
    Class<HashMap> class0 = HashMap.class;
    Class<TypeIdResolver> class1 = TypeIdResolver.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class0, class1);
    // Undeclared exception!
    try {
        objectReader0.readValue((JsonParser) null, (ResolvedType) mapType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Convenience method that binds content read using given parser, using
 *  configuration of this reader, except that expected value type
 *  is specified with the call (instead of currently configured root type).
 *  Value return is either newly constructed, or root value that
 *  was specified with {@link #withValueToUpdate(Object)}.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
    return (T) _bindAsTree(p);
}","public void test2525() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readTree((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Convenience method that binds content read using given parser, using
 *  configuration of this reader, except that content is bound as
 *  JSON tree instead of configured root value type.
 *  Returns {@link JsonNode} that represents the root of the resulting tree, if there
 *  was content to read, or {@code null} if no more content is accessible
 *  via passed {@link JsonParser}.
 * <p>
 *  NOTE! Behavior with end-of-input (no more content) differs between this
 *  {@code readTree} method, and all other methods that take input source: latter
 *  will return ""missing node"", NOT {@code null}
 * <p>
 *  Note: if an object was specified with {@link #withValueToUpdate}, it
 *  will be ignored.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"@Deprecated
public ObjectReader withType(JavaType valueType) {
    return forType(valueType);
}","public void test2626() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) null);
    ObjectReader objectReader1 = objectReader0.withType((JavaType) null);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @deprecated since 2.5 Use {@link #forType(JavaType)} instead
 */"
"public ObjectReader with(Locale l) {
    return _with(_config.with(l));
}","public void test2727() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Locale locale0 = Locale.ENGLISH;
    ObjectReader objectReader1 = objectReader0.with(locale0);
    assertSame(objectReader1, objectReader0);
}",""
"@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T> T readValue(JsonNode src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));
}","public void test2828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    StringReader stringReader0 = new StringReader(""5"");
    JsonNode jsonNode0 = objectReader0.readTree((Reader) stringReader0);
    try {
        objectReader0.readValue(jsonNode0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //  at [Source: UNKNOWN; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 *  Convenience method for converting results from given JSON tree into given
 *  value type. Basically short-cut for:
 * <pre>
 *    objectReader.readValue(src.traverse())
 * </pre>
 */"
"public boolean isIntegralNumber() {
    return false;
}","public void test3232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonNode jsonNode0 = objectReader0.createObjectNode();
    assertFalse(jsonNode0.isIntegralNumber());
}","/**
 * @return True if this node represents an integral (integer)
 *   numeric JSON value
 */"
"public ObjectReader with(DeserializationConfig config) {
    return _with(config);
}","public void test3333() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.with((DeserializationConfig) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Mutant factory method that will construct a new instance that has
 *  specified underlying {@link DeserializationConfig}.
 * <p>
 *  NOTE: use of this method is not recommended, as there are many other
 *  re-configuration methods available.
 */"
"/*
    /**********************************************************
    /* Simple accessors
    /**********************************************************
     */
public boolean isEnabled(DeserializationFeature f) {
    return _config.isEnabled(f);
}","public void test3434() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_INVALID_SUBTYPE;
    boolean boolean0 = objectReader0.isEnabled(deserializationFeature0);
    assertTrue(boolean0);
}",""
"public ObjectReader with(ContextAttributes attrs) {
    return _with(_config.with(attrs));
}","public void test3535() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SimpleType> class0 = SimpleType.class;
    ObjectReader objectReader0 = objectMapper0.readerWithView(class0);
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ObjectReader objectReader1 = objectReader0.with(contextAttributes0);
    assertSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {
    return _with(_config.without(first, other));
}","public void test3636() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_LONG_FOR_INTS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[2];
    // Undeclared exception!
    try {
        objectReader0.without(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified features disabled.
 */"
"protected InputStream _inputStream(URL src) throws IOException {
    return src.openStream();
}","public void test4141() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0._inputStream((URL) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.net.MockURL"", e);
    }
}",""
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods, other
    /**********************************************************
     */
/**
 * Convenience method to bind from {@link JsonPointer}.
 * {@link JsonPointerBasedFilter} is registered and will be used for parsing later.
 * @since 2.6
 */
public ObjectReader at(final String value) {
    return new ObjectReader(this, new JsonPointerBasedFilter(value));
}","public void test4242() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.at(""lx_[e"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid input: JSON Pointer expression must start with '/': \""lx_[e\""
        //
        verifyException(""com.fasterxml.jackson.core.JsonPointer"", e);
    }
}",""
"public InjectableValues getInjectableValues() {
    return _injectableValues;
}","public void test4444() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.reader();
    InjectableValues injectableValues0 = objectReader0.getInjectableValues();
    assertNull(injectableValues0);
}","/**
 * @since 2.6
 */"
"public boolean isEnabled(JsonParser.Feature f) {
    return _parserFactory.isEnabled(f);
}","public void test4646() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    boolean boolean0 = objectReader0.isEnabled(jsonParser_Feature0);
    assertFalse(boolean0);
}",""
"/*
    /**********************************************************
    /* Implementation of rest of ObjectCodec methods
    /**********************************************************
     */
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}","public void test4747() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0, 2);
    BooleanNode booleanNode0 = arrayNode0.booleanNode(false);
    Class<String> class0 = String.class;
    String string0 = objectReader0.treeToValue((TreeNode) booleanNode0, class0);
    assertEquals(""false"", string0);
}",""
"public ObjectReader with(Base64Variant defaultBase64) {
    return _with(_config.with(defaultBase64));
}","public void test4848() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    ObjectReader objectReader1 = objectReader0.with((Base64Variant) null);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader without(DeserializationFeature feature) {
    return _with(_config.without(feature));
}","public void test4949() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_LONG_FOR_INTS;
    ObjectReader objectReader1 = objectReader0.without(deserializationFeature0);
    assertSame(objectReader1, objectReader0);
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified feature disabled.
 */"
"public ObjectReader withAttribute(Object key, Object value) {
    return _with(_config.withAttribute(key, value));
}","public void test5050() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withAttribute((Object) null, (Object) null);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"@Deprecated
public ObjectReader withType(java.lang.reflect.Type valueType) {
    return forType(_config.getTypeFactory().constructType(valueType));
}","public void test5151() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Class<FilteringParserDelegate> class0 = FilteringParserDelegate.class;
    ObjectReader objectReader1 = objectReader0.withType((Type) class0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @deprecated since 2.5 Use {@link #forType(Class)} instead
 */"
"public ObjectReader withoutAttribute(Object key) {
    return _with(_config.withoutAttribute(key));
}","public void test5252() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withoutAttribute(objectMapper0);
    assertSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public ObjectReader with(TimeZone tz) {
    return _with(_config.with(tz));
}","public void test5353() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(true);
    ObjectReader objectReader0 = objectMapper0.reader(jsonNodeFactory0);
    TimeZone timeZone0 = TimeZone.getDefault();
    ObjectReader objectReader1 = objectReader0.with(timeZone0);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {
    return _with(_config.with(first, other));
}","public void test5454() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    // Undeclared exception!
    try {
        objectReader0.with(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified features enabled.
 */"
"public ObjectReader without(FormatFeature feature) {
    return _with(_config.without(feature));
}","public void test5757() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonReadFeature jsonReadFeature0 = JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES;
    ObjectReader objectReader1 = objectReader0.without((FormatFeature) jsonReadFeature0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified feature disabled.
 *
 * @since 2.7
 */"
"public ContextAttributes getAttributes() {
    return _config.getAttributes();
}","public void test5858() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory((ObjectCodec) null);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[7];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    deserializationFeatureArray0[5] = deserializationFeature0;
    deserializationFeatureArray0[6] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    ContextAttributes contextAttributes0 = objectReader0.getAttributes();
    assertNotNull(contextAttributes0);
}","/**
 * @since 2.3
 */"
"public ObjectReader at(final JsonPointer pointer) {
    return new ObjectReader(this, new JsonPointerBasedFilter(pointer));
}","public void test5959() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonPointer jsonPointer0 = JsonPointer.forPath((JsonStreamContext) null, false);
    ObjectReader objectReader1 = objectReader0.at(jsonPointer0);
    assertNotSame(objectReader0, objectReader1);
}","/**
 * Convenience method to bind from {@link JsonPointer}
 * {@link JsonPointerBasedFilter} is registered and will be used for parsing later.
 * @since 2.6
 */"
"@Override
public void writeValue(JsonGenerator gen, Object value) throws IOException {
    throw new UnsupportedOperationException(""Not implemented for ObjectReader"");
}","public void test6060() throws Throwable {
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS;
    ObjectMapper objectMapper0 = new ObjectMapper();
    ContextAttributes contextAttributes0 = ContextAttributes.Impl.getEmpty();
    LongNode longNode0 = LongNode.valueOf((-1));
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes0);
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, longNode0, false);
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, 3);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-5358), objectMapper0, byteArrayBuilder0, byteArrayBuilder0.NO_BYTES, 934, false);
    JsonGeneratorDelegate jsonGeneratorDelegate0 = new JsonGeneratorDelegate(uTF8JsonGenerator0);
    // Undeclared exception!
    try {
        objectReader0.writeValue(jsonGeneratorDelegate0, jsonGenerator_Feature0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Not implemented for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(String src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test6161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    try {
        objectReader0.readValue("""");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: (String)\""\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Method that binds content read from given JSON string,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"public ObjectReader with(InjectableValues injectableValues) {
    if (_injectableValues == injectableValues) {
        return this;
    }
    return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, injectableValues, _dataFormatReaders);
}","public void test6262() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectReader objectReader1 = objectReader0.with((InjectableValues) injectableValues_Std0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that uses
 *  passed {@link InjectableValues} to provide injectable values.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test6363() throws Throwable {
    JsonFactoryBuilder jsonFactoryBuilder0 = new JsonFactoryBuilder();
    JsonFactory jsonFactory0 = new JsonFactory(jsonFactoryBuilder0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    assertSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test6464() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    JsonFactory jsonFactory0 = new JsonFactory(objectReader0);
    JsonFactoryBuilder jsonFactoryBuilder0 = new JsonFactoryBuilder(jsonFactory0);
    JsonFactory jsonFactory1 = new JsonFactory(jsonFactoryBuilder0);
    ObjectReader objectReader1 = objectReader0.with(jsonFactory1);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader with(FormatSchema schema) {
    if (_schema == schema) {
        return this;
    }
    _verifySchemaType(schema);
    return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate, schema, _injectableValues, _dataFormatReaders);
}","public void test6565() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[5];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    ObjectReader objectReader1 = objectReader0.with((FormatSchema) null);
    assertSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  passes specified {@link FormatSchema} to {@link JsonParser} that
 *  is constructed for parsing content.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"@Deprecated
public ObjectReader withType(java.lang.reflect.Type valueType) {
    return forType(_config.getTypeFactory().constructType(valueType));
}","public void test6666() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<FilteringParserDelegate> class0 = FilteringParserDelegate.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    ObjectReader objectReader1 = objectReader0.withType((Type) class0);
    assertSame(objectReader1, objectReader0);
}","/**
 * @deprecated since 2.5 Use {@link #forType(Class)} instead
 */"
"public ObjectReader withValueToUpdate(Object value) {
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        // 18-Oct-2016, tatu: Actually, should be allowed, to remove value
        //   to update, if any
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    /* no real benefit from pre-fetching, as updating readers are much
         * less likely to be reused, and value type may also be forced
         * with a later chained call...
         */
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public void test6767() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withValueToUpdate(objectMapper0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  updates passed Object (as root value), instead of constructing
 *  a new value.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withValueToUpdate(Object value) {
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        // 18-Oct-2016, tatu: Actually, should be allowed, to remove value
        //   to update, if any
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    /* no real benefit from pre-fetching, as updating readers are much
         * less likely to be reused, and value type may also be forced
         * with a later chained call...
         */
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public void test6868() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    BigInteger bigInteger0 = BigInteger.TEN;
    BigIntegerNode bigIntegerNode0 = BigIntegerNode.valueOf(bigInteger0);
    ObjectReader objectReader1 = objectReader0.withValueToUpdate(bigIntegerNode0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  updates passed Object (as root value), instead of constructing
 *  a new value.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"/*
    /**********************************************************
    /* Deserialization methods; others similar to what ObjectMapper has
    /**********************************************************
     */
/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */
@SuppressWarnings(""unchecked"")
public <T> T readValue(InputStream src) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test6969() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValue((InputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: UNKNOWN; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(Reader src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test7070() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    StringReader stringReader0 = new StringReader(""5"");
    try {
        objectReader0.readValue((Reader) stringReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //  at [Source: (StringReader); line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, int offset, int length) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(src, offset, length);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src, offset, length), false));
}","public void test7171() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    byte[] byteArray0 = new byte[6];
    try {
        objectReader0.readValue(byteArray0, 1, 1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: (byte[])\""\u0000\u0000\u0000\u0000\u0000\u0000\""; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that binds content read from given byte array,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(File src) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test7272() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    MockFile mockFile0 = new MockFile("" withfrmat auto-detection: must be byte- not char-based"");
    try {
        objectReader0.readValue((File) mockFile0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(URL src) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test7373() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    URL uRL0 = MockURL.getFileExample();
    // Undeclared exception!
    try {
        objectReader0.readValue(uRL0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}","/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(DataInput src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test7474() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readValue((DataInput) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}","/**
 * @since 2.8
 */"
"public boolean isIntegralNumber() {
    return false;
}","public void test7575() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonNode jsonNode0 = objectReader0.readTree((InputStream) null);
    assertFalse(jsonNode0.isIntegralNumber());
}","/**
 * @return True if this node represents an integral (integer)
 *   numeric JSON value
 */"
"public JsonNode readTree(String json) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(json);
    }
    return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(json), false));
}","public void test7676() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readTree(""{'<}fu"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)): was expecting double-quote to start field name
        //  at [Source: (String)\""{'<}fu\""; line: 1, column: 3]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Same as {@link #readTree(InputStream)} except content read from
 * passed-in {@link String}
 */"
"public boolean isFloat() {
    return false;
}","public void test7777() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    byte[] byteArray0 = new byte[0];
    JsonNode jsonNode0 = objectReader0.readTree(byteArray0);
    assertFalse(jsonNode0.isFloat());
}","/**
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Public API, straight value access
    /**********************************************************
     */
/**
 * Method to use for accessing String values.
 * Does <b>NOT</b> do any conversions for non-String value nodes;
 * for non-String values (ones for which {@link #isTextual} returns
 * false) null will be returned.
 * For String values, null is never returned (but empty Strings may be)
 *
 * @return Textual value this node contains, iff it is a textual
 *   JSON node (comes from JSON String value entry)
 */
public String textValue() {
    return null;
}","public void test7878() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[5];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    byte[] byteArray0 = new byte[5];
    JsonNode jsonNode0 = objectReader0.readTree(byteArray0, (int) (byte) (-113), (-5059));
    assertNull(jsonNode0.textValue());
}",""
"public JsonNode readTree(DataInput src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(src), false));
}","public void test7979() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    // Undeclared exception!
    try {
        objectReader0.readTree((DataInput) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}","/**
 * Same as {@link #readTree(InputStream)} except content read using
 * passed-in {@link DataInput}.
 */"
"public <T> MappingIterator<T> readValues(InputStream src) throws IOException {
    if (_dataFormatReaders != null) {
        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);
    }
    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));
}","public void test8080() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValues((InputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //  at [Source: UNKNOWN; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 *  Method for reading sequence of Objects from parser stream.
 * <p>
 *  Sequence can be either wrapped or unwrapped root-level sequence:
 *  wrapped means that the elements are enclosed in JSON Array;
 *  and unwrapped that elements are directly accessed at main level.
 *  Assumption is that iff the first token of the document is
 *  <code>START_ARRAY</code>, we have a wrapped sequence; otherwise
 *  unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>
 *  is skipped, so that for both cases, underlying {@link JsonParser}
 *  will point to what is expected to be the first token of the first
 *  element.
 * <p>
 *  Note that the wrapped vs unwrapped logic means that it is NOT
 *  possible to use this method for reading an unwrapped sequence
 *  of elements written as JSON Arrays: to read such sequences, one
 *  has to use {@link #readValues(JsonParser)}, making sure parser
 *  points to the first token of the first element (i.e. the second
 *  <code>START_ARRAY</code> which is part of the first element).
 */"
"@SuppressWarnings(""resource"")
public <T> MappingIterator<T> readValues(Reader src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    JsonParser p = _considerFilter(_parserFactory.createParser(src), true);
    DeserializationContext ctxt = createDeserializationContext(p);
    _initForMultiRead(ctxt, p);
    p.nextToken();
    return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
}","public void test8181() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValues((Reader) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //  at [Source: UNKNOWN; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"public <T> MappingIterator<T> readValues(File src) throws IOException {
    if (_dataFormatReaders != null) {
        return _detectBindAndReadValues(_dataFormatReaders.findFormat(_inputStream(src)), false);
    }
    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));
}","public void test8282() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    MockFile mockFile0 = new MockFile(""Root name '%s' does not match expected ('%s') for type %s"");
    try {
        objectReader0.readValues((File) mockFile0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"public <T> MappingIterator<T> readValues(URL src) throws IOException {
    if (_dataFormatReaders != null) {
        return _detectBindAndReadValues(_dataFormatReaders.findFormat(_inputStream(src)), true);
    }
    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));
}","public void test8383() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    URL uRL0 = MockURL.getFileExample();
    // Undeclared exception!
    try {
        objectReader0.readValues(uRL0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 *
 * @param src URL to read to access JSON content to parse.
 */"
"public <T> MappingIterator<T> readValues(DataInput src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));
}","public void test8484() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readValues((DataInput) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}","/**
 * @since 2.8
 */"
"@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T> T readValue(JsonNode src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));
}","public void test8585() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    NullNode nullNode0 = NullNode.instance;
    FloatNode floatNode0 = objectReader0.readValue((JsonNode) nullNode0);
    assertNull(floatNode0);
}","/**
 *  Convenience method for converting results from given JSON tree into given
 *  value type. Basically short-cut for:
 * <pre>
 *    objectReader.readValue(src.traverse())
 * </pre>
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(src, 0, src.length);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test8686() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 34;
    try {
        objectReader0.readValue(byteArray0);
        fail(""Expecting exception: CharConversionException"");
    } catch (CharConversionException e) {
        //
        // Unexpected EOF in the middle of a 4-byte UTF-32 char: got 2, needed 4, at char #1, byte #6)
        //
        verifyException(""com.fasterxml.jackson.core.io.UTF32Reader"", e);
    }
}","/**
 * Method that binds content read from given byte array,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"protected Object _bindAndClose(JsonParser p0) throws IOException {
    try (JsonParser p = p0) {
        Object result;
        DeserializationContext ctxt = createDeserializationContext(p);
        JsonToken t = _initForReading(ctxt, p);
        if (t == JsonToken.VALUE_NULL) {
            if (_valueToUpdate == null) {
                result = _findRootDeserializer(ctxt).getNullValue(ctxt);
            } else {
                result = _valueToUpdate;
            }
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = _valueToUpdate;
        } else {
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);
            if (_unwrapRoot) {
                result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);
            } else {
                if (_valueToUpdate == null) {
                    result = deser.deserialize(p, ctxt);
                } else {
                    deser.deserialize(p, ctxt, _valueToUpdate);
                    result = _valueToUpdate;
                }
            }
        }
        if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
            _verifyNoTrailingTokens(p, ctxt, _valueType);
        }
        return result;
    }
}","public void test8787() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0._bindAndClose((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"protected final JsonNode _bindAndCloseAsTree(JsonParser p0) throws IOException {
    try (JsonParser p = p0) {
        return _bindAsTree(p);
    }
}","public void test8888() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ShortNode> class0 = ShortNode.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    // Undeclared exception!
    try {
        objectReader0._bindAndCloseAsTree((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"protected final void _verifyNoTrailingTokens(JsonParser p, DeserializationContext ctxt, JavaType bindType) throws IOException {
    JsonToken t = p.nextToken();
    if (t != null) {
        Class<?> bt = ClassUtil.rawClass(bindType);
        if (bt == null) {
            if (_valueToUpdate != null) {
                bt = _valueToUpdate.getClass();
            }
        }
        ctxt.reportTrailingTokens(bt, p, t);
    }
}","public void test8989() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ArrayNode arrayNode0 = objectMapper0.createArrayNode();
    JsonParser jsonParser0 = arrayNode0.traverse((ObjectCodec) objectReader0);
    // Undeclared exception!
    try {
        objectReader0._verifyNoTrailingTokens(jsonParser0, (DeserializationContext) null, (JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 * @since 2.9
 */"
"@SuppressWarnings({ ""resource"" })
protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException {
    if (!match.hasMatch()) {
        _reportUnkownFormat(_dataFormatReaders, match);
    }
    JsonParser p = match.createParserWithMatch();
    // One more thing: we Own the input stream now; and while it's
    // not super clean way to do it, we must ensure closure so:
    if (forceClosing) {
        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    }
    // important: use matching ObjectReader (may not be 'this')
    return match.getReader()._bindAndReadValues(p);
}","public void test9090() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader[] objectReaderArray0 = new ObjectReader[0];
    DataFormatReaders dataFormatReaders0 = new DataFormatReaders(objectReaderArray0);
    DataFormatReaders.Match dataFormatReaders_Match0 = dataFormatReaders0.findFormat((InputStream) null);
    // Undeclared exception!
    try {
        objectReader0._detectBindAndReadValues(dataFormatReaders_Match0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other
    /**********************************************************
     */
/**
 * @since 2.2
 */
protected void _verifySchemaType(FormatSchema schema) {
    if (schema != null) {
        if (!_parserFactory.canUseSchema(schema)) {
            throw new IllegalArgumentException(""Cannot use FormatSchema of type "" + schema.getClass().getName() + "" for format "" + _parserFactory.getFormatName());
        }
    }
}","public void test9191() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    objectReader0._verifySchemaType((FormatSchema) null);
}",""
"@SuppressWarnings(""resource"")
public <T> MappingIterator<T> readValues(Reader src) throws IOException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    JsonParser p = _considerFilter(_parserFactory.createParser(src), true);
    DeserializationContext ctxt = createDeserializationContext(p);
    _initForMultiRead(ctxt, p);
    p.nextToken();
    return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
}","public void test9292() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    try {
        objectReader0.readValues((Reader) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Conflicting setter definitions for property \""config\"": com.fasterxml.jackson.databind.ObjectMapper#setConfig(1 params) vs com.fasterxml.jackson.databind.ObjectMapper#setConfig(1 params)
        //  at [Source: UNKNOWN; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"public AccessPattern getEmptyAccessPattern() {
    return AccessPattern.DYNAMIC;
}","public void test9393() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    JsonDeserializer<Object> jsonDeserializer0 = objectReader0._prefetchRootDeserializer(javaType0);
    assertEquals(AccessPattern.DYNAMIC, jsonDeserializer0.getEmptyAccessPattern());
}","/**
 * This method may be called in conjunction with calls to
 * {@link #getEmptyValue(DeserializationContext)}, to check whether it needs
 * to be called just once (static values), or each time empty value is
 * needed.
 *
 * @since 2.9
 */"
