focal_method,test_prefix,docstring
"public final boolean useStaticType() {
    return _asStatic;
}","public void test011() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) class0);
    referenceType0.getReferencedType();
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean isReferenceType() {
    return true;
}","public void test022() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    ReferenceType referenceType0 = new ReferenceType(class0, simpleType0, (Object) null, (Object) null, false);
    boolean boolean0 = referenceType0.isReferenceType();
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public String toString() {
    return new StringBuilder(40).append(""[reference type, class "").append(buildCanonicalName()).append('<').append(_referencedType).append('>').append(']').toString();
}","public void test033() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    String string0 = referenceType0.toString();
    assertEquals(""[reference type, class com.fasterxml.jackson.databind.type.ReferenceType<int<[simple type, class int]>]"", string0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test034() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    String string0 = referenceType0.toString();
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test046() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    Object object0 = new Object();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, object0, object0);
    StringBuilder stringBuilder0 = new StringBuilder();
    referenceType0.getErasedSignature(stringBuilder0);
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test057() throws Throwable {
    Class<Integer> class0 = Integer.class;
    JavaType javaType0 = TypeFactory.unknownType();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, javaType0, (Object) class0, (Object) javaType0);
    referenceType0.getParameterSource();
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean isJavaLangObject() {
    return _class == Object.class;
}","public void test068() throws Throwable {
    Class<String> class0 = String.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    ReferenceType referenceType0 = new ReferenceType(class0, simpleType0, simpleType0, class0, true);
    Class<Object> class1 = Object.class;
    JavaType javaType0 = referenceType0._narrow(class1);
    assertTrue(javaType0.isJavaLangObject());
}","/**
 *  Convenience method, short-hand for
 * <code>
 *    getRawClass() == Object.class
 * </code>
 *  and used to figure if we basically have ""untyped"" type object.
 *
 *  @since 2.5
 */"
"@Override
public ReferenceType withTypeHandler(Object h) {
    if (h == _typeHandler) {
        return this;
    }
    return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);
}","public void test0810() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_STRING;
    ReferenceType referenceType0 = new ReferenceType(class0, simpleType0, (Object) null, (Object) null, false);
    ReferenceType referenceType1 = referenceType0.withTypeHandler((Object) null);
    assertSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test0911() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withContentTypeHandler(simpleType0);
    assertFalse(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public ReferenceType withContentTypeHandler(Object h) {
    if (h == _referencedType.<Object>getTypeHandler()) {
        return this;
    }
    return new ReferenceType(_class, _referencedType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic);
}","public void test0912() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withContentTypeHandler(simpleType0);
    assertNotSame(referenceType1, referenceType0);
}",""
"@Override
public ReferenceType withContentTypeHandler(Object h) {
    if (h == _referencedType.<Object>getTypeHandler()) {
        return this;
    }
    return new ReferenceType(_class, _referencedType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic);
}","public void test1013() throws Throwable {
    Class<Integer> class0 = Integer.class;
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<HashMap> class1 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class1);
    Class<Object> class2 = Object.class;
    ReferenceType referenceType0 = new ReferenceType(class2, mapType0, class0, class2, true);
    ReferenceType referenceType1 = referenceType0.withContentTypeHandler((Object) null);
    assertSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1114() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withValueHandler(simpleType0);
    assertFalse(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public boolean hasValueHandler() {
    return _valueHandler != null;
}","public void test1115() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withValueHandler(simpleType0);
    assertTrue(referenceType1.hasValueHandler());
}","/**
 * @since 2.6
 */"
"@Override
public ReferenceType withValueHandler(Object h) {
    if (h == _valueHandler) {
        return this;
    }
    return new ReferenceType(_class, _referencedType, h, _typeHandler, _asStatic);
}","public void test1216() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = new ReferenceType(class0, simpleType0, simpleType0, referenceType0, false);
    ReferenceType referenceType2 = referenceType1.withValueHandler(simpleType0);
    assertSame(referenceType2, referenceType1);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1217() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = new ReferenceType(class0, simpleType0, simpleType0, referenceType0, false);
    ReferenceType referenceType2 = referenceType1.withValueHandler(simpleType0);
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public ReferenceType withContentValueHandler(Object h) {
    if (h == _referencedType.<Object>getValueHandler()) {
        return this;
    }
    return new ReferenceType(_class, _referencedType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic);
}","public void test1318() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withContentValueHandler(referenceType0);
    assertNotSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1319() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withContentValueHandler(referenceType0);
    assertFalse(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1420() throws Throwable {
    Class<String> class0 = String.class;
    Class<Object> class1 = Object.class;
    Integer integer0 = new Integer((-2427));
    SimpleType simpleType0 = new SimpleType(class1, (-2427), class1, integer0, false);
    Object object0 = new Object();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, object0, (Object) integer0);
    ReferenceType referenceType1 = referenceType0.withContentValueHandler(class1);
    assertFalse(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public ReferenceType withContentValueHandler(Object h) {
    if (h == _referencedType.<Object>getValueHandler()) {
        return this;
    }
    return new ReferenceType(_class, _referencedType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic);
}","public void test1421() throws Throwable {
    Class<String> class0 = String.class;
    Class<Object> class1 = Object.class;
    Integer integer0 = new Integer((-2427));
    SimpleType simpleType0 = new SimpleType(class1, (-2427), class1, integer0, false);
    Object object0 = new Object();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, object0, (Object) integer0);
    ReferenceType referenceType1 = referenceType0.withContentValueHandler(class1);
    assertSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1522() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withStaticTyping();
    assertTrue(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1523() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withStaticTyping();
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public ReferenceType withStaticTyping() {
    if (_asStatic) {
        return this;
    }
    return new ReferenceType(_class, _referencedType.withStaticTyping(), _valueHandler, _typeHandler, true);
}","public void test1624() throws Throwable {
    Class<Integer> class0 = Integer.class;
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<HashMap> class1 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class1);
    Class<Object> class2 = Object.class;
    ReferenceType referenceType0 = new ReferenceType(class2, mapType0, class0, class2, true);
    ReferenceType referenceType1 = referenceType0.withStaticTyping();
    assertSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2028() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) class0);
    String string0 = referenceType0.containedTypeName(0);
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ReferenceType other = (ReferenceType) o;
    if (other._class != _class)
        return false;
    // Otherwise actually mostly worry about referenced type
    return _referencedType.equals(other._referencedType);
}","public void test2131() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withTypeHandler(simpleType0);
    boolean boolean0 = referenceType1.equals(referenceType0);
    assertNotSame(referenceType1, referenceType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2132() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    ReferenceType referenceType1 = referenceType0.withTypeHandler(simpleType0);
    boolean boolean0 = referenceType1.equals(referenceType0);
    assertFalse(referenceType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ReferenceType other = (ReferenceType) o;
    if (other._class != _class)
        return false;
    // Otherwise actually mostly worry about referenced type
    return _referencedType.equals(other._referencedType);
}","public void test2234() throws Throwable {
    Class<Integer> class0 = Integer.class;
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<HashMap> class1 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class1);
    Class<Object> class2 = Object.class;
    ReferenceType referenceType0 = new ReferenceType(class2, mapType0, class0, class2, true);
    boolean boolean0 = referenceType0.equals(referenceType0);
    assertTrue(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ReferenceType other = (ReferenceType) o;
    if (other._class != _class)
        return false;
    // Otherwise actually mostly worry about referenced type
    return _referencedType.equals(other._referencedType);
}","public void test2335() throws Throwable {
    Class<String> class0 = String.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    ReferenceType referenceType0 = new ReferenceType(class0, simpleType0, simpleType0, class0, true);
    boolean boolean0 = referenceType0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2436() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    Object object0 = new Object();
    boolean boolean0 = referenceType0.equals(object0);
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ReferenceType other = (ReferenceType) o;
    if (other._class != _class)
        return false;
    // Otherwise actually mostly worry about referenced type
    return _referencedType.equals(other._referencedType);
}","public void test2437() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    Object object0 = new Object();
    boolean boolean0 = referenceType0.equals(object0);
    assertFalse(boolean0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test2538() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<Object> class1 = Object.class;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    Object object0 = new Object();
    ReferenceType referenceType1 = new ReferenceType(class1, referenceType0, object0, ""vs.,.vy(0KEO"", false);
    boolean boolean0 = referenceType0.equals(referenceType1);
    assertFalse(referenceType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    ReferenceType other = (ReferenceType) o;
    if (other._class != _class)
        return false;
    // Otherwise actually mostly worry about referenced type
    return _referencedType.equals(other._referencedType);
}","public void test2539() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<Object> class1 = Object.class;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) class0, (Object) simpleType0);
    Object object0 = new Object();
    ReferenceType referenceType1 = new ReferenceType(class1, referenceType0, object0, ""vs.,.vy(0KEO"", false);
    boolean boolean0 = referenceType0.equals(referenceType1);
    assertFalse(boolean0);
}",""
