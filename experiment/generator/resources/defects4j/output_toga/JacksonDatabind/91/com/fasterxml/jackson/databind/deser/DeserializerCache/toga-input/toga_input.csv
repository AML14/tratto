focal_method,test_prefix,docstring
"/*
    /**********************************************************
    /* Access to caching aspects
    /**********************************************************
     */
/**
 *  Method that can be used to determine how many deserializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of deserializers get cached;
 *  default implementation caches only dynamically constructed deserializers,
 *  but not eagerly constructed standard deserializers (which is different
 *  from how serializer provider works).
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  deserializer cache, if certain number of entries is reached.
 */
public int cachedDeserializersCount() {
    return _cachedDeserializers.size();
}","public void test000() throws Throwable {
    DeserializerCache deserializerCache0 = new DeserializerCache();
    int int0 = deserializerCache0.cachedDeserializersCount();
    assertEquals(0, int0);
}",""
"/*
    /**********************************************************
    /* JDK serialization handling
    /**********************************************************
     */
Object writeReplace() {
    // instead of making this transient, just clear it:
    _incompleteDeserializers.clear();
    // TODO: clear out ""cheap"" cached deserializers?
    return this;
}","public void test011() throws Throwable {
    DeserializerCache deserializerCache0 = new DeserializerCache();
    Object object0 = deserializerCache0.writeReplace();
    assertSame(object0, deserializerCache0);
}",""
"public void flushCachedDeserializers() {
    _cachedDeserializers.clear();
}","public void test022() throws Throwable {
    DeserializerCache deserializerCache0 = new DeserializerCache();
    deserializerCache0.flushCachedDeserializers();
}","/**
 * Method that will drop all dynamically constructed deserializers (ones that
 * are counted as result value for {@link #cachedDeserializersCount}).
 * This can be used to remove memory usage (in case some deserializers are
 * only used once or so), or to force re-construction of deserializers after
 * configuration changes for mapper than owns the provider.
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test033() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LinkedHashMap> class0 = LinkedHashMap.class;
    MapLikeType mapLikeType0 = typeFactory0.constructMapLikeType(class0, class0, class0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) mapLikeType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    objectMapper0.canDeserialize(javaType0);
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SettableBeanProperty> class0 = SettableBeanProperty.class;
    Class<ObjectIdReferenceProperty> class1 = ObjectIdReferenceProperty.class;
    MapLikeType mapLikeType0 = typeFactory0.constructMapLikeType(class0, class1, class0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) mapLikeType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LinkedHashMap> class0 = LinkedHashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) mapType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public boolean canDeserialize(JavaType type) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null);
}","public void test077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PlaceholderForType placeholderForType0 = new PlaceholderForType(55296);
    objectMapper0.canDeserialize((JavaType) placeholderForType0);
    boolean boolean0 = objectMapper0.canDeserialize((JavaType) placeholderForType0);
    assertTrue(boolean0);
}","/**
 *  Method that can be called to check whether mapper thinks
 *  it could deserialize an Object of given type.
 *  Check is done by checking whether a registered deserializer can
 *  be found or built for the type; if not (either by no mapping being
 *  found, or through an <code>Exception</code> being thrown, false
 *  is returned.
 * <p>
 *  <b>NOTE</b>: in case an exception is thrown during course of trying
 *  co construct matching deserializer, it will be effectively swallowed.
 *  If you want access to that exception, call
 *  {@link #canDeserialize(JavaType, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */"
"public boolean canDeserialize(JavaType type) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null);
}","public void test088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    boolean boolean0 = objectMapper0.canDeserialize((JavaType) collectionLikeType0);
    assertFalse(boolean0);
}","/**
 *  Method that can be called to check whether mapper thinks
 *  it could deserialize an Object of given type.
 *  Check is done by checking whether a registered deserializer can
 *  be found or built for the type; if not (either by no mapping being
 *  found, or through an <code>Exception</code> being thrown, false
 *  is returned.
 * <p>
 *  <b>NOTE</b>: in case an exception is thrown during course of trying
 *  co construct matching deserializer, it will be effectively swallowed.
 *  If you want access to that exception, call
 *  {@link #canDeserialize(JavaType, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */"
"@SuppressWarnings(""unchecked"")
public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException {
    JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);
    if (deser == null) {
        // can this occur?
        return null;
    }
    deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, null, type);
    TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);
    if (typeDeser != null) {
        // important: contextualize to indicate this is for root value
        typeDeser = typeDeser.forProperty(null);
        return new TypeWrappedDeserializer(typeDeser, deser);
    }
    return deser;
}","public void test099() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.findRootValueDeserializer((JavaType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null JavaType passed
        //
        verifyException(""com.fasterxml.jackson.databind.deser.DeserializerCache"", e);
    }
}","/**
 * Method for finding a deserializer for root-level value.
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ArrayType arrayType0 = ArrayType.construct(javaType0, typeBindings0);
    Object object0 = new Object();
    ArrayType arrayType1 = arrayType0.withContentTypeHandler(object0);
    // Undeclared exception!
    try {
        objectMapper0.readerFor((JavaType) arrayType1);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Object cannot be cast to com.fasterxml.jackson.databind.jsontype.TypeDeserializer
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1111() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    objectMapper0.setTypeFactory((TypeFactory) null);
    // Undeclared exception!
    try {
        objectMapper0.readerFor(javaType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.MapperConfig"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1212() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(javaType0, javaType0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) collectionLikeType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1313() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CLASS;
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(jsonTypeInfo_Id0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1414() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    JavaType javaType0 = TypeFactory.unknownType();
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(javaType0, javaType0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) referenceType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LinkedHashMap> class0 = LinkedHashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    MapLikeType mapLikeType0 = mapType0.withKeyValueHandler(objectMapper0);
    // Undeclared exception!
    try {
        objectMapper0.readerFor((JavaType) mapLikeType0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // com.fasterxml.jackson.databind.ObjectMapper cannot be cast to com.fasterxml.jackson.databind.KeyDeserializer
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1717() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ArrayType arrayType0 = ArrayType.construct(javaType0, typeBindings0);
    ArrayType arrayType1 = arrayType0.withContentValueHandler(typeBindings0);
    // Undeclared exception!
    try {
        objectMapper0.readerFor((JavaType) arrayType1);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // com.fasterxml.jackson.databind.type.TypeBindings cannot be cast to com.fasterxml.jackson.databind.JsonDeserializer
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {
    /* Note: mostly copied from findValueDeserializer, except for
         * handling of unknown types
         */
    JsonDeserializer<Object> deser = _findCachedDeserializer(type);
    if (deser == null) {
        deser = _createAndCacheValueDeserializer(ctxt, factory, type);
    }
    return (deser != null);
}","public void test1818() throws Throwable {
    DeserializerCache deserializerCache0 = new DeserializerCache();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<DecimalNode> class0 = DecimalNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructCollectionLikeType(class0, (JavaType) null);
    // Undeclared exception!
    try {
        deserializerCache0.hasValueDeserializerFor(defaultDeserializationContext_Impl0, (DeserializerFactory) null, collectionLikeType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.DeserializerCache"", e);
    }
}","/**
 * Method called to find out whether provider would be able to find
 * a deserializer for given type, using a root reference (i.e. not
 * through fields or membership in an array or collection)
 */"
