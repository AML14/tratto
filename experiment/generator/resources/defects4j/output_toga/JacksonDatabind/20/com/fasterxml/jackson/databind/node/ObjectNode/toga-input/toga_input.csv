focal_method,test_prefix,docstring
"public boolean isBigInteger() {
    return false;
}","public void test000() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.removeAll();
    assertFalse(objectNode1.isBigInteger());
}",""
"/*
    /**********************************************************
    /* TreeNode implementation
    /**********************************************************
     */
//  public abstract JsonToken asToken();
//  public abstract JsonToken traverse();
//  public abstract JsonToken traverse(ObjectCodec codec);
//  public abstract JsonParser.NumberType numberType();
@Override
public int size() {
    return 0;
}","public void test011() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    JsonNode jsonNode0 = objectNode0.putAll(objectNode0);
    assertEquals(0, jsonNode0.size());
}",""
"@Override
public Iterator<String> fieldNames() {
    return _children.keySet().iterator();
}","public void test022() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    Iterator<String> iterator0 = objectNode0.fieldNames();
    assertNotNull(iterator0);
}",""
"@Override
public int hashCode() {
    return _children.hashCode();
}","public void test044() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    objectNode0.hashCode();
}",""
"@Override
protected JsonNode _at(JsonPointer ptr) {
    return get(ptr.getMatchingProperty());
}","public void test055() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    // Undeclared exception!
    try {
        objectNode0._at((JsonPointer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.node.ObjectNode"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, straight value access
    /**********************************************************
     */
/**
 * Method to use for accessing String values.
 * Does <b>NOT</b> do any conversions for non-String value nodes;
 * for non-String values (ones for which {@link #isTextual} returns
 * false) null will be returned.
 * For String values, null is never returned (but empty Strings may be)
 *
 * @return Textual value this node contains, iff it is a textual
 *   JSON node (comes from JSON String value entry)
 */
public String textValue() {
    return null;
}","public void test077() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    JsonNode jsonNode0 = objectNode0.without(""LpN@SVwK` vp{;"");
    assertNull(jsonNode0.textValue());
}",""
"@Override
public int size() {
    return _children.size();
}","public void test099() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.putObject(""kC]()QA-"");
    assertEquals(0, objectNode1.size());
}",""
"public boolean hasNonNull(String fieldName) {
    JsonNode n = get(fieldName);
    return (n != null) && !n.isNull();
}","public void test1010() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    boolean boolean0 = objectNode0.hasNonNull(""LpN@SVwK` vp{;"");
    assertFalse(boolean0);
}","/**
 *  Method that is similar to {@link #has(String)}, but that will
 *  return <code>false</code> for explicitly added nulls.
 * <p>
 *  This method is functionally equivalent to:
 * <pre>
 *    node.get(fieldName) != null && !node.get(fieldName).isNull()
 * </pre>
 *
 *  @since 2.1
 */"
"@Override
public int size() {
    return _children.size();
}","public void test1111() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""<j]gXCuj8z^ "", (-2016056520));
    assertEquals(1, objectNode1.size());
}",""
"public boolean isFloat() {
    return false;
}","public void test1313() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    HashMap<String, BigIntegerNode> hashMap0 = new HashMap<String, BigIntegerNode>();
    JsonNode jsonNode0 = objectNode0.putAll((Map<String, ? extends JsonNode>) hashMap0);
    assertFalse(jsonNode0.isFloat());
}","/**
 * @since 2.2
 */"
"public boolean isLong() {
    return false;
}","public void test1414() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    TreeSet<String> treeSet0 = new TreeSet<String>();
    ObjectNode objectNode1 = objectNode0.remove((Collection<String>) treeSet0);
    assertFalse(objectNode1.isLong());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>long</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java <code>long</code>
 */"
"public JsonNode remove(String fieldName) {
    return _children.remove(fieldName);
}","public void test1515() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    JsonNode jsonNode0 = objectNode0.remove(""zT4YsA$\""1Q'Zj/2)*j"");
    assertNull(jsonNode0);
}","/**
 * Method for removing field entry from this ObjectNode.
 * Will return value of the field, if such field existed;
 * null if not.
 *
 * @return Value of specified field, if it existed; null if not
 */"
"public boolean has(int index) {
    return get(index) != null;
}","public void test1616() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    boolean boolean0 = objectNode0.has((-1554429048));
    assertFalse(boolean0);
}","/**
 *  Method that allows checking whether this node is JSON Array node
 *  and contains a value for specified index
 *  If this is the case
 *  (including case of specified indexing having null as value), returns true;
 *  otherwise returns false.
 * <p>
 *  Note: array element indexes are 0-based.
 * <p>
 *  This method is equivalent to:
 * <pre>
 *    node.get(index) != null
 * </pre>
 * <p>
 *  NOTE: this method will return <code>true</code> for explicitly added
 *  null values.
 *
 *  @param index Index to check
 *
 *  @return True if this node is a JSON Object node, and has a property
 *    entry with specified name (with any value, including null value)
 */"
"/*
    /**********************************************************
    /* Public API, finding value nodes
    /**********************************************************
     */
@Override
public JsonNode findValue(String fieldName) {
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
        if (fieldName.equals(entry.getKey())) {
            return entry.getValue();
        }
        JsonNode value = entry.getValue().findValue(fieldName);
        if (value != null) {
            return value;
        }
    }
    return null;
}","public void test1717() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""LpN@SVwK` vp{;"", 0L);
    JsonNode jsonNode0 = objectNode1.findValue(""JSON"");
    assertNull(jsonNode0);
}",""
"/*
    /**********************************************************
    /* Public API, straight value access
    /**********************************************************
     */
/**
 * Method to use for accessing String values.
 * Does <b>NOT</b> do any conversions for non-String value nodes;
 * for non-String values (ones for which {@link #isTextual} returns
 * false) null will be returned.
 * For String values, null is never returned (but empty Strings may be)
 *
 * @return Textual value this node contains, iff it is a textual
 *   JSON node (comes from JSON String value entry)
 */
public String textValue() {
    return null;
}","public void test1818() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    List<String> list0 = objectNode0.findValuesAsText(""#-H*<g;}-e"");
    ObjectNode objectNode1 = objectNode0.retain((Collection<String>) list0);
    assertNull(objectNode1.textValue());
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o instanceof ObjectNode) {
        return _childrenEqual((ObjectNode) o);
    }
    return false;
}","public void test2021() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ObjectNode objectNode1 = new ObjectNode(jsonNodeFactory0);
    boolean boolean0 = objectNode1.equals(objectNode0);
    assertTrue(boolean0);
}",""
"public boolean isDouble() {
    return false;
}","public void test2122() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put("" <"", false);
    assertFalse(objectNode1.isDouble());
}",""
"public boolean booleanValue() {
    return false;
}","public void test2324() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""b_7~AsxM"", (-1.0F));
    assertFalse(objectNode1.booleanValue());
}","/**
 * Method to use for accessing JSON boolean values (value
 * literals 'true' and 'false').
 * For other types, always returns false.
 *
 * @return Textual value this node contains, iff it is a textual
 *   json node (comes from JSON String value entry)
 */"
"public ObjectNode putPOJO(String fieldName, Object pojo) {
    return _put(fieldName, pojoNode(pojo));
}","public void test2627() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    TextNode textNode0 = jsonNodeFactory0.textNode(""ULHq4{{gcI"");
    ObjectNode objectNode1 = objectNode0.putPOJO(""ULHq4{{gcI"", textNode0);
    assertSame(objectNode1, objectNode0);
}","/**
 * @return This node (to allow chaining)
 */"
"/* Question: should this delegate to `JsonNodeFactory`? It does not absolutely
     * have to, as long as sub-types override the method but...
     */
// note: co-variant for type safety
@SuppressWarnings(""unchecked"")
@Override
public ObjectNode deepCopy() {
    ObjectNode ret = new ObjectNode(_nodeFactory);
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) ret._children.put(entry.getKey(), entry.getValue().deepCopy());
    return ret;
}","public void test2728() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.putNull(""+"");
    ObjectNode objectNode2 = objectNode1.deepCopy();
    assertNotSame(objectNode2, objectNode0);
}",""
"@Override
public int size() {
    return _children.size();
}","public void test2729() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.putNull(""+"");
    ObjectNode objectNode2 = objectNode1.deepCopy();
    assertEquals(1, objectNode2.size());
}",""
"@Override
public JsonNode path(String fieldName) {
    JsonNode n = _children.get(fieldName);
    if (n != null) {
        return n;
    }
    return MissingNode.getInstance();
}","public void test2931() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(false);
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ObjectNode objectNode1 = objectNode0.with("",}w({qq]BNqT[1"");
    JsonNode jsonNode0 = objectNode0.path("",}w({qq]BNqT[1"");
    assertSame(jsonNode0, objectNode1);
}",""
"@Override
public ObjectNode with(String propertyName) {
    JsonNode n = _children.get(propertyName);
    if (n != null) {
        if (n instanceof ObjectNode) {
            return (ObjectNode) n;
        }
        throw new UnsupportedOperationException(""Property '"" + propertyName + ""' has value that is not of type ObjectNode (but "" + n.getClass().getName() + "")"");
    }
    ObjectNode result = objectNode();
    _children.put(propertyName, result);
    return result;
}","public void test3032() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    objectNode0.putNull((String) null);
    // Undeclared exception!
    try {
        objectNode0.with((String) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Property 'null' has value that is not of type ObjectNode (but com.fasterxml.jackson.databind.node.NullNode)
        //
        verifyException(""com.fasterxml.jackson.databind.node.ObjectNode"", e);
    }
}",""
"@Override
public ObjectNode with(String propertyName) {
    JsonNode n = _children.get(propertyName);
    if (n != null) {
        if (n instanceof ObjectNode) {
            return (ObjectNode) n;
        }
        throw new UnsupportedOperationException(""Property '"" + propertyName + ""' has value that is not of type ObjectNode (but "" + n.getClass().getName() + "")"");
    }
    ObjectNode result = objectNode();
    _children.put(propertyName, result);
    return result;
}","public void test3133() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.with(""Xab^sEK*<|~69/<2V"");
    ObjectNode objectNode2 = objectNode0.with(""Xab^sEK*<|~69/<2V"");
    assertSame(objectNode2, objectNode1);
}",""
"@Override
public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException {
    typeSer.writeTypePrefixForObject(this, jg);
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        jg.writeFieldName(en.getKey());
        ((BaseJsonNode) en.getValue()).serialize(jg, provider);
    }
    typeSer.writeTypeSuffixForObject(this, jg);
}","public void test3234() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ArrayNode arrayNode0 = objectNode0.withArray(""Can not pass null property name"");
    arrayNode0.addObject();
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    MockFile mockFile0 = new MockFile(""JSON"");
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF16_LE;
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = (WriterBasedJsonGenerator) jsonFactory0.createGenerator((File) mockFile0, jsonEncoding0);
    SimpleType simpleType0 = (SimpleType) TypeFactory.unknownType();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    AsExternalTypeSerializer asExternalTypeSerializer0 = new AsExternalTypeSerializer(classNameIdResolver0, (BeanProperty) null, ""JSON"");
    objectNode0.serializeWithType(writerBasedJsonGenerator0, (SerializerProvider) null, asExternalTypeSerializer0);
    assertEquals(56320, GeneratorBase.SURR2_FIRST);
}",""
"@Override
public ArrayNode withArray(String propertyName) {
    JsonNode n = _children.get(propertyName);
    if (n != null) {
        if (n instanceof ArrayNode) {
            return (ArrayNode) n;
        }
        throw new UnsupportedOperationException(""Property '"" + propertyName + ""' has value that is not of type ArrayNode (but "" + n.getClass().getName() + "")"");
    }
    ArrayNode result = arrayNode();
    _children.put(propertyName, result);
    return result;
}","public void test3335() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    objectNode0.put(""MTt*yMz"", 460.8990766266048);
    // Undeclared exception!
    try {
        objectNode0.withArray(""MTt*yMz"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Property 'MTt*yMz' has value that is not of type ArrayNode (but com.fasterxml.jackson.databind.node.DoubleNode)
        //
        verifyException(""com.fasterxml.jackson.databind.node.ObjectNode"", e);
    }
}",""
"public boolean isIntegralNumber() {
    return false;
}","public void test3436() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    objectNode0.withArray(""H<,2:"");
    ArrayNode arrayNode0 = objectNode0.withArray(""H<,2:"");
    assertFalse(arrayNode0.isIntegralNumber());
}","/**
 * @return True if this node represents an integral (integer)
 *   numeric JSON value
 */"
"/*
    /**********************************************************
    /* Public API, finding value nodes
    /**********************************************************
     */
@Override
public JsonNode findValue(String fieldName) {
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
        if (fieldName.equals(entry.getKey())) {
            return entry.getValue();
        }
        JsonNode value = entry.getValue().findValue(fieldName);
        if (value != null) {
            return value;
        }
    }
    return null;
}","public void test3537() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    JsonNode jsonNode0 = objectNode0.findValue(""JSON"");
    assertNull(jsonNode0);
}",""
"@Override
public int size() {
    return _children.size();
}","public void test3638() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.with(""<!&"");
    Long long0 = new Long((-2279L));
    objectNode1.put(""=!f{"", long0);
    objectNode0.findValue(""=!f{"");
    assertEquals(1, objectNode0.size());
}",""
"@Override
public ObjectNode findParent(String fieldName) {
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
        if (fieldName.equals(entry.getKey())) {
            return this;
        }
        JsonNode value = entry.getValue().findParent(fieldName);
        if (value != null) {
            return (ObjectNode) value;
        }
    }
    return null;
}","public void test4144() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.with(""<!&"");
    ObjectNode objectNode2 = objectNode0.findParent(""=!f{"");
    assertNotSame(objectNode0, objectNode1);
}",""
"public boolean isLong() {
    return false;
}","public void test4246() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    Long long0 = new Long((-2279L));
    ObjectNode objectNode1 = objectNode0.put(""=!f{"", long0);
    ObjectNode objectNode2 = objectNode1.findParent(""=!f{"");
    assertFalse(objectNode2.isLong());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>long</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java <code>long</code>
 */"
"@Override
public ObjectNode findParent(String fieldName) {
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
        if (fieldName.equals(entry.getKey())) {
            return this;
        }
        JsonNode value = entry.getValue().findParent(fieldName);
        if (value != null) {
            return (ObjectNode) value;
        }
    }
    return null;
}","public void test4347() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ObjectNode objectNode1 = objectNode0.put(""Internal error: entry should be a Number, but is of type "", (short) (-3));
    ArrayNode arrayNode0 = objectNode0.putArray(""7R$O!=;AAfrFl>NPjc"");
    ObjectNode objectNode2 = arrayNode0.insertObject(200);
    ObjectNode objectNode3 = objectNode2._put("")"", objectNode1);
    ObjectNode objectNode4 = objectNode3.findParent(""Internal error: entry should be a Number, but is of type "");
    assertNotNull(objectNode4);
}",""
"@Override
public int size() {
    return _children.size();
}","public void test4348() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ObjectNode objectNode1 = objectNode0.put(""Internal error: entry should be a Number, but is of type "", (short) (-3));
    ArrayNode arrayNode0 = objectNode0.putArray(""7R$O!=;AAfrFl>NPjc"");
    ObjectNode objectNode2 = arrayNode0.insertObject(200);
    ObjectNode objectNode3 = objectNode2._put("")"", objectNode1);
    ObjectNode objectNode4 = objectNode3.findParent(""Internal error: entry should be a Number, but is of type "");
    assertEquals(2, objectNode4.size());
}",""
"@Override
public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {
    for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
        if (fieldName.equals(entry.getKey())) {
            if (foundSoFar == null) {
                foundSoFar = new ArrayList<JsonNode>();
            }
            foundSoFar.add(this);
        } else {
            // only add children if parent not added
            foundSoFar = entry.getValue().findParents(fieldName, foundSoFar);
        }
    }
    return foundSoFar;
}","public void test4550() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.putNull("" (expected type: "");
    List<JsonNode> list0 = objectNode1.findParents(""com.fasterxml.jackson.databind.deser.AbstractDeserializer"");
    // Undeclared exception!
    try {
        objectNode1.findParents("" (expected type: "", list0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.AbstractList"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, serialization
    /**********************************************************
     */
/**
 * Method that can be called to serialize this node and
 * all of its descendants using specified JSON generator.
 */
@Override
public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException {
    jg.writeStartObject();
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        jg.writeFieldName(en.getKey());
        /* 17-Feb-2009, tatu: Can we trust that all nodes will always
                 *   extend BaseJsonNode? Or if not, at least implement
                 *   JsonSerializable? Let's start with former, change if
                 *   we must.
                 */
        ((BaseJsonNode) en.getValue()).serialize(jg, provider);
    }
    jg.writeEndObject();
}","public void test4651() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    objectNode0.putNull(""{"");
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer();
    IOContext iOContext0 = new IOContext(bufferRecycler0, objectWriter0, true);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, objectMapper0, byteArrayOutputStream0);
    // Undeclared exception!
    try {
        objectNode0.serialize(uTF8JsonGenerator0, (SerializerProvider) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.node.NullNode"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, type introspection
    /**********************************************************
     */
// // First high-level division between values, containers and ""missing""
/**
 * Return the type of this node
 *
 * @return the node type as a {@link JsonNodeType} enum value
 *
 * @since 2.2
 */
public abstract JsonNodeType getNodeType();","public void test4752() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    ObjectNode objectNode0 = arrayNode0.insertObject(0);
    JsonNode jsonNode0 = objectNode0.set("";0lx#Wm?`"", arrayNode0);
    assertEquals(JsonNodeType.OBJECT, jsonNode0.getNodeType());
}",""
"public boolean isFloatingPointNumber() {
    return false;
}","public void test4853() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    JsonNode jsonNode0 = objectNode0.set(""hj-H4"", (JsonNode) null);
    assertFalse(jsonNode0.isFloatingPointNumber());
}","/**
 * @return True if this node represents a non-integral
 *   numeric JSON value
 */"
"@Override
public int size() {
    return _children.size();
}","public void test4954() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    HashMap<String, TextNode> hashMap0 = new HashMap<String, TextNode>();
    hashMap0.put(""ZxdX"", (TextNode) null);
    objectNode0.setAll((Map<String, ? extends JsonNode>) hashMap0);
    assertEquals(1, objectNode0.size());
}",""
"@Override
public int size() {
    return _children.size();
}","public void test5055() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    NullNode nullNode0 = jsonNodeFactory0.nullNode();
    hashMap0.put("">!Q_l @"", nullNode0);
    objectNode0.setAll((Map<String, ? extends JsonNode>) hashMap0);
    assertEquals(1, objectNode0.size());
}",""
"public JsonNode replace(String fieldName, JsonNode value) {
    if (value == null) {
        // let's not store 'raw' nulls but nodes
        value = nullNode();
    }
    return _children.put(fieldName, value);
}","public void test5156() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    JsonNode jsonNode0 = objectNode0.replace(""zT4YsA$\""1Q'Zj/2)*j"", objectNode0);
    assertNull(jsonNode0);
}","/**
 * Method for replacing value of specific property with passed
 * value, and returning value (or null if none).
 *
 * @param fieldName Property of which value to replace
 * @param value Value to set property to, replacing old value if any
 *
 * @return Old value of the property; null if there was no such property
 *   with value
 *
 * @since 2.1
 */"
"public JsonNode replace(String fieldName, JsonNode value) {
    if (value == null) {
        // let's not store 'raw' nulls but nodes
        value = nullNode();
    }
    return _children.put(fieldName, value);
}","public void test5257() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    JsonNode jsonNode0 = objectNode0.replace(""!=U)md/"", (JsonNode) null);
    assertNull(jsonNode0);
}","/**
 * Method for replacing value of specific property with passed
 * value, and returning value (or null if none).
 *
 * @param fieldName Property of which value to replace
 * @param value Value to set property to, replacing old value if any
 *
 * @return Old value of the property; null if there was no such property
 *   with value
 *
 * @since 2.1
 */"
"/*
    /**********************************************************
    /* Extended ObjectNode API, mutators, generic
    /**********************************************************
     */
/**
 * Method that will set specified field, replacing old value, if any.
 *
 * @param value to set field to; if null, will be converted
 *   to a {@link NullNode} first  (to remove field entry, call
 *   {@link #remove} instead)
 *
 * @return Old value of the field, if any; null if there was no
 *   old value.
 *
 * @deprecated Since 2.4 use either {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},
 */
@Deprecated
public JsonNode put(String fieldName, JsonNode value) {
    if (value == null) {
        // let's not store 'raw' nulls but nodes
        value = nullNode();
    }
    return _children.put(fieldName, value);
}","public void test5358() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    JsonNode jsonNode0 = objectNode0.put("":`"", (JsonNode) objectNode0);
    assertNull(jsonNode0);
}",""
"/*
    /**********************************************************
    /* Extended ObjectNode API, mutators, generic
    /**********************************************************
     */
/**
 * Method that will set specified field, replacing old value, if any.
 *
 * @param value to set field to; if null, will be converted
 *   to a {@link NullNode} first  (to remove field entry, call
 *   {@link #remove} instead)
 *
 * @return Old value of the field, if any; null if there was no
 *   old value.
 *
 * @deprecated Since 2.4 use either {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},
 */
@Deprecated
public JsonNode put(String fieldName, JsonNode value) {
    if (value == null) {
        // let's not store 'raw' nulls but nodes
        value = nullNode();
    }
    return _children.put(fieldName, value);
}","public void test5459() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, (Map<String, JsonNode>) null);
    // Undeclared exception!
    try {
        objectNode0.put(""com.fasterxml.jackson.databind.ser.std.NumberSerializer"", (JsonNode) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.node.ObjectNode"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, straight value access
    /**********************************************************
     */
/**
 * Method to use for accessing String values.
 * Does <b>NOT</b> do any conversions for non-String value nodes;
 * for non-String values (ones for which {@link #isTextual} returns
 * false) null will be returned.
 * For String values, null is never returned (but empty Strings may be)
 *
 * @return Textual value this node contains, iff it is a textual
 *   JSON node (comes from JSON String value entry)
 */
public String textValue() {
    return null;
}","public void test5560() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    Short short0 = new Short((short) (-1202));
    ObjectNode objectNode1 = objectNode0.put("" getter: "", short0);
    assertNull(objectNode1.textValue());
}",""
"public boolean isFloatingPointNumber() {
    return false;
}","public void test5661() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""=9zI)RRvckwLgHU"", (Short) null);
    assertFalse(objectNode1.isFloatingPointNumber());
}","/**
 * @return True if this node represents a non-integral
 *   numeric JSON value
 */"
"@Override
public String asText() {
    return """";
}","public void test5762() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    Integer integer0 = new Integer(0);
    ObjectNode objectNode1 = objectNode0.put("":Q)fa-"", integer0);
    assertEquals("""", objectNode1.asText());
}",""
"public ObjectNode put(String fieldName, Integer v) {
    return _put(fieldName, (v == null) ? nullNode() : numberNode(v.intValue()));
}","public void test5863() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""LpN@SVwK` vp{;"", (Integer) null);
    assertSame(objectNode0, objectNode1);
}","/**
 * Alternative method that we need to avoid bumping into NPE issues
 * with auto-unboxing.
 *
 * @return This node (to allow chaining)
 */"
"public ObjectNode put(String fieldName, Long v) {
    return _put(fieldName, (v == null) ? nullNode() : numberNode(v.longValue()));
}","public void test5964() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""ftfMh"", (Long) null);
    assertSame(objectNode0, objectNode1);
}","/**
 * Method for setting value of a field to specified numeric value.
 * The underlying {@link JsonNode} that will be added is constructed
 * using {@link JsonNodeFactory#numberNode(Long)}, and may be
 *  ""smaller"" (like {@link IntNode}) in cases where value fits within
 *  range of a smaller integral numeric value.
 * <p>
 * Note that this is alternative to {@link #put(String, long)} needed to avoid
 * bumping into NPE issues with auto-unboxing.
 *
 * @return This node (to allow chaining)
 */"
"@Override
public String asText() {
    return """";
}","public void test6065() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    Float float0 = new Float((-176.3724F));
    ObjectNode objectNode1 = objectNode0.put(""#-H*<g;}-e"", float0);
    assertEquals("""", objectNode1.asText());
}",""
"@Override
public JsonParser.NumberType numberType() {
    // most types non-numeric, so:
    return null;
}","public void test6166() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""]`"", (Float) null);
    assertNull(objectNode1.numberType());
}","/**
 * Returns code that identifies type of underlying numeric
 * value, if (and only if) node is a number node.
 */"
"@Override
public String asText() {
    return """";
}","public void test6267() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    Double double0 = new Double(1.0);
    ObjectNode objectNode1 = objectNode0.put(""oU^yF5p'{<R%j1T%"", double0);
    assertEquals("""", objectNode1.asText());
}",""
"@Override
public int size() {
    return _children.size();
}","public void test6368() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""SOLID_MATCH"", (Double) null);
    assertEquals(1, objectNode1.size());
}",""
"@Override
public JsonParser.NumberType numberType() {
    // most types non-numeric, so:
    return null;
}","public void test6469() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    BigDecimal bigDecimal0 = BigDecimal.TEN;
    ObjectNode objectNode1 = objectNode0.put(""XgZ15KUnv2B}"", bigDecimal0);
    assertNull(objectNode1.numberType());
}","/**
 * Returns code that identifies type of underlying numeric
 * value, if (and only if) node is a number node.
 */"
"public boolean isLong() {
    return false;
}","public void test6570() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put((String) null, (BigDecimal) null);
    assertFalse(objectNode1.isLong());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>long</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java <code>long</code>
 */"
"public boolean isDouble() {
    return false;
}","public void test6671() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""-}+OPSl29"", ""-}+OPSl29"");
    assertFalse(objectNode1.isDouble());
}",""
"public boolean isInt() {
    return false;
}","public void test6772() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    ObjectNode objectNode1 = objectNode0.put(""{"", (String) null);
    assertFalse(objectNode1.isInt());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>int</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java int
 */"
"public ObjectNode put(String fieldName, Boolean v) {
    return _put(fieldName, (v == null) ? nullNode() : booleanNode(v.booleanValue()));
}","public void test6873() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    Boolean boolean0 = new Boolean("", copied "");
    ObjectNode objectNode1 = objectNode0.put(""2|UEa<\""`(2d"", boolean0);
    assertSame(objectNode0, objectNode1);
}","/**
 * Alternative method that we need to avoid bumping into NPE issues
 * with auto-unboxing.
 *
 * @return This node (to allow chaining)
 */"
"public boolean isLong() {
    return false;
}","public void test6974() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""Xab^sEK*<|~69/<2V"", (Boolean) null);
    assertFalse(objectNode1.isLong());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>long</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java <code>long</code>
 */"
"/*
    /**********************************************************
    /* Public API, straight value access
    /**********************************************************
     */
/**
 * Method to use for accessing String values.
 * Does <b>NOT</b> do any conversions for non-String value nodes;
 * for non-String values (ones for which {@link #isTextual} returns
 * false) null will be returned.
 * For String values, null is never returned (but empty Strings may be)
 *
 * @return Textual value this node contains, iff it is a textual
 *   JSON node (comes from JSON String value entry)
 */
public String textValue() {
    return null;
}","public void test7075() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    ObjectNode objectNode1 = objectNode0.put(""Internal error: entry should be a Number, but is of type "", (byte[]) null);
    assertNull(objectNode1.textValue());
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o instanceof ObjectNode) {
        return _childrenEqual((ObjectNode) o);
    }
    return false;
}","public void test7176() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    ObjectNode objectNode0 = arrayNode0.insertObject(0);
    boolean boolean0 = objectNode0.equals(objectNode0);
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o instanceof ObjectNode) {
        return _childrenEqual((ObjectNode) o);
    }
    return false;
}","public void test7277() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    ObjectNode objectNode0 = jsonNodeFactory0.objectNode();
    boolean boolean0 = objectNode0.equals((Object) null);
    assertFalse(boolean0);
}",""
"/*
    /**********************************************************
    /* Standard methods
    /**********************************************************
     */
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o instanceof ObjectNode) {
        return _childrenEqual((ObjectNode) o);
    }
    return false;
}","public void test7378() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    NullNode nullNode0 = jsonNodeFactory0.nullNode();
    boolean boolean0 = objectNode0.equals(nullNode0);
    assertFalse(boolean0);
}",""
