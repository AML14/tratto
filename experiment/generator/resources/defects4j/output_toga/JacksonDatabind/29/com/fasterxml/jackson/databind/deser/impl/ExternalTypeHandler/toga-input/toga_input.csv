focal_method,test_prefix,docstring
"public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException {
    // first things first: deserialize all data buffered:
    final int len = _properties.length;
    Object[] values = new Object[len];
    for (int i = 0; i < len; ++i) {
        String typeId = _typeIds[i];
        if (typeId == null) {
            // let's allow missing both type and property (may already have been set, too)
            if (_tokens[i] == null) {
                continue;
            }
            // but not just one
            // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'
            if (!_properties[i].hasDefaultType()) {
                throw ctxt.mappingException(""Missing external type id property '%s'"", _properties[i].getTypePropertyName());
            }
            typeId = _properties[i].getDefaultTypeId();
        } else if (_tokens[i] == null) {
            SettableBeanProperty prop = _properties[i].getProperty();
            throw ctxt.mappingException(""Missing property '%s' for external type id '%s'"", prop.getName(), _properties[i].getTypePropertyName());
        }
        values[i] = _deserialize(jp, ctxt, i, typeId);
    }
    // second: fill in creator properties:
    for (int i = 0; i < len; ++i) {
        SettableBeanProperty prop = _properties[i].getProperty();
        if (creator.findCreatorProperty(prop.getName()) != null) {
            buffer.assignParameter(prop, values[i]);
        }
    }
    Object bean = creator.build(ctxt, buffer);
    // third: assign non-creator properties
    for (int i = 0; i < len; ++i) {
        SettableBeanProperty prop = _properties[i].getProperty();
        if (creator.findCreatorProperty(prop.getName()) == null) {
            prop.set(bean, values[i]);
        }
    }
    return bean;
}","public void test000() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = new PropertyName("""");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<Module> class0 = Module.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, """", true, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, (-283), """", propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    CreatorCollector.Vanilla creatorCollector_Vanilla0 = new CreatorCollector.Vanilla(123);
    SettableBeanProperty[] settableBeanPropertyArray0 = new SettableBeanProperty[3];
    settableBeanPropertyArray0[0] = (SettableBeanProperty) creatorProperty0;
    settableBeanPropertyArray0[1] = (SettableBeanProperty) creatorProperty0;
    settableBeanPropertyArray0[2] = (SettableBeanProperty) creatorProperty0;
    PropertyBasedCreator propertyBasedCreator0 = new PropertyBasedCreator(creatorCollector_Vanilla0, settableBeanPropertyArray0);
    // Undeclared exception!
    try {
        externalTypeHandler1.complete((JsonParser) null, (DeserializationContext) null, (PropertyValueBuffer) null, propertyBasedCreator0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"", e);
    }
}","/**
 * Variant called when creation of the POJO involves buffering of creator properties
 * as well as property-based creator.
 */"
"public ExternalTypeHandler start() {
    return new ExternalTypeHandler(this);
}","public void test011() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = externalTypeHandler0.start();
    assertNotSame(externalTypeHandler0, externalTypeHandler1);
}",""
"@SuppressWarnings(""resource"")
protected final Object _deserialize(JsonParser p, DeserializationContext ctxt, int index, String typeId) throws IOException {
    JsonParser p2 = _tokens[index].asParser(p);
    JsonToken t = p2.nextToken();
    // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
    TokenBuffer merged = new TokenBuffer(p);
    merged.writeStartArray();
    merged.writeString(typeId);
    merged.copyCurrentStructure(p2);
    merged.writeEndArray();
    // needs to point to START_OBJECT (or whatever first token is)
    JsonParser mp = merged.asParser(p);
    mp.nextToken();
    return _properties[index].getProperty().deserialize(mp, ctxt);
}","public void test022() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    // Undeclared exception!
    try {
        externalTypeHandler0._deserialize((JsonParser) null, (DeserializationContext) null, (-108), ""X5%"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"", e);
    }
}",""
"@SuppressWarnings(""resource"")
protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException {
    /* Ok: time to mix type id, value; and we will actually use ""wrapper-array""
         * style to ensure we can handle all kinds of JSON constructs.
         */
    JsonParser p2 = _tokens[index].asParser(p);
    JsonToken t = p2.nextToken();
    // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
    TokenBuffer merged = new TokenBuffer(p);
    merged.writeStartArray();
    merged.writeString(typeId);
    merged.copyCurrentStructure(p2);
    merged.writeEndArray();
    // needs to point to START_OBJECT (or whatever first token is)
    JsonParser mp = merged.asParser(p);
    mp.nextToken();
    _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);
}","public void test033() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    // Undeclared exception!
    try {
        externalTypeHandler0._deserializeAndSet((JsonParser) null, (DeserializationContext) null, externalTypeHandler_Builder0, 1579, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"", e);
    }
}",""
"public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    if (!prop.hasTypePropertyName(propName)) {
        return false;
    }
    String typeId = jp.getText();
    // note: can NOT skip child values (should always be String anyway)
    boolean canDeserialize = (bean != null) && (_tokens[index] != null);
    // Minor optimization: deserialize properties as soon as we have all we need:
    if (canDeserialize) {
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        // clear stored data, to avoid deserializing+setting twice:
        _tokens[index] = null;
    } else {
        _typeIds[index] = typeId;
    }
    return true;
}","public void test044() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    boolean boolean0 = externalTypeHandler0.handleTypePropertyValue((JsonParser) null, (DeserializationContext) null, ""~+E"", (Object) null);
    assertFalse(boolean0);
}","/**
 * Method called to see if given property/value pair is an external type
 * id; and if so handle it. This is <b>only</b> to be called in case
 * containing POJO has similarly named property as the external type id;
 * otherwise {@link #handlePropertyValue} should be called instead.
 */"
"public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    if (!prop.hasTypePropertyName(propName)) {
        return false;
    }
    String typeId = jp.getText();
    // note: can NOT skip child values (should always be String anyway)
    boolean canDeserialize = (bean != null) && (_tokens[index] != null);
    // Minor optimization: deserialize properties as soon as we have all we need:
    if (canDeserialize) {
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        // clear stored data, to avoid deserializing+setting twice:
        _tokens[index] = null;
    } else {
        _typeIds[index] = typeId;
    }
    return true;
}","public void test055() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = new PropertyName(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler$ExtTypedProperty"", ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler$ExtTypedProperty"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""gC_p"", true, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_REQUIRED;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, 7, externalTypeHandler_Builder0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    boolean boolean0 = externalTypeHandler0.handleTypePropertyValue((JsonParser) null, (DeserializationContext) null, ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler$ExtTypedProperty"", propertyMetadata0);
    assertFalse(boolean0);
}","/**
 * Method called to see if given property/value pair is an external type
 * id; and if so handle it. This is <b>only</b> to be called in case
 * containing POJO has similarly named property as the external type id;
 * otherwise {@link #handlePropertyValue} should be called instead.
 */"
"public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    if (!prop.hasTypePropertyName(propName)) {
        return false;
    }
    String typeId = jp.getText();
    // note: can NOT skip child values (should always be String anyway)
    boolean canDeserialize = (bean != null) && (_tokens[index] != null);
    // Minor optimization: deserialize properties as soon as we have all we need:
    if (canDeserialize) {
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        // clear stored data, to avoid deserializing+setting twice:
        _tokens[index] = null;
    } else {
        _typeIds[index] = typeId;
    }
    return true;
}","public void test066() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = PropertyName.construct(""co.aster1ml.jacks{n.databind.deser.impl.ExternalTypeHavdler$ExtyedProperty"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""co.aster1ml.jacks{n.databind.deser.impl.ExternalTypeHavdler$ExtyedProperty"", false, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, (-12), typeFactory0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    JsonFactory jsonFactory0 = new JsonFactory();
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory0.createParser((Reader) pipedReader0);
    // Undeclared exception!
    try {
        externalTypeHandler0.handleTypePropertyValue(jsonParser0, (DeserializationContext) null, ""co.aster1ml.jacks{n.databind.deser.impl.ExternalTypeHavdler$ExtyedProperty"", (Object) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"", e);
    }
}","/**
 * Method called to see if given property/value pair is an external type
 * id; and if so handle it. This is <b>only</b> to be called in case
 * containing POJO has similarly named property as the external type id;
 * otherwise {@link #handlePropertyValue} should be called instead.
 */"
"public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    if (!prop.hasTypePropertyName(propName)) {
        return false;
    }
    String typeId = jp.getText();
    // note: can NOT skip child values (should always be String anyway)
    boolean canDeserialize = (bean != null) && (_tokens[index] != null);
    // Minor optimization: deserialize properties as soon as we have all we need:
    if (canDeserialize) {
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        // clear stored data, to avoid deserializing+setting twice:
        _tokens[index] = null;
    } else {
        _typeIds[index] = typeId;
    }
    return true;
}","public void test077() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = new PropertyName(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"", false, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, 17, typeFactory0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    JsonFactory jsonFactory0 = new JsonFactory();
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory0.createParser((Reader) pipedReader0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    boolean boolean0 = externalTypeHandler1.handleTypePropertyValue(jsonParser0, defaultDeserializationContext_Impl0, ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"", typeFactory0);
    assertTrue(boolean0);
}","/**
 * Method called to see if given property/value pair is an external type
 * id; and if so handle it. This is <b>only</b> to be called in case
 * containing POJO has similarly named property as the external type id;
 * otherwise {@link #handlePropertyValue} should be called instead.
 */"
"public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    boolean canDeserialize;
    if (prop.hasTypePropertyName(propName)) {
        _typeIds[index] = jp.getText();
        jp.skipChildren();
        canDeserialize = (bean != null) && (_tokens[index] != null);
    } else {
        @SuppressWarnings(""resource"")
        TokenBuffer tokens = new TokenBuffer(jp);
        tokens.copyCurrentStructure(jp);
        _tokens[index] = tokens;
        canDeserialize = (bean != null) && (_typeIds[index] != null);
    }
    /* Minor optimization: let's deserialize properties as soon as
         * we have all pertinent information:
         */
    if (canDeserialize) {
        String typeId = _typeIds[index];
        // clear stored data, to avoid deserializing+setting twice:
        _typeIds[index] = null;
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        _tokens[index] = null;
    }
    return true;
}","public void test088() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    boolean boolean0 = externalTypeHandler0.handlePropertyValue((JsonParser) null, (DeserializationContext) null, ""com.fastKrxml.jackson.databind.ser.std.N8mberSerializer`$LongSerializer"", externalTypeHandler_Builder0);
    assertFalse(boolean0);
}","/**
 * Method called to ask handler to handle value of given property,
 * at point where parser points to the first token of the value.
 * Handling can mean either resolving type id it contains (if it matches type
 * property name), or by buffering the value for further use.
 *
 * @return True, if the given property was properly handled
 */"
"public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    boolean canDeserialize;
    if (prop.hasTypePropertyName(propName)) {
        _typeIds[index] = jp.getText();
        jp.skipChildren();
        canDeserialize = (bean != null) && (_tokens[index] != null);
    } else {
        @SuppressWarnings(""resource"")
        TokenBuffer tokens = new TokenBuffer(jp);
        tokens.copyCurrentStructure(jp);
        _tokens[index] = tokens;
        canDeserialize = (bean != null) && (_typeIds[index] != null);
    }
    /* Minor optimization: let's deserialize properties as soon as
         * we have all pertinent information:
         */
    if (canDeserialize) {
        String typeId = _typeIds[index];
        // clear stored data, to avoid deserializing+setting twice:
        _typeIds[index] = null;
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        _tokens[index] = null;
    }
    return true;
}","public void test099() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = PropertyName.construct(""com.fasterxm.jackson.databinddser.std.dkDeserikWizers"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, (String) null, true, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_REQUIRED;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, (-18), class0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    // Undeclared exception!
    try {
        externalTypeHandler0.handlePropertyValue((JsonParser) null, (DeserializationContext) null, ""com.fasterxm.jackson.databinddser.std.dkDeserikWizers"", ""com.fasterxm.jackson.databinddser.std.dkDeserikWizers"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}","/**
 * Method called to ask handler to handle value of given property,
 * at point where parser points to the first token of the value.
 * Handling can mean either resolving type id it contains (if it matches type
 * property name), or by buffering the value for further use.
 *
 * @return True, if the given property was properly handled
 */"
"public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    boolean canDeserialize;
    if (prop.hasTypePropertyName(propName)) {
        _typeIds[index] = jp.getText();
        jp.skipChildren();
        canDeserialize = (bean != null) && (_tokens[index] != null);
    } else {
        @SuppressWarnings(""resource"")
        TokenBuffer tokens = new TokenBuffer(jp);
        tokens.copyCurrentStructure(jp);
        _tokens[index] = tokens;
        canDeserialize = (bean != null) && (_typeIds[index] != null);
    }
    /* Minor optimization: let's deserialize properties as soon as
         * we have all pertinent information:
         */
    if (canDeserialize) {
        String typeId = _typeIds[index];
        // clear stored data, to avoid deserializing+setting twice:
        _typeIds[index] = null;
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        _tokens[index] = null;
    }
    return true;
}","public void test1010() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = PropertyName.NO_NAME;
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""ZTpMX^%%$v"", true, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, (-2912), classNameIdResolver0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    JsonFactory jsonFactory0 = new JsonFactory();
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory0.createParser((Reader) pipedReader0);
    boolean boolean0 = externalTypeHandler1.handlePropertyValue(jsonParser0, (DeserializationContext) null, ""ZTpMX^%%$v"", (Object) null);
    assertTrue(boolean0);
}","/**
 * Method called to ask handler to handle value of given property,
 * at point where parser points to the first token of the value.
 * Handling can mean either resolving type id it contains (if it matches type
 * property name), or by buffering the value for further use.
 *
 * @return True, if the given property was properly handled
 */"
"public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException {
    Integer I = _nameToPropertyIndex.get(propName);
    if (I == null) {
        return false;
    }
    int index = I.intValue();
    ExtTypedProperty prop = _properties[index];
    boolean canDeserialize;
    if (prop.hasTypePropertyName(propName)) {
        _typeIds[index] = jp.getText();
        jp.skipChildren();
        canDeserialize = (bean != null) && (_tokens[index] != null);
    } else {
        @SuppressWarnings(""resource"")
        TokenBuffer tokens = new TokenBuffer(jp);
        tokens.copyCurrentStructure(jp);
        _tokens[index] = tokens;
        canDeserialize = (bean != null) && (_typeIds[index] != null);
    }
    /* Minor optimization: let's deserialize properties as soon as
         * we have all pertinent information:
         */
    if (canDeserialize) {
        String typeId = _typeIds[index];
        // clear stored data, to avoid deserializing+setting twice:
        _typeIds[index] = null;
        _deserializeAndSet(jp, ctxt, bean, index, typeId);
        _tokens[index] = null;
    }
    return true;
}","public void test1111() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = new PropertyName(""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"", false, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, (-2883), classNameIdResolver0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    JsonFactory jsonFactory0 = new JsonFactory();
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory0.createParser((Reader) pipedReader0);
    boolean boolean0 = externalTypeHandler1.handlePropertyValue(jsonParser0, (DeserializationContext) null, ""com.fasterxml.jackson.databind.deser.impl.ExternalTypeHavdler$ExtypedProperty"", jsonParser0);
    assertTrue(boolean0);
}","/**
 * Method called to ask handler to handle value of given property,
 * at point where parser points to the first token of the value.
 * Handling can mean either resolving type id it contains (if it matches type
 * property name), or by buffering the value for further use.
 *
 * @return True, if the given property was properly handled
 */"
"@Override
public int size() {
    return (_annotations == null) ? 0 : _annotations.size();
}","public void test1212() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = PropertyName.USE_DEFAULT;
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""com.fasterxm.jackson.databinddeser.std.dkDeserializers"", true, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, 1763, typeFactory0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    AnnotationMap annotationMap1 = (AnnotationMap) externalTypeHandler1.complete((JsonParser) null, (DeserializationContext) null, (Object) annotationMap0);
    assertEquals(0, annotationMap1.size());
}",""
"public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException {
    // first things first: deserialize all data buffered:
    final int len = _properties.length;
    Object[] values = new Object[len];
    for (int i = 0; i < len; ++i) {
        String typeId = _typeIds[i];
        if (typeId == null) {
            // let's allow missing both type and property (may already have been set, too)
            if (_tokens[i] == null) {
                continue;
            }
            // but not just one
            // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'
            if (!_properties[i].hasDefaultType()) {
                throw ctxt.mappingException(""Missing external type id property '%s'"", _properties[i].getTypePropertyName());
            }
            typeId = _properties[i].getDefaultTypeId();
        } else if (_tokens[i] == null) {
            SettableBeanProperty prop = _properties[i].getProperty();
            throw ctxt.mappingException(""Missing property '%s' for external type id '%s'"", prop.getName(), _properties[i].getTypePropertyName());
        }
        values[i] = _deserialize(jp, ctxt, i, typeId);
    }
    // second: fill in creator properties:
    for (int i = 0; i < len; ++i) {
        SettableBeanProperty prop = _properties[i].getProperty();
        if (creator.findCreatorProperty(prop.getName()) != null) {
            buffer.assignParameter(prop, values[i]);
        }
    }
    Object bean = creator.build(ctxt, buffer);
    // third: assign non-creator properties
    for (int i = 0; i < len; ++i) {
        SettableBeanProperty prop = _properties[i].getProperty();
        if (creator.findCreatorProperty(prop.getName()) == null) {
            prop.set(bean, values[i]);
        }
    }
    return bean;
}","public void test1313() throws Throwable {
    ExternalTypeHandler.Builder externalTypeHandler_Builder0 = new ExternalTypeHandler.Builder();
    PropertyName propertyName0 = new PropertyName(""com.kasterxml.jacksondatabid.deser.impl.ExternalTypeHandler$ExtTJpePopTy"");
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(simpleType0, classNameIdResolver0, ""com.kasterxml.jacksondatabid.deser.impl.ExternalTypeHandler$ExtTJpePopTy"", false, class0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_REQUIRED;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, simpleType0, propertyName0, asArrayTypeDeserializer0, annotationMap0, (AnnotatedParameter) null, 2, classNameIdResolver0, propertyMetadata0);
    externalTypeHandler_Builder0.addExternal(creatorProperty0, asArrayTypeDeserializer0);
    ExternalTypeHandler externalTypeHandler0 = externalTypeHandler_Builder0.build();
    ExternalTypeHandler externalTypeHandler1 = new ExternalTypeHandler(externalTypeHandler0);
    CreatorCollector.Vanilla creatorCollector_Vanilla0 = new CreatorCollector.Vanilla(2);
    SettableBeanProperty[] settableBeanPropertyArray0 = new SettableBeanProperty[0];
    PropertyBasedCreator propertyBasedCreator0 = PropertyBasedCreator.construct((DeserializationContext) null, creatorCollector_Vanilla0, settableBeanPropertyArray0);
    // Undeclared exception!
    try {
        externalTypeHandler1.complete((JsonParser) null, (DeserializationContext) null, (PropertyValueBuffer) null, propertyBasedCreator0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator"", e);
    }
}","/**
 * Variant called when creation of the POJO involves buffering of creator properties
 * as well as property-based creator.
 */"
