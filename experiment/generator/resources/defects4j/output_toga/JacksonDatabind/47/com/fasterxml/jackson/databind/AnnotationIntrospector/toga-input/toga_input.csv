focal_method,test_prefix,docstring
"@Override
public ReferenceType withValueHandler(Object h) {
    if (h == _valueHandler) {
        return this;
    }
    return new ReferenceType(_class, _bindings, _superClass, _superInterfaces, _referencedType, h, _typeHandler, _asStatic);
}","public void test000() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationIntrospector annotationIntrospector1 = AnnotationIntrospector.pair(annotationIntrospector0, annotationIntrospector0);
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.ALWAYS;
    annotationIntrospector1.findSerializationInclusionForContent((Annotated) null, jsonInclude_Include0);
    AnnotationIntrospector.nopInstance();
    JavaType javaType0 = null;
    ReferenceType referenceType0 = ReferenceType.upgradeFrom((JavaType) null, (JavaType) null);
    // Undeclared exception!
    try {
        referenceType0.withValueHandler(javaType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Missing referencedType
        //
        verifyException(""com.fasterxml.jackson.databind.type.ReferenceType"", e);
    }
}",""
"@Override
@SuppressWarnings(""deprecation"")
public JsonInclude.Value findPropertyInclusion(Annotated a) {
    JsonInclude inc = _findAnnotation(a, JsonInclude.class);
    JsonInclude.Include valueIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.value();
    if (valueIncl == JsonInclude.Include.USE_DEFAULTS) {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        if (ann != null) {
            JsonSerialize.Inclusion i2 = ann.include();
            switch(i2) {
                case ALWAYS:
                    valueIncl = JsonInclude.Include.ALWAYS;
                    break;
                case NON_NULL:
                    valueIncl = JsonInclude.Include.NON_NULL;
                    break;
                case NON_DEFAULT:
                    valueIncl = JsonInclude.Include.NON_DEFAULT;
                    break;
                case NON_EMPTY:
                    valueIncl = JsonInclude.Include.NON_EMPTY;
                    break;
                case DEFAULT_INCLUSION:
                default:
            }
        }
    }
    JsonInclude.Include contentIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.content();
    return JsonInclude.Value.construct(valueIncl, contentIncl);
}","public void test011() throws Throwable {
    JacksonAnnotationIntrospector jacksonAnnotationIntrospector0 = (JacksonAnnotationIntrospector) ObjectMapper.DEFAULT_ANNOTATION_INTROSPECTOR;
    jacksonAnnotationIntrospector0.findPropertyInclusion((Annotated) null);
}",""
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    objectMapper0.readerFor(class0);
    AnnotationIntrospector.nopInstance();
}",""
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.getSerializerProviderInstance();
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    objectMapper0.setAnnotationIntrospectors(annotationIntrospector0, annotationIntrospector0);
    Class<AnnotationIntrospector> class0 = AnnotationIntrospector.class;
    objectMapper0.readerFor(class0);
    AnnotationIntrospector.nopInstance();
}",""
"public Object findKeyDeserializer(Annotated am) {
    return null;
}","public void test077() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findKeyDeserializer((Annotated) null);
}","/**
 * Method for getting a deserializer definition for keys of
 * associated <code>Map</code> property.
 * Type of definition is either instance (of type
 * {@link JsonDeserializer}) or Class (of type
 * <code>Class&lt;JsonDeserializer></code>); if value of different
 * type is returned, a runtime exception may be thrown by caller.
 */"
"public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {
    return new AnnotationIntrospectorPair(a1, a2);
}","public void test088() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findDeserializer((Annotated) null);
    AnnotationIntrospector.pair(annotationIntrospector0, annotationIntrospector0);
}",""
"// since 2.7
@Deprecated
public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {
    return defValue;
}","public void test1010() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getDefaultCreator();
    annotationIntrospector0.findKeyDeserializer((Annotated) null);
    annotationIntrospector0.findDeserializer((Annotated) null);
    annotationIntrospector0.findReferenceType((AnnotatedMember) null);
    Class<Annotation>[] classArray0 = (Class<Annotation>[]) Array.newInstance(Class.class, 9);
    Class<Annotation> class0 = Annotation.class;
    classArray0[4] = class0;
    classArray0[6] = classArray0[2];
    classArray0[7] = class0;
    classArray0[8] = classArray0[6];
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.NON_EMPTY;
    annotationIntrospector0.findSerializationInclusion((Annotated) null, jsonInclude_Include0);
}","/**
 *  Method for checking whether given annotated entity (class, method,
 *  field) defines which Bean/Map properties are to be included in
 *  serialization.
 *  If no annotation is found, method should return given second
 *  argument; otherwise value indicated by the annotation.
 * <p>
 *  Note that meaning of inclusion value depends on whether it is for
 *  a Class or property (field/method/constructor): in former case,
 *  it is the default for all properties; in latter case it is specific
 *  override for annotated property.
 *
 *  @return Enumerated value indicating which properties to include
 *    in serialization
 *
 *  @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
 */"
"@Override
public boolean hasAnySetterAnnotation(AnnotatedMethod am) {
    /* No dedicated disabling; regular @JsonIgnore used
         * if needs to be ignored (and if so, is handled prior
         * to this method getting called)
         */
    return _hasAnnotation(am, JsonAnySetter.class);
}","public void test1111() throws Throwable {
    JacksonAnnotationIntrospector jacksonAnnotationIntrospector0 = (JacksonAnnotationIntrospector) ObjectMapper.DEFAULT_ANNOTATION_INTROSPECTOR;
    jacksonAnnotationIntrospector0.hasAnySetterAnnotation((AnnotatedMethod) null);
}",""
"public String findClassDescription(AnnotatedClass ac) {
    return null;
}","public void test1313() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.allIntrospectors();
    annotationIntrospector0.findClassDescription((AnnotatedClass) null);
}","/**
 * Method used to check whether specified class defines a human-readable
 * description to use for documentation.
 * There are no further definitions for contents; for example, whether
 * these may be marked up using HTML (or something like wiki format like Markup)
 * is not defined.
 *
 * @return Human-readable description, if any.
 *
 * @since 2.7
 */"
"public Object findInjectableValueId(AnnotatedMember m) {
    return null;
}","public void test1515() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    annotationIntrospector0.findInjectableValueId((AnnotatedMember) null);
}","/**
 * Method called to find out whether given member expectes a value
 * to be injected, and if so, what is the identifier of the value
 * to use during injection.
 * Type if identifier needs to be compatible with provider of
 * values (of type {@link InjectableValues}); often a simple String
 * id is used.
 *
 * @param m Member to check
 *
 * @return Identifier of value to inject, if any; null if no injection
 *   indicator is found
 */"
"/*
    /**********************************************************
    /* Annotations for Object Id handling
    /**********************************************************
     */
/**
 * Method for checking whether given annotated thing
 * (type, or accessor) indicates that values
 * referenced (values of type of annotated class, or
 * values referenced by annotated property; latter
 * having precedence) should include Object Identifier,
 * and if so, specify details of Object Identity used.
 *
 * @since 2.0
 */
public ObjectIdInfo findObjectIdInfo(Annotated ann) {
    return null;
}","public void test1616() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    annotationIntrospector0.findObjectIdInfo((Annotated) null);
}",""
"public Boolean hasRequiredMarker(AnnotatedMember m) {
    return null;
}","public void test1717() throws Throwable {
    AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findInjectableValueId((AnnotatedMember) null);
    annotationIntrospector0.hasRequiredMarker((AnnotatedMember) null);
}","/**
 * Method that can be called to check whether this member has
 * an annotation that suggests whether value for matching property
 * is required or not.
 *
 * @since 2.0
 */"
"public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);
}","public void test1818() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationIntrospector annotationIntrospector1 = AnnotationIntrospector.pair(annotationIntrospector0, annotationIntrospector0);
    objectMapper0.setAnnotationIntrospectors(annotationIntrospector1, annotationIntrospector1);
    Class<Annotation> class0 = Annotation.class;
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {
    return objectIdInfo;
}","public void test2020() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JacksonAnnotationIntrospector jacksonAnnotationIntrospector0 = (JacksonAnnotationIntrospector) ObjectMapper.DEFAULT_ANNOTATION_INTROSPECTOR;
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.isTypeId((AnnotatedMember) null);
    PropertyName propertyName0 = PropertyName.NO_NAME;
    Class<Integer> class0 = Integer.class;
    Class<ObjectIdGenerators.IntSequenceGenerator> class1 = ObjectIdGenerators.IntSequenceGenerator.class;
    Class<SimpleObjectIdResolver> class2 = SimpleObjectIdResolver.class;
    ObjectIdInfo objectIdInfo0 = new ObjectIdInfo(propertyName0, class0, class1, class2);
    annotationIntrospector0.findObjectReferenceInfo((Annotated) null, objectIdInfo0);
}","/**
 * Method for figuring out additional properties of an Object Identity reference
 *
 * @since 2.1
 */"
"/*
    /**********************************************************
    /* Serialization: property annotations
    /**********************************************************
     */
/**
 * Method for checking whether given property accessors (method,
 * field) has an annotation that suggests property name to use
 * for serialization.
 * Should return null if no annotation
 * is found; otherwise a non-null name (possibly
 * {@link PropertyName#USE_DEFAULT}, which means ""use default heuristics"").
 *
 * @param a Property accessor to check
 *
 * @return Name to use if found; null if not.
 *
 * @since 2.1
 */
public PropertyName findNameForSerialization(Annotated a) {
    /*
        if (name != null) {
            if (name.length() == 0) { // empty String means 'default'
                return PropertyName.USE_DEFAULT;
            }
            return new PropertyName(name);
        }
        */
    return null;
}","public void test2121() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.version();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    AnnotationIntrospector.ReferenceProperty annotationIntrospector_ReferenceProperty0 = AnnotationIntrospector.ReferenceProperty.managed("""");
    jsonLocationInstantiator0.getDefaultCreator();
    annotationIntrospector0.findPropertyInclusion((Annotated) null);
    annotationIntrospector_ReferenceProperty0.getName();
    annotationIntrospector0.findDeserializer((Annotated) null);
    annotationIntrospector0.findNameForSerialization((Annotated) null);
}",""
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test2222() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[2];
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    mapperFeatureArray0[0] = mapperFeature0;
    MapperFeature mapperFeature1 = MapperFeature.AUTO_DETECT_SETTERS;
    mapperFeatureArray0[1] = mapperFeature1;
    objectMapper0.disable(mapperFeatureArray0);
    Class<BeanPropertyWriter> class0 = BeanPropertyWriter.class;
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
    AnnotationIntrospector.nopInstance();
}",""
"public JsonInclude.Value findPropertyInclusion(Annotated a) {
    return JsonInclude.Value.empty();
}","public void test2323() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findPropertyInclusion((Annotated) null);
}","/**
 * Method for checking inclusion criteria for a type (Class) or property (yes, method
 * name is bit unfortunate -- not just for properties!).
 * In case of class, acts as the default for properties POJO contains; for properties
 * acts as override for class defaults and possible global defaults.
 *
 * @since 2.6
 */"
"public List<NamedType> findSubtypes(Annotated a) {
    return null;
}","public void test2424() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findSubtypes((Annotated) null);
}","/**
 * Method for locating annotation-specified subtypes related to annotated
 * entity (class, method, field). Note that this is only guaranteed to be
 * a list of directly
 * declared subtypes, no recursive processing is guarantees (i.e. caller
 * has to do it if/as necessary)
 *
 * @param a Annotated entity (class, field/method) to check for annotations
 */"
"/*
    /**********************************************************
    /* Meta-annotations (annotations for annotation types)
    /**********************************************************
     */
/**
 * Method for checking whether given annotation is considered an
 * annotation bundle: if so, all meta-annotations it has will
 * be used instead of annotation (""bundle"") itself.
 *
 * @since 2.0
 */
public boolean isAnnotationBundle(Annotation ann) {
    return false;
}","public void test2525() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    AnnotationMap annotationMap0 = new AnnotationMap();
    Class<Annotation> class0 = Annotation.class;
    annotationMap0.get(class0);
    annotationIntrospector0.isAnnotationBundle((Annotation) null);
}",""
"/*
    /**********************************************************
    /* Serialization: general annotations
    /**********************************************************
     */
/**
 * Method for getting a serializer definition on specified method
 * or field. Type of definition is either instance (of type
 * {@link JsonSerializer}) or Class (of type
 * <code>Class&lt;JsonSerializer></code>); if value of different
 * type is returned, a runtime exception may be thrown by caller.
 */
public Object findSerializer(Annotated am) {
    return null;
}","public void test2626() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    Object object0 = new Object();
    annotationIntrospector0.findSerializer((Annotated) null);
}",""
"public Object findFilterId(Annotated ann) {
    return null;
}","public void test2727() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findPropertyIndex((Annotated) null);
    annotationIntrospector0.findFilterId((Annotated) null);
}","/**
 * Method for finding if annotated class has associated filter; and if so,
 * to return id that is used to locate filter.
 *
 * @return Id of the filter to use for filtering properties of annotated
 *    class, if any; or null if none found.
 */"
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test2828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BeanPropertyWriter> class0 = BeanPropertyWriter.class;
    objectMapper0.readerFor(class0);
    AnnotationIntrospector.nopInstance();
}",""
"public Object findKeySerializer(Annotated am) {
    return null;
}","public void test2929() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findKeySerializer((Annotated) null);
}","/**
 * Method for getting a serializer definition for keys of associated <code>Map</code> property.
 * Type of definition is either instance (of type
 * {@link JsonSerializer}) or Class (of type
 * <code>Class&lt;JsonSerializer></code>); if value of different
 * type is returned, a runtime exception may be thrown by caller.
 */"
"public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) {
    return null;
}","public void test3333() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.findUnwrappingNameTransformer((AnnotatedMember) null);
}","/**
 * Method called to check whether given property is marked to be ""unwrapped""
 * when being serialized (and appropriately handled in reverse direction,
 * i.e. expect unwrapped representation during deserialization).
 * Return value is the name transformation to use, if wrapping/unwrapping
 * should  be done, or null if not -- note that transformation may simply
 * be identity transformation (no changes).
 */"
"// since 2.7
@Deprecated
public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {
    return defValue;
}","public void test3434() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    annotationIntrospector0.hasRequiredMarker((AnnotatedMember) null);
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.ALWAYS;
    annotationIntrospector0.findSerializationInclusion((Annotated) null, jsonInclude_Include0);
}","/**
 *  Method for checking whether given annotated entity (class, method,
 *  field) defines which Bean/Map properties are to be included in
 *  serialization.
 *  If no annotation is found, method should return given second
 *  argument; otherwise value indicated by the annotation.
 * <p>
 *  Note that meaning of inclusion value depends on whether it is for
 *  a Class or property (field/method/constructor): in former case,
 *  it is the default for all properties; in latter case it is specific
 *  override for annotated property.
 *
 *  @return Enumerated value indicating which properties to include
 *    in serialization
 *
 *  @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
 */"
"public String findPropertyDescription(Annotated ann) {
    return null;
}","public void test3535() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.NON_ABSENT;
    annotationIntrospector0.findPropertyDescription((Annotated) null);
}","/**
 * Method used to check whether specified property member (accessor
 * or mutator) defines human-readable description to use for documentation.
 * There are no further definitions for contents; for example, whether
 * these may be marked up using HTML is not defined.
 *
 * @return Human-readable description, if any.
 *
 * @since 2.3
 */"
"public Class<?>[] findViews(Annotated a) {
    return null;
}","public void test3737() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findViews((Annotated) null);
}","/**
 * Method for checking if annotated property (represented by a field or
 * getter/setter method) has definitions for views it is to be included in.
 * If null is returned, no view definitions exist and property is always
 * included (or always excluded as per default view inclusion configuration);
 * otherwise it will only be included for views included in returned
 * array. View matches are checked using class inheritance rules (sub-classes
 * inherit inclusions of super-classes)
 *
 * @param a Annotated property (represented by a method, field or ctor parameter)
 * @return Array of views (represented by classes) that the property is included in;
 *    if null, always included (same as returning array containing <code>Object.class</code>)
 */"
"public Class<?>[] findViews(Annotated a) {
    return null;
}","public void test3838() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findFormat((Annotated) null);
    annotationIntrospector0.findImplicitPropertyName((AnnotatedMember) null);
    annotationIntrospector0.findViews((Annotated) null);
}","/**
 * Method for checking if annotated property (represented by a field or
 * getter/setter method) has definitions for views it is to be included in.
 * If null is returned, no view definitions exist and property is always
 * included (or always excluded as per default view inclusion configuration);
 * otherwise it will only be included for views included in returned
 * array. View matches are checked using class inheritance rules (sub-classes
 * inherit inclusions of super-classes)
 *
 * @param a Annotated property (represented by a method, field or ctor parameter)
 * @return Array of views (represented by classes) that the property is included in;
 *    if null, always included (same as returning array containing <code>Object.class</code>)
 */"
"public JsonFormat.Value findFormat(Annotated memberOrClass) {
    return null;
}","public void test3939() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findFormat((Annotated) null);
}","/**
 * Method for finding format annotations for property or class.
 * Return value is typically used by serializers and/or
 * deserializers to customize presentation aspects of the
 * serialized value.
 *
 * @since 2.1
 */"
"/*
    /**********************************************************
    /* Serialization: class annotations
    /**********************************************************
     */
/**
 * Method for accessing defined property serialization order (which may be
 * partial). May return null if no ordering is defined.
 */
public String[] findSerializationPropertyOrder(AnnotatedClass ac) {
    return null;
}","public void test4040() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findSerializationPropertyOrder((AnnotatedClass) null);
}",""
"public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {
    return null;
}","public void test4141() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findPOJOBuilderConfig((AnnotatedClass) null);
}","/**
 * @since 2.0
 */"
"public Object findNullSerializer(Annotated am) {
    return null;
}","public void test4242() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findNullSerializer((Annotated) null);
}","/**
 * Method for getting a serializer definition for serializer to use
 * for nulls (null values) of associated property or type.
 *
 * @since 2.3
 */"
"public Object findSerializationConverter(Annotated a) {
    return null;
}","public void test4343() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.findSerializationConverter((Annotated) null);
}","/**
 *  Method for finding {@link Converter} that annotated entity
 *  (property or class) has indicated to be used as part of
 *  serialization. If not null, either has to be actual
 *  {@link Converter} instance, or class for such converter;
 *  and resulting converter will be used first to convert property
 *  value to converter target type, and then serializer for that
 *  type is used for actual serialization.
 * <p>
 *  This feature is typically used to convert internal values into types
 *  that Jackson can convert.
 * <p>
 *  Note also that this feature does not necessarily work well with polymorphic
 *  type handling, or object identity handling; if such features are needed
 *  an explicit serializer is usually better way to handle serialization.
 *
 *  @param a Annotated property (field, method) or class to check for
 *    annotations
 *
 *  @since 2.2
 */"
"public Object findDeserializationContentConverter(AnnotatedMember a) {
    return null;
}","public void test4545() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.getConfig();
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, class0);
    stdValueInstantiator0.getDelegateCreator();
    annotationIntrospector0.findDeserializationContentConverter((AnnotatedMember) null);
}","/**
 *  Method for finding {@link Converter} that annotated property
 *  has indicated needs to be used for values of container type
 *  (this also means that method should only be called for properties
 *  of container types, List/Map/array properties).
 * <p>
 *  If not null, either has to be actual
 *  {@link Converter} instance, or class for such converter;
 *  and resulting converter will be used after Jackson has deserializer
 *  data into intermediate type (Converter input type), and Converter
 *  needs to convert this into its target type to be set as property value.
 * <p>
 *  Other notes are same as those for {@link #findDeserializationConverter}
 *
 *  @param a Annotated property (field, method) to check.
 *
 *  @since 2.2
 */"
"@Deprecated
public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
    return null;
}","public void test4646() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getDefaultCreator();
    annotationIntrospector0.findDeserializationType((Annotated) null, (JavaType) null);
}","/**
 * Method for accessing annotated type definition that a
 * property can have, to be used as the type for deserialization
 * instead of the static (declared) type.
 * Type is usually narrowing conversion (i.e.subtype of declared type).
 * Declared return type of the method is also considered acceptable.
 *
 * @param baseType Assumed type before considering annotations
 *
 * @return Class to use for deserialization instead of declared type
 *
 * @deprecated Since 2.7 call {@link #refineDeserializationType} instead
 */"
"/*
    /**********************************************************
    /* Deserialization: class annotations
    /**********************************************************
     */
/**
 * Method getting {@link ValueInstantiator} to use for given
 * type (class): return value can either be an instance of
 * instantiator, or class of instantiator to create.
 */
public Object findValueInstantiator(AnnotatedClass ac) {
    return null;
}","public void test4747() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forSerialization(pOJOPropertiesCollector0);
    BeanSerializerBuilder beanSerializerBuilder0 = new BeanSerializerBuilder(basicBeanDescription0);
    beanSerializerBuilder0.getClassInfo();
    annotationIntrospector0.findRootName((AnnotatedClass) null);
    annotationIntrospector0.findValueInstantiator((AnnotatedClass) null);
}",""
"public Object findContentDeserializer(Annotated am) {
    return null;
}","public void test4848() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findContentDeserializer((Annotated) null);
}","/**
 * Method for getting a deserializer definition for content (values) of
 * associated <code>Collection</code>, <code>array</code> or
 * <code>Map</code> property.
 * Type of definition is either instance (of type
 * {@link JsonDeserializer}) or Class (of type
 * <code>Class&lt;JsonDeserializer></code>); if value of different
 * type is returned, a runtime exception may be thrown by caller.
 */"
"public JsonProperty.Access findPropertyAccess(Annotated ann) {
    return null;
}","public void test4949() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.findPropertyAccess((Annotated) null);
}","/**
 * Method for finding optional access definition for a property, annotated
 * on one of its accessors. If a definition for read-only, write-only
 * or read-write cases, visibility rules may be modified. Note, however,
 * that even more specific annotations (like one for ignoring specific accessor)
 * may further override behavior of the access definition.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Deserialization: property annotations
    /**********************************************************
     */
/**
 * Method for checking whether given property accessors (method,
 * field) has an annotation that suggests property name to use
 * for deserialization (reading JSON into POJOs).
 * Should return null if no annotation
 * is found; otherwise a non-null name (possibly
 * {@link PropertyName#USE_DEFAULT}, which means ""use default heuristics"").
 *
 * @param a Property accessor to check
 *
 * @return Name to use if found; null if not.
 *
 * @since 2.1
 */
public PropertyName findNameForDeserialization(Annotated a) {
    /*
        if (name != null) {
            if (name.length() == 0) { // empty String means 'default'
                return PropertyName.USE_DEFAULT;
            }
            return new PropertyName(name);
        }
        */
    return null;
}","public void test5050() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.findNameForDeserialization((Annotated) null);
}",""
"public Object findContentSerializer(Annotated am) {
    return null;
}","public void test5151() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findContentSerializer((Annotated) null);
}","/**
 * Method for getting a serializer definition for content (values) of
 * associated <code>Collection</code>, <code>array</code> or <code>Map</code> property.
 * Type of definition is either instance (of type
 * {@link JsonSerializer}) or Class (of type
 * <code>Class&lt;JsonSerializer></code>); if value of different
 * type is returned, a runtime exception may be thrown by caller.
 */"
"public Object findSerializationContentConverter(AnnotatedMember a) {
    return null;
}","public void test5252() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.version();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    annotationIntrospector0.findSerializationContentConverter((AnnotatedMember) null);
}","/**
 *  Method for finding {@link Converter} that annotated property
 *  has indicated needs to be used for values of container type
 *  (this also means that method should only be called for properties
 *  of container types, List/Map/array properties).
 * <p>
 *  If not null, either has to be actual
 *  {@link Converter} instance, or class for such converter;
 *  and resulting converter will be used first to convert property
 *  value to converter target type, and then serializer for that
 *  type is used for actual serialization.
 * <p>
 *  Other notes are same as those for {@link #findSerializationConverter}
 *
 *  @param a Annotated property (field, method) to check.
 *
 *  @since 2.2
 */"
"public Class<?> findPOJOBuilder(AnnotatedClass ac) {
    return null;
}","public void test5353() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findPOJOBuilder((AnnotatedClass) null);
}","/**
 *  Method for finding Builder object to use for constructing
 *  value instance and binding data (sort of combining value
 *  instantiators that can construct, and deserializers
 *  that can bind data).
 * <p>
 *  Note that unlike accessors for some helper Objects, this
 *  method does not allow returning instances: the reason is
 *  that builders have state, and a separate instance needs
 *  to be created for each deserialization call.
 *
 *  @since 2.0
 */"
"public Object findNamingStrategy(AnnotatedClass ac) {
    return null;
}","public void test5454() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findClassDescription((AnnotatedClass) null);
    annotationIntrospector0.findNamingStrategy((AnnotatedClass) null);
}","/**
 * Method for finding {@link PropertyNamingStrategy} for given
 * class, if any specified by annotations; and if so, either return
 * a {@link PropertyNamingStrategy} instance, or Class to use for
 * creating instance
 *
 * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one
 *   is specified for given class; null if not.
 *
 * @since 2.1
 */"
"public String findPropertyDefaultValue(Annotated ann) {
    return null;
}","public void test5555() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationIntrospector.ReferenceProperty.Type.values();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, (SubtypeResolver) null, simpleMixInResolver0, rootNameLookup0);
    Class<AnnotationIntrospector> class0 = AnnotationIntrospector.class;
    StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator(deserializationConfig0, class0);
    stdValueInstantiator0.getDelegateCreator();
    annotationIntrospector0.findPropertyDefaultValue((Annotated) null);
}","/**
 * Method for finding suggested default value (as simple textual serialization)
 * for the property. While core databind does not make any use of it, it is exposed
 * for extension modules to use: an expected use is generation of schema representations
 * and documentation.
 *
 * @since 2.5
 */"
"@Deprecated
public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
    return null;
}","public void test5656() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getDelegateCreator();
    annotationIntrospector0.findDeserializationKeyType((Annotated) null, (JavaType) null);
}","/**
 * Method for accessing additional narrowing type definition that a
 * method can have, to define more specific key type to use.
 * It should be only be used with {@link java.util.Map} types.
 *
 * @param baseKeyType Assumed key type before considering annotations
 *
 * @return Class specifying more specific type to use instead of
 *   declared type, if annotation found; null if not
 *
 * @deprecated Since 2.7 call {@link #refineDeserializationType} instead
 */"
"public Object findDeserializationConverter(Annotated a) {
    return null;
}","public void test5757() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getArrayDelegateCreator();
    annotationIntrospector0.findDeserializationConverter((Annotated) null);
}","/**
 *  Method for finding {@link Converter} that annotated entity
 *  (property or class) has indicated to be used as part of
 *  deserialization.
 *  If not null, either has to be actual
 *  {@link Converter} instance, or class for such converter;
 *  and resulting converter will be used after Jackson has deserializer
 *  data into intermediate type (Converter input type), and Converter
 *  needs to convert this into its target type to be set as property value.
 * <p>
 *  This feature is typically used to convert intermediate Jackson types
 *  (that default deserializers can produce) into custom type instances.
 * <p>
 *  Note also that this feature does not necessarily work well with polymorphic
 *  type handling, or object identity handling; if such features are needed
 *  an explicit deserializer is usually better way to handle deserialization.
 *
 *  @param a Annotated property (field, method) or class to check for
 *    annotations
 *
 *  @since 2.2
 */"
"public boolean hasAnySetterAnnotation(AnnotatedMethod am) {
    return false;
}","public void test5858() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.hasAnySetterAnnotation((AnnotatedMethod) null);
}","/**
 * Method for checking whether given method has an annotation
 * that suggests that the method is to serve as ""any setter"";
 * method to be used for setting values of any properties for
 * which no dedicated setter method is found.
 *
 * @return True if such annotation is found (and is not disabled),
 *   false otherwise
 */"
"// TODO: Deprecate in 2.8?
/**
 * Method for determining the String value to use for serializing
 * given enumeration entry; used when serializing enumerations
 * as Strings (the standard method).
 *
 * @return Serialized enum value.
 */
public String findEnumValue(Enum<?> value) {
    return value.name();
}","public void test5959() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findEnumValue((Enum<?>) null);
}",""
"/*
    /**********************************************************
    /* Default Versioned impl
    /**********************************************************
     */
@Override
public abstract Version version();","public void test6060() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    Collection<AnnotationIntrospector> collection0 = annotationIntrospector0.allIntrospectors();
    annotationIntrospector0.findKeySerializer((Annotated) null);
    annotationIntrospector0.findTypeName((AnnotatedClass) null);
    annotationIntrospector0.findDeserializer((Annotated) null);
    annotationIntrospector0.findPropertyInclusion((Annotated) null);
    annotationIntrospector0.allIntrospectors(collection0);
    // Undeclared exception!
    try {
        annotationIntrospector0.version();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.AbstractList"", e);
    }
}",""
"public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {
    for (int i = 0, len = enumValues.length; i < len; ++i) {
        /* 12-Mar-2016, tatu: This is quite tricky, considering that we should NOT
             *   overwrite values with default `name`... so for now, let's only delegate
             *   if no value has been set. Still not optimal but has to do
             */
        // TODO: In 2.8, stop delegation?
        if (names[i] == null) {
            names[i] = findEnumValue(enumValues[i]);
        }
    }
    return names;
}","public void test6161() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationIntrospector.ReferenceProperty.Type[] annotationIntrospector_ReferenceProperty_TypeArray0 = AnnotationIntrospector.ReferenceProperty.Type.values();
    String[] stringArray0 = new String[3];
    Class<BeanPropertyWriter> class0 = BeanPropertyWriter.class;
    annotationIntrospector0.findEnumValues(class0, annotationIntrospector_ReferenceProperty_TypeArray0, stringArray0);
}","/**
 *  Method for efficiently figuring out which if given set of <code>Enum</code> values
 *  have explicitly defined name. Method will overwrite entries in incoming <code>names</code>
 *  array with explicit names found, if any, leaving other entries unmodified.
 * <p>
 *  Default implementation will simply delegate to {@link #findEnumValue}, which is close
 *  enough, although unfortunately NOT 100% equivalent (as it will also consider <code>name()</code>
 *  to give explicit value).
 *
 *  @since 2.7
 */"
"public Boolean isIgnorableType(AnnotatedClass ac) {
    return null;
}","public void test6363() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.isIgnorableType((AnnotatedClass) null);
}","/**
 * Method for checking whether properties that have specified type
 * (class, not generics aware) should be completely ignored for
 * serialization and deserialization purposes.
 *
 * @param ac Type to check
 *
 * @return Boolean.TRUE if properties of type should be ignored;
 *   Boolean.FALSE if they are not to be ignored, null for default
 *   handling (which is 'do not ignore')
 */"
"public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {
    return null;
}","public void test6464() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    annotationIntrospector0.findIgnoreUnknownProperties((AnnotatedClass) null);
}","/**
 * Method for checking whether an annotation indicates that all unknown properties
 */"
"// since 2.7
@Deprecated
public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
    return null;
}","public void test6565() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    jsonLocationInstantiator0.getWithArgsCreator();
    annotationIntrospector0.findSerializationKeyType((Annotated) null, (JavaType) null);
}","/**
 * Method for finding possible widening type definition that a property
 * value can have, to define less specific key type to use for serialization.
 * It should be only be used with {@link java.util.Map} types.
 *
 * @return Class specifying more general type to use instead of
 *   declared type, if annotation found; null if not
 *
 * @deprecated Since 2.7 call {@link #refineSerializationType} instead
 */"
"public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);
}","public void test6767() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    Class<Annotation> class0 = Annotation.class;
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test6868() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BeanPropertyWriter> class0 = BeanPropertyWriter.class;
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
    AnnotationIntrospector.nopInstance();
}",""
"public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config, AnnotatedMethod setter1, AnnotatedMethod setter2) {
    return null;
}","public void test6969() throws Throwable {
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationIntrospector.ReferenceProperty.Type.values();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, (SubtypeResolver) null, simpleMixInResolver0, rootNameLookup0);
    System.setCurrentTimeMillis(0L);
    annotationIntrospector0.resolveSetterConflict(deserializationConfig0, (AnnotatedMethod) null, (AnnotatedMethod) null);
}","/**
 * Method called in cases where a class has two methods eligible to be used
 * for the same logical property, and default logic is not enough to figure
 * out clear precedence. Introspector may try to choose one to use; or, if
 * unable, return `null` to indicate it can not resolve the problem.
 *
 * @since 2.7
 */"
"/*
    /**********************************************************
    /* Factory methods
    /**********************************************************
     */
/**
 * Factory method for accessing ""no operation"" implementation
 * of introspector: instance that will never find any annotation-based
 * configuration.
 */
public static AnnotationIntrospector nopInstance() {
    return NopAnnotationIntrospector.instance;
}","public void test7070() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    MapLikeType mapLikeType0 = MapLikeType.upgradeFrom(javaType0, javaType0, javaType0);
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    objectMapper0.acceptJsonFormatVisitor((JavaType) mapLikeType0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
    AnnotationIntrospector.nopInstance();
}",""
