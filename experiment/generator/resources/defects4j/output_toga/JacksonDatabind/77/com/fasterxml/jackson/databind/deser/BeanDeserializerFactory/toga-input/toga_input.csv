focal_method,test_prefix,docstring
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    SQLDataException sQLDataException0 = new SQLDataException();
    IOContext iOContext0 = new IOContext(bufferRecycler0, sQLDataException0, true);
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ByteQuadsCanonicalizer byteQuadsCanonicalizer0 = ByteQuadsCanonicalizer.createRoot();
    UTF8StreamJsonParser uTF8StreamJsonParser0 = new UTF8StreamJsonParser(iOContext0, 2, pipedInputStream0, objectMapper0, byteQuadsCanonicalizer0, (byte[]) null, 496, 3, true);
    UnresolvedForwardReference unresolvedForwardReference0 = new UnresolvedForwardReference(uTF8StreamJsonParser0, ""b|; \""x>H@4PX_s"");
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(unresolvedForwardReference0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"@Override
public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {
    // First: need a BeanDescription for builder class
    JavaType builderType = ctxt.constructType(builderClass);
    BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);
    return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);
}","public void test011() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<FloatNode> class0 = FloatNode.class;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.instance.createBuilderBasedDeserializer(defaultDeserializationContext_Impl0, (JavaType) null, (BeanDescription) null, class0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"@Override
public DeserializerFactory withConfig(DeserializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional deserializers, or losing deserializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    if (getClass() != BeanDeserializerFactory.class) {
        throw new IllegalStateException(""Subtype of BeanDeserializerFactory ("" + getClass().getName() + "") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with "" + ""additional deserializer definitions"");
    }
    return new BeanDeserializerFactory(config);
}","public void test022() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory((DeserializerFactoryConfig) null);
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withConfig((DeserializerFactoryConfig) null);
    assertSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Method used by module registration functionality, to construct a new bean
 * deserializer factory
 * with different configuration settings.
 */"
"public boolean isCachable() {
    return false;
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<String> class0 = String.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(resolvedRecursiveType0, resolvedRecursiveType0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    JsonDeserializer<AsExternalTypeDeserializer> jsonDeserializer0 = (JsonDeserializer<AsExternalTypeDeserializer>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(jsonDeserializer0).toString();
    BeanDeserializerModifier beanDeserializerModifier0 = mock(BeanDeserializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn(jsonDeserializer0).when(beanDeserializerModifier0).modifyDeserializer(any(com.fasterxml.jackson.databind.DeserializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonDeserializer.class));
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withDeserializerModifier(beanDeserializerModifier0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    JsonDeserializer<?> jsonDeserializer1 = beanDeserializerFactory1.findStdDeserializer(defaultDeserializationContext_Impl0, referenceType0, (BeanDescription) null);
    assertFalse(jsonDeserializer1.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    // May have multiple resolvers, call in precedence order until one returns non-null
    for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {
        JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);
        if (concrete != null) {
            return concrete;
        }
    }
    return null;
}","public void test044() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    JavaType javaType0 = beanDeserializerFactory1.materializeAbstractType(defaultDeserializationContext_Impl0, (JavaType) null, (BeanDescription) null);
    assertNull(javaType0);
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test055() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    BeanDeserializerModifier beanDeserializerModifier0 = mock(BeanDeserializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((List) null).when(beanDeserializerModifier0).updateProperties(any(com.fasterxml.jackson.databind.DeserializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), anyList());
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withDeserializerModifier(beanDeserializerModifier0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(deserializerFactory0);
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    // Undeclared exception!
    try {
        objectMapper0.readerForUpdating(defaultSerializerProvider_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test066() throws Throwable {
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(pOJOPropertiesCollector0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test077() throws Throwable {
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[8];
    MapperFeature mapperFeature0 = MapperFeature.USE_GETTERS_AS_SETTERS;
    mapperFeatureArray0[0] = mapperFeature0;
    mapperFeatureArray0[1] = mapperFeature0;
    mapperFeatureArray0[2] = mapperFeature0;
    MapperFeature mapperFeature1 = MapperFeature.DEFAULT_VIEW_INCLUSION;
    mapperFeatureArray0[3] = mapperFeature1;
    mapperFeatureArray0[4] = mapperFeature0;
    mapperFeatureArray0[5] = mapperFeatureArray0[2];
    mapperFeatureArray0[6] = mapperFeature1;
    mapperFeatureArray0[7] = mapperFeatureArray0[4];
    objectMapper0.disable(mapperFeatureArray0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(pOJOPropertiesCollector0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {
    Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();
    if (raw != null) {
        boolean fixAccess = ctxt.canOverrideAccessModifiers();
        boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
        for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {
            AnnotatedMember m = entry.getValue();
            if (fixAccess) {
                // to ensure we can call it
                m.fixAccess(forceAccess);
            }
            builder.addInjectable(PropertyName.construct(m.getName()), m.getType(), beanDesc.getClassAnnotations(), m, entry.getKey());
        }
    }
}","public void test099() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    HashMap<Object, AnnotatedMember> hashMap0 = new HashMap<Object, AnnotatedMember>();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn(hashMap0).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    hashMap0.put(defaultDeserializationContext_Impl0, (AnnotatedMember) null);
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl1 = new DefaultDeserializationContext.Impl(defaultDeserializationContext_Impl0, deserializationConfig0, jsonParser0, injectableValues_Std0);
    BeanDeserializerBuilder beanDeserializerBuilder0 = new BeanDeserializerBuilder(basicBeanDescription0, deserializationConfig0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.addInjectables(defaultDeserializationContext_Impl1, basicBeanDescription0, beanDeserializerBuilder0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}","/**
 * Method called locate all members used for value injection (if any),
 * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.
 */"
"protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException {
    if (ctxt.canOverrideAccessModifiers()) {
        // to ensure we can call it
        setter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
    }
    // we know it's a 2-arg method, second arg is the value
    JavaType type = setter.getParameterType(1);
    BeanProperty.Std property = new BeanProperty.Std(PropertyName.construct(setter.getName()), type, null, beanDesc.getClassAnnotations(), setter, PropertyMetadata.STD_OPTIONAL);
    type = resolveType(ctxt, beanDesc, type, setter);
    /* AnySetter can be annotated with @JsonDeserialize (etc) just like a
         * regular setter... so let's see if those are used.
         * Returns null if no annotations, in which case binding will
         * be done at a later point.
         */
    JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter);
    /* Otherwise, method may specify more specific (sub-)class for
         * value (no need to check if explicit deser was specified):
         */
    type = modifyTypeByAnnotation(ctxt, setter, type);
    if (deser == null) {
        deser = type.getValueHandler();
    }
    TypeDeserializer typeDeser = type.getTypeHandler();
    return new SettableAnyProperty(property, setter, type, deser, typeDeser);
}","public void test1010() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    LinkedHashMap<String, Object> linkedHashMap0 = new LinkedHashMap<String, Object>();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std(linkedHashMap0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl1 = new DefaultDeserializationContext.Impl(defaultDeserializationContext_Impl0, deserializationConfig0, jsonParser0, injectableValues_Std0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.constructAnySetter(defaultDeserializationContext_Impl1, basicBeanDescription0, (AnnotatedMethod) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}","/**
 * Method called to construct fallback {@link SettableAnyProperty}
 * for handling unknown bean properties, given a method that
 * has been designated as such setter.
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1111() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS;
    objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, (String) null);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(defaultSerializerProvider_Impl0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"/*
    /**********************************************************
    /* Helper methods for Bean deserializer, other
    /**********************************************************
     */
/**
 *  Helper method used to skip processing for types that we know
 *  can not be (i.e. are never consider to be) beans:
 *  things like primitives, Arrays, Enums, and proxy types.
 * <p>
 *  Note that usually we shouldn't really be getting these sort of
 *  types anyway; but better safe than sorry.
 */
protected boolean isPotentialBeanType(Class<?> type) {
    String typeStr = ClassUtil.canBeABeanType(type);
    if (typeStr != null) {
        throw new IllegalArgumentException(""Can not deserialize Class "" + type.getName() + "" (of type "" + typeStr + "") as a Bean"");
    }
    if (ClassUtil.isProxyType(type)) {
        throw new IllegalArgumentException(""Can not deserialize Proxy class "" + type.getName() + "" as a Bean"");
    }
    /* also: can't deserialize some local classes: static are ok; in-method not;
         * and with [JACKSON-594], other non-static inner classes are ok
         */
    typeStr = ClassUtil.isLocalType(type, true);
    if (typeStr != null) {
        throw new IllegalArgumentException(""Can not deserialize Class "" + type.getName() + "" (of type "" + typeStr + "") as a Bean"");
    }
    return true;
}","public void test1212() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<FormatStyle> class0 = FormatStyle.class;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.isPotentialBeanType(class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not deserialize Class java.time.format.FormatStyle (of type enum) as a Bean
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}",""
