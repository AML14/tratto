focal_method,test_prefix,docstring
"public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
    copyCurrentStructure(jp);
    return this;
}","public void test0000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, true, true);
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(tokenBuffer_Parser0, tokenBuffer_Parser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(deserializerFactory0);
    // Undeclared exception!
    try {
        tokenBuffer0.deserialize(jsonParserSequence0, defaultDeserializationContext_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Helper method used by standard deserializer.
 *
 * @since 2.3
 */"
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test0012() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, true);
    tokenBuffer0.firstToken();
    System.setCurrentTimeMillis(2183L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer_Segment0.findObjectId(8);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getText();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test0013() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, true);
    tokenBuffer0.firstToken();
    System.setCurrentTimeMillis(2183L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer_Segment0.findObjectId(8);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getText();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test0014() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, true);
    tokenBuffer0.firstToken();
    System.setCurrentTimeMillis(2183L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer_Segment0.findObjectId(8);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getText();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test0027() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer1.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test0028() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer2.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test0029() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertFalse(tokenBuffer2.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00210() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00211() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertTrue(tokenBuffer2.canWriteObjectId());
}",""
"@Override
public void writeRaw(char c) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test00312() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw('[');
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test00413() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    String string0 = ""q/>'Q3EaEv1MC=G"";
    jsonGenerator0.writeFieldName(""q/>'Q3EaEv1MC=G"");
    // Undeclared exception!
    tokenBuffer0.serialize(jsonGenerator0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00514() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00515() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00617() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00618() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    String string0 = tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test00619() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00720() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_COMMENTS;
    JsonParser jsonParser0 = tokenBuffer_Parser0.disable(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00721() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_COMMENTS;
    JsonParser jsonParser0 = tokenBuffer_Parser0.disable(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    String string0 = tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test00722() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_COMMENTS;
    JsonParser jsonParser0 = tokenBuffer_Parser0.disable(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test00723() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_COMMENTS;
    JsonParser jsonParser0 = tokenBuffer_Parser0.disable(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"@Override
public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test00824() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigInteger bigInteger0 = BigInteger.ONE;
    BigInteger bigInteger1 = BigInteger.ONE;
    int int0 = 5;
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue("""", 5, 5);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00925() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.isClosed();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    JsonParser jsonParser0 = tokenBuffer_Parser0.configure(jsonParser_Feature0, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParser0);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.QUOTE_FIELD_NAMES;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    tokenBuffer0.writeNumber((long) 16);
    tokenBuffer_Parser0.getParsingContext();
    assertEquals(75, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test01028() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    assertEquals(JsonToken.VALUE_STRING, tokenBuffer1.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01029() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test01030() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertFalse(tokenBuffer2.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01031() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer2.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test01032() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode intNode0 = IntNode.valueOf((-1810));
    tokenBuffer1.writeTypeId(intNode0);
    tokenBuffer1.serialize(tokenBuffer0);
    assertFalse(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01033() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode intNode0 = IntNode.valueOf((-1810));
    tokenBuffer1.writeTypeId(intNode0);
    tokenBuffer1.serialize(tokenBuffer0);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test01034() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode intNode0 = IntNode.valueOf((-1810));
    tokenBuffer1.writeTypeId(intNode0);
    tokenBuffer1.serialize(tokenBuffer0);
    assertEquals(JsonToken.VALUE_STRING, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01035() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode intNode0 = IntNode.valueOf((-1810));
    tokenBuffer1.writeTypeId(intNode0);
    tokenBuffer1.serialize(tokenBuffer0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01036() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode intNode0 = IntNode.valueOf((-1810));
    tokenBuffer1.writeTypeId(intNode0);
    tokenBuffer1.serialize(tokenBuffer0);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public void writeRaw(String text) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test01238() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    PipedWriter pipedWriter0 = new PipedWriter();
    PipedReader pipedReader0 = new PipedReader(pipedWriter0);
    jsonFactory0.createParser((Reader) pipedReader0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    ObjectMapper objectMapper1 = objectMapper0.configure(jsonParser_Feature0, false);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectReader objectReader0 = objectMapper1.reader(jsonNodeFactory0);
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader1);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw(""JSON"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test01442() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01443() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01444() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01445() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    tokenBuffer_Parser0.overrideCurrentName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test01446() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    tokenBuffer_Parser0.overrideCurrentName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    assertFalse(tokenBuffer1.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01447() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment0._nativeIds = treeMap0;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0._append(jsonToken0, (Object) null);
    tokenBuffer_Parser0.overrideCurrentName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01549() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(46, jsonToken0);
    Version version0 = Version.unknownVersion();
    SimpleModule simpleModule0 = new SimpleModule("", "", version0);
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer_Segment1.appendRaw(16, 16, (Object) simpleModule0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment2, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.getText();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01551() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(46, jsonToken0);
    Version version0 = Version.unknownVersion();
    SimpleModule simpleModule0 = new SimpleModule("", "", version0);
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer_Segment1.appendRaw(16, 16, (Object) simpleModule0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment2, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.getText();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01653() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigInteger bigInteger0 = BigInteger.ONE;
    BigInteger bigInteger1 = BigInteger.ONE;
    bigInteger1.add(bigInteger0);
    bigInteger0.modPow(bigInteger1, bigInteger1);
    Locale locale0 = new Locale(""yZ%S{"");
    HashMap<TemporalField, Long> hashMap0 = new HashMap<TemporalField, Long>();
    tokenBuffer0.writeEndObject();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01654() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigInteger bigInteger0 = BigInteger.ONE;
    BigInteger bigInteger1 = BigInteger.ONE;
    bigInteger1.add(bigInteger0);
    bigInteger0.modPow(bigInteger1, bigInteger1);
    Locale locale0 = new Locale(""yZ%S{"");
    HashMap<TemporalField, Long> hashMap0 = new HashMap<TemporalField, Long>();
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01856() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01860() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test01861() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    BigInteger bigInteger0 = BigInteger.ZERO;
    tokenBuffer2.writeTypeId(bigInteger0);
    tokenBuffer0.serialize(tokenBuffer1);
    tokenBuffer_Parser0.getCurrentLocation();
    assertFalse(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01862() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    BigInteger bigInteger0 = BigInteger.ZERO;
    tokenBuffer2.writeTypeId(bigInteger0);
    tokenBuffer0.serialize(tokenBuffer1);
    tokenBuffer_Parser0.getCurrentLocation();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test01963() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.close();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    TreeMap<String, JsonNode> treeMap0 = new TreeMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, treeMap0);
    ObjectNode objectNode1 = objectNode0.put(""[TokenBuffer: "", (-1672));
    LinkedList<String> linkedList0 = new LinkedList<String>();
    ObjectNode objectNode2 = objectNode1.without((Collection<String>) linkedList0);
    ArrayNode arrayNode0 = objectNode2.withArray(""[objectId="");
    NumericNode numericNode0 = arrayNode0.numberNode((short) 1069);
    tokenBuffer0.writeTree(numericNode0);
    tokenBuffer0.writeString((String) null);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue((String) null, 9, 41);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02064() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    tokenBuffer0.writeNumber((-91));
    tokenBuffer0.writeStartArray();
    assertEquals(JsonToken.START_ARRAY, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02065() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    tokenBuffer0.writeNumber((-91));
    tokenBuffer0.writeStartArray();
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer1.toString();
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02066() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    tokenBuffer0.writeNumber((-91));
    tokenBuffer0.writeStartArray();
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer1.toString();
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02168() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.close();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    tokenBuffer_Parser0.overrideCurrentName(""k"");
    tokenBuffer0.writeObjectId(tokenBuffer_Segment1);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02271() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.isClosed();
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    assertEquals(JsonToken.FIELD_NAME, jsonToken0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02272() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.isClosed();
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02273() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.isClosed();
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02376() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer1._appendRaw(16, (Object) null);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02377() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer1._appendRaw(16, (Object) null);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test02481() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: VALUE_NUMBER_INT]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02482() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    String string0 = tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02483() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02585() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    tokenBuffer0._hasNativeId = true;
    charArray0[4] = 'd';
    charArray0[5] = '`';
    tokenBuffer0.writeEndObject();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02586() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    tokenBuffer0._hasNativeId = true;
    charArray0[4] = 'd';
    charArray0[5] = '`';
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02788() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    tokenBuffer0._hasNativeId = true;
    tokenBuffer0.writeNumber(0.0F);
    charArray0[4] = 'd';
    charArray0[2] = '`';
    tokenBuffer0.writeEndObject();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02789() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    tokenBuffer0._hasNativeId = true;
    tokenBuffer0.writeNumber(0.0F);
    charArray0[4] = 'd';
    charArray0[2] = '`';
    tokenBuffer0.writeEndObject();
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02790() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    tokenBuffer0._hasNativeId = true;
    tokenBuffer0.writeNumber(0.0F);
    charArray0[4] = 'd';
    charArray0[2] = '`';
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02895() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    tokenBuffer0.serialize(jsonGenerator0);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test02996() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectCodec objectCodec0 = null;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.writeStartArray();
    // Undeclared exception!
    try {
        tokenBuffer0.serialize((JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test03097() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.appendRaw(13, 13, (Object) null);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    Integer integer0 = new Integer(16);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    tokenBuffer0.asParser((JsonParser) tokenBuffer_Parser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    // Undeclared exception!
    tokenBuffer1.append(tokenBuffer1);
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test03299() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    char[] charArray0 = new char[5];
    charArray0[0] = 'T';
    charArray0[1] = 'f';
    charArray0[2] = 'Z';
    PropertyNamingStrategy.PascalCaseStrategy propertyNamingStrategy_PascalCaseStrategy0 = (PropertyNamingStrategy.PascalCaseStrategy) PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE;
    ObjectMapper objectMapper1 = objectMapper0.setPropertyNamingStrategy(propertyNamingStrategy_PascalCaseStrategy0);
    charArray0[3] = '0';
    charArray0[4] = '<';
    JsonParser jsonParser0 = jsonFactory0.createParser(charArray0, 4, (-3324));
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    tokenBuffer0.writeNumber((long) 4);
    JsonGenerator.Feature jsonGenerator_Feature1 = JsonGenerator.Feature.QUOTE_FIELD_NAMES;
    tokenBuffer0.enable(jsonGenerator_Feature1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    tokenBuffer_Segment0.append((-3324), jsonToken0);
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test033101() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[0] = ':';
    charArray0[1] = '`';
    charArray0[2] = 'i';
    charArray0[3] = 'i';
    charArray0[4] = 'd';
    charArray0[5] = '/';
    charArray0[6] = 'm';
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue(charArray0, 0, (-408));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test034102() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    tokenBuffer_Parser0.isClosed();
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw(""3/iK4q(\\"", 16, (-5006));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test035103() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Short short0 = new Short((short) (-2163));
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(short0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_INTEGER_FOR_INTS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[8];
    deserializationFeatureArray0[0] = deserializationFeature0;
    deserializationFeatureArray0[1] = deserializationFeature0;
    deserializationFeatureArray0[2] = deserializationFeature0;
    deserializationFeatureArray0[3] = deserializationFeature0;
    deserializationFeatureArray0[4] = deserializationFeature0;
    deserializationFeatureArray0[5] = deserializationFeature0;
    deserializationFeatureArray0[6] = deserializationFeature0;
    deserializationFeatureArray0[7] = deserializationFeature0;
    ObjectReader objectReader1 = objectReader0.without(deserializationFeature0, deserializationFeatureArray0);
    JsonNode jsonNode0 = objectReader1.createObjectNode();
    objectReader1.treeAsTokens(jsonNode0);
    DeserializationFeature deserializationFeature1 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    ObjectReader objectReader2 = objectReader1.without(deserializationFeature1);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader2);
    tokenBuffer0.toString();
    tokenBuffer0.writeNumber(""[TokenBuffer: ]"");
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw(""[TokenBuffer: ]"", 2072, (int) (short) (-2163));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test036105() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Integer integer0 = new Integer(4438);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer0.writeStartArray();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(3, 1450, (Object) objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    tokenBuffer1._append(jsonToken0, tokenBuffer_Segment0);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test036106() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Integer integer0 = new Integer(4438);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer0.writeStartArray();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(3, 1450, (Object) objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    tokenBuffer1._append(jsonToken0, tokenBuffer_Segment0);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test038110() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    System.setCurrentTimeMillis(0L);
    int int0 = tokenBuffer_Parser0.getTextLength();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test038113() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    System.setCurrentTimeMillis(0L);
    int int0 = tokenBuffer_Parser0.getTextLength();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test039114() throws Throwable {
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test039115() throws Throwable {
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test040118() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    JsonToken jsonToken0 = JsonToken.VALUE_TRUE;
    tokenBuffer0._append(jsonToken0);
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 52;
    byteArray0[3] = (byte) (-14);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawUTF8String(byteArray0, (byte) 0, 0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test041119() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    assertFalse(tokenBuffer3.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test041120() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    assertEquals(79, tokenBuffer3.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test041121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    assertTrue(tokenBuffer3.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test041122() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test044125() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<Module> class0 = Module.class;
    ServiceLoader.loadInstalled(class0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_FINAL;
    objectMapper0.disableDefaultTyping();
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0);
    ObjectMapper objectMapper2 = objectMapper1.disableDefaultTyping();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper2);
    tokenBuffer0.canWriteBinaryNatively();
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-85);
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 107;
    byteArray0[3] = (byte) (-64);
    byteArray0[4] = (byte) 86;
    byteArray0[5] = (byte) (-29);
    byteArray0[6] = (byte) 125;
    byteArray0[7] = (byte) 119;
    // Undeclared exception!
    try {
        tokenBuffer0.writeUTF8String(byteArray0, (-3706), (-3706));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test047128() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer0.writeNumber(1.7195296F);
    byte[] byteArray0 = new byte[19];
    byteArray0[4] = (byte) (-91);
    byteArray0[7] = (byte) (-91);
    SerializationFeature serializationFeature0 = SerializationFeature.CLOSE_CLOSEABLE;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, false);
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectMapper objectMapper2 = objectMapper1.setNodeFactory(jsonNodeFactory0);
    ObjectReader objectReader0 = objectMapper2.reader((InjectableValues) injectableValues_Std0);
    objectReader0.withRootName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeObjectFieldStart("""");
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer1.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test047129() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer0.writeNumber(1.7195296F);
    byte[] byteArray0 = new byte[19];
    byteArray0[4] = (byte) (-91);
    byteArray0[7] = (byte) (-91);
    SerializationFeature serializationFeature0 = SerializationFeature.CLOSE_CLOSEABLE;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, false);
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectMapper objectMapper2 = objectMapper1.setNodeFactory(jsonNodeFactory0);
    ObjectReader objectReader0 = objectMapper2.reader((InjectableValues) injectableValues_Std0);
    objectReader0.withRootName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeObjectFieldStart("""");
    tokenBuffer0.writeEndArray();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test047130() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer0.writeNumber(1.7195296F);
    byte[] byteArray0 = new byte[19];
    byteArray0[4] = (byte) (-91);
    byteArray0[7] = (byte) (-91);
    SerializationFeature serializationFeature0 = SerializationFeature.CLOSE_CLOSEABLE;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, false);
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectMapper objectMapper2 = objectMapper1.setNodeFactory(jsonNodeFactory0);
    ObjectReader objectReader0 = objectMapper2.reader((InjectableValues) injectableValues_Std0);
    objectReader0.withRootName("""");
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeObjectFieldStart("""");
    tokenBuffer0.writeEndArray();
    assertFalse(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test050133() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    char[] charArray0 = new char[7];
    charArray0[1] = '`';
    charArray0[2] = 'i';
    charArray0[3] = 'i';
    tokenBuffer0._hasNativeId = true;
    charArray0[4] = 'd';
    charArray0[5] = '/';
    JsonToken jsonToken0 = JsonToken.END_OBJECT;
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.modPow(bigInteger0, bigInteger0);
    tokenBuffer0._append(jsonToken0, bigInteger0);
    tokenBuffer0.writeEndObject();
    tokenBuffer0.setFeatureMask((-3261));
    assertEquals((-3261), tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test052135() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    tokenBuffer_Segment1.next();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test052136() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    tokenBuffer_Segment1.next();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test053137() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumberField("""", bigDecimal0);
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.modPow(bigInteger0, bigInteger0);
    tokenBuffer0.writeEndObject();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test053138() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumberField("""", bigDecimal0);
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.modPow(bigInteger0, bigInteger0);
    tokenBuffer0.writeEndObject();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    SimpleModule simpleModule0 = new SimpleModule("""");
    BigInteger bigInteger1 = BigInteger.ZERO;
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    tokenBuffer1._append(jsonToken0, """");
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test053139() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumberField("""", bigDecimal0);
    BigInteger bigInteger0 = BigInteger.ONE;
    bigInteger0.modPow(bigInteger0, bigInteger0);
    tokenBuffer0.writeEndObject();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    SimpleModule simpleModule0 = new SimpleModule("""");
    BigInteger bigInteger1 = BigInteger.ZERO;
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    tokenBuffer1._append(jsonToken0, """");
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test054140() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextLength();
    Integer integer0 = new Integer(0);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(0, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""5O"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    mockPrintWriter0.append('Z');
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0._append(jsonToken0, bigDecimal0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    SerializedString serializedString0 = new SerializedString(""5O"");
    tokenBuffer1.writeTypeId(jsonFactory0);
    try {
        tokenBuffer2.serialize(tokenBuffer0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized value type for VALUE_NUMBER_FLOAT: java.lang.Integer, can not serialize
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test056146() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    tokenBuffer_Parser0.getCurrentName();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test056147() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    tokenBuffer_Parser0.getCurrentName();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test058150() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(tokenBuffer_Parser0, tokenBuffer_Parser0);
    ObjectCodec objectCodec0 = jsonParserSequence0.getCodec();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectCodec0, false);
    tokenBuffer0.firstToken();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test058152() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(tokenBuffer_Parser0, tokenBuffer_Parser0);
    ObjectCodec objectCodec0 = jsonParserSequence0.getCodec();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectCodec0, false);
    tokenBuffer0.firstToken();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test061159() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0);
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    JsonToken jsonToken1 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer0._append(jsonToken1, jsonToken0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test061160() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0);
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    JsonToken jsonToken1 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer0._append(jsonToken1, jsonToken0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode.valueOf(6);
    SerializedString serializedString1 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer2.writeTypeId(tokenBuffer_Segment1);
    tokenBuffer2.serialize(tokenBuffer1);
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test061161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(16, jsonToken0);
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    JsonToken jsonToken1 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer0._append(jsonToken1, jsonToken0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode.valueOf(6);
    SerializedString serializedString1 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer2.writeTypeId(tokenBuffer_Segment1);
    tokenBuffer2.serialize(tokenBuffer1);
    assertTrue(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test062163() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    String string0 = tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test062164() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test063168() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test063169() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test064171() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test064172() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertFalse(tokenBuffer2.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test064173() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test064174() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer2.getFeatureMask());
}",""
"@Override
public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test065176() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    BigInteger bigInteger0 = BigInteger.ZERO;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(1069, jsonToken0, (Object) bigInteger0, (Object) ""}q3o-!Bh,!o?O}"");
    short short0 = (short) 2308;
    Short short1 = new Short((short) 2308);
    tokenBuffer_Segment1.append(16, jsonToken0, (Object) short1);
    int int0 = 16;
    int int1 = 0;
    tokenBuffer_Segment0._tokenTypes = 891L;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.getEmbeddedObject();
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.writeEndObject();
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    char[] charArray0 = new char[1];
    charArray0[0] = 'I';
    // Undeclared exception!
    try {
        tokenBuffer1.writeRaw(charArray0, 16, 3241);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test066177() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField("")D(o^RTD&P,]i2Sp*$<"", 0.0F);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    JsonGenerator.Feature jsonGenerator_Feature1 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    boolean boolean1 = tokenBuffer0.isEnabled(jsonGenerator_Feature1);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test066178() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField("")D(o^RTD&P,]i2Sp*$<"", 0.0F);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    JsonGenerator.Feature jsonGenerator_Feature1 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    boolean boolean1 = tokenBuffer0.isEnabled(jsonGenerator_Feature1);
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"//public JsonGenerator configure(SerializationFeature f, boolean state) { }
@Override
public boolean isEnabled(Feature f) {
    return (_generatorFeatures & f.getMask()) != 0;
}","public void test066179() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField("")D(o^RTD&P,]i2Sp*$<"", 0.0F);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    JsonGenerator.Feature jsonGenerator_Feature1 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    boolean boolean1 = tokenBuffer0.isEnabled(jsonGenerator_Feature1);
    assertFalse(boolean1 == boolean0);
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test069185() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser1);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer1.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test069186() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser1);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(79, tokenBuffer2.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test069187() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser1);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertFalse(tokenBuffer2.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test070191() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    jsonGenerator0.writeFieldName(""q/>'Q3EaEv1MC=G"");
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.overrideCurrentName("""");
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test070192() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    jsonGenerator0.writeFieldName(""q/>'Q3EaEv1MC=G"");
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.overrideCurrentName("""");
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: FIELD_NAME(q/>'Q3EaEv1MC=G)]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test070193() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    jsonGenerator0.writeFieldName(""q/>'Q3EaEv1MC=G"");
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.overrideCurrentName("""");
    String string0 = tokenBuffer0.toString();
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* JsonGenerator implementation; pass-through copy
    /**********************************************************
     */
@Override
public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(jp.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(jp.getCurrentName());
            break;
        case VALUE_STRING:
            if (jp.hasTextCharacters()) {
                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());
            } else {
                writeString(jp.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch(jp.getNumberType()) {
                case INT:
                    writeNumber(jp.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(jp.getBigIntegerValue());
                    break;
                default:
                    writeNumber(jp.getLongValue());
            }
            break;
        case VALUE_NUMBER_FLOAT:
            switch(jp.getNumberType()) {
                case BIG_DECIMAL:
                    writeNumber(jp.getDecimalValue());
                    break;
                case FLOAT:
                    writeNumber(jp.getFloatValue());
                    break;
                default:
                    writeNumber(jp.getDoubleValue());
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(jp.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
    }
}","public void test071194() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeFieldName(""OM`A%4`q[[7g"");
    tokenBuffer0.writeNumberField(""OM`A%4`q[[7g"", (-1.0F));
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer1._first;
    Double double0 = new Double((-1.0F));
    tokenBuffer0.toString();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonFactory jsonFactory1 = jsonFactory0.copy();
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory1.createParser((Reader) pipedReader0);
    // Undeclared exception!
    try {
        tokenBuffer1.copyCurrentEvent(jsonParser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test073201() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    tokenBuffer0.writeNumberField("""", (-1.0F));
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ContextAttributes contextAttributes1 = contextAttributes0.withoutSharedAttribute(tokenBuffer_Parser0);
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes1);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectReader0, true, true);
    boolean boolean0 = tokenBuffer_Parser1.isClosed();
    int int0 = tokenBuffer0.getFeatureMask();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test073202() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    tokenBuffer0.writeNumberField("""", (-1.0F));
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ContextAttributes contextAttributes1 = contextAttributes0.withoutSharedAttribute(tokenBuffer_Parser0);
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes1);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectReader0, true, true);
    boolean boolean0 = tokenBuffer_Parser1.isClosed();
    int int0 = tokenBuffer0.getFeatureMask();
    assertEquals(79, int0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test073203() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeFieldName("""");
    tokenBuffer0.writeNumberField("""", (-1.0F));
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    Double double0 = new Double(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ContextAttributes contextAttributes1 = contextAttributes0.withoutSharedAttribute(tokenBuffer_Parser0);
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes1);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectReader0, true, true);
    boolean boolean0 = tokenBuffer_Parser1.isClosed();
    int int0 = tokenBuffer0.getFeatureMask();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test074205() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    jsonParser0.nextValue();
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer2.flush();
    assertFalse(tokenBuffer2.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test074206() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    jsonParser0.nextValue();
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer2.flush();
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test074207() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    jsonParser0.nextValue();
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer2.flush();
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer1.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test074208() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    int int0 = tokenBuffer_Segment0.rawType(0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    jsonParser0.nextValue();
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer2.flush();
    assertTrue(tokenBuffer2.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test075210() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertEquals(79, tokenBuffer1.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test075211() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertEquals(79, tokenBuffer3.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test075212() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertTrue(tokenBuffer3.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test075213() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertTrue(tokenBuffer3.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test075214() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertEquals(JsonToken.END_ARRAY, tokenBuffer3.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test075215() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test076216() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = new SerializedString(""[m;k!0"");
    tokenBuffer0.writeTypeId(""$gSY2u`^EyOdJ_X"");
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test076217() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = new SerializedString(""[m;k!0"");
    tokenBuffer0.writeTypeId(""$gSY2u`^EyOdJ_X"");
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test078219() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectCodec objectCodec0 = null;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer_Segment0.append(16, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.writeStartArray();
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer1.append(tokenBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {
    writeString(new String(text, offset, len));
}","public void test079220() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumberField("""", bigDecimal0);
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(809, jsonToken0);
    SerializedString serializedString0 = new SerializedString("""");
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer_Segment1.append(809, jsonToken0, (Object) tokenBuffer0, (Object) serializedString0);
    TokenBuffer.Segment tokenBuffer_Segment3 = tokenBuffer_Segment2.append(16, jsonToken0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment3, (ObjectCodec) null, false, false);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    JsonParser jsonParser0 = tokenBuffer_Parser0.enable(jsonParser_Feature0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParser0);
    tokenBuffer1.writeStartArray();
    tokenBuffer0.serialize(tokenBuffer1);
    tokenBuffer0.writeNumberField("""", (float) 809);
    tokenBuffer1.getFeatureMask();
    char[] charArray0 = new char[9];
    charArray0[0] = '2';
    charArray0[1] = 'g';
    charArray0[2] = 'l';
    charArray0[3] = '';
    charArray0[4] = 'Z';
    charArray0[5] = '\'';
    charArray0[6] = 'P';
    charArray0[7] = 'l';
    charArray0[8] = '=';
    // Undeclared exception!
    try {
        tokenBuffer0.writeString(charArray0, 7, (-552));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test080224() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.overrideCurrentName(""_;eg`7U<7@Sng~\""fH7"");
    assertEquals(79, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test080225() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    JsonLocation jsonLocation0 = tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.overrideCurrentName(""_;eg`7U<7@Sng~\""fH7"");
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test081226() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    // Undeclared exception!
    tokenBuffer2.append(tokenBuffer0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test083228() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    Integer integer0 = new Integer(16);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(16, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    String string0 = ""5O"";
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""5O"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    mockPrintWriter0.append('Z');
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0._append(jsonToken0, bigDecimal0);
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test084229() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    TokenBuffer tokenBuffer1 = (TokenBuffer) tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    String string0 = ""q/>'Q3EaEv1MC=G"";
    tokenBuffer1.writeFieldName(""q/>'Q3EaEv1MC=G"");
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer1);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test085230() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.writeStartArray();
    TokenBuffer tokenBuffer2 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer2.serialize(tokenBuffer1);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1._append(jsonToken0, serializedString0);
    // Undeclared exception!
    try {
        tokenBuffer0.append(tokenBuffer1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Internal error: entry should be a Number, but is of type com.fasterxml.jackson.core.io.SerializedString
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer$Parser"", e);
    }
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test086231() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    tokenBuffer0.writeNullField(""Called operation not supported for TokenBuffer"");
    tokenBuffer0.writeString((SerializableString) null);
    tokenBuffer0.version();
    tokenBuffer0.toString();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonFactory jsonFactory1 = new JsonFactory((ObjectCodec) null);
    PipedReader pipedReader0 = new PipedReader();
    JsonParser jsonParser0 = jsonFactory1.createParser((Reader) pipedReader0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer_Segment0.append((int) (short) 1, jsonToken0, (Object) bigDecimal0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1._append(jsonToken0, tokenBuffer0);
    tokenBuffer0.append(tokenBuffer0);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(jsonParser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeObjectId(Object id) {
    _objectId = id;
    _hasNativeId = true;
}","public void test087232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, false, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    tokenBuffer0.firstToken();
    tokenBuffer_Parser0.peekNextToken();
    Object object0 = tokenBuffer0._objectId;
    tokenBuffer0.writeObjectId((Object) null);
}",""
"@Override
public void writeObjectId(Object id) {
    _objectId = id;
    _hasNativeId = true;
}","public void test088233() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    TokenBuffer.Parser tokenBuffer_Parser1 = (TokenBuffer.Parser) tokenBuffer_Parser0.setFeatureMask((-2106));
    tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser1);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, serializedString0);
    tokenBuffer_Parser1.peekNextToken();
    tokenBuffer1.writeObjectId(jsonToken0);
}",""
"@Override
public final void writeEndArray() throws IOException, JsonGenerationException {
    _append(JsonToken.END_ARRAY);
    // Let's allow unbalanced tho... i.e. not run out of root level, ever
    JsonWriteContext c = _writeContext.getParent();
    if (c != null) {
        _writeContext = c;
    }
}","public void test090235() throws Throwable {
    FileSystemHandling.shouldAllThrowIOExceptions();
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, true);
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectReader objectReader0 = objectMapper1.reader((InjectableValues) injectableValues_Std0);
    ObjectReader objectReader1 = objectReader0.withRootName(""JSON"");
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader1);
    tokenBuffer0.writeEndArray();
}",""
"@Override
public void writeRawValue(String text) throws IOException, JsonGenerationException {
    _reportUnsupportedOperation();
}","public void test091236() throws Throwable {
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    Class<Integer> class0 = Integer.TYPE;
    IOContext iOContext0 = new IOContext(bufferRecycler0, class0, true);
    PipedWriter pipedWriter0 = new PipedWriter();
    PipedReader pipedReader0 = new PipedReader(pipedWriter0, 3);
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    char[] charArray0 = new char[4];
    charArray0[0] = 'g';
    charArray0[1] = '5';
    charArray0[2] = 'v';
    charArray0[3] = 'Z';
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 3, pipedReader0, objectMapper0, charsToNameCanonicalizer0, charArray0, 4, 4, true);
    JsonParserDelegate jsonParserDelegate0 = new JsonParserDelegate(readerBasedJsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserDelegate0);
    tokenBuffer0.useDefaultPrettyPrinter();
    tokenBuffer0.writeEndArray();
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue(""3XWmTVh)sW"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeBoolean(boolean state) throws IOException, JsonGenerationException {
    _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);
}","public void test092237() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.close();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    tokenBuffer_Segment1.next();
    tokenBuffer_Parser0.overrideCurrentName(""k"");
    tokenBuffer0.writeBoolean(false);
}",""
"@Override
public void writeObjectId(Object id) {
    _objectId = id;
    _hasNativeId = true;
}","public void test094239() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumberField("""", bigDecimal0);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(809, jsonToken0);
    SerializedString serializedString0 = new SerializedString("""");
    tokenBuffer_Segment1.append(809, jsonToken0, (Object) tokenBuffer0, (Object) serializedString0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    JsonParser jsonParser0 = tokenBuffer_Parser0.enable(jsonParser_Feature0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.firstToken();
    tokenBuffer_Parser0.peekNextToken();
    tokenBuffer_Parser0.getText();
    TokenBuffer tokenBuffer4 = new TokenBuffer(tokenBuffer_Parser0);
    Integer integer0 = new Integer(16);
    tokenBuffer4.writeObjectId(integer0);
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test095240() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    int int0 = new Integer((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    tokenBuffer_Segment0.append((-1764), jsonToken0);
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    JsonToken jsonToken1 = JsonToken.END_ARRAY;
    tokenBuffer0._append(jsonToken1, serializedString0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer1.append(tokenBuffer0);
    IntNode.valueOf((-2106));
    SerializedString serializedString1 = new SerializedString(""com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer"");
    tokenBuffer2.writeTypeId(serializedString1);
    tokenBuffer2.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test096241() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    tokenBuffer_Segment0.append(16, jsonToken0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.writeStartArray();
    tokenBuffer1.serialize((JsonGenerator) null);
    TokenBuffer tokenBuffer2 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    JsonToken jsonToken1 = JsonToken.END_ARRAY;
    tokenBuffer1._append(jsonToken1, """");
    TokenBuffer tokenBuffer3 = tokenBuffer1.append(tokenBuffer2);
    // Undeclared exception!
    tokenBuffer3.append(tokenBuffer1);
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test097242() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = new SerializedString(""Unrecognized value type for VALUE_NUMBER_FLOAT: "");
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    tokenBuffer0._append(jsonToken0, tokenBuffer1);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    IntNode.valueOf(16);
    tokenBuffer1.writeTypeId(""$gSY2u`^EyOdJ_X"");
    // Undeclared exception!
    try {
        tokenBuffer0.serialize(tokenBuffer2);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // com.fasterxml.jackson.databind.util.TokenBuffer cannot be cast to java.lang.Number
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test098243() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextLength();
    Integer integer0 = new Integer(0);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(0, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""5O"");
    tokenBuffer0.writeObjectField(""4f(=m)|<l<K\u0001}v"", (Object) null);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    mockPrintWriter0.append('Z');
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0._append(jsonToken0, bigDecimal0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    SerializedString serializedString0 = new SerializedString(""5O"");
    tokenBuffer1.writeTypeId(jsonFactory0);
    tokenBuffer2.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test099244() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Parser tokenBuffer_Parser0 = (TokenBuffer.Parser) tokenBuffer0.asParser((ObjectCodec) null);
    tokenBuffer0.writeNullField(""Called operation not supported for TokenBuffer"");
    tokenBuffer0.writeString((SerializableString) null);
    tokenBuffer0.version();
    tokenBuffer0.toString();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonFactory jsonFactory1 = jsonFactory0.copy();
    PipedReader pipedReader0 = new PipedReader();
    ReaderBasedJsonParser readerBasedJsonParser0 = (ReaderBasedJsonParser) jsonFactory1.createParser((Reader) pipedReader0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    tokenBuffer0._append(jsonToken0, (Object) null);
    TokenBuffer tokenBuffer2 = new TokenBuffer(readerBasedJsonParser0);
    tokenBuffer1.append(tokenBuffer0);
    tokenBuffer0.firstToken();
    tokenBuffer_Parser0.peekNextToken();
    SerializedString serializedString0 = new SerializedString(""Tc8m}D"");
    tokenBuffer1.writeTypeId((Object) null);
    tokenBuffer0.serialize(tokenBuffer1);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test101246() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextLength();
    Integer integer0 = new Integer(4438);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(0, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.append(tokenBuffer1);
    JsonToken jsonToken0 = JsonToken.FIELD_NAME;
    tokenBuffer0._append(jsonToken0, (Object) null);
    TokenBuffer tokenBuffer2 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer3 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer2.append(tokenBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test102247() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask(16);
    tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1._append(jsonToken0, tokenBuffer_Parser0);
    tokenBuffer0.append(tokenBuffer1);
    IntNode.valueOf(16);
    Byte byte0 = new Byte((byte) (-116));
    tokenBuffer0.writeTypeId(byte0);
    tokenBuffer0.serialize(tokenBuffer1);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test103248() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, false);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-3721));
    Integer integer0 = new Integer((-3721));
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParser0);
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    JsonToken jsonToken1 = JsonToken.START_OBJECT;
    tokenBuffer_Segment0.append((-3721), jsonToken1);
    SerializedString serializedString0 = new SerializedString("""");
    JsonToken jsonToken2 = JsonToken.VALUE_NUMBER_FLOAT;
    tokenBuffer1._append(jsonToken0, tokenBuffer_Segment0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer3 = tokenBuffer0.append(tokenBuffer2);
    JsonToken jsonToken3 = JsonToken.VALUE_FALSE;
    tokenBuffer1._append(jsonToken3, jsonToken1);
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper1 = objectMapper0.setSubtypeResolver(stdSubtypeResolver0);
    TokenBuffer tokenBuffer4 = new TokenBuffer(objectMapper1);
    TokenBuffer tokenBuffer5 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer6 = new TokenBuffer(objectMapper1);
    // Undeclared exception!
    try {
        tokenBuffer6.append(tokenBuffer3);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test104249() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer_Segment0.append(76, jsonToken0, (Object) tokenBuffer_Parser0, (Object) jsonToken0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer0.writeStartArray();
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer1._appendRaw(6, tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer2.serialize(tokenBuffer0);
    TokenBuffer tokenBuffer3 = new TokenBuffer((ObjectCodec) null);
    JsonToken jsonToken1 = JsonToken.VALUE_TRUE;
    tokenBuffer1._append(jsonToken1, tokenBuffer0);
    TokenBuffer tokenBuffer4 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer3.append(tokenBuffer1);
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test105250() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    tokenBuffer0.writeBoolean(true);
    tokenBuffer_Parser0.getText();
    TokenBuffer tokenBuffer2 = new TokenBuffer(objectMapper0);
    BigDecimal bigDecimal0 = new BigDecimal((double) (-1));
    tokenBuffer2.writeObjectId(bigDecimal0);
    tokenBuffer2.toString();
}",""
"@Override
public final void writeEndObject() throws IOException, JsonGenerationException {
    _append(JsonToken.END_OBJECT);
    // Let's allow unbalanced tho... i.e. not run out of root level, ever
    JsonWriteContext c = _writeContext.getParent();
    if (c != null) {
        _writeContext = c;
    }
}","public void test108253() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    TokenBuffer.Parser tokenBuffer_Parser0 = (TokenBuffer.Parser) tokenBuffer0.asParser((ObjectCodec) objectMapper0);
    tokenBuffer0.writeNullField(""Called operation not supported for TokenBuffer"");
    tokenBuffer0.version();
    tokenBuffer0.toString();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonFactory jsonFactory1 = jsonFactory0.copy();
    tokenBuffer0.writeStartArray();
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("", can not serialize"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, false);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    JsonFactory jsonFactory2 = jsonFactory1.disable(jsonGenerator_Feature0);
    JsonFactory.Feature jsonFactory_Feature0 = JsonFactory.Feature.INTERN_FIELD_NAMES;
    jsonFactory2.configure(jsonFactory_Feature0, false);
    StringWriter stringWriter0 = new StringWriter();
    WriterBasedJsonGenerator writerBasedJsonGenerator0 = (WriterBasedJsonGenerator) jsonFactory0.createGenerator((Writer) stringWriter0);
    tokenBuffer0.serialize(writerBasedJsonGenerator0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    JsonToken jsonToken0 = JsonToken.END_OBJECT;
    Short short0 = new Short((short) 1);
    tokenBuffer1._append(jsonToken0, short0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer3 = tokenBuffer0.append(tokenBuffer1);
    TokenBuffer tokenBuffer4 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer4.firstToken();
    JsonToken jsonToken1 = tokenBuffer_Parser0.peekNextToken();
    tokenBuffer1.writeObjectId(tokenBuffer4);
    tokenBuffer_Parser0.getTextLength();
    tokenBuffer3._append(jsonToken1);
    tokenBuffer0.writeEndObject();
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test109254() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, false, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    TokenBuffer tokenBuffer1 = (TokenBuffer) tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    tokenBuffer0.serialize(tokenBuffer1);
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    tokenBuffer0._append(jsonToken0, (Object) null);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer1);
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test110255() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectCodec objectCodec0 = null;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeStartArray();
    tokenBuffer0.writeStartArray();
    // Undeclared exception!
    tokenBuffer0.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test111256() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    IntNode intNode0 = new IntNode(16);
    tokenBuffer_Segment0.append(1, jsonToken0, (Object) intNode0, (Object) jsonToken0);
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, false, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.getCharacterEscapes();
    TokenBuffer tokenBuffer1 = (TokenBuffer) tokenBuffer0.setCharacterEscapes((CharacterEscapes) null);
    tokenBuffer0.append(tokenBuffer1);
    JsonToken jsonToken1 = JsonToken.VALUE_FALSE;
    tokenBuffer0._append(jsonToken1, (Object) null);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer1);
}",""
"@Override
public boolean isClosed() {
    return _closed;
}","public void test113258() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.close();
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    TreeMap<Integer, Object> treeMap0 = new TreeMap<Integer, Object>();
    tokenBuffer_Segment1._nativeIds = treeMap0;
    tokenBuffer_Parser0.overrideCurrentName(""k"");
    tokenBuffer0.writeObjectId(tokenBuffer_Segment1);
    tokenBuffer0.isClosed();
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test114259() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) 1);
    tokenBuffer0.asParser((ObjectCodec) null);
    tokenBuffer0.writeNullField(""Called operation not supported for TokenBuffer"");
    tokenBuffer0.writeString((SerializableString) null);
    tokenBuffer0.version();
    tokenBuffer0.toString();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonFactory jsonFactory1 = jsonFactory0.copy();
    tokenBuffer0.writeStartArray();
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""JSON"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, false);
    MockPrintWriter mockPrintWriter1 = (MockPrintWriter) mockPrintWriter0.append('k');
    jsonFactory1.createGenerator((Writer) mockPrintWriter1);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test118263() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getTextLength();
    int int0 = 4438;
    Integer integer0 = new Integer(4438);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(0, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""5O"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_FLOAT;
    JsonToken jsonToken1 = JsonToken.VALUE_NUMBER_INT;
    Byte byte0 = new Byte((byte) (-58));
    tokenBuffer0._append(jsonToken1, byte0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer1.append(tokenBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test119264() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer_Segment0.next();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, objectMapper0, false, true);
    tokenBuffer_Parser0.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._last;
    JsonToken jsonToken0 = JsonToken.VALUE_FALSE;
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer0._last;
    SerializedString serializedString0 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer0._append(jsonToken0, ""Can not instantiate abstract type "");
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer2.append(tokenBuffer1);
    IntNode.valueOf(1851);
    SerializedString serializedString1 = new SerializedString(""Can not instantiate abstract type "");
    tokenBuffer1.writeTypeId((Object) null);
    tokenBuffer0.serialize(tokenBuffer2);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test120265() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    Integer integer0 = new Integer(16);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer_Segment0.appendRaw(16, 16, (Object) integer0, (Object) tokenBuffer0, (Object) bigInteger0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""5O"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    mockPrintWriter0.append('Z');
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonToken jsonToken0 = JsonToken.VALUE_NUMBER_INT;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0._append(jsonToken0, bigDecimal0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer1.writeTypeId(jsonFactory0);
    // Undeclared exception!
    tokenBuffer2.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test122267() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    tokenBuffer_Segment0.append(11, jsonToken0, (Object) null, (Object) objectMapper0, (Object) objectMapper0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, true, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeStartArray();
    JsonToken jsonToken1 = JsonToken.VALUE_FALSE;
    tokenBuffer_Segment0.append(2031, jsonToken1);
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer1.writeStartArray();
    TokenBuffer tokenBuffer2 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer3 = new TokenBuffer(tokenBuffer_Parser0);
    tokenBuffer3.serialize(tokenBuffer1);
    TokenBuffer tokenBuffer4 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    JsonToken jsonToken2 = JsonToken.FIELD_NAME;
    tokenBuffer3._append(jsonToken2, tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer0.append(tokenBuffer3);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                jgen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                jgen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                jgen.writeStartObject();
                break;
            case END_OBJECT:
                jgen.writeEndObject();
                break;
            case START_ARRAY:
                jgen.writeStartArray();
                break;
            case END_ARRAY:
                jgen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeFieldName((SerializableString) ob);
                    } else {
                        jgen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        jgen.writeString((SerializableString) ob);
                    } else {
                        jgen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        jgen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        jgen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        jgen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        jgen.writeNumber((Short) n);
                    } else {
                        jgen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        jgen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        jgen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        jgen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        jgen.writeNull();
                    } else if (n instanceof String) {
                        jgen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                jgen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                jgen.writeBoolean(false);
                break;
            case VALUE_NULL:
                jgen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                jgen.writeObject(segment.get(ptr));
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test123268() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    tokenBuffer0.writeNumber(1.7195296F);
    byte[] byteArray0 = new byte[8];
    byteArray0[1] = (byte) (-78);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-78);
    byteArray0[4] = (byte) (-91);
    byteArray0[7] = (byte) (-91);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer0.writeNumber(bigInteger0);
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._last;
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    jsonFactory0.setCodec(objectMapper0);
    char[] charArray0 = new char[0];
    IntNode.valueOf((byte) (-91));
    Short short0 = new Short((short) 1767);
    tokenBuffer0.writeTypeId(short0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0, true);
    tokenBuffer0.serialize(tokenBuffer1);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"@Override
public final void writeEndArray() throws IOException, JsonGenerationException {
    _append(JsonToken.END_ARRAY);
    // Let's allow unbalanced tho... i.e. not run out of root level, ever
    JsonWriteContext c = _writeContext.getParent();
    if (c != null) {
        _writeContext = c;
    }
}","public void test124269() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    FileSystemHandling.shouldAllThrowIOExceptions();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    JsonParser jsonParser0 = tokenBuffer_Parser0.setFeatureMask((-2106));
    tokenBuffer_Segment0.rawType((-2106));
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    jsonParser0.getText();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1._append(jsonToken0, serializedString0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    tokenBuffer0._appendRaw((-1100), tokenBuffer_Segment0);
    tokenBuffer_Segment0.appendRaw(5, 8, (Object) jsonToken0, (Object) null, (Object) null);
    TokenBuffer tokenBuffer3 = tokenBuffer2.append(tokenBuffer0);
    tokenBuffer3.writeEndArray();
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser jp = other.asParser();
    while (jp.nextToken() != null) {
        copyCurrentStructure(jp);
    }
    return this;
}","public void test126271() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.getTextLength();
    Float float0 = new Float((float) 0);
    JsonToken jsonToken0 = JsonToken.VALUE_FALSE;
    Integer integer0 = new Integer(15);
    JsonToken jsonToken1 = JsonToken.END_OBJECT;
    tokenBuffer0._append(jsonToken1, jsonToken0);
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""+kC+$GI?~6g"");
    TokenBuffer tokenBuffer1 = new TokenBuffer(tokenBuffer_Parser0);
    TokenBuffer tokenBuffer2 = tokenBuffer1.append(tokenBuffer0);
    tokenBuffer1.serialize(tokenBuffer0);
    TokenBuffer tokenBuffer3 = new TokenBuffer(objectMapper0);
    tokenBuffer1._objectCodec = (ObjectCodec) objectMapper0;
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    JsonToken jsonToken2 = JsonToken.VALUE_FALSE;
    tokenBuffer3._append(jsonToken2, tokenBuffer0);
    // Undeclared exception!
    tokenBuffer1.append(tokenBuffer2);
}",""
