focal_method,test_prefix,docstring
"public boolean willSuppressNulls() {
    return _suppressNulls;
}","public void test000() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    BeanPropertyWriter beanPropertyWriter0 = new BeanPropertyWriter();
    Class<AnnotatedMethod>[] classArray0 = (Class<AnnotatedMethod>[]) Array.newInstance(Class.class, 1);
    BeanPropertyWriter beanPropertyWriter1 = beanSerializerFactory0.constructFilteredBeanWriter(beanPropertyWriter0, classArray0);
    assertFalse(beanPropertyWriter1.willSuppressNulls());
}",""
"@Override
public SerializerFactory withConfig(SerializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional serializers, or losing serializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    if (getClass() != BeanSerializerFactory.class) {
        throw new IllegalStateException(""Subtype of BeanSerializerFactory ("" + getClass().getName() + "") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with "" + ""additional serializer definitions"");
    }
    return new BeanSerializerFactory(config);
}","public void test011() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withConfig(serializerFactoryConfig0);
    assertSame(serializerFactory0, beanSerializerFactory0);
}","/**
 * Method used by module registration functionality, to attach additional
 * serializer providers into this serializer factory. This is typically
 * handled by constructing a new instance with additional serializers,
 * to ensure thread-safe access.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<CollectionLikeType> class0 = CollectionLikeType.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    // Then JsonSerializable, @JsonValue etc:
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }
    final SerializationConfig config = prov.getConfig();
    // Container types differ from non-container types
    // (note: called method checks for module-provided serializers)
    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
            // [Issue#23]: Need to figure out how to force passed parameterization
            //  to stick...
            /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
        }
        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        // Will return right away, since called method does post-processing:
        if (ser != null) {
            return ser;
        }
    } else {
        // Modules may provide serializers of POJO types:
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }
    }
    // Otherwise, we will check ""primary types""; both marker types that
    // indicate specific handling (JsonSerializable), or main types that have
    // precedence over container types
    if (ser == null) {
        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
        if (ser == null) {
            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
            if (ser == null) {
                // And this is where this class comes in: if type is not a
                // known ""primary JDK type"", perhaps it's a bean? We can still
                // get a null, if we can't find a single suitable bean property.
                ser = findBeanSerializer(prov, type, beanDesc);
                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                if (ser == null) {
                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                    //   'unknown' serializer assigned earlier, here, so that it gets properly
                    //   post-processed
                    if (ser == null) {
                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                    }
                }
            }
        }
    }
    if (ser != null) {
        // [Issue#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifySerializer(config, beanDesc, ser);
            }
        }
    }
    return ser;
}","public void test033() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<CollectionLikeType> class0 = CollectionLikeType.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forOtherUse((MapperConfig<?>) null, simpleType0, (AnnotatedClass) null);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class1 = HashMap.class;
    Class<BeanSerializer> class2 = BeanSerializer.class;
    MapType mapType0 = typeFactory0.constructMapType(class1, class1, class2);
    // Undeclared exception!
    try {
        beanSerializerFactory0._createSerializer2(defaultSerializerProvider_Impl0, mapType0, basicBeanDescription0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    Class<Integer> class1 = Integer.class;
    SimpleType simpleType0 = SimpleType.construct(class1);
    MapType mapType0 = MapType.construct(class0, simpleType0, simpleType0);
    ObjectWriter objectWriter0 = objectMapper0.writerFor((JavaType) mapType0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Configuration: ser/deser factory, provider access
    /**********************************************************
     */
/**
 * Method for setting specific {@link SerializerFactory} to use
 * for constructing (bean) serializers.
 */
public ObjectMapper setSerializerFactory(SerializerFactory f) {
    _serializerFactory = f;
    return this;
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    SimpleSerializers simpleSerializers0 = new SimpleSerializers();
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withAdditionalSerializers(simpleSerializers0);
    objectMapper0.setSerializerFactory(serializerFactory0);
    assertNotSame(serializerFactory0, beanSerializerFactory0);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test056() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    SimpleSerializers simpleSerializers0 = new SimpleSerializers();
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withAdditionalSerializers(simpleSerializers0);
    objectMapper0.setSerializerFactory(serializerFactory0);
    Class<BasicBeanDescription> class0 = BasicBeanDescription.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test067() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<MapperFeature> class0 = MapperFeature.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Configuration: ser/deser factory, provider access
    /**********************************************************
     */
/**
 * Method for setting specific {@link SerializerFactory} to use
 * for constructing (bean) serializers.
 */
public ObjectMapper setSerializerFactory(SerializerFactory f) {
    _serializerFactory = f;
    return this;
}","public void test078() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    ObjectMapper objectMapper0 = new ObjectMapper();
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    BeanSerializerBuilder beanSerializerBuilder0 = new BeanSerializerBuilder((BeanDescription) null);
    BeanSerializerModifier beanSerializerModifier0 = mock(BeanSerializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((List<BeanPropertyWriter>) null).when(beanSerializerModifier0).changeProperties(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), anyList());
    doReturn((JsonSerializer) null).when(beanSerializerModifier0).modifySerializer(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonSerializer.class));
    doReturn((List<BeanPropertyWriter>) null).when(beanSerializerModifier0).orderProperties(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), anyList());
    doReturn(beanSerializerBuilder0).when(beanSerializerModifier0).updateBuilder(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.ser.BeanSerializerBuilder.class));
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withSerializerModifier(beanSerializerModifier0);
    objectMapper0.setSerializerFactory(serializerFactory0);
    assertNotSame(serializerFactory0, beanSerializerFactory0);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test079() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    ObjectMapper objectMapper0 = new ObjectMapper();
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    BeanSerializerBuilder beanSerializerBuilder0 = new BeanSerializerBuilder((BeanDescription) null);
    BeanSerializerModifier beanSerializerModifier0 = mock(BeanSerializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((List<BeanPropertyWriter>) null).when(beanSerializerModifier0).changeProperties(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), anyList());
    doReturn((JsonSerializer) null).when(beanSerializerModifier0).modifySerializer(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonSerializer.class));
    doReturn((List<BeanPropertyWriter>) null).when(beanSerializerModifier0).orderProperties(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), anyList());
    doReturn(beanSerializerBuilder0).when(beanSerializerModifier0).updateBuilder(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.ser.BeanSerializerBuilder.class));
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withSerializerModifier(beanSerializerModifier0);
    objectMapper0.setSerializerFactory(serializerFactory0);
    Class<BeanSerializer> class0 = BeanSerializer.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Other public methods that are not part of
    /* JsonSerializerFactory API
    /**********************************************************
     */
/**
 * Method that will try to construct a {@link BeanSerializer} for
 * given class. Returns null if no properties are found.
 */
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    // First things first: we know some types are not beans...
    if (!isPotentialBeanType(type.getRawClass())) {
        // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,
        //   as per [Issue#24]
        if (!type.isEnumType()) {
            return null;
        }
    }
    return constructBeanSerializer(prov, beanDesc);
}","public void test0810() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<MapperFeature> class0 = MapperFeature.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forOtherUse((MapperConfig<?>) null, simpleType0, (AnnotatedClass) null);
    // Undeclared exception!
    try {
        beanSerializerFactory0.findBeanSerializer((SerializerProvider) null, simpleType0, basicBeanDescription0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BeanSerializerFactory"", e);
    }
}",""
"/*
    /**********************************************************
    /* Other public methods that are not part of
    /* JsonSerializerFactory API
    /**********************************************************
     */
/**
 * Method that will try to construct a {@link BeanSerializer} for
 * given class. Returns null if no properties are found.
 */
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    // First things first: we know some types are not beans...
    if (!isPotentialBeanType(type.getRawClass())) {
        // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,
        //   as per [Issue#24]
        if (!type.isEnumType()) {
            return null;
        }
    }
    return constructBeanSerializer(prov, beanDesc);
}","public void test0911() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SimpleObjectIdResolver> class0 = SimpleObjectIdResolver.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    JsonSerializer<Object> jsonSerializer0 = beanSerializerFactory0.findBeanSerializer(defaultSerializerProvider_Impl0, arrayType0, (BeanDescription) null);
    assertNull(jsonSerializer0);
}",""
"/*
    /**********************************************************
    /* Overridable non-public factory methods
    /**********************************************************
     */
/**
 * Method called to construct serializer for serializing specified bean type.
 *
 * @since 2.1
 */
@SuppressWarnings(""unchecked"")
protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {
    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
    // 05-Jul-2012, tatu: ... but we should be able to just return ""unknown type"" serializer, right?
    if (beanDesc.getBeanClass() == Object.class) {
        return prov.getUnknownTypeSerializer(Object.class);
        //            throw new IllegalArgumentException(""Can not create bean serializer for Object.class"");
    }
    final SerializationConfig config = prov.getConfig();
    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
    builder.setConfig(config);
    // First: any detectable (auto-detect, annotations) properties to serialize?
    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
    if (props == null) {
        props = new ArrayList<BeanPropertyWriter>();
    }
    // [databind#638]: Allow injection of ""virtual"" properties:
    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);
    // [JACKSON-440] Need to allow modification bean properties to serialize:
    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            props = mod.changeProperties(config, beanDesc, props);
        }
    }
    // Any properties to suppress?
    props = filterBeanProperties(config, beanDesc, props);
    // [JACKSON-440] Need to allow reordering of properties to serialize
    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            props = mod.orderProperties(config, beanDesc, props);
        }
    }
    /* And if Object Id is needed, some preparation for that as well: better
         * do before view handling, mostly for the custom id case which needs
         * access to a property
         */
    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
    builder.setProperties(props);
    builder.setFilterId(findFilterId(config, beanDesc));
    AnnotatedMember anyGetter = beanDesc.findAnyGetter();
    if (anyGetter != null) {
        if (config.canOverrideAccessModifiers()) {
            anyGetter.fixAccess();
        }
        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());
        // copied from BasicSerializerFactory.buildMapSerializer():
        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
        JavaType valueType = type.getContentType();
        TypeSerializer typeSer = createTypeSerializer(config, valueType);
        // last 2 nulls; don't know key, value serializers (yet)
        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers
        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);
        // TODO: support '@JsonIgnoreProperties' with any setter?
        // TODO: can we find full PropertyName?
        PropertyName name = new PropertyName(anyGetter.getName());
        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);
        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
    }
    // Next: need to gather view information, if any:
    processViews(config, builder);
    // Finally: let interested parties mess with the result bit more...
    if (_factoryConfig.hasSerializerModifiers()) {
        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
            builder = mod.updateBuilder(config, beanDesc, builder);
        }
    }
    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();
    if (ser == null) {
        // If we get this far, there were no properties found, so no regular BeanSerializer
        // would be constructed. But, couple of exceptions.
        // First: if there are known annotations, just create 'empty bean' serializer
        if (beanDesc.hasKnownClassAnnotations()) {
            return builder.createDummy();
        }
    }
    return ser;
}","public void test1012() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forOtherUse((MapperConfig<?>) null, simpleType0, (AnnotatedClass) null);
    // Undeclared exception!
    try {
        beanSerializerFactory0.constructBeanSerializer((SerializerProvider) null, basicBeanDescription0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BeanSerializerFactory"", e);
    }
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test1113() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.REQUIRE_SETTERS_FOR_GETTERS;
    objectMapper0.configure(mapperFeature0, true);
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test1214() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.DEFAULT_VIEW_INCLUSION;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, false);
    Class<TypeIdResolver> class0 = TypeIdResolver.class;
    ObjectWriter objectWriter0 = objectMapper1.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test1315() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.REQUIRE_SETTERS_FOR_GETTERS;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, true);
    PropertyAccessor propertyAccessor0 = PropertyAccessor.ALL;
    JsonAutoDetect.Visibility jsonAutoDetect_Visibility0 = JsonAutoDetect.Visibility.ANY;
    objectMapper0.setVisibility(propertyAccessor0, jsonAutoDetect_Visibility0);
    Class<BasicBeanDescription> class0 = BasicBeanDescription.class;
    ObjectWriter objectWriter0 = objectMapper1.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test1416() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS;
    objectMapper0.configure(mapperFeature0, false);
    Class<Module> class0 = Module.class;
    ObjectWriter objectWriter0 = objectMapper0.writerFor((Class<?>) class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
