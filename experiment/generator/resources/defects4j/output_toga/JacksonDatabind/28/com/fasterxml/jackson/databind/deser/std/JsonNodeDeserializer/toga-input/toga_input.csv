focal_method,test_prefix,docstring
"/*
    /**********************************************************
    /* Public API, value access with conversion(s)/coercion(s)
    /**********************************************************
     */
/**
 * Method that will return a valid String representation of
 * the container value, if the node is a value node
 * (method {@link #isValueNode} returns true),
 * otherwise empty String.
 */
public abstract String asText();","public void test22() throws Throwable {
    JsonNodeDeserializer jsonNodeDeserializer0 = new JsonNodeDeserializer();
    JsonNode jsonNode0 = jsonNodeDeserializer0.getNullValue((DeserializationContext) null);
    assertEquals(""null"", jsonNode0.asText());
}",""
"/*
    /**********************************************************
    /* Public API, type introspection
    /**********************************************************
     */
// // First high-level division between values, containers and ""missing""
/**
 * Return the type of this node
 *
 * @return the node type as a {@link JsonNodeType} enum value
 *
 * @since 2.2
 */
public abstract JsonNodeType getNodeType();","public void test33() throws Throwable {
    JsonNodeDeserializer jsonNodeDeserializer0 = new JsonNodeDeserializer();
    JsonNode jsonNode0 = jsonNodeDeserializer0.getNullValue();
    assertEquals(JsonNodeType.NULL, jsonNode0.getNodeType());
}",""
"public boolean isCachable() {
    return false;
}","public void test44() throws Throwable {
    Class<ArrayNode> class0 = ArrayNode.class;
    JsonDeserializer<? extends JsonNode> jsonDeserializer0 = JsonNodeDeserializer.getDeserializer(class0);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test55() throws Throwable {
    Class<ObjectNode> class0 = ObjectNode.class;
    JsonDeserializer<? extends JsonNode> jsonDeserializer0 = JsonNodeDeserializer.getDeserializer(class0);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test66() throws Throwable {
    Class<String> class0 = String.class;
    JsonDeserializer<? extends JsonNode> jsonDeserializer0 = JsonNodeDeserializer.getDeserializer(class0);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"@Override
public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    switch(p.getCurrentTokenId()) {
        case JsonTokenId.ID_START_OBJECT:
            return deserializeObject(p, ctxt, ctxt.getNodeFactory());
        case JsonTokenId.ID_START_ARRAY:
            return deserializeArray(p, ctxt, ctxt.getNodeFactory());
        default:
            return deserializeAny(p, ctxt, ctxt.getNodeFactory());
    }
}","public void test77() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    JsonNodeDeserializer jsonNodeDeserializer0 = new JsonNodeDeserializer();
    // Undeclared exception!
    try {
        jsonNodeDeserializer0.deserialize(jsonParser0, (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer"", e);
    }
}","/**
 * Implementation that will produce types of any JSON nodes; not just one
 * deserializer is registered to handle (in case of more specialized handler).
 * Overridden by typed sub-classes for more thorough checking
 */"
