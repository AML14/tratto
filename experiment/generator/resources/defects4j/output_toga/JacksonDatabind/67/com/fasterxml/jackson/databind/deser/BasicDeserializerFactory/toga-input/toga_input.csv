focal_method,test_prefix,docstring
"// since 2.8
@Deprecated
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {
    return resolveMemberAndTypeAnnotations(ctxt, member, type);
}","public void test000() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<TokenBuffer> class0 = TokenBuffer.class;
    MapType mapType0 = MapType.construct(class0, typeBindings0, javaType0, (JavaType[]) null, javaType0, javaType0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.resolveType(defaultDeserializationContext_Impl0, (BeanDescription) null, mapType0, (AnnotatedMember) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * @deprecated since 2.8 call {@link #resolveMemberAndTypeAnnotations} instead.
 */"
"public boolean hasAbstractTypeResolvers() {
    return _abstractTypeResolvers.length > 0;
}","public void test011() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DeserializerFactoryConfig deserializerFactoryConfig1 = beanDeserializerFactory0.getFactoryConfig();
    assertFalse(deserializerFactoryConfig1.hasAbstractTypeResolvers());
}",""
"@Override
public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {
    return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));
}","public void test022() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleKeyDeserializers simpleKeyDeserializers0 = new SimpleKeyDeserializers();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAdditionalKeyDeserializers(simpleKeyDeserializers0);
    assertNotSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link KeyDeserializers}.
 */"
"@Override
public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {
    return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    assertNotSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link AbstractTypeResolver}.
 */"
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<JsonLocation> class0 = JsonLocation.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) resolvedRecursiveType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test055() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<SQLTransactionRollbackException> class0 = SQLTransactionRollbackException.class;
    ValueInstantiator.Base valueInstantiator_Base0 = new ValueInstantiator.Base(class0);
    SimpleModule simpleModule1 = simpleModule0.addValueInstantiator(class0, valueInstantiator_Base0);
    objectMapper0.registerModule(simpleModule1);
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) javaType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test066() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(jsonFactory0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test077() throws Throwable {
    Class<SQLException> class0 = SQLException.class;
    AnnotatedClass annotatedClass0 = AnnotatedClass.constructWithoutSuperTypes((Class<?>) class0, (MapperConfig<?>) null);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, annotatedClass0, class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector returned Class java.sql.SQLException; expected Class<ValueInstantiator>
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test088() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ValueInstantiator valueInstantiator0 = beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, (Object) null);
    assertNull(valueInstantiator0);
}",""
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test099() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<DoubleNode> class0 = DoubleNode.class;
    ValueInstantiator.Base valueInstantiator_Base0 = new ValueInstantiator.Base(class0);
    ValueInstantiator valueInstantiator0 = beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, valueInstantiator_Base0);
    assertSame(valueInstantiator0, valueInstantiator_Base0);
}",""
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test1010() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, deserializerFactoryConfig0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector returned key deserializer definition of type com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig; expected type KeyDeserializer or Class<KeyDeserializer> instead
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName name = intr.findNameForDeserialization(param);
        if (name != null) {
            return name;
        }
        // 14-Apr-2014, tatu: Need to also consider possible implicit name
        //  (for JDK8, or via paranamer)
        String str = intr.findImplicitPropertyName(param);
        if (str != null && !str.isEmpty()) {
            return PropertyName.construct(str);
        }
    }
    return null;
}","public void test1111() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    PropertyName propertyName0 = beanDeserializerFactory0._findParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName name = intr.findNameForDeserialization(param);
        if (name != null) {
            return name;
        }
        // 14-Apr-2014, tatu: Need to also consider possible implicit name
        //  (for JDK8, or via paranamer)
        String str = intr.findImplicitPropertyName(param);
        if (str != null && !str.isEmpty()) {
            return PropertyName.construct(str);
        }
    }
    return null;
}","public void test1212() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, (JavaType) null, annotationMap0, (-1962));
    PropertyName propertyName0 = beanDeserializerFactory0._findParamName(annotatedParameter0, (AnnotationIntrospector) null);
    assertNull(propertyName0);
}",""
"protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    String str = intr.findImplicitPropertyName(param);
    if (str != null && !str.isEmpty()) {
        return PropertyName.construct(str);
    }
    return null;
}","public void test1313() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    PropertyName propertyName0 = beanDeserializerFactory0._findImplicitParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        return intr.findNameForDeserialization(param);
    }
    return null;
}","public void test1414() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    PropertyName propertyName0 = beanDeserializerFactory0._findExplicitParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        return intr.findNameForDeserialization(param);
    }
    return null;
}","public void test1515() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JavaType javaType0 = TypeFactory.unknownType();
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(javaType0, javaType0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, collectionLikeType0, annotationMap0, (-751));
    PropertyName propertyName0 = beanDeserializerFactory0._findExplicitParamName(annotatedParameter0, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test1616() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName((AnnotatedParameter) null, (AnnotationIntrospector) null);
    assertFalse(boolean0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test1717() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    JavaType javaType0 = TypeFactory.unknownType();
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, javaType0, annotationMap0, 799);
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName(annotatedParameter0, (AnnotationIntrospector) null);
    assertFalse(boolean0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test1818() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    JavaType javaType0 = TypeFactory.unknownType();
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, javaType0, annotationMap0, 2);
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName(annotatedParameter0, annotationIntrospector0);
    assertFalse(boolean0);
}",""
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test1919() throws Throwable {
    Class<BatchUpdateException> class0 = BatchUpdateException.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) arrayType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2020() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<String> class0 = String.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) arrayType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2121() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LongNode> class0 = LongNode.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    BeanDeserializerModifier beanDeserializerModifier0 = mock(BeanDeserializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((JsonDeserializer) null).when(beanDeserializerModifier0).modifyArrayDeserializer(any(com.fasterxml.jackson.databind.DeserializationConfig.class), any(com.fasterxml.jackson.databind.type.ArrayType.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonDeserializer.class));
    simpleModule0.setDeserializerModifier(beanDeserializerModifier0);
    objectMapper0.registerModule(simpleModule0);
    try {
        objectMapper0.readValues((JsonParser) null, (ResolvedType) arrayType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not find a Value deserializer for abstract type [array type, component type: [simple type, class com.fasterxml.jackson.databind.node.LongNode]]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2222() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<CollectionType> class0 = CollectionType.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    objectMapper0.enableDefaultTyping();
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) arrayType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2323() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    Class<DataTruncation> class0 = DataTruncation.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (JavaType[]) null);
    Class<SQLNonTransientConnectionException> class1 = SQLNonTransientConnectionException.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<EnumSet> class2 = EnumSet.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType((Class<? extends Collection>) class2, (JavaType) resolvedRecursiveType0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    ArrayNode arrayNode0 = jsonNodeFactory0.arrayNode(1);
    JsonParser jsonParser0 = arrayNode0.traverse((ObjectCodec) objectMapper0);
    try {
        objectMapper0.readValues(jsonParser0, (ResolvedType) collectionType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Type [recursive type; UNRESOLVED not Java Enum type
        //  at [Source: java.lang.String@0000000003; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2424() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    Class<String> class0 = String.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (JavaType[]) null);
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayList> class1 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType((Class<? extends Collection>) class1, (JavaType) resolvedRecursiveType0);
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) collectionType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {
    Class<?> collectionClass = type.getRawClass();
    collectionClass = _collectionFallbacks.get(collectionClass.getName());
    if (collectionClass == null) {
        return null;
    }
    return (CollectionType) config.constructSpecializedType(type, collectionClass);
}","public void test2525() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<TokenBuffer> class0 = TokenBuffer.class;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    CollectionType collectionType0 = beanDeserializerFactory0._mapAbstractCollectionType(resolvedRecursiveType0, (DeserializationConfig) null);
    assertNull(collectionType0);
}",""
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2626() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SQLClientInfoException> class0 = SQLClientInfoException.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ConcurrentSkipListMap> class1 = ConcurrentSkipListMap.class;
    MapType mapType0 = typeFactory0.constructMapType((Class<? extends Map>) class1, (JavaType) arrayType0, (JavaType) arrayType0);
    try {
        objectMapper0.readValues((JsonParser) null, (ResolvedType) mapType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not find a (Map) Key deserializer for type [array type, component type: [simple type, class java.sql.SQLClientInfoException]]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2727() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LongNode> class0 = LongNode.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) arrayType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test2828() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ArrayNode arrayNode0 = jsonNodeFactory0.arrayNode();
    JsonParser jsonParser0 = arrayNode0.traverse((ObjectCodec) objectMapper0);
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(javaType0, javaType0);
    try {
        objectMapper0.readValues(jsonParser0, (ResolvedType) referenceType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not find a Value deserializer for type [reference type, class java.lang.Object<java.lang.Object<[simple type, class java.lang.Object]>]
        //  at [Source: java.lang.String@0000000003; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"/*
    /**********************************************************
    /* Helper methods, finding custom deserializers
    /**********************************************************
     */
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {
    for (Deserializers d : _factoryConfig.deserializers()) {
        JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);
        if (deser != null) {
            return deser;
        }
    }
    return null;
}","public void test2929() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleDeserializers simpleDeserializers0 = new SimpleDeserializers();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(simpleDeserializers0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    Class<ObjectNode> class0 = ObjectNode.class;
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0._findCustomTreeNodeDeserializer(class0, (DeserializationConfig) null, (BeanDescription) null);
    assertNull(jsonDeserializer0);
}",""
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test3030() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SQLClientInfoException> class0 = SQLClientInfoException.class;
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<DataTruncation> class1 = DataTruncation.class;
    simpleModule0.addDeserializer(class1, (JsonDeserializer<? extends DataTruncation>) null);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper1.readValues((JsonParser) null, (ResolvedType) arrayType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test3131() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<DataTruncation> class0 = DataTruncation.class;
    SimpleModule simpleModule1 = simpleModule0.addDeserializer(class0, (JsonDeserializer<? extends DataTruncation>) null);
    objectMapper0.registerModule(simpleModule1);
    MappingIterator<LinkedHashMap<SQLSyntaxErrorException, Object>> mappingIterator0 = objectMapper0.readValues((JsonParser) null, (ResolvedType) javaType0);
    assertNotNull(mappingIterator0);
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test3232() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(javaType0, javaType0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<DataTruncation> class0 = DataTruncation.class;
    SimpleModule simpleModule1 = simpleModule0.addDeserializer(class0, (JsonDeserializer<? extends DataTruncation>) null);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    try {
        objectMapper1.readValues((JsonParser) null, (ResolvedType) collectionLikeType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not find a Value deserializer for type [collection-like type; class java.lang.Object, contains [simple type, class java.lang.Object]]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test3333() throws Throwable {
    JavaType javaType0 = TypeFactory.unknownType();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<DataTruncation> class0 = DataTruncation.class;
    SimpleModule simpleModule1 = simpleModule0.addDeserializer(class0, (JsonDeserializer<? extends DataTruncation>) null);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    Class<ObjectNode> class1 = ObjectNode.class;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded(class1, javaType0);
    JavaType[] javaTypeArray0 = new JavaType[6];
    javaTypeArray0[0] = javaType0;
    MapType mapType0 = MapType.construct(class0, typeBindings0, javaType0, javaTypeArray0, javaTypeArray0[0], javaType0);
    try {
        objectMapper1.readValues((JsonParser) null, (ResolvedType) mapType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not find a Value deserializer for type [map type; class java.sql.DataTruncation, [simple type, class java.lang.Object] -> [simple type, class java.lang.Object]]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"// not used, possibly remove as early as 2.9
@Deprecated
protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test3434() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<SQLIntegrityConstraintViolationException> class0 = SQLIntegrityConstraintViolationException.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * @deprecated since 2.8 call <code>findJsonValueMethod</code> on {@link BeanDescription} instead
 */"
"// not used, possibly remove as early as 2.9
@Deprecated
protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test3535() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotatedMethod annotatedMethod0 = beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, (JavaType) null);
    assertNull(annotatedMethod0);
}","/**
 * @deprecated since 2.8 call <code>findJsonValueMethod</code> on {@link BeanDescription} instead
 */"
