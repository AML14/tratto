focal_method,test_prefix,docstring
"@SuppressWarnings(""unchecked"")
public void setAnswersForStubbing(List<Answer> answers) {
    invocationContainerImpl.setAnswersForStubbing(answers);
}","public void test11() throws Throwable {
    MockHandler<Object> mockHandler0 = new MockHandler<Object>();
    // Undeclared exception!
    try {
        mockHandler0.setAnswersForStubbing((List<Answer>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.ArrayList"", e);
    }
}",""
"public boolean hasAnswersForStubbing() {
    return !answersForStubbing.isEmpty();
}","public void test22() throws Throwable {
    MockHandler<Object> mockHandler0 = new MockHandler<Object>();
    InvocationContainerImpl invocationContainerImpl0 = (InvocationContainerImpl) mockHandler0.getInvocationContainer();
    assertFalse(invocationContainerImpl0.hasAnswersForStubbing());
}",""
"public VoidMethodStubbable<T> voidMethodStubbable(T mock) {
    return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);
}","public void test33() throws Throwable {
    MockHandler<Object> mockHandler0 = new MockHandler<Object>();
    VoidMethodStubbable<Object> voidMethodStubbable0 = mockHandler0.voidMethodStubbable(mockHandler0);
    assertNotNull(voidMethodStubbable0);
}",""
"public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();
    //if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        //We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
            // this means there is an invocation on a different mock. Re-adding verification mode
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        }
    }
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}","public void test44() throws Throwable {
    Invocation invocation0 = mock(Invocation.class, new ViolatedAssumptionAnswer());
    MockHandler<ReturnsElementsOf> mockHandler0 = new MockHandler<ReturnsElementsOf>();
    try {
        mockHandler0.handle(invocation0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.internal.MockHandler"", e);
    }
}",""
"public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();
    //if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        //We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
            // this means there is an invocation on a different mock. Re-adding verification mode
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        }
    }
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}","public void test55() throws Throwable {
    Invocation invocation0 = mock(Invocation.class, new ViolatedAssumptionAnswer());
    MockHandler<Locale.Category> mockHandler0 = new MockHandler<Locale.Category>();
    ThreadSafeMockingProgress threadSafeMockingProgress0 = (ThreadSafeMockingProgress) mockHandler0.mockingProgress;
    InvocationContainerImpl invocationContainerImpl0 = new InvocationContainerImpl(threadSafeMockingProgress0);
    invocationContainerImpl0.addAnswerForVoidMethod((Answer) null);
    mockHandler0.invocationContainerImpl = invocationContainerImpl0;
    try {
        mockHandler0.handle(invocation0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.concurrent.ConcurrentLinkedQueue"", e);
    }
}",""
"public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();
    //if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        //We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);
            verificationMode.verify(data);
            return null;
            // this means there is an invocation on a different mock. Re-adding verification mode
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
        }
    }
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}","public void test66() throws Throwable {
    Integer integer0 = new Integer((-43));
    Invocation invocation0 = mock(Invocation.class, new ViolatedAssumptionAnswer());
    doReturn((Method) null).when(invocation0).getMethod();
    doReturn(integer0).when(invocation0).getMock();
    MockHandler<ReturnsElementsOf> mockHandler0 = new MockHandler<ReturnsElementsOf>();
    ThreadSafeMockingProgress threadSafeMockingProgress0 = new ThreadSafeMockingProgress();
    VerificationWithTimeout verificationWithTimeout0 = new VerificationWithTimeout((-43), (VerificationMode) null);
    MockAwareVerificationMode mockAwareVerificationMode0 = new MockAwareVerificationMode(integer0, verificationWithTimeout0);
    threadSafeMockingProgress0.verificationStarted(mockAwareVerificationMode0);
    try {
        mockHandler0.handle(invocation0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.internal.creation.DelegatingMethod"", e);
    }
}",""
