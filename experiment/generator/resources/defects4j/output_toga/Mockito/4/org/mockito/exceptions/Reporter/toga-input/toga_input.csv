focal_method,test_prefix,docstring
"public void cannotMockFinalClass(Class<?> clazz) {
    throw new MockitoException(join(""Cannot mock/spy "" + clazz.toString(), ""Mockito cannot mock/spy following:"", ""  - final classes"", ""  - anonymous classes"", ""  - primitive types""));
}","public void test000() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<ClientInfoStatus> class0 = ClientInfoStatus.class;
    // Undeclared exception!
    try {
        reporter0.cannotMockFinalClass(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void extraInterfacesDoesNotAcceptNullParameters() {
    throw new MockitoException(join(""extraInterfaces() does not accept null parameters.""));
}","public void test011() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.extraInterfacesDoesNotAcceptNullParameters();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {
    throw new WrongTypeOfReturnValue(join(actualType + "" cannot be returned by "" + methodName + ""()"", methodName + ""() should return "" + expectedType, ""***"", ""If you're unsure why you're getting above error read on."", ""Due to the nature of the syntax above problem might occur because:"", ""1. This exception *might* occur in wrongly written multi-threaded tests."", ""   Please refer to Mockito FAQ on limitations of concurrency testing."", ""2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - "", ""   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method."", """"));
}","public void test022() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.wrongTypeOfReturnValue(""mTt.u<FQ--I<>8$}0"", ""mTt.u<FQ--I<>8$}0"", ""mTt.u<FQ--I<>8$}0"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void invalidArgumentRangeAtIdentityAnswerCreationTime() {
    throw new MockitoException(join(""Invalid argument index."", ""The index need to be a positive number that indicates the position of the argument to return."", ""However it is possible to use the -1 value to indicates that the last argument should be"", ""returned.""));
}","public void test033() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.invalidArgumentRangeAtIdentityAnswerCreationTime();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {
    throw new MockitoException(join(""Cannot instantiate a @Spy for '"" + fieldName + ""' field."", ""You haven't provided the instance for spying at field declaration so I tried to construct the instance."", ""However, I failed because: "" + details.getMessage(), ""Examples of correct usage of @Spy:"", ""   @Spy List mock = new LinkedList();"", ""   @Spy Foo foo; //only if Foo has parameterless constructor"", ""   //also, don't forget about MockitoAnnotations.initMocks();"", """"), details);
}","public void test044() throws Throwable {
    Reporter reporter0 = new Reporter();
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""has returned: \"""", ""has returned: \"""", 1);
    // Undeclared exception!
    try {
        reporter0.cannotInitializeForSpyAnnotation(""has returned: \"""", sQLTransientConnectionException0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {
    String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);
    throw new TooLittleActualInvocations(message);
}","public void test055() throws Throwable {
    Reporter reporter0 = new Reporter();
    org.mockito.internal.reporting.Discrepancy discrepancy0 = new org.mockito.internal.reporting.Discrepancy(1931, 1931);
    LocationImpl locationImpl0 = new LocationImpl();
    // Undeclared exception!
    try {
        reporter0.tooLittleActualInvocations(discrepancy0, (DescribedInvocation) null, locationImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void noMoreInteractionsWantedInOrder(Invocation undesired) {
    throw new VerificationInOrderFailure(join(""No interactions wanted here:"", new LocationImpl(), ""But found this interaction on mock '"" + undesired.getMock() + ""':"", undesired.getLocation()));
}","public void test066() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.noMoreInteractionsWantedInOrder((Invocation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void usingConstructorWithFancySerializable(SerializableMode mode) {
    throw new MockitoException(""Mocks instantiated with constructor cannot be combined with "" + mode + "" serialization mode."");
}","public void test077() throws Throwable {
    Reporter reporter0 = new Reporter();
    SerializableMode serializableMode0 = SerializableMode.ACROSS_CLASSLOADERS;
    // Undeclared exception!
    try {
        reporter0.usingConstructorWithFancySerializable(serializableMode0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void mocksHaveToBePassedWhenCreatingInOrder() {
    throw new MockitoException(join(""Method requires argument(s)!"", ""Pass mocks that require verification in order."", ""For example:"", ""    InOrder inOrder = inOrder(mockOne, mockTwo);""));
}","public void test088() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.mocksHaveToBePassedWhenCreatingInOrder();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void notAMockPassedWhenCreatingInOrder() {
    throw new NotAMockException(join(""Argument(s) passed is not a mock!"", ""Pass mocks that require verification in order."", ""For example:"", ""    InOrder inOrder = inOrder(mockOne, mockTwo);""));
}","public void test099() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.notAMockPassedWhenCreatingInOrder();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void inOrderRequiresFamiliarMock() {
    throw new MockitoException(join(""InOrder can only verify mocks that were passed in during creation of InOrder."", ""For example:"", ""    InOrder inOrder = inOrder(mockOne);"", ""    inOrder.verify(mockOne).doStuff();""));
}","public void test1010() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.inOrderRequiresFamiliarMock();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotVerifyToString() {
    throw new MockitoException(join(""Mockito cannot verify toString()"", ""toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). "" + ""Verifying it may give inconsistent or hard to understand results. "" + ""Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)"", ""However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.""));
}","public void test1111() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.cannotVerifyToString();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
    throw new MockitoException(join(""Methods called on mock must exist in delegated instance."", ""When calling: "" + mockMethod + "" on mock: "" + safelyGetMockName(mock), ""no such method was found."", ""Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods"", ""(delegate instance had type: "" + delegate.getClass().getSimpleName() + "")""));
}","public void test1212() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.delegatedMethodDoesNotExistOnDelegate((Method) null, """", (Object) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void invocationListenerDoesNotAcceptNullParameters() {
    throw new MockitoException(""invocationListeners() does not accept null parameters"");
}","public void test1313() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.invocationListenerDoesNotAcceptNullParameters();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {
    String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);
    throw new VerificationInOrderFailure(join(""Verification in order failure:"" + message));
}","public void test1414() throws Throwable {
    Reporter reporter0 = new Reporter();
    LocationImpl locationImpl0 = new LocationImpl();
    // Undeclared exception!
    try {
        reporter0.tooManyActualInvocationsInOrder(1, 1, (DescribedInvocation) null, locationImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {
    throw new MockitoException(join(""Cannot instantiate @InjectMocks field named '"" + fieldName + ""'."", ""You haven't provided the instance at field declaration so I tried to construct the instance."", ""However, I failed because: "" + details.getMessage(), ""Examples of correct usage of @InjectMocks:"", ""   @InjectMocks Service service = new Service();"", ""   @InjectMocks Service service;"", ""   //also, don't forget about MockitoAnnotations.initMocks();"", ""   //and... don't forget about some @Mocks for injection :)"", """"), details);
}","public void test1515() throws Throwable {
    Reporter reporter0 = new Reporter();
    SQLException sQLException0 = new SQLException(""    when(mock.isOk()).thenReturn(true);"", ""    when(mock.isOk()).thenReturn(true);"");
    // Undeclared exception!
    try {
        reporter0.cannotInitializeForInjectMocksAnnotation(""    when(mock.isOk()).thenReturn(true);"", sQLException0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void unfinishedVerificationException(Location location) {
    UnfinishedVerificationException exception = new UnfinishedVerificationException(join(""Missing method call for verify(mock) here:"", location, """", ""Example of correct verification:"", ""    verify(mock).doSomething()"", """", ""Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods."", ""Those methods *cannot* be stubbed/verified."", MockitoLimitations.NON_PUBLIC_PARENT, """"));
    throw exception;
}","public void test1616() throws Throwable {
    Reporter reporter0 = new Reporter();
    LocationImpl locationImpl0 = new LocationImpl();
    // Undeclared exception!
    try {
        reporter0.unfinishedVerificationException(locationImpl0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {
    String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);
    throw new TooManyActualInvocations(message);
}","public void test1717() throws Throwable {
    Reporter reporter0 = new Reporter();
    StackTraceFilter stackTraceFilter0 = new StackTraceFilter();
    LocationImpl locationImpl0 = new LocationImpl(stackTraceFilter0);
    // Undeclared exception!
    try {
        reporter0.tooManyActualInvocations((-1134), (-1134), (DescribedInvocation) null, locationImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void spyAndDelegateAreMutuallyExclusive() {
    throw new MockitoException(join(""Settings should not define a spy instance and a delegated instance at the same time.""));
}","public void test1818() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.spyAndDelegateAreMutuallyExclusive();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void defaultAnswerDoesNotAcceptNullParameter() {
    throw new MockitoException(""defaultAnswer() does not accept null parameter"");
}","public void test1919() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.defaultAnswerDoesNotAcceptNullParameter();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotStubWithNullThrowable() {
    throw new MockitoException(join(""Cannot stub with null throwable!""));
}","public void test2020() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.cannotStubWithNullThrowable();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {
    String allInvocations;
    if (invocations.isEmpty()) {
        allInvocations = ""Actually, there were zero interactions with this mock.\n"";
    } else {
        StringBuilder sb = new StringBuilder(""\nHowever, there were other interactions with this mock:\n"");
        for (DescribedInvocation i : invocations) {
            sb.append(i.toString()).append(""\n"").append(i.getLocation()).append(""\n\n"");
        }
        allInvocations = sb.toString();
    }
    String message = createWantedButNotInvokedMessage(wanted);
    throw new WantedButNotInvoked(message + allInvocations);
}","public void test2121() throws Throwable {
    Reporter reporter0 = new Reporter();
    Vector<InvocationImpl> vector0 = new Vector<InvocationImpl>();
    // Undeclared exception!
    try {
        reporter0.wantedButNotInvoked((DescribedInvocation) null, (List<? extends DescribedInvocation>) vector0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void extraInterfacesRequiresAtLeastOneInterface() {
    throw new MockitoException(join(""extraInterfaces() requires at least one interface.""));
}","public void test2222() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.extraInterfacesRequiresAtLeastOneInterface();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {
    throw new VerificationInOrderFailure(join(""Verification in order failure"", ""Wanted but not invoked:"", wanted.toString(), new LocationImpl(), ""Wanted anywhere AFTER following interaction:"", previous.toString(), previous.getLocation(), """"));
}","public void test2323() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.wantedButNotInvokedInOrder((DescribedInvocation) null, (DescribedInvocation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void invocationListenersRequiresAtLeastOneListener() {
    throw new MockitoException(""invocationListeners() requires at least one listener"");
}","public void test2424() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.invocationListenersRequiresAtLeastOneListener();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotStubVoidMethodWithAReturnValue(String methodName) {
    throw new CannotStubVoidMethodWithReturnValue(join(""'"" + methodName + ""' is a *void method* and it *cannot* be stubbed with a *return value*!"", ""Voids are usually stubbed with Throwables:"", ""    doThrow(exception).when(mock).someVoidMethod();"", ""***"", ""If you're unsure why you're getting above error read on."", ""Due to the nature of the syntax above problem might occur because:"", ""1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version."", ""2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods."", ""3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - "", ""   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method."", ""4. "" + MockitoLimitations.NON_PUBLIC_PARENT, """"));
}","public void test2525() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.cannotStubVoidMethodWithAReturnValue("""");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void moreThanOneAnnotationNotAllowed(String fieldName) {
    throw new MockitoException(""You cannot have more than one Mockito annotation on a field!\n"" + ""The field '"" + fieldName + ""' has multiple Mockito annotations.\n"" + ""For info how to use annotations see examples in javadoc for MockitoAnnotations class."");
}","public void test2626() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.moreThanOneAnnotationNotAllowed("""");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void nullPassedToWhenMethod() {
    throw new NullInsteadOfMockException(join(""Argument passed to when() is null!"", ""Example of correct stubbing:"", ""    doThrow(new RuntimeException()).when(mock).someMethod();"", ""Also, if you use @Mock annotation don't miss initMocks()""));
}","public void test2727() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.nullPassedToWhenMethod();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {
    throw new InvalidUseOfMatchersException(join(""Invalid use of argument matchers inside additional matcher "" + additionalMatcherName + "" !"", new LocationImpl(), """", expectedSubMatchersCount + "" sub matchers expected, "" + matcherStack.size() + "" recorded:"", locationsOf(matcherStack), """", ""This exception may occur if matchers are combined with raw values:"", ""    //incorrect:"", ""    someMethod(AdditionalMatchers.and(isNotNull(), \""raw String\"");"", ""When using matchers, all arguments have to be provided by matchers."", ""For example:"", ""    //correct:"", ""    someMethod(AdditionalMatchers.and(isNotNull(), eq(\""raw String\""));"", """", ""For more info see javadoc for Matchers and AdditionalMatchers classes."", """"));
}","public void test2828() throws Throwable {
    Reporter reporter0 = new Reporter();
    ArrayList<LocalizedMatcher> arrayList0 = new ArrayList<LocalizedMatcher>();
    // Undeclared exception!
    try {
        reporter0.incorrectUseOfAdditionalMatchers("""", 2147483645, arrayList0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void notAMockPassedToVerify(Class type) {
    throw new NotAMockException(join(""Argument passed to verify() is of type "" + type.getSimpleName() + "" and is not a mock!"", ""Make sure you place the parenthesis correctly!"", ""See the examples of correct verifications:"", ""    verify(mock).someMethod();"", ""    verify(mock, times(10)).someMethod();"", ""    verify(mock, atLeastOnce()).someMethod();""));
}","public void test2929() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<StubbedInvocationMatcher> class0 = StubbedInvocationMatcher.class;
    // Undeclared exception!
    try {
        reporter0.notAMockPassedToVerify(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {
    throw new MockitoException(""This combination of annotations is not permitted on a single field:\n"" + ""@"" + undesiredAnnotationOne + "" and @"" + undesiredAnnotationTwo);
}","public void test3030() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.unsupportedCombinationOfAnnotations("""", """");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void incorrectUseOfApi() {
    throw new MockitoException(join(""Incorrect use of API detected here:"", new LocationImpl(), """", ""You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once."", ""Examples of correct usage:"", ""    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);"", ""    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);"", """"));
}","public void test3131() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.incorrectUseOfApi();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void onlyVoidMethodsCanBeSetToDoNothing() {
    throw new MockitoException(join(""Only void methods can doNothing()!"", ""Example of correct use of doNothing():"", ""    doNothing()."", ""    doThrow(new RuntimeException())"", ""    .when(mock).someVoidMethod();"", ""Above means:"", ""someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called""));
}","public void test3232() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.onlyVoidMethodsCanBeSetToDoNothing();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {
    throw new InvalidUseOfMatchersException(join(""Invalid use of argument matchers!"", expectedMatchersCount + "" matchers expected, "" + recordedMatchers.size() + "" recorded:"" + locationsOf(recordedMatchers), """", ""This exception may occur if matchers are combined with raw values:"", ""    //incorrect:"", ""    someMethod(anyObject(), \""raw String\"");"", ""When using matchers, all arguments have to be provided by matchers."", ""For example:"", ""    //correct:"", ""    someMethod(anyObject(), eq(\""String by matcher\""));"", """", ""For more info see javadoc for Matchers class."", """"));
}","public void test3333() throws Throwable {
    Reporter reporter0 = new Reporter();
    Vector<LocalizedMatcher> vector0 = new Vector<LocalizedMatcher>();
    // Undeclared exception!
    try {
        reporter0.invalidUseOfMatchers(0, vector0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void atMostAndNeverShouldNotBeUsedWithTimeout() {
    throw new FriendlyReminderException(join("""", ""Don't panic! I'm just a friendly reminder!"", ""timeout() should not be used with atMost() or never() because..."", ""...it does not make much sense - the test would have passed immediately in concurency"", ""We kept this method only to avoid compilation errors when upgrading Mockito."", ""In future release we will remove timeout(x).atMost(y) from the API."", ""If you want to find out more please refer to issue 235"", """"));
}","public void test3434() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.atMostAndNeverShouldNotBeUsedWithTimeout();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void notAMockPassedToWhenMethod() {
    throw new NotAMockException(join(""Argument passed to when() is not a mock!"", ""Example of correct stubbing:"", ""    doThrow(new RuntimeException()).when(mock).someMethod();""));
}","public void test3535() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.notAMockPassedToWhenMethod();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {
    throw new MockitoAssertionError(join(""Wanted at most "" + pluralize(maxNumberOfInvocations) + "" but was "" + foundSize));
}","public void test3636() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.wantedAtMostX(23, 23);
        fail(""Expecting exception: MockitoAssertionError"");
    } catch (MockitoAssertionError e) {
    }
}",""
"public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
    throw new MockitoException(join(""Methods called on delegated instance must have compatible return types with the mock."", ""When calling: "" + mockMethod + "" on mock: "" + safelyGetMockName(mock), ""return type should be: "" + mockMethod.getReturnType().getSimpleName() + "", but was: "" + delegateMethod.getReturnType().getSimpleName(), ""Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods"", ""(delegate instance had type: "" + delegate.getClass().getSimpleName() + "")""));
}","public void test3737() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<InvocationImpl> class0 = InvocationImpl.class;
    Matcher<InvocationImpl> matcher0 = Is.isA(class0);
    LocalizedMatcher localizedMatcher0 = new LocalizedMatcher(matcher0);
    // Undeclared exception!
    try {
        reporter0.delegatedMethodHasWrongReturnType((Method) null, (Method) null, (Object) null, localizedMatcher0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void nullPassedToVerify() {
    throw new NullInsteadOfMockException(join(""Argument passed to verify() should be a mock but is null!"", ""Examples of correct verifications:"", ""    verify(mock).someMethod();"", ""    verify(mock, times(10)).someMethod();"", ""    verify(mock, atLeastOnce()).someMethod();"", ""    not: verify(mock.someMethod());"", ""Also, if you use @Mock annotation don't miss initMocks()""));
}","public void test3838() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.nullPassedToVerify();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {
    String message = join(""Argument(s) are different! Wanted:"", wanted, new LocationImpl(), ""Actual invocation has different arguments:"", actual, actualLocation, """");
    throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
}","public void test3939() throws Throwable {
    Reporter reporter0 = new Reporter();
    LocationImpl locationImpl0 = new LocationImpl();
    // Undeclared exception!
    try {
        reporter0.argumentsAreDifferent("" recorded:"", "" recorded:"", locationImpl0);
        fail(""Expecting exception: ArgumentsAreDifferent"");
    } catch (ArgumentsAreDifferent e) {
    }
}",""
"public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {
    throw new MockitoException(join(""extraInterfaces() accepts only interfaces."", ""You passed following type: "" + wrongType.getSimpleName() + "" which is not an interface.""));
}","public void test4040() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<String> class0 = String.class;
    // Undeclared exception!
    try {
        reporter0.extraInterfacesAcceptsOnlyInterfaces(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {
    throw new MockitoException(join(""You are using the setting 'withSettings().serializable()' however the type you are trying to mock '"" + classToMock.getSimpleName() + ""'"", ""do not implement Serializable AND do not have a no-arg constructor."", ""This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized"", """", ""Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,"", ""i.e. the top-most superclass has to implements Serializable."", """"));
}","public void test4141() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<LocalizedMatcher> class0 = LocalizedMatcher.class;
    // Undeclared exception!
    try {
        reporter0.serializableWontWorkForObjectsThatDontImplementSerializable(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void mocksHaveToBePassedToVerifyNoMoreInteractions() {
    throw new MockitoException(join(""Method requires argument(s)!"", ""Pass mocks that should be verified, e.g:"", ""    verifyNoMoreInteractions(mockOne, mockTwo);"", ""    verifyZeroInteractions(mockOne, mockTwo);"", """"));
}","public void test4242() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.mocksHaveToBePassedToVerifyNoMoreInteractions();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void smartNullPointerException(String invocation, Location location) {
    throw new SmartNullPointerException(join(""You have a NullPointerException here:"", new LocationImpl(), ""because this method call was *not* stubbed correctly:"", location, invocation, """"));
}","public void test4343() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.smartNullPointerException("""", (Location) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}",""
"public void unfinishedStubbing(Location location) {
    throw new UnfinishedStubbingException(join(""Unfinished stubbing detected here:"", location, """", ""E.g. thenReturn() may be missing."", ""Examples of correct stubbing:"", ""    when(mock.isOk()).thenReturn(true);"", ""    when(mock.isOk()).thenThrow(exception);"", ""    doThrow(exception).when(mock).someVoidMethod();"", ""Hints:"", "" 1. missing thenReturn()"", "" 2. you are trying to stub a final method, you naughty developer!"", "" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed"", """"));
}","public void test4444() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.unfinishedStubbing((Location) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}",""
"public void nullPassedWhenCreatingInOrder() {
    throw new NullInsteadOfMockException(join(""Argument(s) passed is null!"", ""Pass mocks that require verification in order."", ""For example:"", ""    InOrder inOrder = inOrder(mockOne, mockTwo);""));
}","public void test4545() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.nullPassedWhenCreatingInOrder();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void checkedExceptionInvalid(Throwable t) {
    throw new MockitoException(join(""Checked exception is invalid for this method!"", ""Invalid: "" + t));
}","public void test4646() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.checkedExceptionInvalid((Throwable) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void noArgumentValueWasCaptured() {
    throw new MockitoException(join(""No argument value was captured!"", ""You might have forgotten to use argument.capture() in verify()..."", ""...or you used capture() in stubbing but stubbed method was not called."", ""Be aware that it is recommended to use capture() only with verify()"", """", ""Examples of correct argument capturing:"", ""    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);"", ""    verify(mock).doSomething(argument.capture());"", ""    assertEquals(\""John\"", argument.getValue().getName());"", """"));
}","public void test4747() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.noArgumentValueWasCaptured();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void fieldInitialisationThrewException(Field field, Throwable details) {
    throw new MockitoException(join(""Cannot instantiate @InjectMocks field named '"" + field.getName() + ""' of type '"" + field.getType() + ""'."", ""You haven't provided the instance at field declaration so I tried to construct the instance."", ""However the constructor or the initialization block threw an exception : "" + details.getMessage(), """"), details);
}","public void test4848() throws Throwable {
    Reporter reporter0 = new Reporter();
    SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException();
    // Undeclared exception!
    try {
        reporter0.fieldInitialisationThrewException((Field) null, sQLTransactionRollbackException0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {
    throw new InvalidUseOfMatchersException(join(""Misplaced argument matcher detected here:"", locationsOf(lastMatchers), """", ""You cannot use argument matchers outside of verification or stubbing."", ""Examples of correct usage of argument matchers:"", ""    when(mock.get(anyInt())).thenReturn(null);"", ""    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());"", ""    verify(mock).someMethod(contains(\""foo\""))"", """", ""Also, this error might show up because you use argument matchers with methods that cannot be mocked."", ""Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode()."", MockitoLimitations.NON_PUBLIC_PARENT, """"));
}","public void test4949() throws Throwable {
    Reporter reporter0 = new Reporter();
    LinkedList<LocalizedMatcher> linkedList0 = new LinkedList<LocalizedMatcher>();
    // Undeclared exception!
    try {
        reporter0.misplacedArgumentMatcher(linkedList0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {
    throw new MockitoException(StringJoiner.join(""The invocation listener with type "" + listener.getClass().getName(), ""threw an exception : "" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);
}","public void test5050() throws Throwable {
    Reporter reporter0 = new Reporter();
    VerboseMockInvocationLogger verboseMockInvocationLogger0 = new VerboseMockInvocationLogger();
    // Undeclared exception!
    try {
        reporter0.invocationListenerThrewException(verboseMockInvocationLogger0, (Throwable) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {
    ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
    String scenario = scenarioPrinter.print(invocations);
    throw new NoInteractionsWanted(join(""No interactions wanted here:"", new LocationImpl(), ""But found this interaction on mock '"" + undesired.getMock() + ""':"", undesired.getLocation(), scenario));
}","public void test5151() throws Throwable {
    Reporter reporter0 = new Reporter();
    LinkedList<VerificationAwareInvocation> linkedList0 = new LinkedList<VerificationAwareInvocation>();
    // Undeclared exception!
    try {
        reporter0.noMoreInteractionsWanted((Invocation) null, linkedList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void wantedButNotInvoked(DescribedInvocation wanted) {
    throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));
}","public void test5252() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.wantedButNotInvoked((DescribedInvocation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void nullPassedToVerifyNoMoreInteractions() {
    throw new NullInsteadOfMockException(join(""Argument(s) passed is null!"", ""Examples of correct verifications:"", ""    verifyNoMoreInteractions(mockOne, mockTwo);"", ""    verifyZeroInteractions(mockOne, mockTwo);""));
}","public void test5353() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.nullPassedToVerifyNoMoreInteractions();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {
    throw new MockitoException(join(""Mocked type must be the same as the type of your spied instance."", ""Mocked type must be: "" + spiedInstance.getClass().getSimpleName() + "", but is: "" + mockedType.getSimpleName(), ""  //correct spying:"", ""  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );"", ""  //incorrect - types don't match:"", ""  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );""));
}","public void test5454() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<Object> class0 = Object.class;
    // Undeclared exception!
    try {
        reporter0.mockedTypeIsInconsistentWithSpiedInstanceType(class0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotCallAbstractRealMethod() {
    throw new MockitoException(join(""Cannot call abstract real method on java object!"", ""Calling real methods is only possible when mocking non abstract method."", ""  //correct example:"", ""  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();""));
}","public void test5555() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.cannotCallAbstractRealMethod();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void stubPassedToVerify() {
    throw new CannotVerifyStubOnlyMock(join(""Argument passed to verify() is a stubOnly() mock, not a full blown mock!"", ""If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.""));
}","public void test5656() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.stubPassedToVerify();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {
    String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);
    throw new VerificationInOrderFailure(join(""Verification in order failure:"" + message));
}","public void test5757() throws Throwable {
    Reporter reporter0 = new Reporter();
    org.mockito.internal.reporting.Discrepancy discrepancy0 = new org.mockito.internal.reporting.Discrepancy((-3232), (-3232));
    // Undeclared exception!
    try {
        reporter0.tooLittleActualInvocationsInOrder(discrepancy0, (DescribedInvocation) null, (Location) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {
    throw new NeverWantedButInvoked(join(wanted.toString(), ""Never wanted here:"", new LocationImpl(), ""But invoked here:"", firstUndesired, """"));
}","public void test5858() throws Throwable {
    Reporter reporter0 = new Reporter();
    LocationImpl locationImpl0 = new LocationImpl();
    // Undeclared exception!
    try {
        reporter0.neverWantedButInvoked((DescribedInvocation) null, locationImpl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
    throw new MockitoException(join(""Mocked type must be the same as the type of your delegated instance."", ""Mocked type must be: "" + delegatedInstance.getClass().getSimpleName() + "", but is: "" + mockedType.getSimpleName(), ""  //correct delegate:"", ""  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );"", ""  //incorrect - types don't match:"", ""  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );""));
}","public void test5959() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<InvocationMatcher> class0 = InvocationMatcher.class;
    // Undeclared exception!
    try {
        reporter0.mockedTypeIsInconsistentWithDelegatedInstanceType(class0, class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void notAMockPassedToVerifyNoMoreInteractions() {
    throw new NotAMockException(join(""Argument(s) passed is not a mock!"", ""Examples of correct verifications:"", ""    verifyNoMoreInteractions(mockOne, mockTwo);"", ""    verifyZeroInteractions(mockOne, mockTwo);"", """"));
}","public void test6060() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.notAMockPassedToVerifyNoMoreInteractions();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
    throw new MockitoException(join(""Mockito couldn't inject mock dependency '"" + safelyGetMockName(matchingMock) + ""' on field "", ""'"" + field + ""'"", ""whose type '"" + field.getDeclaringClass().getCanonicalName() + ""' was annotated by @InjectMocks in your test."", ""Also I failed because: "" + exceptionCauseMessageIfAvailable(details), """"), details);
}","public void test6161() throws Throwable {
    Reporter reporter0 = new Reporter();
    SQLInvalidAuthorizationSpecException sQLInvalidAuthorizationSpecException0 = new SQLInvalidAuthorizationSpecException(""Invalid XPath : "");
    // Undeclared exception!
    try {
        reporter0.cannotInjectDependency((Field) null, (Object) null, sQLInvalidAuthorizationSpecException0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void missingMethodInvocation() {
    throw new MissingMethodInvocationException(join(""when() requires an argument which has to be 'a method call on a mock'."", ""For example:"", ""    when(mock.getArticles()).thenReturn(articles);"", """", ""Also, this error might show up because:"", ""1. you stub either of: final/private/equals()/hashCode() methods."", ""   Those methods *cannot* be stubbed/verified."", ""   "" + MockitoLimitations.NON_PUBLIC_PARENT, ""2. inside when() you don't call method on mock but on some other object."", """"));
}","public void test6262() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.missingMethodInvocation();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {
    throw new WrongTypeOfReturnValue(join(""The argument of type '"" + actualType.getSimpleName() + ""' cannot be returned because the following "", ""method should return the type '"" + expectedType + ""'"", "" -> "" + safelyGetMockName(invocation.getMock()) + ""."" + invocation.getMethod().getName() + ""()"", """", ""The reason for this error can be :"", ""1. The wanted argument position is incorrect."", ""2. The answer is used on the wrong interaction."", """", ""Position of the wanted argument is "" + argumentIndex + "" and "" + possibleArgumentTypesOf(invocation), ""***"", ""However if you're still unsure why you're getting above error read on."", ""Due to the nature of the syntax above problem might occur because:"", ""1. This exception *might* occur in wrongly written multi-threaded tests."", ""   Please refer to Mockito FAQ on limitations of concurrency testing."", ""2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - "", ""   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method."", """"));
}","public void test6363() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<Integer> class0 = Integer.class;
    // Undeclared exception!
    try {
        reporter0.wrongTypeOfArgumentToReturn((InvocationOnMock) null, ""jQ"", class0, 1183);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void reportNoSubMatchersFound(String additionalMatcherName) {
    throw new InvalidUseOfMatchersException(join(""No matchers found for additional matcher "" + additionalMatcherName, new LocationImpl(), """"));
}","public void test6464() throws Throwable {
    Reporter reporter0 = new Reporter();
    // Undeclared exception!
    try {
        reporter0.reportNoSubMatchersFound(""   "");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {
    throw new MockitoException(join(""extraInterfaces() does not accept the same type as the mocked type."", ""You mocked following type: "" + wrongType.getSimpleName(), ""and you passed the same very interface to the extraInterfaces()""));
}","public void test6565() throws Throwable {
    Reporter reporter0 = new Reporter();
    Class<Integer> class0 = Integer.class;
    // Undeclared exception!
    try {
        reporter0.extraInterfacesCannotContainMockedType(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {
    throw new InvalidUseOfMatchersException(join(""Misplaced argument matcher detected here:"", locationsOf(lastMatchers), """", ""You cannot use argument matchers outside of verification or stubbing."", ""Examples of correct usage of argument matchers:"", ""    when(mock.get(anyInt())).thenReturn(null);"", ""    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());"", ""    verify(mock).someMethod(contains(\""foo\""))"", """", ""Also, this error might show up because you use argument matchers with methods that cannot be mocked."", ""Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode()."", MockitoLimitations.NON_PUBLIC_PARENT, """"));
}","public void test6666() throws Throwable {
    Reporter reporter0 = new Reporter();
    LinkedList<LocalizedMatcher> linkedList0 = new LinkedList<LocalizedMatcher>();
    linkedList0.add((LocalizedMatcher) null);
    // Undeclared exception!
    try {
        reporter0.misplacedArgumentMatcher(linkedList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
"public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {
    String allInvocations;
    if (invocations.isEmpty()) {
        allInvocations = ""Actually, there were zero interactions with this mock.\n"";
    } else {
        StringBuilder sb = new StringBuilder(""\nHowever, there were other interactions with this mock:\n"");
        for (DescribedInvocation i : invocations) {
            sb.append(i.toString()).append(""\n"").append(i.getLocation()).append(""\n\n"");
        }
        allInvocations = sb.toString();
    }
    String message = createWantedButNotInvokedMessage(wanted);
    throw new WantedButNotInvoked(message + allInvocations);
}","public void test6767() throws Throwable {
    Reporter reporter0 = new Reporter();
    ArrayList<InvocationImpl> arrayList0 = new ArrayList<InvocationImpl>();
    arrayList0.add((InvocationImpl) null);
    // Undeclared exception!
    try {
        reporter0.wantedButNotInvoked((DescribedInvocation) null, (List<? extends DescribedInvocation>) arrayList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.exceptions.Reporter"", e);
    }
}",""
