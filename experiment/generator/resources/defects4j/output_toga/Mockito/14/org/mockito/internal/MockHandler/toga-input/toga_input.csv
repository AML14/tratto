focal_method,test_prefix,docstring
"public VoidMethodStubbable<T> voidMethodStubbable(T mock) {
    return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);
}","public void test00() throws Throwable {
    MockHandler<Locale.Category> mockHandler0 = new MockHandler<Locale.Category>();
    Locale.Category locale_Category0 = Locale.Category.FORMAT;
    VoidMethodStubbable<Locale.Category> voidMethodStubbable0 = mockHandler0.voidMethodStubbable(locale_Category0);
    assertNotNull(voidMethodStubbable0);
}",""
"@SuppressWarnings(""unchecked"")
public void setAnswersForStubbing(List<Answer> answers) {
    invocationContainerImpl.setAnswersForStubbing(answers);
}","public void test22() throws Throwable {
    MockHandler<Object> mockHandler0 = new MockHandler<Object>();
    // Undeclared exception!
    try {
        mockHandler0.setAnswersForStubbing((List<Answer>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.ArrayList"", e);
    }
}",""
"public boolean hasAnswersForStubbing() {
    return !answersForStubbing.isEmpty();
}","public void test33() throws Throwable {
    MockHandler<Object> mockHandler0 = new MockHandler<Object>();
    InvocationContainerImpl invocationContainerImpl0 = (InvocationContainerImpl) mockHandler0.getInvocationContainer();
    assertFalse(invocationContainerImpl0.hasAnswersForStubbing());
}",""
"public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();
    //if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        //We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest
        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);
        verificationMode.verify(data);
        return null;
    }
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}","public void test44() throws Throwable {
    Invocation invocation0 = mock(Invocation.class, new ViolatedAssumptionAnswer());
    MockHandler<String> mockHandler0 = new MockHandler<String>();
    try {
        mockHandler0.handle(invocation0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.internal.MockHandler"", e);
    }
}",""
"public Object handle(Invocation invocation) throws Throwable {
    if (invocationContainerImpl.hasAnswersForStubbing()) {
        // stubbing voids with stubVoid() or doAnswer() style
        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
        invocationContainerImpl.setMethodForStubbing(invocationMatcher);
        return null;
    }
    VerificationMode verificationMode = mockingProgress.pullVerificationMode();
    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);
    mockingProgress.validateState();
    //if verificationMode is not null then someone is doing verify()
    if (verificationMode != null) {
        //We need to check if verification was started on the correct mock
        // - see VerifyingWithAnExtraCallToADifferentMockTest
        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);
        verificationMode.verify(data);
        return null;
    }
    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
    mockingProgress.reportOngoingStubbing(ongoingStubbing);
    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
    if (stubbedInvocation != null) {
        stubbedInvocation.captureArgumentsFrom(invocation);
        return stubbedInvocation.answer(invocation);
    } else {
        Object ret = mockSettings.getDefaultAnswer().answer(invocation);
        // redo setting invocation for potential stubbing in case of partial
        // mocks / spies.
        // Without it, the real method inside 'when' might have delegated
        // to other self method and overwrite the intended stubbed method
        // with a different one.
        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
        return ret;
    }
}","public void test55() throws Throwable {
    MockHandler<String> mockHandler0 = new MockHandler<String>();
    mockHandler0.invocationContainerImpl.addAnswerForVoidMethod((Answer) null);
    try {
        mockHandler0.handle((Invocation) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.mockito.internal.invocation.InvocationMatcher"", e);
    }
}",""
