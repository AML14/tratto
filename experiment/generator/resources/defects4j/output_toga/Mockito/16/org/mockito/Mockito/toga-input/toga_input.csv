focal_method,test_prefix,docstring
"public static <T> T mock(Class<T> classToMock) {
    return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
}","public void test000() throws Throwable {
    Class<String> class0 = String.class;
    // Undeclared exception!
    try {
        Mockito.mock(class0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Creates mock object of given class or interface.
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param classToMock class or interface to mock
 * @return mock object
 */"
"public static Stubber doNothing() {
    return MOCKITO_CORE.doAnswer(new DoesNothing());
}","public void test011() throws Throwable {
    Stubber stubber0 = Mockito.doNothing();
    assertNotNull(stubber0);
}","/**
 * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b>
 * However, there are rare situations when doNothing() comes handy:
 * <p>
 * 1. Stubbing consecutive calls on a void method:
 * <pre>
 *   doNothing().
 *   doThrow(new RuntimeException())
 *   .when(mock).someVoidMethod();
 *
 *   //does nothing the first time:
 *   mock.someVoidMethod();
 *
 *   //throws RuntimeException the next time:
 *   mock.someVoidMethod();
 * </pre>
 *
 * 2. When you spy real objects and you want the void method to do nothing:
 * <pre>
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //let's make clear() do nothing
 *   doNothing().when(spy).clear();
 *
 *   spy.add(""one"");
 *
 *   //clear() does nothing, so the list still contains ""one""
 *   spy.clear();
 * </pre>
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @return stubber - to select a method for stubbing
 */"
"public static <T> T verify(T mock, VerificationMode mode) {
    return MOCKITO_CORE.verify(mock, mode);
}","public void test022() throws Throwable {
    VerificationMode verificationMode0 = Mockito.only();
    // Undeclared exception!
    try {
        Mockito.verify("";XQ"", verificationMode0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Verifies certain behavior happened at least once / exact number of times / never. E.g:
 * <pre>
 *   verify(mock, times(5)).someMethod(""was called five times"");
 *
 *   verify(mock, atLeast(2)).someMethod(""was called at least two times"");
 *
 *   //you can use flexible argument matchers, e.g:
 *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);
 * </pre>
 *
 * <b>times(1) is the default</b> and can be omitted
 * <p>
 * Arguments passed are compared using equals() method.
 * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
 * <p>
 *
 * @param mock to be verified
 * @param mode times(x), atLeastOnce() or never()
 *
 * @return mock object itself
 */"
"public static <T> OngoingStubbing<T> when(T methodCall) {
    return MOCKITO_CORE.when(methodCall);
}","public void test033() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.when(""TH<$5{*%#x64% "");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
 * <p>
 * Simply put: ""<b>When</b> the x method is called <b>then</b> return y"".
 * <p>
 * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>
 * <p>
 * Examples:
 *
 * <pre>
 * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);
 *
 * //you can use flexible argument matchers, e.g:
 * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);
 *
 * //setting exception to be thrown:
 * when(mock.someMethod(""some arg"")).thenThrow(new RuntimeException());
 *
 * //you can set different behavior for consecutive method calls.
 * //Last stubbing (e.g: thenReturn(""foo"")) determines the behavior of further consecutive calls.
 * when(mock.someMethod(""some arg""))
 *  .thenThrow(new RuntimeException())
 *  .thenReturn(""foo"");
 *
 * //Alternative, shorter version for consecutive stubbing:
 * when(mock.someMethod(""some arg""))
 *  .thenReturn(""one"", ""two"");
 * //is the same as:
 * when(mock.someMethod(""some arg""))
 *  .thenReturn(""one"")
 *  .thenReturn(""two"");
 *
 * //shorter version for consecutive method calls throwing exceptions:
 * when(mock.someMethod(""some arg""))
 *  .thenThrow(new RuntimeException(), new NullPointerException();
 *
 * </pre>
 *
 * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}
 * <p>
 * Stubbing can be overridden: for example common stubbing can go to fixture
 * setup but the test methods can override it.
 * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
 * <p>
 * Once stubbed, the method will always return stubbed value regardless
 * of how many times it is called.
 * <p>
 * Last stubbing is more important - when you stubbed the same method with
 * the same arguments many times.
 * <p>
 * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 * Let's say you've stubbed foo.bar().
 * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
 * If your code doesn't care what get(0) returns then it should not be stubbed.
 * Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
 *
 * <p>
 * See examples in javadoc for {@link Mockito} class
 * @param methodCall method to be stubbed
 */"
"public static void verifyZeroInteractions(Object... mocks) {
    MOCKITO_CORE.verifyNoMoreInteractions(mocks);
}","public void test044() throws Throwable {
    Object[] objectArray0 = new Object[0];
    // Undeclared exception!
    try {
        Mockito.verifyZeroInteractions(objectArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Verifies that no interactions happened on given mocks.
 * <pre>
 *   verifyZeroInteractions(mockOne, mockTwo);
 * </pre>
 * This method will also detect invocations
 * that occurred before the test method, for example: in setUp(), &#064;Before method or in constructor.
 * Consider writing nice code that makes interactions only in test methods.
 * <p>
 * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param mocks to be verified
 */"
"public static <T> void reset(T... mocks) {
    MOCKITO_CORE.reset(mocks);
}","public void test055() throws Throwable {
    Object[] objectArray0 = new Object[0];
    Mockito.reset(objectArray0);
    assertEquals(0, objectArray0.length);
}","/**
 * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
 * Normally, you don't need to reset your mocks, just create new mocks for each test method.
 * <p>
 * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.
 * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.
 * Follow the whisper of your test methods: ""Please keep us small & focused on single behavior"".
 * There are several threads about it on mockito mailing list.
 * <p>
 * The only reason we added reset() method is to
 * make it possible to work with container-injected mocks.
 * See issue 55 (<a href=""http://code.google.com/p/mockito/issues/detail?id=55"">here</a>)
 * or FAQ (<a href=""http://code.google.com/p/mockito/wiki/FAQ"">here</a>).
 * <p>
 * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much).
 * <pre>
 *   List mock = mock(List.class);
 *   when(mock.size()).thenReturn(10);
 *   mock.add(1);
 *
 *   reset(mock);
 *   //at this point the mock forgot any interactions & stubbing
 * </pre>
 *
 * @param <T>
 * @param mocks to be reset
 */"
"public static Stubber doCallRealMethod() {
    return MOCKITO_CORE.doAnswer(new CallsRealMethods());
}","public void test066() throws Throwable {
    Stubber stubber0 = Mockito.doCallRealMethod();
    assertNotNull(stubber0);
}","/**
 * Use doCallRealMethod() when you want to call the real implementation of a method.
 * <p>
 * As usual you are going to read <b>the partial mock warning</b>:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't...
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * <p>
 * However, there are rare cases when partial mocks come handy:
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 * <p>
 * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
 * <b>Mockito.spy() is a recommended way of creating partial mocks.</b>
 * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.
 * <p>
 * Example:
 * <pre>
 *   Foo mock = mock(Foo.class);
 *   doCallRealMethod().when(mock).someVoidMethod();
 *
 *   // this will call the real implementation of Foo.someVoidMethod()
 *   mock.someVoidMethod();
 * </pre>
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @return stubber - to select a method for stubbing
 */"
"public static <T> T mock(Class<T> classToMock, String name) {
    return mock(classToMock, withSettings().name(name).defaultAnswer(RETURNS_DEFAULTS));
}","public void test077() throws Throwable {
    Class<Object> class0 = Object.class;
    // Undeclared exception!
    try {
        Mockito.mock(class0, ""\""YWG@lYX?RbomF/kLU"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
 * <p>
 * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
 * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
 * <p>
 * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}
 * <p>
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @param classToMock class or interface to mock
 * @param name of the mock
 * @return mock object
 */"
"/*
     * Helps debugging failing tests.
     * <p>
     * TODO: add more info & examples.
     */
public static MockitoDebugger debug() {
    return new MockitoDebuggerImpl();
}","public void test088() throws Throwable {
    MockitoDebugger mockitoDebugger0 = Mockito.debug();
    assertNotNull(mockitoDebugger0);
}",""
"public static VerificationMode never() {
    return times(0);
}","public void test099() throws Throwable {
    VerificationMode verificationMode0 = Mockito.never();
    assertNotNull(verificationMode0);
}","/**
 * Alias to times(0), see {@link Mockito#times(int)}
 * <p>
 * Verifies that interaction did not happen. E.g:
 * <pre>
 *   verify(mock, never()).someMethod();
 * </pre>
 *
 * <p>
 * If you want to verify there were NO interactions with the mock
 * check out {@link Mockito#verifyZeroInteractions(Object...)}
 * or {@link Mockito#verifyNoMoreInteractions(Object...)}
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @return verification mode
 */"
"public static InOrder inOrder(Object... mocks) {
    return MOCKITO_CORE.inOrder(mocks);
}","public void test1010() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.inOrder((Object[]) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Creates InOrder object that allows verifying mocks in order.
 *
 * <pre>
 *   InOrder inOrder = inOrder(firstMock, secondMock);
 *
 *   inOrder.verify(firstMock).add(""was called first"");
 *   inOrder.verify(secondMock).add(""was called second"");
 * </pre>
 *
 * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one
 * but only those that you are interested in testing in order.
 * <p>
 * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param mocks to be verified in order
 *
 * @return InOrder object to be used to verify in order
 */"
"public static <T> T spy(T object) {
    return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings().spiedInstance(object).defaultAnswer(CALLS_REAL_METHODS));
}","public void test1111() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.spy((Object) ""uS"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
 * <p>
 * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
 * <p>
 * As usual you are going to read <b>the partial mock warning</b>:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't...
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * <p>
 * However, there are rare cases when partial mocks come handy:
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 * <p>
 * Example:
 *
 * <pre>
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //optionally, you can stub out some methods:
 *   when(spy.size()).thenReturn(100);
 *
 *   //using the spy calls <b>real</b> methods
 *   spy.add(""one"");
 *   spy.add(""two"");
 *
 *   //prints ""one"" - the first element of a list
 *   System.out.println(spy.get(0));
 *
 *   //size() method was stubbed - 100 is printed
 *   System.out.println(spy.size());
 *
 *   //optionally, you can verify
 *   verify(spy).add(""one"");
 *   verify(spy).add(""two"");
 * </pre>
 *
 * <h4>Important gotcha on spying real objects!</h4>
 *
 * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
 *
 * <pre>
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
 *   when(spy.get(0)).thenReturn(""foo"");
 *
 *   //You have to use doReturn() for stubbing
 *   doReturn(""foo"").when(spy).get(0);
 * </pre>
 *
 * 2. Watch out for final methods.
 * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
 * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
 * Typically you may get a NullPointerException because mock instances don't have fields initiated.
 *
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param object
 *            to spy on
 * @return a spy of the real object
 */"
"public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
    return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
}","public void test1212() throws Throwable {
    Class<String> class0 = String.class;
    Answer<Object> answer0 = Mockito.RETURNS_DEFAULTS;
    // Undeclared exception!
    try {
        Mockito.mock(class0, (Answer) answer0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Creates mock with a specified strategy for its answers to interactions.
 * It's quite advanced feature and typically you don't need it to write decent tests.
 * However it can be helpful when working with legacy systems.
 * <p>
 * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
 *
 * <pre>
 *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
 *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 * </pre>
 *
 * <p>See examples in javadoc for {@link Mockito} class</p>
 *
 * @param classToMock class or interface to mock
 * @param defaultAnswer default answer for unstubbed methods
 *
 * @return mock object
 */"
"public static Stubber doAnswer(Answer answer) {
    return MOCKITO_CORE.doAnswer(answer);
}","public void test1414() throws Throwable {
    Stubber stubber0 = Mockito.doAnswer((Answer) null);
    assertNotNull(stubber0);
}","/**
 * Use doAnswer() when you want to stub a void method with generic {@link Answer}.
 * <p>
 * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
 * <p>
 * Example:
 *
 * <pre>
 *  doAnswer(new Answer() {
 *      public Object answer(InvocationOnMock invocation) {
 *          Object[] args = invocation.getArguments();
 *          Mock mock = invocation.getMock();
 *          return null;
 *      }})
 *  .when(mock).someMethod();
 * </pre>
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param answer to answer when the stubbed method is called
 * @return stubber - to select a method for stubbing
 */"
"public static VerificationMode atMost(int maxNumberOfInvocations) {
    return VerificationModeFactory.atMost(maxNumberOfInvocations);
}","public void test1515() throws Throwable {
    VerificationMode verificationMode0 = Mockito.atMost(0);
    assertNotNull(verificationMode0);
}","/**
 * Allows at-most-x verification. E.g:
 * <pre>
 *   verify(mock, atMost(3)).someMethod(""some arg"");
 * </pre>
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @param maxNumberOfInvocations max number of invocations
 *
 * @return verification mode
 */"
"public static <T> VoidMethodStubbable<T> stubVoid(T mock) {
    return MOCKITO_CORE.stubVoid(mock);
}","public void test1616() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.stubVoid(""Zk_mhRIBa<tWv-i"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * <pre>
 *   //Instead of:
 *   stubVoid(mock).toThrow(e).on().someVoidMethod();
 *
 *   //Please do:
 *   doThrow(e).when(mock).someVoidMethod();
 * </pre>
 *
 * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods.
 * <p>
 * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:
 *
 * <pre>
 * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();
 *
 * //you can stub with different behavior for consecutive calls.
 * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.
 * stubVoid(mock)
 *   .toThrow(new RuntimeException())
 *   .toReturn()
 *   .on().someMethod();
 * </pre>
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids
 *
 * @param mock
 *            to stub
 * @return stubbable object that allows stubbing with throwable
 */"
"@Deprecated
public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {
    return MOCKITO_CORE.stub(methodCall);
}","public void test1717() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.stub("""");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * <pre>
 *   //Instead of:
 *   stub(mock.count()).toReturn(10);
 *
 *   //Please do:
 *   when(mock.count()).thenReturn(10);
 * </pre>
 *
 * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)}
 * <p>
 * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:
 * <pre>
 *   Mockito.stub;  <i>replace with:</i>  Mockito.when;
 *   stub(          <i>replace with:</i>  when(
 *   .toReturn(     <i>replace with:</i>  .thenReturn(
 *   .toThrow(      <i>replace with:</i>  .thenThrow(
 *   .toAnswer(     <i>replace with:</i>  .thenAnswer(
 * </pre>
 * If you're an existing user then sorry for making your code littered with deprecation warnings.
 * This change was required to make Mockito better.
 *
 * @param methodCall
 *            method call
 * @return DeprecatedOngoingStubbing object to set stubbed value/exception
 */"
"public static void verifyNoMoreInteractions(Object... mocks) {
    MOCKITO_CORE.verifyNoMoreInteractions(mocks);
}","public void test1818() throws Throwable {
    String[] stringArray0 = new String[1];
    // Undeclared exception!
    try {
        Mockito.verifyNoMoreInteractions(stringArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Checks if any of given mocks has any unverified interaction.
 * <p>
 * You can use this method after you verified your mocks - to make sure that nothing
 * else was invoked on your mocks.
 * <p>
 * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
 * <p>
 * Stubbed invocations (if called) are also treated as interactions.
 * <p>
 * A word of <b>warning</b>:
 * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method.
 * verifyNoMoreInteractions() is not recommended to use in every test method.
 * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 * Abusing it leads to overspecified, less maintainable tests. You can find further reading
 * <a href=""http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/"">here</a>.
 * <p>
 * This method will also detect unverified invocations that occurred before the test method,
 * for example: in setUp(), &#064;Before method or in constructor.
 * Consider writing nice code that makes interactions only in test methods.
 *
 * <p>
 * Example:
 *
 * <pre>
 * //interactions
 * mock.doSomething();
 * mock.doSomethingUnexpected();
 *
 * //verification
 * verify(mock).doSomething();
 *
 * //following will fail because 'doSomethingUnexpected()' is unexpected
 * verifyNoMoreInteractions(mock);
 *
 * </pre>
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @param mocks to be verified
 */"
"public static VerificationMode atLeastOnce() {
    return VerificationModeFactory.atLeastOnce();
}","public void test1919() throws Throwable {
    VerificationMode verificationMode0 = Mockito.atLeastOnce();
    assertNotNull(verificationMode0);
}","/**
 * Allows at-least-once verification. E.g:
 * <pre>
 *   verify(mock, atLeastOnce()).someMethod(""some arg"");
 * </pre>
 * Alias to atLeast(1)
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @return verification mode
 */"
"public static VerificationMode atLeast(int minNumberOfInvocations) {
    return VerificationModeFactory.atLeast(minNumberOfInvocations);
}","public void test2020() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.atLeast((-5));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Allows at-least-x verification. E.g:
 * <pre>
 *   verify(mock, atLeast(3)).someMethod(""some arg"");
 * </pre>
 *
 * See examples in javadoc for {@link Mockito} class
 *
 * @param minNumberOfInvocations minimum number of invocations
 *
 * @return verification mode
 */"
"public static Stubber doReturn(Object toBeReturned) {
    return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));
}","public void test2121() throws Throwable {
    VerificationMode verificationMode0 = Mockito.only();
    Stubber stubber0 = Mockito.doReturn(verificationMode0);
    assertNotNull(stubber0);
}","/**
 * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.
 * <p>
 * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
 * and more readable</b> (especially when stubbing consecutive calls).
 * <p>
 * Here are those rare occasions when doReturn() comes handy:
 * <p>
 *
 * 1. When spying real objects and calling real methods on a spy brings side effects
 *
 * <pre>
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
 *   when(spy.get(0)).thenReturn(""foo"");
 *
 *   //You have to use doReturn() for stubbing:
 *   doReturn(""foo"").when(spy).get(0);
 * </pre>
 *
 * 2. Overriding a previous exception-stubbing:
 *
 * <pre>
 *   when(mock.foo()).thenThrow(new RuntimeException());
 *
 *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
 *   when(mock.foo()).thenReturn(""bar"");
 *
 *   //You have to use doReturn() for stubbing:
 *   doReturn(""bar"").when(mock).foo();
 * </pre>
 *
 * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though.
 * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
 * overridding stubbing is a potential code smell that points out too much stubbing.
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param toBeReturned to be returned when the stubbed method is called
 * @return stubber - to select a method for stubbing
 */"
"public static <T> T verify(T mock) {
    return MOCKITO_CORE.verify(mock, times(1));
}","public void test2222() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.verify((Object) ""'oL.~H?Uxt#r=W.P@&"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Verifies certain behavior <b>happened once</b>
 * <p>
 * Alias to <code>verify(mock, times(1))</code> E.g:
 * <pre>
 *   verify(mock).someMethod(""some arg"");
 * </pre>
 * Above is equivalent to:
 * <pre>
 *   verify(mock, times(1)).someMethod(""some arg"");
 * </pre>
 * <p>
 * Arguments passed are compared using equals() method.
 * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
 * <p>
 * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 * Let's say you've stubbed foo.bar().
 * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
 * If your code doesn't care what get(0) returns then it should not be stubbed.
 * Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
 *
 * <p>
 * See examples in javadoc for {@link Mockito} class
 *
 * @param mock to be verified
 * @return mock object itself
 */"
"public static void validateMockitoUsage() {
    MOCKITO_CORE.validateMockitoUsage();
}","public void test2323() throws Throwable {
    // Undeclared exception!
    try {
        Mockito.validateMockitoUsage();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=""http://code.google.com/p/mockito/wiki/FAQ"">http://code.google.com/p/mockito/wiki/FAQ</a>
 * <p>
 * In case of questions you may also post to mockito mailing list: <a href=""http://groups.google.com/group/mockito"">http://groups.google.com/group/mockito</a>
 * <p>
 * validateMockitoUsage() <b>explicitly validates</b> the framework state to detect invalid use of Mockito.
 * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.
 * <p>
 * Examples of incorrect use:
 * <pre>
 * //Oups, someone forgot thenReturn() part:
 * when(mock.get());
 *
 * //Oups, someone put the verified method call inside verify() where it should be outside:
 * verify(mock.execute());
 *
 * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:
 * verify(mock);
 * </pre>
 *
 * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
 * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.).
 * But even though the exception might be thrown in the next test,
 * the exception <b>message contains a navigable stack trace element</b> with location of the defect.
 * Hence you can click and find the place where Mockito was misused.
 * <p>
 * Sometimes though, you might want to validate the framework usage explicitly.
 * For example, one of the users wanted to put validateMockitoUsage() in his &#064;After method
 * so that he knows immediately when he misused Mockito.
 * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.
 * One more benefit of having validateMockitoUsage() in &#064;After is that jUnit runner will always fail in the test method with defect
 * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.
 * But even though JUnit might report next test as red, don't worry about it
 * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
 * <p>
 * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.
 * <p>
 * Bear in mind that <b>usually you don't have to validateMockitoUsage()</b>
 * and framework validation triggered on next-time basis should be just enough,
 * mainly because of enhanced exception message with clickable location of defect.
 * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
 * (like your own runner or base class for all tests) because adding a special action to &#064;After has zero cost.
 * <p>
 * See examples in javadoc for {@link Mockito} class
 */"
"public static Stubber doThrow(Throwable toBeThrown) {
    return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));
}","public void test2424() throws Throwable {
    Stubber stubber0 = Mockito.doThrow((Throwable) null);
    assertNotNull(stubber0);
}","/**
 * Use doThrow() when you want to stub the void method with an exception.
 * <p>
 * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
 * <p>
 * Example:
 *
 * <pre>
 *   doThrow(new RuntimeException()).when(mock).someVoidMethod();
 * </pre>
 *
 * @param toBeThrown to be thrown when the stubbed method is called
 * @return stubber - to select a method for stubbing
 */"
