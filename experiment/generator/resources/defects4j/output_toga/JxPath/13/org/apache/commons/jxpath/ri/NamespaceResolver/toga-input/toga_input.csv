focal_method,test_prefix,docstring
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test000() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    QName qName0 = new QName(""+THH#@na:M"", """");
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    String string0 = namespaceResolver0.getNamespaceURI(""<<unknown namespace>>"");
    assertNull(string0);
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public boolean isSealed() {
    return sealed;
}","public void test011() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    namespaceResolver0.seal();
    boolean boolean0 = namespaceResolver0.isSealed();
    assertTrue(boolean0);
}","/**
 * Learn whether this NamespaceResolver has been sealed.
 * @return
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test022() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    QName qName0 = new QName((String) null, ""j;"");
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver0.registerNamespace("""", ""SdpXe2"");
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    String string0 = namespaceResolver0.getPrefix(""SdpXe2"");
    assertEquals("""", string0);
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test034() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    namespaceResolver0.registerNamespace(""<<unknown namespace>>"", ""<<unknown namespace>>"");
    String string0 = namespaceResolver0.getNamespaceURI(""<<unknown namespace>>"");
    assertEquals(""<<unknown namespace>>"", string0);
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public synchronized void registerNamespace(String prefix, String namespaceURI) {
    if (isSealed()) {
        throw new IllegalStateException(""Cannot register namespaces on a sealed NamespaceResolver"");
    }
    namespaceMap.put(prefix, namespaceURI);
    reverseMap = null;
}","public void test045() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    namespaceResolver0.namespaceMap = null;
    // Undeclared exception!
    try {
        namespaceResolver0.registerNamespace(""xml:space"", ""xml:space"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Registers a namespace prefix.
 *
 * @param prefix A namespace prefix
 * @param namespaceURI A URI for that prefix
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test056() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    namespaceResolver0.reverseMap = hashMap0;
    Integer integer0 = new Integer(2427);
    hashMap0.put("""", integer0);
    // Undeclared exception!
    try {
        namespaceResolver0.getPrefix("""");
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test067() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    namespaceResolver0.namespaceMap = null;
    // Undeclared exception!
    try {
        namespaceResolver0.getNamespaceURI("""");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test078() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    HashMap<String, NamespaceResolver> hashMap0 = new HashMap<String, NamespaceResolver>();
    hashMap0.put(""o"", namespaceResolver0);
    namespaceResolver0.namespaceMap = hashMap0;
    // Undeclared exception!
    try {
        namespaceResolver0.getNamespaceURI(""o"");
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.jxpath.ri.NamespaceResolver cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public boolean isSealed() {
    return sealed;
}","public void test089() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    NamespaceResolver namespaceResolver1 = new NamespaceResolver(namespaceResolver0);
    namespaceResolver1.seal();
    assertTrue(namespaceResolver1.isSealed());
}","/**
 * Learn whether this NamespaceResolver has been sealed.
 * @return
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test0910() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    NamespaceResolver namespaceResolver1 = new NamespaceResolver(namespaceResolver0);
    QName qName0 = new QName("">"");
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver1.setNamespaceContextPointer(variablePointer0);
    // Undeclared exception!
    try {
        namespaceResolver1.getPrefix(""<<unknown namespace>>"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test1011() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    QName qName0 = new QName((String) null, (String) null);
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver0.registerNamespace(""<<unknown namespace>>"", ""<<unknown namespace>>"");
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    String string0 = namespaceResolver0.getPrefix(""<<unknown namespace>>"");
    assertEquals(""<<unknown namespace>>"", string0);
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test1112() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    QName qName0 = new QName((String) null, (String) null);
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    namespaceResolver0.getPrefix(""<<unknown namespace>>"");
    String string0 = namespaceResolver0.getPrefix(""<<unknown namespace>>"");
    assertNull(string0);
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test1213() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    NamespaceResolver namespaceResolver1 = new NamespaceResolver(namespaceResolver0);
    String string0 = namespaceResolver1.getNamespaceURI(""K,':["");
    assertNull(string0);
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public Pointer getNamespaceContextPointer() {
    if (pointer == null && parent != null) {
        return parent.getNamespaceContextPointer();
    }
    return pointer;
}","public void test1314() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    NamespaceResolver namespaceResolver1 = new NamespaceResolver(namespaceResolver0);
    Pointer pointer0 = namespaceResolver1.getNamespaceContextPointer();
    assertNull(pointer0);
}","/**
 * Get the namespace context pointer.
 * @return Pointer
 */"
"public Pointer getNamespaceContextPointer() {
    if (pointer == null && parent != null) {
        return parent.getNamespaceContextPointer();
    }
    return pointer;
}","public void test1415() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver((NamespaceResolver) null);
    Pointer pointer0 = namespaceResolver0.getNamespaceContextPointer();
    assertNull(pointer0);
}","/**
 * Get the namespace context pointer.
 * @return Pointer
 */"
"public boolean isNode() {
    return !isContainer();
}","public void test1516() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    QName qName0 = new QName("">"");
    VariablePointer variablePointer0 = new VariablePointer(qName0);
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    VariablePointer variablePointer1 = (VariablePointer) namespaceResolver0.getNamespaceContextPointer();
    assertFalse(variablePointer1.isNode());
}","/**
 * @deprecated Please use !isContainer()
 */"
"public synchronized void registerNamespace(String prefix, String namespaceURI) {
    if (isSealed()) {
        throw new IllegalStateException(""Cannot register namespaces on a sealed NamespaceResolver"");
    }
    namespaceMap.put(prefix, namespaceURI);
    reverseMap = null;
}","public void test1617() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    namespaceResolver0.seal();
    // Undeclared exception!
    try {
        namespaceResolver0.registerNamespace((String) null, (String) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot register namespaces on a sealed NamespaceResolver
        //
        verifyException(""org.apache.commons.jxpath.ri.NamespaceResolver"", e);
    }
}","/**
 * Registers a namespace prefix.
 *
 * @param prefix A namespace prefix
 * @param namespaceURI A URI for that prefix
 */"
"public synchronized String getNamespaceURI(String prefix) {
    /**
     * Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3
     */
    String uri = (String) namespaceMap.get(prefix);
    if (uri == null && pointer != null) {
        uri = pointer.getNamespaceURI(prefix);
    }
    if (uri == null && parent != null) {
        return parent.getNamespaceURI(prefix);
    }
    return uri;
}","public void test1718() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver((NamespaceResolver) null);
    namespaceResolver0.registerNamespace("""", """");
    String string0 = namespaceResolver0.getNamespaceURI("""");
    assertEquals("""", string0);
}","/**
 * Given a prefix, returns a registered namespace URI. If the requested
 * prefix was not defined explicitly using the registerNamespace method,
 * JXPathContext will then check the context node to see if the prefix is
 * defined there. See
 * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
 *
 * @param prefix The namespace prefix to look up
 * @return namespace URI or null if the prefix is undefined.
 */"
"public boolean isSealed() {
    return sealed;
}","public void test1819() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    boolean boolean0 = namespaceResolver0.isSealed();
    assertFalse(boolean0);
}","/**
 * Learn whether this NamespaceResolver has been sealed.
 * @return
 */"
"public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","public void test1920() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver();
    BasicVariables basicVariables0 = new BasicVariables();
    QName qName0 = new QName("""", """");
    VariablePointer variablePointer0 = new VariablePointer(basicVariables0, qName0);
    namespaceResolver0.setNamespaceContextPointer(variablePointer0);
    // Undeclared exception!
    try {
        namespaceResolver0.getPrefix("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No such variable: ':'
        //
        verifyException(""org.apache.commons.jxpath.BasicVariables"", e);
    }
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */"
"public Object clone() {
    try {
        NamespaceResolver result = (NamespaceResolver) super.clone();
        result.sealed = false;
        return result;
    } catch (CloneNotSupportedException e) {
        // Of course, it's supported.
        e.printStackTrace();
        return null;
    }
}","public void test2021() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver((NamespaceResolver) null);
    NamespaceResolver namespaceResolver1 = (NamespaceResolver) namespaceResolver0.clone();
    assertNotSame(namespaceResolver1, namespaceResolver0);
}","/**
 * {@inheritDoc}
 * @see java.lang.Object#clone()
 */"
"public boolean isSealed() {
    return sealed;
}","public void test2022() throws Throwable {
    NamespaceResolver namespaceResolver0 = new NamespaceResolver((NamespaceResolver) null);
    NamespaceResolver namespaceResolver1 = (NamespaceResolver) namespaceResolver0.clone();
    assertFalse(namespaceResolver1.isSealed());
}","/**
 * Learn whether this NamespaceResolver has been sealed.
 * @return
 */"
