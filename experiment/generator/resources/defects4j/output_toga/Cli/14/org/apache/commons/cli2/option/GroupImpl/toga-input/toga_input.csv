focal_method,test_prefix,docstring
"public String getDescription() {
    return description;
}","public void test000() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addSwitch(groupImpl0, true);
    assertEquals(""^>Td)Y'jfHlw,D_"", groupImpl0.getDescription());
}",""
"public int getMinimum() {
    return minimum;
}","public void test001() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addSwitch(groupImpl0, true);
    assertEquals((-134), groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test002() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addSwitch(groupImpl0, true);
    assertEquals((-134), groupImpl0.getMaximum());
}",""
"public String getPreferredName() {
    return name;
}","public void test003() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addSwitch(groupImpl0, true);
    assertEquals(""DateValidator.date.OutOfRange"", groupImpl0.getPreferredName());
}",""
"public int getMaximum() {
    return maximum;
}","public void test014() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Hcw|cN^aFv%#"", ""|qXI,R?/98tI60Nb"", 982, 982);
    groupImpl0.getAnonymous();
    assertEquals(982, groupImpl0.getMaximum());
}",""
"public String getPreferredName() {
    return name;
}","public void test015() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Hcw|cN^aFv%#"", ""|qXI,R?/98tI60Nb"", 982, 982);
    groupImpl0.getAnonymous();
    assertEquals(""Hcw|cN^aFv%#"", groupImpl0.getPreferredName());
}",""
"public String getDescription() {
    return description;
}","public void test016() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Hcw|cN^aFv%#"", ""|qXI,R?/98tI60Nb"", 982, 982);
    groupImpl0.getAnonymous();
    assertEquals(""|qXI,R?/98tI60Nb"", groupImpl0.getDescription());
}",""
"public int getMinimum() {
    return minimum;
}","public void test017() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Hcw|cN^aFv%#"", ""|qXI,R?/98tI60Nb"", 982, 982);
    groupImpl0.getAnonymous();
    assertEquals(982, groupImpl0.getMinimum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test028() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 0, 0);
    int int0 = groupImpl0.getMaximum();
    assertEquals(0, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test029() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 0, 0);
    int int0 = groupImpl0.getMaximum();
    assertEquals(0, int0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test0311() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ArgumentImpl argumentImpl0 = new ArgumentImpl("""", ""DateValidator.date.OutOfRange"", 1626, 1626, 'l', 'l', (Validator) null, "">>Td)'jfHlw,D_"", linkedList0, 1626);
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", "">>Td)'jfHlw,D_"", (-134), (-134));
    groupImpl0.toString();
    assertEquals((-134), groupImpl0.getMaximum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test0412() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, ""yjdo_:x{"", 62, 569);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertEquals(569, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test0413() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, ""yjdo_:x{"", 62, 569);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertEquals(62, groupImpl0.getMinimum());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0414() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, ""yjdo_:x{"", 62, 569);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertFalse(boolean0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0516() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", (-1056), (-1056));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertTrue(boolean0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0618() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption("""", """", 14);
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", 14, 14);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""T|QhH<[\""t,Cj7|!"");
    assertTrue(boolean0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0720() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", (-1056), (-1056));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""Passes properties and values to the application"");
    assertFalse(boolean0);
}",""
"public String getDescription() {
    return description;
}","public void test0821() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""Passes properties and values to the application"", 1999, 1999);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals(""Passes properties and values to the application"", groupImpl0.getDescription());
}",""
"public String getPreferredName() {
    return name;
}","public void test0822() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""Passes properties and values to the application"", 1999, 1999);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals(""-D"", groupImpl0.getPreferredName());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0823() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""Passes properties and values to the application"", 1999, 1999);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertFalse(boolean0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test0824() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""Passes properties and values to the application"", 1999, 1999);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals(1999, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test0825() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""Passes properties and values to the application"", 1999, 1999);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals(1999, groupImpl0.getMinimum());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (commandLine.looksLikeOption(arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0927() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""DateValidator.date.OutOfRange"", ""DateValidator.date.OutOfRange"", 1626, 1626, 'l', 'l', (Validator) null, ""DateValidator.date.OutOfRange"", linkedList0, 1626);
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""ecELT)"");
    assertTrue(boolean0);
}",""
"public void process(final WriteableCommandLine commandLine, final ListIterator arguments) throws OptionException {
    String previous = null;
    // [START process each command line token
    while (arguments.hasNext()) {
        // grab the next argument
        final String arg = (String) arguments.next();
        // if we have just tried to process this instance
        if (arg == previous) {
            // rollback and abort
            arguments.previous();
            break;
        }
        // remember last processed instance
        previous = arg;
        final Option opt = (Option) optionMap.get(arg);
        // option found
        if (opt != null) {
            arguments.previous();
            opt.process(commandLine, arguments);
        } else // [START option NOT found
        {
            // it might be an anonymous argument continue search
            // [START argument may be anonymous
            if (commandLine.looksLikeOption(arg)) {
                // narrow the search
                final Collection values = optionMap.tailMap(arg).values();
                boolean foundMemberOption = false;
                for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption; ) {
                    final Option option = (Option) i.next();
                    if (option.canProcess(commandLine, arg)) {
                        foundMemberOption = true;
                        arguments.previous();
                        option.process(commandLine, arguments);
                    }
                }
                // back track and abort this group if necessary
                if (!foundMemberOption) {
                    arguments.previous();
                    return;
                }
            } else // [END argument may be anonymous
            // [START argument is NOT anonymous
            {
                // move iterator back, current value not used
                arguments.previous();
                // if there are no anonymous arguments then this group can't
                // process the argument
                if (anonymous.isEmpty()) {
                    break;
                }
                // TODO: why do we iterate over all anonymous arguments?
                // canProcess will always return true?
                for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
                    final Argument argument = (Argument) i.next();
                    if (argument.canProcess(commandLine, arguments)) {
                        argument.process(commandLine, arguments);
                    }
                }
            }
            // [END argument is NOT anonymous
        }
        // [END option NOT found
    }
    // [END process each command line token
}","public void test1028() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", 95, 95);
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add(""-D"");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    try {
        groupImpl0.process(writeableCommandLineImpl0, listIterator0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Unexpected -D while processing
        //
        verifyException(""org.apache.commons.cli2.option.PropertyOption"", e);
    }
}",""
"public int getMinimum() {
    return minimum;
}","public void test1130() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    PropertyOption propertyOption1 = new PropertyOption("""", """", (-1205));
    linkedList0.add(propertyOption1);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-1205), (-1205));
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add(""Passes properties and values to the application"");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList1);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals((-1205), groupImpl0.getMinimum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test1231() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", 95, 95);
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add(""-D"");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(95, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1232() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", 95, 95);
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add(""-D"");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(95, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test1334() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 0, 0);
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add("""");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(0, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1335() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 0, 0);
    LinkedList<String> linkedList1 = new LinkedList<String>();
    linkedList1.add("""");
    ListIterator<String> listIterator0 = linkedList1.listIterator();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(0, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test1437() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ArgumentImpl argumentImpl0 = new ArgumentImpl("""", ""DateValidator.date.OutOfRange"", 1626, 1626, 'l', 'l', (Validator) null, ""WD vn"", linkedList0, 1626);
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""DateValidator.date.OutOfRange"", ""^>Td)Y'jfHlw,D_"", (-134), (-134));
    argumentImpl0.toString();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    ListIterator<String> listIterator0 = (ListIterator<String>) mock(ListIterator.class, new ViolatedAssumptionAnswer());
    doReturn(true, false, false).when(listIterator0).hasNext();
    doReturn(""--"").when(listIterator0).next();
    doReturn(""DateValidator.date.OutOfRange"").when(listIterator0).previous();
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals((-134), groupImpl0.getMinimum());
}",""
"public String getDescription() {
    return description;
}","public void test1538() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""-D"", (-363), (-363));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals(""-D"", groupImpl0.getDescription());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1539() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""-D"", (-363), (-363));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals((-363), groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test1540() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""-D"", (-363), (-363));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals((-363), groupImpl0.getMinimum());
}",""
"public String getPreferredName() {
    return name;
}","public void test1541() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""-D"", (-363), (-363));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals(""Passes properties and values to the application"", groupImpl0.getPreferredName());
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1642() throws Throwable {
    LinkedList<Command> linkedList0 = new LinkedList<Command>();
    LinkedHashSet<Switch> linkedHashSet0 = new LinkedHashSet<Switch>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, ""-^=mE?U6H#JG\""|.\\x"", 93, 93);
    Command command0 = new Command(""|"", ""-^=mE?U6H#JG\""|.\\x"", linkedHashSet0, true, (Argument) null, groupImpl0, 33);
    linkedList0.add(command0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(command0, linkedList0);
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Missing required option |
        //
        verifyException(""org.apache.commons.cli2.option.Command"", e);
    }
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1743() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""=*>cz@9R#W8%Q&d"", ""=*>cz@9R#W8%Q&d"", (-45), (-45));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    linkedList0.offer(groupImpl0);
    // Undeclared exception!
    groupImpl0.validate(writeableCommandLineImpl0);
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1844() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""-D"", (-363), (-363));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addSwitch(propertyOption0, true);
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Unexpected -D while processing Passes properties and values to the application
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1945() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""NMZ~J)|5'/3$<OP'9t]"", ""NMZ~J)|5'/3$<OP'9t]"", 41, 41);
    LinkedList<Object> linkedList1 = new LinkedList<Object>();
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList1);
    writeableCommandLineImpl0.addSwitch(propertyOption0, true);
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Missing option NMZ~J)|5'/3$<OP'9t]
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired() || option instanceof Group;
        if (validate) {
            option.validate(commandLine);
        }
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test2046() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""org.apache.commons.cli2.DisplaySetting"", ""org.apache.commons.cli2.option.OptionImpl"", (-1409), (-1570));
    FileValidator fileValidator0 = FileValidator.getExistingFileInstance();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""org.apache.commons.cli2.option.OptionImpl"", ""org.apache.commons.cli2.option.OptionImpl"", (-1409), (-1409), '1', '1', fileValidator0, ""QIZ"", linkedList0, (-1570));
    SourceDestArgument sourceDestArgument0 = new SourceDestArgument(argumentImpl0, argumentImpl0, '\u0000', 's', ""j~"", linkedList0);
    linkedList0.add((ArgumentImpl) sourceDestArgument0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    GroupImpl groupImpl1 = new GroupImpl(linkedList0, """", ""--"", (-1570), (-1409));
    // Undeclared exception!
    try {
        groupImpl1.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Collections$EmptyIterator"", e);
    }
}",""
"public void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator) {
    final Set helpSettingsCopy = new HashSet(helpSettings);
    final boolean optional = (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);
    final boolean expanded = (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);
    final boolean named = !expanded || ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));
    final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);
    final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);
    helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);
    final boolean both = named && expanded;
    if (optional) {
        buffer.append('[');
    }
    if (named) {
        buffer.append(name);
    }
    if (both) {
        buffer.append("" ("");
    }
    if (expanded) {
        final Set childSettings;
        if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {
            childSettings = DisplaySetting.NONE;
        } else {
            childSettings = new HashSet(helpSettingsCopy);
            childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);
        }
        // grab a list of the group's options.
        final List list;
        if (comp == null) {
            // default to using the initial order
            list = options;
        } else {
            // sort options if comparator is supplied
            list = new ArrayList(options);
            Collections.sort(list, comp);
        }
        // for each option.
        for (final Iterator i = list.iterator(); i.hasNext(); ) {
            final Option option = (Option) i.next();
            // append usage information
            option.appendUsage(buffer, childSettings, comp);
            // add separators as needed
            if (i.hasNext()) {
                buffer.append(separator);
            }
        }
    }
    if (both) {
        buffer.append(')');
    }
    if (optional && outer) {
        buffer.append(']');
    }
    if (arguments) {
        for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
            buffer.append(' ');
            final Option option = (Option) i.next();
            option.appendUsage(buffer, helpSettingsCopy, comp);
        }
    }
    if (optional && !outer) {
        buffer.append(']');
    }
}","public void test2147() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Unexpected.token"", ""Unexpected.token"", 0, 0);
    LinkedHashSet<GroupImpl> linkedHashSet0 = new LinkedHashSet<GroupImpl>();
    // Undeclared exception!
    try {
        groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) null, ""[Unexpected.token ()]"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public int getMaximum() {
    return maximum;
}","public void test2248() throws Throwable {
    LinkedList<SourceDestArgument> linkedList0 = new LinkedList<SourceDestArgument>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 285, 285);
    LinkedHashSet<Switch> linkedHashSet0 = new LinkedHashSet<Switch>();
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) comparator0, (String) null);
    assertEquals(285, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2249() throws Throwable {
    LinkedList<SourceDestArgument> linkedList0 = new LinkedList<SourceDestArgument>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 285, 285);
    LinkedHashSet<Switch> linkedHashSet0 = new LinkedHashSet<Switch>();
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) comparator0, (String) null);
    assertEquals(285, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2350() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.addFirst(propertyOption0);
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", 0, 0);
    String string0 = groupImpl0.toString();
    assertEquals(0, groupImpl0.getMaximum());
}",""
"public String toString() {
    final StringBuffer buffer = new StringBuffer();
    appendUsage(buffer, DisplaySetting.ALL, null);
    return buffer.toString();
}","public void test2351() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.addFirst(propertyOption0);
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""-D"", ""-D"", 0, 0);
    String string0 = groupImpl0.toString();
    assertEquals(""[-D (-D<property>=<value>|-D<property>=<value>)]"", string0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test2452() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 0, 0);
    LinkedHashSet<GroupImpl> linkedHashSet0 = new LinkedHashSet<GroupImpl>();
    List list0 = groupImpl0.helpLines(0, linkedHashSet0, (Comparator) null);
    assertEquals(0, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2453() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 0, 0);
    LinkedHashSet<GroupImpl> linkedHashSet0 = new LinkedHashSet<GroupImpl>();
    List list0 = groupImpl0.helpLines(0, linkedHashSet0, (Comparator) null);
    assertEquals(0, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2556() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""ks9<Au"", ""ks9<Au"", 1116, 1116);
    List list0 = groupImpl0.helpLines(1116, displaySetting0.ALL, (Comparator) null);
    assertEquals(1116, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2557() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""ks9<Au"", ""ks9<Au"", 1116, 1116);
    List list0 = groupImpl0.helpLines(1116, displaySetting0.ALL, (Comparator) null);
    assertEquals(1116, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2659() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""ksucA'"", ""ksucA'"", (-1759), (-1759));
    Comparator<DisplaySetting> comparator0 = (Comparator<DisplaySetting>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines((-1759), displaySetting0.ALL, comparator0);
    assertEquals((-1759), groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2660() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    PropertyOption propertyOption0 = new PropertyOption();
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""ksucA'"", ""ksucA'"", (-1759), (-1759));
    Comparator<DisplaySetting> comparator0 = (Comparator<DisplaySetting>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines((-1759), displaySetting0.ALL, comparator0);
    assertEquals((-1759), groupImpl0.getMinimum());
}",""
"public Option findOption(final String trigger) {
    final Iterator i = getOptions().iterator();
    while (i.hasNext()) {
        final Option option = (Option) i.next();
        final Option found = option.findOption(trigger);
        if (found != null) {
            return found;
        }
    }
    return null;
}","public void test2761() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    Option option0 = groupImpl0.findOption(""-D"");
    assertNotNull(option0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test2762() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    Option option0 = groupImpl0.findOption(""-D"");
    assertEquals((-330), groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2763() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    Option option0 = groupImpl0.findOption(""-D"");
    assertEquals((-330), groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2864() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    groupImpl0.findOption(""Passes properties and values to the application"");
    assertEquals((-330), groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2865() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    groupImpl0.findOption(""Passes properties and values to the application"");
    assertEquals((-330), groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2966() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 3440, 3440);
    boolean boolean0 = groupImpl0.isRequired();
    assertEquals(3440, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2967() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 3440, 3440);
    boolean boolean0 = groupImpl0.isRequired();
    assertEquals(3440, groupImpl0.getMinimum());
}",""
"public boolean isRequired() {
    return getMinimum() > 0;
}","public void test2968() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 3440, 3440);
    boolean boolean0 = groupImpl0.isRequired();
    assertTrue(boolean0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test3069() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.defaults(writeableCommandLineImpl0);
    assertEquals((-330), groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test3070() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Passes properties and values to the application"", ""Passes properties and values to the application"", (-330), (-330));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.defaults(writeableCommandLineImpl0);
    assertEquals((-330), groupImpl0.getMaximum());
}",""
"public String getDescription() {
    return description;
}","public void test3172() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    NumberValidator numberValidator0 = NumberValidator.getCurrencyInstance();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""'"", ""'"", 281, 281, 'o', 'o', numberValidator0, ""'"", linkedList0, 'o');
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""'"", ""Unexpected.token"", '\u0000', '\u0000');
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.defaults(writeableCommandLineImpl0);
    assertEquals(""Unexpected.token"", groupImpl0.getDescription());
}",""
