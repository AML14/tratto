focal_method,test_prefix,docstring
"public int getMaximum() {
    return maximum;
}","public void test000() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ListIterator<String> listIterator0 = (ListIterator<String>) mock(ListIterator.class, new ViolatedAssumptionAnswer());
    doReturn(true).when(listIterator0).hasNext();
    doReturn(""Argument.too.many.values"").when(listIterator0).next();
    doReturn(""Argument.too.many.values"").when(listIterator0).previous();
    NumberValidator numberValidator0 = NumberValidator.getNumberInstance();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""Argument.too.many.values"", ""Argument.too.many.values"", 1, 1, 'i', 't', numberValidator0, ""Argument.too.many.values"", linkedList0, (-2908));
    SourceDestArgument sourceDestArgument0 = new SourceDestArgument(argumentImpl0, argumentImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(sourceDestArgument0, linkedList0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(842, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test001() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ListIterator<String> listIterator0 = (ListIterator<String>) mock(ListIterator.class, new ViolatedAssumptionAnswer());
    doReturn(true).when(listIterator0).hasNext();
    doReturn(""Argument.too.many.values"").when(listIterator0).next();
    doReturn(""Argument.too.many.values"").when(listIterator0).previous();
    NumberValidator numberValidator0 = NumberValidator.getNumberInstance();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""Argument.too.many.values"", ""Argument.too.many.values"", 1, 1, 'i', 't', numberValidator0, ""Argument.too.many.values"", linkedList0, (-2908));
    SourceDestArgument sourceDestArgument0 = new SourceDestArgument(argumentImpl0, argumentImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(sourceDestArgument0, linkedList0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(842, groupImpl0.getMinimum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test012() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.missing.values"", """", 6837, 1910, true);
    groupImpl0.getAnonymous();
    assertEquals(6837, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test013() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.missing.values"", """", 6837, 1910, true);
    groupImpl0.getAnonymous();
    assertEquals(1910, groupImpl0.getMaximum());
}",""
"public String getPreferredName() {
    return name;
}","public void test014() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.missing.values"", """", 6837, 1910, true);
    groupImpl0.getAnonymous();
    assertEquals(""Argument.missing.values"", groupImpl0.getPreferredName());
}",""
"public String getDescription() {
    return description;
}","public void test015() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.missing.values"", """", 6837, 1910, true);
    groupImpl0.getAnonymous();
    assertEquals("""", groupImpl0.getDescription());
}",""
"public int getMaximum() {
    return maximum;
}","public void test026() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" ("", "" ("", 91, 91, true);
    int int0 = groupImpl0.getMaximum();
    assertEquals(91, int0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test027() throws Throwable {
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" ("", "" ("", 91, 91, true);
    int int0 = groupImpl0.getMaximum();
    assertEquals(91, groupImpl0.getMinimum());
}",""
"public String toString() {
    final StringBuffer buffer = new StringBuffer();
    appendUsage(buffer, DisplaySetting.ALL, null);
    return buffer.toString();
}","public void test0411() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    LinkedList<SourceDestArgument> linkedList1 = new LinkedList<SourceDestArgument>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList1, """", ""2K1gjZtPWHU89!H-+)"", 2149, (-2255), false);
    linkedList0.add((Object) groupImpl0);
    GroupImpl groupImpl1 = new GroupImpl(linkedList0, """", """", (-2255), (-2255), false);
    String string0 = groupImpl1.toString();
    assertEquals(""[ ([ ()])]"", string0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0512() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 97, 97, false);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertFalse(boolean0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test0513() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 97, 97, false);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertEquals(97, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test0514() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 97, 97, false);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, (String) null);
    assertEquals(97, groupImpl0.getMaximum());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0616() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    LinkedHashSet<Integer> linkedHashSet0 = new LinkedHashSet<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""("", ""("", 1825, 1825, false);
    DefaultOption defaultOption0 = new DefaultOption(""("", ""("", false, ""("", ""("", linkedHashSet0, (Set) null, false, (Argument) null, groupImpl0, 1825);
    linkedList0.add(defaultOption0);
    GroupImpl groupImpl1 = new GroupImpl(linkedList0, ""("", ""("", 1825, 1825, true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl1, linkedList0);
    boolean boolean0 = groupImpl1.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""("");
    assertTrue(boolean0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0718() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    LinkedList<PropertyOption> linkedList1 = new LinkedList<PropertyOption>();
    linkedList1.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList1, """", ""-D"", (-4288), (-1121), true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""Lo"");
    assertFalse(boolean0);
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0820() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    LinkedList<PropertyOption> linkedList1 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = new PropertyOption("""", ""-D"", (-4288));
    linkedList1.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList1, """", ""-D"", (-4288), (-1121), true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""Lo"");
    assertTrue(boolean0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test0921() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", (-725), (-725), true);
    PropertyOption propertyOption0 = new PropertyOption("""", """", (-725));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals((-725), groupImpl0.getMaximum());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test0922() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", (-725), (-725), true);
    PropertyOption propertyOption0 = new PropertyOption("""", """", (-725));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertFalse(boolean0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test0923() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", (-725), (-725), true);
    PropertyOption propertyOption0 = new PropertyOption("""", """", (-725));
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""-D"");
    assertEquals((-725), groupImpl0.getMinimum());
}",""
"public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {
    if (arg == null) {
        return false;
    }
    // if arg does not require bursting
    if (optionMap.containsKey(arg)) {
        return true;
    }
    // filter
    final Map tailMap = optionMap.tailMap(arg);
    // check if bursting is required
    for (final Iterator iter = tailMap.values().iterator(); iter.hasNext(); ) {
        final Option option = (Option) iter.next();
        if (option.canProcess(commandLine, arg)) {
            return true;
        }
    }
    if (looksLikeOption(commandLine, arg)) {
        return false;
    }
    // anonymous argument(s) means we can process it
    if (anonymous.size() > 0) {
        return true;
    }
    return false;
}","public void test1025() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    NumberValidator numberValidator0 = NumberValidator.getPercentInstance();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""9F?66Q|Y\""#*"", ""9F?66Q|Y\""#*"", 97, 97, 'd', 'd', numberValidator0, ""Unexpected.token"", linkedList0, 97);
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""9F?66Q|Y\""#*"", ""9F?66Q|Y\""#*"", 97, 97, true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    boolean boolean0 = groupImpl0.canProcess((WriteableCommandLine) writeableCommandLineImpl0, ""9F?66Q|Y\""#*"");
    assertTrue(boolean0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test1228() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ListIterator<String> listIterator0 = (ListIterator<String>) mock(ListIterator.class, new ViolatedAssumptionAnswer());
    doReturn(true).when(listIterator0).hasNext();
    doReturn(""Argument.too.many.values"").when(listIterator0).next();
    doReturn(""Argument.too.many.values"").when(listIterator0).previous();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    PropertyOption propertyOption0 = new PropertyOption(""Argument.too.many.values"", ""Argument.too.many.values"", 0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(842, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1229() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    ListIterator<String> listIterator0 = (ListIterator<String>) mock(ListIterator.class, new ViolatedAssumptionAnswer());
    doReturn(true).when(listIterator0).hasNext();
    doReturn(""Argument.too.many.values"").when(listIterator0).next();
    doReturn(""Argument.too.many.values"").when(listIterator0).previous();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    PropertyOption propertyOption0 = new PropertyOption(""Argument.too.many.values"", ""Argument.too.many.values"", 0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    groupImpl0.process(writeableCommandLineImpl0, listIterator0);
    assertEquals(842, groupImpl0.getMaximum());
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired();
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            validate = true;
        }
        if (validate) {
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1330() throws Throwable {
    LinkedList<Switch> linkedList0 = new LinkedList<Switch>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Unexpected.token"", ""Unexpected.token"", 41, 41, true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Missing option Unexpected.token
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public boolean isRequired() {
    return (getParent() == null || super.isRequired()) && getMinimum() > 0;
}","public void test1431() throws Throwable {
    LinkedList<GroupImpl> linkedList0 = new LinkedList<GroupImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""2dK7j!21Y9#@- `g S"", ""2dK7j!21Y9#@- `g S"", (-848), (-848), true);
    linkedList0.add(groupImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    assertFalse(groupImpl0.isRequired());
}","/**
 * Tests whether this option is required. For groups we evaluate the
 * <code>required</code> flag common to all options, but also take the
 * minimum constraints into account.
 *
 * @return a flag whether this option is required
 */"
"public int getMinimum() {
    return minimum;
}","public void test1432() throws Throwable {
    LinkedList<GroupImpl> linkedList0 = new LinkedList<GroupImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""2dK7j!21Y9#@- `g S"", ""2dK7j!21Y9#@- `g S"", (-848), (-848), true);
    linkedList0.add(groupImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals((-848), groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1433() throws Throwable {
    LinkedList<GroupImpl> linkedList0 = new LinkedList<GroupImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""2dK7j!21Y9#@- `g S"", ""2dK7j!21Y9#@- `g S"", (-848), (-848), true);
    linkedList0.add(groupImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.validate(writeableCommandLineImpl0);
    assertEquals((-848), groupImpl0.getMaximum());
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired();
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            validate = true;
        }
        if (validate) {
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1534() throws Throwable {
    LinkedList<GroupImpl> linkedList0 = new LinkedList<GroupImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""2dK7j!21Y9#@- `g S"", ""2dK7j!21Y9#@- `g S"", (-848), (-848), true);
    linkedList0.add(groupImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addOption(groupImpl0);
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Unexpected 2dK7j!21Y9#@- `g S while processing 2dK7j!21Y9#@- `g S
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired();
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            validate = true;
        }
        if (validate) {
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1635() throws Throwable {
    LinkedList<GroupImpl> linkedList0 = new LinkedList<GroupImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""kYk"", ""9<iME\nW^T"", (-2596), 1882, false);
    linkedList0.add(groupImpl0);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    writeableCommandLineImpl0.addOption(groupImpl0);
    // Undeclared exception!
    groupImpl0.validate(writeableCommandLineImpl0);
}",""
"public void validate(final WriteableCommandLine commandLine) throws OptionException {
    // number of options found
    int present = 0;
    // reference to first unexpected option
    Option unexpected = null;
    for (final Iterator i = options.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        // needs validation?
        boolean validate = option.isRequired();
        // if the child option is present then validate it
        if (commandLine.hasOption(option)) {
            if (++present > maximum) {
                unexpected = option;
                break;
            }
            validate = true;
        }
        if (validate) {
            option.validate(commandLine);
        }
    }
    // too many options
    if (unexpected != null) {
        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());
    }
    // too few option
    if (present < minimum) {
        throw new OptionException(this, ResourceConstants.MISSING_OPTION);
    }
    // validate each anonymous argument
    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
        final Option option = (Option) i.next();
        option.validate(commandLine);
    }
}","public void test1736() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    UrlValidator urlValidator0 = new UrlValidator();
    ArgumentImpl argumentImpl0 = new ArgumentImpl("""", """", (-1), (-1), 'g', 'g', urlValidator0, "" "", linkedList0, 181);
    linkedList0.offerLast(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" "", "" "", 0, (-1), true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(argumentImpl0, linkedList0);
    // Undeclared exception!
    try {
        groupImpl0.validate(writeableCommandLineImpl0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -1
        //
        verifyException(""java.util.Collections$EmptyList"", e);
    }
}",""
"public boolean isRequired() {
    return (getParent() == null || super.isRequired()) && getMinimum() > 0;
}","public void test1837() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 94, 94, true);
    LinkedHashSet<Locale.LanguageRange> linkedHashSet0 = new LinkedHashSet<Locale.LanguageRange>();
    Comparator<Command> comparator0 = (Comparator<Command>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) comparator0, (String) null);
    assertTrue(groupImpl0.isRequired());
}","/**
 * Tests whether this option is required. For groups we evaluate the
 * <code>required</code> flag common to all options, but also take the
 * minimum constraints into account.
 *
 * @return a flag whether this option is required
 */"
"public int getMinimum() {
    return minimum;
}","public void test1838() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 94, 94, true);
    LinkedHashSet<Locale.LanguageRange> linkedHashSet0 = new LinkedHashSet<Locale.LanguageRange>();
    Comparator<Command> comparator0 = (Comparator<Command>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) comparator0, (String) null);
    assertEquals(94, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test1839() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, (String) null, (String) null, 94, 94, true);
    LinkedHashSet<Locale.LanguageRange> linkedHashSet0 = new LinkedHashSet<Locale.LanguageRange>();
    Comparator<Command> comparator0 = (Comparator<Command>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    groupImpl0.appendUsage((StringBuffer) null, (Set) linkedHashSet0, (Comparator) comparator0, (String) null);
    assertEquals(94, groupImpl0.getMaximum());
}",""
"public String toString() {
    final StringBuffer buffer = new StringBuffer();
    appendUsage(buffer, DisplaySetting.ALL, null);
    return buffer.toString();
}","public void test1941() throws Throwable {
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    linkedList0.add(propertyOption0);
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", ""-D"", (-4288), (-1121), true);
    String string0 = groupImpl0.toString();
    assertEquals(""[ (-D<property>=<value>|-D<property>=<value>)]"", string0);
}",""
"public String toString() {
    final StringBuffer buffer = new StringBuffer();
    appendUsage(buffer, DisplaySetting.ALL, null);
    return buffer.toString();
}","public void test2043() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    NumberValidator numberValidator0 = NumberValidator.getIntegerInstance();
    LinkedList<Object> linkedList1 = new LinkedList<Object>();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""Argument.to.any.va>ues"", ""Argument.to.any.va>ues"", (-843), (-843), 'A', 'A', numberValidator0, ""z<q3VEG^`2IJecgC>l"", linkedList1, (-843));
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.to.any.va>ues"", ""Argument.to.any.va>ues"", (-843), (-843), true);
    String string0 = groupImpl0.toString();
    assertEquals(""[Argument.to.any.va>ues ()] "", string0);
}",""
"public int getMinimum() {
    return minimum;
}","public void test2144() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    LinkedHashSet<Object> linkedHashSet0 = new LinkedHashSet<Object>();
    Comparator<Command> comparator0 = (Comparator<Command>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines(842, linkedHashSet0, comparator0);
    assertEquals(842, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2145() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.too.many.values"", ""Argument.too.many.values"", 842, 842, true);
    LinkedHashSet<Object> linkedHashSet0 = new LinkedHashSet<Object>();
    Comparator<Command> comparator0 = (Comparator<Command>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines(842, linkedHashSet0, comparator0);
    assertEquals(842, groupImpl0.getMaximum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2248() throws Throwable {
    LinkedList<DisplaySetting> linkedList0 = new LinkedList<DisplaySetting>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""org.apache.comm<ns.clO2.option.ArgumentItpl"", ""org.apache.comm<ns.clO2.option.ArgumentItpl"", 233, (-3481), true);
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines((-4140), displaySetting0.ALL, comparator0);
    assertEquals((-3481), groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2249() throws Throwable {
    LinkedList<DisplaySetting> linkedList0 = new LinkedList<DisplaySetting>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""org.apache.comm<ns.clO2.option.ArgumentItpl"", ""org.apache.comm<ns.clO2.option.ArgumentItpl"", 233, (-3481), true);
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    List list0 = groupImpl0.helpLines((-4140), displaySetting0.ALL, comparator0);
    assertEquals(233, groupImpl0.getMinimum());
}",""
"public List helpLines(final int depth, final Set helpSettings, final Comparator comp) {
    final List helpLines = new ArrayList();
    if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {
        final HelpLine helpLine = new HelpLineImpl(this, depth);
        helpLines.add(helpLine);
    }
    if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {
        // grab a list of the group's options.
        final List list;
        if (comp == null) {
            // default to using the initial order
            list = options;
        } else {
            // sort options if comparator is supplied
            list = new ArrayList(options);
            Collections.sort(list, comp);
        }
        // for each option
        for (final Iterator i = list.iterator(); i.hasNext(); ) {
            final Option option = (Option) i.next();
            helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));
        }
    }
    if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {
        for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {
            final Option option = (Option) i.next();
            helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));
        }
    }
    return helpLines;
}","public void test2350() throws Throwable {
    LinkedList<DisplaySetting> linkedList0 = new LinkedList<DisplaySetting>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, """", """", 0, (-3481), false);
    DisplaySetting displaySetting0 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    DisplaySetting displaySetting1 = mock(DisplaySetting.class, new ViolatedAssumptionAnswer());
    linkedList0.add(displaySetting1);
    // Undeclared exception!
    try {
        groupImpl0.helpLines(176, displaySetting0.ALL, (Comparator) null);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.cli2.DisplaySetting$MockitoMock$42688077 cannot be cast to org.apache.commons.cli2.Option
        //
        verifyException(""org.apache.commons.cli2.option.GroupImpl"", e);
    }
}",""
"public int getMinimum() {
    return minimum;
}","public void test2451() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    LinkedHashSet<Integer> linkedHashSet0 = new LinkedHashSet<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" ("", "" ("", 1859, 1859, true);
    DefaultOption defaultOption0 = new DefaultOption("" ("", "" ("", true, "" ("", "" ("", linkedHashSet0, (Set) null, true, (Argument) null, groupImpl0, 1859);
    linkedList0.add(defaultOption0);
    Option option0 = groupImpl0.findOption("" ("");
    assertEquals(1859, groupImpl0.getMinimum());
}",""
"public Option findOption(final String trigger) {
    final Iterator i = getOptions().iterator();
    while (i.hasNext()) {
        final Option option = (Option) i.next();
        final Option found = option.findOption(trigger);
        if (found != null) {
            return found;
        }
    }
    return null;
}","public void test2452() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    LinkedHashSet<Integer> linkedHashSet0 = new LinkedHashSet<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" ("", "" ("", 1859, 1859, true);
    DefaultOption defaultOption0 = new DefaultOption("" ("", "" ("", true, "" ("", "" ("", linkedHashSet0, (Set) null, true, (Argument) null, groupImpl0, 1859);
    linkedList0.add(defaultOption0);
    Option option0 = groupImpl0.findOption("" ("");
    assertNotNull(option0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test2453() throws Throwable {
    LinkedList<DefaultOption> linkedList0 = new LinkedList<DefaultOption>();
    LinkedHashSet<Integer> linkedHashSet0 = new LinkedHashSet<Integer>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, "" ("", "" ("", 1859, 1859, true);
    DefaultOption defaultOption0 = new DefaultOption("" ("", "" ("", true, "" ("", "" ("", linkedHashSet0, (Set) null, true, (Argument) null, groupImpl0, 1859);
    linkedList0.add(defaultOption0);
    Option option0 = groupImpl0.findOption("" ("");
    assertEquals(1859, groupImpl0.getMaximum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2554() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""N4hr$9|djnLV!"", ""N4hr$9|djnLV!"", 50, 50, false);
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""N4hr$9|djnLV!"", ""N4hr$9|djnLV!"", 50, 50, 'Y', 'Y', (Validator) null, ""N4hr$9|djnLV!"", linkedList0, 50);
    linkedList0.add(argumentImpl0);
    groupImpl0.findOption(""N4hr$9|djnLV!"");
    assertEquals(50, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2555() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""N4hr$9|djnLV!"", ""N4hr$9|djnLV!"", 50, 50, false);
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""N4hr$9|djnLV!"", ""N4hr$9|djnLV!"", 50, 50, 'Y', 'Y', (Validator) null, ""N4hr$9|djnLV!"", linkedList0, 50);
    linkedList0.add(argumentImpl0);
    groupImpl0.findOption(""N4hr$9|djnLV!"");
    assertEquals(50, groupImpl0.getMinimum());
}",""
"public int getMaximum() {
    return maximum;
}","public void test2656() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""?'OC%f`oP%tU2-'.S"", ""?'OC%f`oP%tU2-'.S"", 1, 1, true);
    PropertyOption propertyOption0 = new PropertyOption();
    groupImpl0.setParent(propertyOption0);
    String string0 = groupImpl0.toString();
    assertEquals(1, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2657() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""?'OC%f`oP%tU2-'.S"", ""?'OC%f`oP%tU2-'.S"", 1, 1, true);
    PropertyOption propertyOption0 = new PropertyOption();
    groupImpl0.setParent(propertyOption0);
    String string0 = groupImpl0.toString();
    assertEquals(1, groupImpl0.getMinimum());
}",""
"public String toString() {
    final StringBuffer buffer = new StringBuffer();
    appendUsage(buffer, DisplaySetting.ALL, null);
    return buffer.toString();
}","public void test2658() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""?'OC%f`oP%tU2-'.S"", ""?'OC%f`oP%tU2-'.S"", 1, 1, true);
    PropertyOption propertyOption0 = new PropertyOption();
    groupImpl0.setParent(propertyOption0);
    String string0 = groupImpl0.toString();
    assertEquals(""?'OC%f`oP%tU2-'.S ()"", string0);
}",""
"public int getMaximum() {
    return maximum;
}","public void test2760() throws Throwable {
    LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();
    PropertyOption propertyOption0 = PropertyOption.INSTANCE;
    linkedList0.add(propertyOption0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Misming.option"", ""Misming.option"", 2399, 2399, true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);
    groupImpl0.defaults(writeableCommandLineImpl0);
    assertEquals(2399, groupImpl0.getMaximum());
}",""
"public int getMinimum() {
    return minimum;
}","public void test2862() throws Throwable {
    LinkedList<ArgumentImpl> linkedList0 = new LinkedList<ArgumentImpl>();
    NumberValidator numberValidator0 = NumberValidator.getIntegerInstance();
    LinkedList<Object> linkedList1 = new LinkedList<Object>();
    ArgumentImpl argumentImpl0 = new ArgumentImpl(""Argument.to.any.va>ues"", ""Argument.to.any.va>ues"", (-843), (-843), 'A', 'A', numberValidator0, ""z<q3VEG^`2IJecgC>l"", linkedList1, (-843));
    linkedList0.add(argumentImpl0);
    GroupImpl groupImpl0 = new GroupImpl(linkedList0, ""Argument.to.any.va>ues"", ""Argument.to.any.va>ues"", (-843), (-843), true);
    WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(groupImpl0, linkedList0);
    groupImpl0.defaults(writeableCommandLineImpl0);
    assertEquals((-843), groupImpl0.getMinimum());
}",""
