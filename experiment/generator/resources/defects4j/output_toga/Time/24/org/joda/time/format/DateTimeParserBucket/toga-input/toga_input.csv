focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * Parses a {@code LocalDate} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#localDateParser()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static LocalDate parse(String str) {
    return parse(str, ISODateTimeFormat.localDateParser());
}","public void test011() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.parse(""43r]uw&4"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""43r]uw&4\"" is malformed at \""r]uw&4\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test033() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.CANADA_FRENCH;
    Integer integer0 = new Integer(949);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, iSOChronology0, locale0, integer0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""|"", locale0);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(false, ""dLa;;DP"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot parse \""dLa;;DP\"": Value \""|\"" for monthOfYear is not supported
        //
        verifyException(""org.joda.time.chrono.GJLocaleSymbols"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone used by computeMillis, or null if an offset is
 * used instead.
 */
public DateTimeZone getZone() {
    return iZone;
}","public void test044() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    Locale locale0 = Locale.CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(24L, buddhistChronology0, locale0, (Integer) buddhistChronology0.BE, 1);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertNotNull(dateTimeZone0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test045() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    Locale locale0 = Locale.CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(24L, buddhistChronology0, locale0, (Integer) buddhistChronology0.BE, 1);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test056() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2036L), gregorianChronology0, locale0);
    dateTimeParserBucket0.getPivotYear();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test067() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forID((String) null);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    Locale locale0 = Locale.JAPANESE;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2289L), gregorianChronology0, locale0, integer0);
    dateTimeParserBucket0.getPivotYear();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test078() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    Integer integer0 = new Integer((-72));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, islamicChronology0, locale0, integer0);
    dateTimeParserBucket0.getPivotYear();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test089() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gJChronology0, dateTimeZone0);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(zonedChronology0);
    Locale locale0 = Locale.ROOT;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-45L), lenientChronology0, locale0, integer0, 0);
    dateTimeParserBucket0.setOffset(959);
    int int0 = dateTimeParserBucket0.getOffset();
    assertEquals(959, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test0910() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.TAIWAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1328L), gregorianChronology0, locale0);
    dateTimeParserBucket0.setOffset((-2297));
    int int0 = dateTimeParserBucket0.getOffset();
    assertEquals((-2297), int0);
}",""
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test1011() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_INDIAN;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance((DateTimeZone) fixedDateTimeZone0, islamicChronology_LeapYearPatternType0);
    Locale locale0 = Locale.JAPANESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1211L), islamicChronology0, locale0, (Integer) 1, (-306));
    long long0 = dateTimeParserBucket0.computeMillis(false, ""an,em"");
    assertEquals((-1211L), long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"public long computeMillis(boolean resetFields) {
    return computeMillis(resetFields, null);
}","public void test1112() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone((TimeZone) null);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = copticChronology0.withUTC();
    Locale locale0 = new Locale(""org.joda.time.DateTimeUtils$OffsetMillisProvider"", ""org.joda.time.DateTimeUtils$OffsetMillisProvider"");
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, chronology0, locale0);
    long long0 = dateTimeParserBucket0.computeMillis(false);
    assertEquals(0L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"public long computeMillis() {
    return computeMillis(false, null);
}","public void test1213() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, buddhistChronology0, locale0, (Integer) 1);
    long long0 = dateTimeParserBucket0.computeMillis();
    assertEquals(0L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"public long computeMillis() {
    return computeMillis(false, null);
}","public void test1314() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeField dateTimeField0 = buddhistChronology0.secondOfDay();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, buddhistChronology0, locale0, (Integer) 1);
    dateTimeParserBucket0.saveField(dateTimeField0, 0);
    long long0 = dateTimeParserBucket0.computeMillis();
    assertEquals((-28800000L), long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"static int compareReverse(DurationField a, DurationField b) {
    if (a == null || !a.isSupported()) {
        if (b == null || !b.isSupported()) {
            return 0;
        }
        return -1;
    }
    if (b == null || !b.isSupported()) {
        return 1;
    }
    return -a.compareTo(b);
}","public void test1415() throws Throwable {
    MillisDurationField millisDurationField0 = (MillisDurationField) MillisDurationField.INSTANCE;
    DurationFieldType durationFieldType0 = DurationFieldType.millis();
    ScaledDurationField scaledDurationField0 = new ScaledDurationField(millisDurationField0, durationFieldType0, 606);
    int int0 = DateTimeParserBucket.compareReverse(scaledDurationField0, millisDurationField0);
    assertEquals((-1), int0);
}",""
"public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {
    saveField(new SavedField(fieldType.getField(iChrono), text, locale));
}","public void test1516() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, buddhistChronology0, locale0, (Integer) 1);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.saveField((DateTimeFieldType) null, ""`2-T1=0IpZC7f>(iDw"", locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeParserBucket"", e);
    }
}","/**
 * Saves a datetime field text value.
 *
 * @param fieldType  the field type
 * @param text  the text value
 * @param locale  the locale to use
 */"
"public void saveField(DateTimeFieldType fieldType, int value) {
    saveField(new SavedField(fieldType.getField(iChrono), value));
}","public void test1617() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(912L, julianChronology0, locale0);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.saveField((DateTimeFieldType) null, (-2428));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeParserBucket"", e);
    }
}","/**
 * Saves a datetime field value.
 *
 * @param fieldType  the field type
 * @param value  the value
 */"
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test1718() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.JAPANESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, ethiopicChronology0, locale0, (Integer) 1, 169200000);
    dateTimeParserBucket0.saveField((DateTimeField) null, (-28800000));
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(false, ""z6G8<MyYn0=nBd"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeParserBucket"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"public long computeMillis() {
    return computeMillis(false, null);
}","public void test1819() throws Throwable {
    Locale locale0 = Locale.PRC;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1321L), (Chronology) null, locale0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, (-2281));
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -2281 for hourOfHalfday must be in the range [0,11]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"public long computeMillis() {
    return computeMillis(false, null);
}","public void test1920() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.CANADA_FRENCH;
    Integer integer0 = new Integer(949);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, iSOChronology0, locale0, integer0);
    dateTimeParserBucket0.saveField((DateTimeField) null, 2933);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeParserBucket"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"static int compareReverse(DurationField a, DurationField b) {
    if (a == null || !a.isSupported()) {
        if (b == null || !b.isSupported()) {
            return 0;
        }
        return -1;
    }
    if (b == null || !b.isSupported()) {
        return 1;
    }
    return -a.compareTo(b);
}","public void test2021() throws Throwable {
    int int0 = DateTimeParserBucket.compareReverse((DurationField) null, (DurationField) null);
    assertEquals(0, int0);
}",""
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test2223() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(ethiopicChronology0);
    Chronology chronology0 = lenientChronology0.withZone((DateTimeZone) null);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(606, chronology0, (Locale) null, (Integer) 1);
    long long0 = dateTimeParserBucket0.computeMillis(true, """");
    assertEquals(28800606L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test2224() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(ethiopicChronology0);
    Chronology chronology0 = lenientChronology0.withZone((DateTimeZone) null);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(606, chronology0, (Locale) null, (Integer) 1);
    long long0 = dateTimeParserBucket0.computeMillis(true, """");
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test2325() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(243L, (Chronology) null, locale0, (Integer) null, (-3230));
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeField dateTimeField0 = buddhistChronology0.secondOfMinute();
    dateTimeParserBucket0.saveField(dateTimeField0, (-3230));
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(true, (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -3230 for secondOfMinute must be in the range [0,59]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test2426() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    Locale locale0 = Locale.US;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1120L), iSOChronology0, locale0, (Integer) null, 32);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""org.joda.time.format.DateTimeFormatterBuilder$Composite"", locale0);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(true, ""America/Phoenix"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot parse \""America/Phoenix\"": Value \""org.joda.time.format.DateTimeFormatterBuilder$Composite\"" for centuryOfEra is not supported
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"public boolean restoreState(Object savedState) {
    if (savedState instanceof SavedState) {
        if (((SavedState) savedState).restoreState(this)) {
            iSavedState = savedState;
            return true;
        }
    }
    return false;
}","public void test2527() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.CANADA;
    Integer integer0 = Integer.valueOf(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, julianChronology0, locale0, integer0);
    Object object0 = dateTimeParserBucket0.saveState();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DurationField durationField0 = buddhistChronology0.weekyears();
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, durationField0);
    dateTimeParserBucket0.saveField((DateTimeField) unsupportedDateTimeField0, 0);
    boolean boolean0 = dateTimeParserBucket0.restoreState(object0);
    assertTrue(boolean0);
}","/**
 * Restores the state of this bucket from a previously saved state. The
 * state object passed into this method is not consumed, and it can be used
 * later to restore to that state again.
 *
 * @param savedState opaque saved state, returned from saveState
 * @return true state object is valid and state restored
 */"
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test2528() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.CANADA;
    Integer integer0 = Integer.valueOf(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, julianChronology0, locale0, integer0);
    Object object0 = dateTimeParserBucket0.saveState();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DurationField durationField0 = buddhistChronology0.weekyears();
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, durationField0);
    dateTimeParserBucket0.saveField((DateTimeField) unsupportedDateTimeField0, 0);
    boolean boolean0 = dateTimeParserBucket0.restoreState(object0);
    long long0 = dateTimeParserBucket0.computeMillis(true, ""1"");
    assertEquals(0L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test2629() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(2077L, ethiopicChronology0, locale0, (Integer) 1, 1);
    dateTimeParserBucket0.setZone(dateTimeZone0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test2730() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(2077L, ethiopicChronology0, locale0, (Integer) 1, 1);
    TimeZone timeZone0 = TimeZone.getTimeZone(""+01:00"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    dateTimeParserBucket0.setZone(dateTimeZone0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test2831() throws Throwable {
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, (Chronology) null, (Locale) null, integer0, 0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"static int compareReverse(DurationField a, DurationField b) {
    if (a == null || !a.isSupported()) {
        if (b == null || !b.isSupported()) {
            return 0;
        }
        return -1;
    }
    if (b == null || !b.isSupported()) {
        return 1;
    }
    return -a.compareTo(b);
}","public void test2932() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeField dateTimeField0 = buddhistChronology0.year();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DelegatedDateTimeField delegatedDateTimeField0 = new DelegatedDateTimeField(dateTimeField0, dateTimeFieldType0);
    DurationField durationField0 = delegatedDateTimeField0.getLeapDurationField();
    DurationField durationField1 = buddhistChronology0.eras();
    int int0 = DateTimeParserBucket.compareReverse(durationField0, durationField1);
    assertEquals(1, int0);
}",""
"public long computeMillis(boolean resetFields) {
    return computeMillis(resetFields, null);
}","public void test3033() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    Locale locale0 = Locale.TAIWAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1120L), iSOChronology0, locale0, (Integer) null, (-3660));
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""org.joda.time.format.DateTimeFormatterBuilder$Composite"", locale0);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.secondOfDay();
    dateTimeParserBucket0.saveField(dateTimeFieldType1, ""org.joda.time.format.DateTimeFormatterBuilder$Composite"", locale0);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value \""org.joda.time.format.DateTimeFormatterBuilder$Composite\"" for centuryOfEra is not supported
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"static int compareReverse(DurationField a, DurationField b) {
    if (a == null || !a.isSupported()) {
        if (b == null || !b.isSupported()) {
            return 0;
        }
        return -1;
    }
    if (b == null || !b.isSupported()) {
        return 1;
    }
    return -a.compareTo(b);
}","public void test3134() throws Throwable {
    DurationFieldType durationFieldType0 = DurationFieldType.weeks();
    UnsupportedDurationField unsupportedDurationField0 = UnsupportedDurationField.getInstance(durationFieldType0);
    int int0 = DateTimeParserBucket.compareReverse(unsupportedDurationField0, unsupportedDurationField0);
    assertEquals(0, int0);
}",""
"public long computeMillis(boolean resetFields) {
    return computeMillis(resetFields, null);
}","public void test3235() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    Locale locale0 = Locale.TAIWAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1120L), iSOChronology0, locale0, (Integer) null, (-3660));
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""org.joda.time.format.DateTimeFormatterBuilder$Composite"", locale0);
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""org.joda.time.format.DateTimeFormatterBuilder$Composite"", locale0);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value \""org.joda.time.format.DateTimeFormatterBuilder$Composite\"" for centuryOfEra is not supported
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"public long computeMillis(boolean resetFields, String text) {
    SavedField[] savedFields = iSavedFields;
    int count = iSavedFieldsCount;
    if (iSavedFieldsShared) {
        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();
        iSavedFieldsShared = false;
    }
    sort(savedFields, count);
    if (count > 0) {
        // alter base year for parsing if first field is month or day
        DurationField months = DurationFieldType.months().getField(iChrono);
        DurationField days = DurationFieldType.days().getField(iChrono);
        DurationField first = savedFields[0].iField.getDurationField();
        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
            saveField(DateTimeFieldType.year(), iDefaultYear);
            return computeMillis(resetFields, text);
        }
    }
    long millis = iMillis;
    try {
        for (int i = 0; i < count; i++) {
            millis = savedFields[i].set(millis, resetFields);
        }
    } catch (IllegalFieldValueException e) {
        if (text != null) {
            e.prependMessage(""Cannot parse \"""" + text + '""');
        }
        throw e;
    }
    if (iZone == null) {
        millis -= iOffset;
    } else {
        int offset = iZone.getOffsetFromLocal(millis);
        millis -= offset;
        if (offset != iZone.getOffset(millis)) {
            String message = ""Illegal instant due to time zone offset transition ("" + iZone + ')';
            if (text != null) {
                message = ""Cannot parse \"""" + text + ""\"": "" + message;
            }
            throw new IllegalArgumentException(message);
        }
    }
    return millis;
}","public void test3336() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.CANADA_FRENCH;
    Integer integer0 = new Integer(949);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0L, iSOChronology0, locale0, integer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeField dateTimeField0 = buddhistChronology0.dayOfWeek();
    dateTimeParserBucket0.saveField(dateTimeField0, 10);
    dateTimeParserBucket0.saveField(dateTimeField0, 1);
    // Undeclared exception!
    try {
        dateTimeParserBucket0.computeMillis(false, ""dLa;;DP"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot parse \""dLa;;DP\"": Value 10 for dayOfWeek must be in the range [1,7]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @param text optional text being parsed, to be included in any error message
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 * @since 1.3
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test3539() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    DateTimeParserBucket.SavedState dateTimeParserBucket_SavedState0 = (DateTimeParserBucket.SavedState) dateTimeParserBucket0.saveState();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""&h-UNPsd[>x7o=S"", locale0);
    boolean boolean0 = dateTimeParserBucket_SavedState0.restoreState(dateTimeParserBucket0);
    long long0 = dateTimeParserBucket0.computeMillis(false);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public long computeMillis(boolean resetFields) {
    return computeMillis(resetFields, null);
}","public void test3540() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    DateTimeParserBucket.SavedState dateTimeParserBucket_SavedState0 = (DateTimeParserBucket.SavedState) dateTimeParserBucket0.saveState();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    dateTimeParserBucket0.saveField(dateTimeFieldType0, ""&h-UNPsd[>x7o=S"", locale0);
    boolean boolean0 = dateTimeParserBucket_SavedState0.restoreState(dateTimeParserBucket0);
    long long0 = dateTimeParserBucket0.computeMillis(false);
    assertEquals(31478399966L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"public Object saveState() {
    if (iSavedState == null) {
        iSavedState = new SavedState();
    }
    return iSavedState;
}","public void test3641() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer((-2347));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, integer0);
    DateTimeParserBucket dateTimeParserBucket1 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, (Integer) null, (-2347));
    Object object0 = dateTimeParserBucket1.saveState();
    assertNotNull(object0);
}","/**
 * Saves the state of this bucket, returning it in an opaque object. Call
 * restoreState to undo any changes that were made since the state was
 * saved. Calls to saveState may be nested.
 *
 * @return opaque saved state, which may be passed to restoreState
 */"
"public boolean restoreState(Object savedState) {
    if (savedState instanceof SavedState) {
        if (((SavedState) savedState).restoreState(this)) {
            iSavedState = savedState;
            return true;
        }
    }
    return false;
}","public void test3642() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer((-2347));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, integer0);
    DateTimeParserBucket dateTimeParserBucket1 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, (Integer) null, (-2347));
    Object object0 = dateTimeParserBucket1.saveState();
    boolean boolean0 = dateTimeParserBucket0.restoreState(object0);
    assertFalse(boolean0);
}","/**
 * Restores the state of this bucket from a previously saved state. The
 * state object passed into this method is not consumed, and it can be used
 * later to restore to that state again.
 *
 * @param savedState opaque saved state, returned from saveState
 * @return true state object is valid and state restored
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test3643() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer((-2347));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, integer0);
    DateTimeParserBucket dateTimeParserBucket1 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, (Integer) null, (-2347));
    Object object0 = dateTimeParserBucket1.saveState();
    boolean boolean0 = dateTimeParserBucket0.restoreState(object0);
    assertEquals(0, dateTimeParserBucket1.getOffset());
}",""
"public boolean restoreState(Object savedState) {
    if (savedState instanceof SavedState) {
        if (((SavedState) savedState).restoreState(this)) {
            iSavedState = savedState;
            return true;
        }
    }
    return false;
}","public void test3744() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    boolean boolean0 = dateTimeParserBucket0.restoreState(gregorianChronology0);
    assertFalse(boolean0);
}","/**
 * Restores the state of this bucket from a previously saved state. The
 * state object passed into this method is not consumed, and it can be used
 * later to restore to that state again.
 *
 * @param savedState opaque saved state, returned from saveState
 * @return true state object is valid and state restored
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test3745() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    boolean boolean0 = dateTimeParserBucket0.restoreState(gregorianChronology0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test3846() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    dateTimeParserBucket0.saveState();
    Object object0 = dateTimeParserBucket0.saveState();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Object saveState() {
    if (iSavedState == null) {
        iSavedState = new SavedState();
    }
    return iSavedState;
}","public void test3847() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(31449599966L, gregorianChronology0, locale0);
    dateTimeParserBucket0.saveState();
    Object object0 = dateTimeParserBucket0.saveState();
    assertNotNull(object0);
}","/**
 * Saves the state of this bucket, returning it in an opaque object. Call
 * restoreState to undo any changes that were made since the state was
 * saved. Calls to saveState may be nested.
 *
 * @return opaque saved state, which may be passed to restoreState
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test3949() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1328L), gregorianChronology0, locale0);
    DateTimeParserBucket.SavedState dateTimeParserBucket_SavedState0 = dateTimeParserBucket0.new SavedState();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    DateTimeField dateTimeField0 = buddhistChronology0.clockhourOfHalfday();
    dateTimeParserBucket0.saveField(dateTimeField0, 1);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    boolean boolean0 = dateTimeParserBucket_SavedState0.restoreState(dateTimeParserBucket0);
    dateTimeParserBucket0.saveField(dateTimeFieldType0, 3462);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4050() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.JAPANESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1295L), gregorianChronology0, locale0);
    Integer integer0 = new Integer(3462);
    dateTimeParserBucket0.setPivotYear(integer0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4151() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer((-2347));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1L, gregorianChronology0, locale0, integer0);
    dateTimeParserBucket0.getLocale();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public long computeMillis() {
    return computeMillis(false, null);
}","public void test4252() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(2077L, ethiopicChronology0, locale0, (Integer) 1, 1);
    long long0 = dateTimeParserBucket0.computeMillis();
    assertEquals(28802077L, long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4253() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(2077L, ethiopicChronology0, locale0, (Integer) 1, 1);
    long long0 = dateTimeParserBucket0.computeMillis();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4354() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(912L, julianChronology0, locale0);
    int int0 = dateTimeParserBucket0.getOffset();
    assertEquals(0, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4455() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forID((String) null);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    Locale locale0 = Locale.UK;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, buddhistChronology0, locale0, (Integer) 1, 1);
    dateTimeParserBucket0.getPivotYear();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public long computeMillis(boolean resetFields) {
    return computeMillis(resetFields, null);
}","public void test4556() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.JAPANESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1295L), gregorianChronology0, locale0);
    long long0 = dateTimeParserBucket0.computeMillis(true);
    assertEquals((-1295L), long0);
}","/**
 * Computes the parsed datetime by setting the saved fields.
 * This method is idempotent, but it is not thread-safe.
 *
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4657() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(2077L, ethiopicChronology0, locale0, (Integer) 1, 1);
    dateTimeParserBucket0.getChronology();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis,
 * unless getZone doesn't return null.
 */
public int getOffset() {
    return iOffset;
}","public void test4758() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1328L), gregorianChronology0, locale0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone used by computeMillis, or null if an offset is
 * used instead.
 */
public DateTimeZone getZone() {
    return iZone;
}","public void test4759() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-1328L), gregorianChronology0, locale0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertNull(dateTimeZone0);
}",""
