focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute,
 * providing control over how the result is split into fields.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The PeriodType parameter controls how the result is created. It allows
 * you to omit certain fields from the result if desired. For example,
 * you may not want the result to include weeks, in which case you pass
 * in <code>PeriodType.yearMonthDayTime()</code>.
 *
 * @param type  the period type of the new period, null means standard type
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @throws UnsupportedOperationException if this period contains non-zero
 *  years or months but the specified period type does not support them
 * @since 1.5
 */
public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();
    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        if (years != 0) {
            result = result.withYears(years);
        }
        if (months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}","public void test0000() throws Throwable {
    PeriodType periodType0 = PeriodType.months();
    Period period0 = Period.days(12);
    Period period1 = period0.minusMonths(83);
    // Undeclared exception!
    try {
        period1.normalizedStandard(periodType0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test0011() throws Throwable {
    Period period0 = Period.minutes(648);
    Period period1 = period0.plusDays((-2241));
    Duration duration0 = period1.toStandardDuration();
    assertEquals((-193583520000L), duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test0022() throws Throwable {
    Period period0 = Period.hours(98);
    Duration duration0 = period0.toStandardDuration();
    assertEquals(352800000L, duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test0033() throws Throwable {
    Period period0 = Period.minutes(648);
    Duration duration0 = period0.toStandardDuration();
    assertEquals(38880000L, duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test0044() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusSeconds(2527);
    Duration duration0 = period1.toStandardDuration();
    assertEquals(2527000L, duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of seconds that this period represents.
 *
 * @return the number of seconds in the period
 */
public int getSeconds() {
    return getValue();
}","public void test0055() throws Throwable {
    Period period0 = Period.weeks(758);
    Seconds seconds0 = period0.toStandardSeconds();
    assertEquals(458438400, seconds0.getSeconds());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of minutes that this period represents.
 *
 * @return the number of minutes in the period
 */
public int getMinutes() {
    return getValue();
}","public void test0066() throws Throwable {
    Period period0 = Period.weeks(648);
    Minutes minutes0 = period0.toStandardMinutes();
    assertEquals(6531840, minutes0.getMinutes());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of minutes that this period represents.
 *
 * @return the number of minutes in the period
 */
public int getMinutes() {
    return getValue();
}","public void test0077() throws Throwable {
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = new Period((-4294967296L), periodType0);
    Minutes minutes0 = period0.toStandardMinutes();
    assertEquals((-71582), minutes0.getMinutes());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test0088() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Period period1 = period0.minusMinutes(30);
    Days days0 = period1.toStandardDays();
    assertEquals(0, days0.getDays());
}",""
"public Days toStandardDays() {
    checkYearsAndMonths(""Days"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    long days = millis / DateTimeConstants.MILLIS_PER_DAY;
    days = FieldUtils.safeAdd(days, getDays());
    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));
    return Days.days(FieldUtils.safeToInt(days));
}","public void test0089() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Period period1 = period0.minusMinutes(30);
    Days days0 = period1.toStandardDays();
    assertNotSame(period1, period0);
}","/**
 * Converts this period to a period in days assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard days in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of days is too large to be represented
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this period to a period in weeks assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard weeks in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of weeks is too large to be represented
 * @since 1.5
 */
public Weeks toStandardWeeks() {
    checkYearsAndMonths(""Weeks"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;
    long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;
    return Weeks.weeks(FieldUtils.safeToInt(weeks));
}","public void test00910() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    Weeks weeks0 = period2.toStandardWeeks();
    assertNotSame(period2, period1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of weeks that this period represents.
 *
 * @return the number of weeks in the period
 */
public int getWeeks() {
    return getValue();
}","public void test00911() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    Weeks weeks0 = period2.toStandardWeeks();
    assertEquals(361, weeks0.getWeeks());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of weeks that this period represents.
 *
 * @return the number of weeks in the period
 */
public int getWeeks() {
    return getValue();
}","public void test01012() throws Throwable {
    Duration duration0 = Duration.standardMinutes(1000L);
    Period period0 = duration0.toPeriod();
    Weeks weeks0 = period0.toStandardWeeks();
    assertEquals(0, weeks0.getWeeks());
}",""
"public Period withFieldAdded(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (value == 0) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    super.addFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test01113() throws Throwable {
    LocalTime localTime0 = new LocalTime(0L);
    Period period0 = new Period(localTime0, localTime0, (PeriodType) null);
    Minutes minutes0 = Minutes.standardMinutesIn(period0);
    Weeks weeks0 = minutes0.toStandardWeeks();
    DurationFieldType durationFieldType0 = weeks0.getFieldType();
    Period period1 = period0.withFieldAdded(durationFieldType0, 1599);
    assertNotSame(period1, period0);
}","/**
 * Creates a new Period instance with the valueToAdd added to the specified field.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to add
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */"
"public Period withDays(int days) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);
    return new Period(values, getPeriodType());
}","public void test01214() throws Throwable {
    Duration duration0 = Duration.ZERO;
    Period period0 = duration0.toPeriod();
    Period period1 = period0.withDays(1500);
    assertNotSame(period0, period1);
}","/**
 * Returns a new period with the specified number of days.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to add, may be negative
 * @return the new period with the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of weeks that this period represents.
 *
 * @return the number of weeks in the period
 */
public int getWeeks() {
    return getValue();
}","public void test01315() throws Throwable {
    PeriodType periodType0 = PeriodType.yearWeekDay();
    PeriodType periodType1 = periodType0.withYearsRemoved();
    Period period0 = new Period(30962844000000L, 31556952000L, periodType1);
    Weeks weeks0 = period0.toStandardWeeks();
    assertEquals((-51143), weeks0.getWeeks());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of seconds that this period represents.
 *
 * @return the number of seconds in the period
 */
public int getSeconds() {
    return getValue();
}","public void test01416() throws Throwable {
    Days days0 = Days.SEVEN;
    Duration duration0 = days0.toStandardDuration();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTime dateTime0 = new DateTime((DateTimeZone) fixedDateTimeZone0);
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = duration0.toPeriodFrom((ReadableInstant) dateTime0, periodType0);
    Seconds seconds0 = period0.toStandardSeconds();
    assertEquals(604800, seconds0.getSeconds());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of seconds that this period represents.
 *
 * @return the number of seconds in the period
 */
public int getSeconds() {
    return getValue();
}","public void test01517() throws Throwable {
    LocalTime localTime0 = new LocalTime();
    LocalTime localTime1 = localTime0.withLocalMillis(0L);
    Period period0 = Period.fieldDifference(localTime0, localTime1);
    Seconds seconds0 = period0.toStandardSeconds();
    assertEquals((-44481), seconds0.getSeconds());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of minutes that this period represents.
 *
 * @return the number of minutes in the period
 */
public int getMinutes() {
    return getValue();
}","public void test01618() throws Throwable {
    Period period0 = Period.minutes(648);
    Period period1 = period0.plusDays((-2241));
    Minutes minutes0 = period1.toStandardMinutes();
    assertEquals((-3226392), minutes0.getMinutes());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of hours that this period represents.
 *
 * @return the number of hours in the period
 */
public int getHours() {
    return getValue();
}","public void test01719() throws Throwable {
    Period period0 = Period.minutes(648);
    Period period1 = period0.plusDays((-2241));
    Hours hours0 = period1.toStandardHours();
    assertEquals((-53774), hours0.getHours());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test01820() throws Throwable {
    Period period0 = Period.minutes(10209375);
    Duration duration0 = period0.ZERO.toStandardDuration();
    assertEquals(0L, duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test01921() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTime dateTime0 = DateTime.now((Chronology) gregorianChronology0);
    Period period0 = new Period(dateTime0, dateTime0);
    Period period1 = period0.withWeeks(1007);
    Duration duration0 = period1.toStandardDuration();
    assertEquals(609033600000L, duration0.getMillis());
}",""
"public long getStandardSeconds() {
    return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
}","public void test02022() throws Throwable {
    Period period0 = Period.ZERO;
    Period period1 = period0.plusWeeks((-2230));
    Duration duration0 = period1.toStandardDuration();
    assertEquals((-1348704000L), duration0.getStandardSeconds());
}","/**
 * Gets the length of this duration in seconds assuming that there are the
 * standard number of milliseconds in a second.
 * <p>
 * This method assumes that there are 1000 milliseconds in a second.
 * All currently supplied chronologies use this definition.
 * <p>
 * This returns <code>getMillis() / 1000</code>.
 * The result is an integer division, so 2999 millis returns 2 seconds.
 *
 * @return the length of the duration in standard seconds
 * @since 1.6
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test02123() throws Throwable {
    Period period0 = Period.hours(839);
    Days days0 = period0.toStandardDays();
    assertEquals(34, days0.getDays());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test02224() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Period period1 = period0.withWeeks((-420));
    Days days0 = period1.toStandardDays();
    assertEquals((-2940), days0.getDays());
}",""
"//-----------------------------------------------------------------------
/**
 * Parses a {@code Period} from the specified string.
 * <p>
 * This uses {@link ISOPeriodFormat#standard()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static Period parse(String str) {
    return parse(str, ISOPeriodFormat.standard());
}","public void test02325() throws Throwable {
    Period period0 = Period.parse(""PT0S"");
    assertNotNull(period0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the years field part of the period.
 *
 * @return the number of years in the period, zero if unsupported
 */
public int getYears() {
    return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);
}","public void test02426() throws Throwable {
    Period period0 = new Period(26, (-1071), 1467, 12, 907, 139, 139, 12, (PeriodType) null);
    int int0 = period0.getYears();
    assertEquals(26, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the years field part of the period.
 *
 * @return the number of years in the period, zero if unsupported
 */
public int getYears() {
    return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);
}","public void test02527() throws Throwable {
    Period period0 = new Period((-41), (-3005), (-3005), (-41), (-3005), (-230), (-4053), (-230));
    int int0 = period0.getYears();
    assertEquals((-41), int0);
}",""
"public int getWeeks() {
    return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);
}","public void test02628() throws Throwable {
    Period period0 = new Period((-5051), 2527, 2527, 2527, 137, (-5051), (-1584), 137);
    int int0 = period0.getWeeks();
    assertEquals(2527, int0);
}","/**
 * Gets the weeks field part of the period.
 *
 * @return the number of weeks in the period, zero if unsupported
 */"
"public int getWeeks() {
    return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);
}","public void test02729() throws Throwable {
    Period period0 = Period.months(8);
    Period period1 = period0.ZERO.minusWeeks(2);
    int int0 = period1.getWeeks();
    assertEquals((-2), int0);
}","/**
 * Gets the weeks field part of the period.
 *
 * @return the number of weeks in the period, zero if unsupported
 */"
"public int getSeconds() {
    return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);
}","public void test02830() throws Throwable {
    Period period0 = Period.seconds(2679);
    int int0 = period0.getSeconds();
    assertEquals(2679, int0);
}","/**
 * Gets the seconds field part of the period.
 *
 * @return the number of seconds in the period, zero if unsupported
 */"
"public int getSeconds() {
    return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);
}","public void test02931() throws Throwable {
    Period period0 = new Period((-3624), 10, (-2171), (-3624));
    int int0 = period0.getSeconds();
    assertEquals((-2171), int0);
}","/**
 * Gets the seconds field part of the period.
 *
 * @return the number of seconds in the period, zero if unsupported
 */"
"public int getMonths() {
    return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);
}","public void test03032() throws Throwable {
    Period period0 = Period.minutes((-2229));
    Period period1 = period0.minusMonths((-2229));
    int int0 = period1.getMonths();
    assertEquals(2229, int0);
}","/**
 * Gets the months field part of the period.
 *
 * @return the number of months in the period, zero if unsupported
 */"
"public int getMinutes() {
    return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);
}","public void test03133() throws Throwable {
    Period period0 = Period.millis(0);
    int int0 = period0.getMinutes();
    assertEquals(0, int0);
}","/**
 * Gets the minutes field part of the period.
 *
 * @return the number of minutes in the period, zero if unsupported
 */"
"public int getMinutes() {
    return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);
}","public void test03234() throws Throwable {
    PeriodType periodType0 = PeriodType.standard();
    Period period0 = new Period((-1783), (-1783), (-990), (-1783), (-1783), (-1083), 805, (-1083), periodType0);
    int int0 = period0.getMinutes();
    assertEquals((-1083), int0);
}","/**
 * Gets the minutes field part of the period.
 *
 * @return the number of minutes in the period, zero if unsupported
 */"
"public int getMillis() {
    return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);
}","public void test03335() throws Throwable {
    Period period0 = Period.millis(9);
    int int0 = period0.getMillis();
    assertEquals(9, int0);
}","/**
 * Gets the millis field part of the period.
 *
 * @return the number of millis in the period, zero if unsupported
 */"
"public int getMillis() {
    return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);
}","public void test03436() throws Throwable {
    Period period0 = new Period(2, (-1863), 153692453, (-516), 153692453, (-516), 2, 153692453);
    Period period1 = period0.ZERO.minusWeeks((-516));
    Period period2 = period1.plusMillis((-1863));
    int int0 = period2.getMillis();
    assertEquals((-1863), int0);
}","/**
 * Gets the millis field part of the period.
 *
 * @return the number of millis in the period, zero if unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the hours field part of the period.
 *
 * @return the number of hours in the period, zero if unsupported
 */
public int getHours() {
    return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);
}","public void test03537() throws Throwable {
    Period period0 = new Period(26, (-1071), 1467, 12, 907, 139, 139, 12, (PeriodType) null);
    int int0 = period0.getHours();
    assertEquals(907, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the hours field part of the period.
 *
 * @return the number of hours in the period, zero if unsupported
 */
public int getHours() {
    return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);
}","public void test03638() throws Throwable {
    LocalTime localTime0 = new LocalTime(0L);
    Period period0 = new Period(localTime0, localTime0, (PeriodType) null);
    Period period1 = period0.withHours(174);
    Period period2 = period1.ZERO.minus(period1);
    int int0 = period2.getHours();
    assertEquals((-174), int0);
}",""
"public int getDays() {
    return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);
}","public void test03739() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    int int0 = period2.getDays();
    assertNotSame(period2, period1);
}","/**
 * Gets the days field part of the period.
 *
 * @return the number of days in the period, zero if unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to add, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period withYears(int years) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);
    return new Period(values, getPeriodType());
}","public void test03841() throws Throwable {
    PeriodType periodType0 = PeriodType.yearWeekDay();
    PeriodType periodType1 = periodType0.withYearsRemoved();
    Period period0 = new Period(30962844000000L, 31556952000L, periodType1);
    // Undeclared exception!
    try {
        period0.withYears(263);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to add, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period withYears(int years) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);
    return new Period(values, getPeriodType());
}","public void test03942() throws Throwable {
    Period period0 = Period.weeks(9);
    PeriodType.YEAR_INDEX = 204;
    // Undeclared exception!
    try {
        period0.withYears(526);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 204
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"public Period withWeeks(int weeks) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);
    return new Period(values, getPeriodType());
}","public void test04043() throws Throwable {
    Duration duration0 = Duration.standardMinutes(60L);
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = duration0.toPeriod(periodType0);
    // Undeclared exception!
    try {
        period0.withWeeks((-1));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of weeks.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new period with the increased weeks
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withWeeks(int weeks) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);
    return new Period(values, getPeriodType());
}","public void test04144() throws Throwable {
    PeriodType periodType0 = PeriodType.standard();
    Period period0 = new Period((-1783), (-1783), (-990), (-1783), (-1783), (-1083), 805, 1783, periodType0);
    PeriodType.WEEK_INDEX = (-3076);
    // Undeclared exception!
    try {
        period0.withWeeks(3514);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -3076
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of weeks.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new period with the increased weeks
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withSeconds(int seconds) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);
    return new Period(values, getPeriodType());
}","public void test04245() throws Throwable {
    Days days0 = Days.SEVEN;
    Duration duration0 = days0.toStandardDuration();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTime dateTime0 = new DateTime((DateTimeZone) fixedDateTimeZone0);
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = duration0.toPeriodFrom((ReadableInstant) dateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.withSeconds(1000);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of seconds.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to add, may be negative
 * @return the new period with the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withSeconds(int seconds) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);
    return new Period(values, getPeriodType());
}","public void test04346() throws Throwable {
    Period period0 = Period.months(8);
    PeriodType.SECOND_INDEX = 8;
    // Undeclared exception!
    try {
        period0.ZERO.withSeconds((-1877));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 8
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of seconds.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to add, may be negative
 * @return the new period with the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a new Period instance with the same field values but
 * different PeriodType.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param type  the period type to use, null means standard
 * @return the new period instance
 * @throws IllegalArgumentException if the new period won't accept all of the current fields
 */
public Period withPeriodType(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    if (type.equals(getPeriodType())) {
        return this;
    }
    return new Period(this, type);
}","public void test04447() throws Throwable {
    int[] intArray0 = new int[3];
    PeriodType periodType0 = new PeriodType(""7ht"", (DurationFieldType[]) null, intArray0);
    Period period0 = new Period(15271875, (-207), 1, (-1115), 292271022, (-207), 4082, (-207));
    // Undeclared exception!
    try {
        period0.withPeriodType(periodType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Period instance with the same field values but
 * different PeriodType.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param type  the period type to use, null means standard
 * @return the new period instance
 * @throws IllegalArgumentException if the new period won't accept all of the current fields
 */
public Period withPeriodType(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    if (type.equals(getPeriodType())) {
        return this;
    }
    return new Period(this, type);
}","public void test04548() throws Throwable {
    Period period0 = Period.weeks((-2274));
    PeriodType periodType0 = PeriodType.days();
    // Undeclared exception!
    try {
        period0.withPeriodType(periodType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'weeks'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}",""
"public Period withMonths(int months) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);
    return new Period(values, getPeriodType());
}","public void test04649() throws Throwable {
    Duration duration0 = Duration.millis(1000L);
    Seconds seconds0 = duration0.toStandardSeconds();
    PeriodType periodType0 = seconds0.getPeriodType();
    Period period0 = new Period(duration0, (ReadableInstant) null, periodType0);
    // Undeclared exception!
    try {
        period0.withMonths(0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of months.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to add, may be negative
 * @return the new period with the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withMonths(int months) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);
    return new Period(values, getPeriodType());
}","public void test04750() throws Throwable {
    Period period0 = Period.months((-5051));
    PeriodType.MONTH_INDEX = (-5);
    // Undeclared exception!
    try {
        period0.withMonths(1269);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -5
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of months.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to add, may be negative
 * @return the new period with the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withMinutes(int minutes) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test04851() throws Throwable {
    PeriodType periodType0 = PeriodType.yearWeekDay();
    Period period0 = new Period((-1050L), periodType0);
    // Undeclared exception!
    try {
        period0.withMinutes(892);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of minutes.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period with the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withMinutes(int minutes) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test04952() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = new Period(513, 0, 0, 513, 0, 0, 513, 0, periodType0);
    PeriodType.MINUTE_INDEX = 12;
    // Undeclared exception!
    try {
        period0.ZERO.withMinutes((-550));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 12
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of minutes.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period with the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withMillis(int millis) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);
    return new Period(values, getPeriodType());
}","public void test05053() throws Throwable {
    Period period0 = Period.minutes(648);
    PeriodType.MILLI_INDEX = (-1456);
    // Undeclared exception!
    try {
        period0.withMillis(648);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1456
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of millis.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to add, may be negative
 * @return the new period with the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withHours(int hours) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);
    return new Period(values, getPeriodType());
}","public void test05154() throws Throwable {
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(0, 0, 0, 0, 0, 0, 0, 0, periodType0);
    // Undeclared exception!
    try {
        period0.withHours(18);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of hours.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to add, may be negative
 * @return the new period with the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withHours(int hours) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);
    return new Period(values, getPeriodType());
}","public void test05255() throws Throwable {
    Period period0 = Period.hours(0);
    PeriodType.HOUR_INDEX = (-2094);
    // Undeclared exception!
    try {
        period0.withHours(8);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2094
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of hours.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to add, may be negative
 * @return the new period with the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test05356() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    Period period3 = period1.ZERO.plusHours((-5051));
    Hours hours0 = period2.toStandardHours();
    period3.withFields(hours0);
    assertFalse(period3.equals((Object) period0));
}",""
"public Period withFields(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    newValues = super.mergePeriodInto(newValues, period);
    return new Period(newValues, getPeriodType());
}","public void test05357() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    Period period3 = period1.ZERO.plusHours((-5051));
    Hours hours0 = period2.toStandardHours();
    period3.withFields(hours0);
    assertNotSame(period2, period1);
}","/**
 * Creates a new Period instance with the fields from the specified period
 * copied on top of those from this period.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to copy from, null ignored
 * @return the new period instance
 * @throws IllegalArgumentException if a field type is unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of hours that this period represents.
 *
 * @return the number of hours in the period
 */
public int getHours() {
    return getValue();
}","public void test05358() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.plusSeconds(2527);
    Period period3 = period1.ZERO.plusHours((-5051));
    Hours hours0 = period2.toStandardHours();
    period3.withFields(hours0);
    assertEquals(60648, hours0.getHours());
}",""
"public Period withDays(int days) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);
    return new Period(values, getPeriodType());
}","public void test05459() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTime dateTime0 = new DateTime((-563L), (Chronology) buddhistChronology0);
    Period period0 = new Period(dateTime0, dateTime0);
    PeriodType.DAY_INDEX = 522;
    // Undeclared exception!
    try {
        period0.ZERO.withDays(0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 522
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of days.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to add, may be negative
 * @return the new period with the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this period to a period in weeks assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard weeks in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of weeks is too large to be represented
 * @since 1.5
 */
public Weeks toStandardWeeks() {
    checkYearsAndMonths(""Weeks"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;
    long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;
    return Weeks.weeks(FieldUtils.safeToInt(weeks));
}","public void test05560() throws Throwable {
    Period period0 = Period.months(2453);
    // Undeclared exception!
    try {
        period0.toStandardWeeks();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Weeks as this period contains months and months vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Converts this period to a period in weeks assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard weeks in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of weeks is too large to be represented
 * @since 1.5
 */
public Weeks toStandardWeeks() {
    checkYearsAndMonths(""Weeks"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;
    long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;
    return Weeks.weeks(FieldUtils.safeToInt(weeks));
}","public void test05661() throws Throwable {
    Period period0 = Period.millis((-5326));
    PeriodType.MONTH_INDEX = 3140;
    // Undeclared exception!
    try {
        period0.toStandardWeeks();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public Seconds toStandardSeconds() {
    checkYearsAndMonths(""Seconds"");
    long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
    seconds = FieldUtils.safeAdd(seconds, getSeconds());
    seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));
    seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));
    seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));
    seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));
    return Seconds.seconds(FieldUtils.safeToInt(seconds));
}","public void test05762() throws Throwable {
    Period period0 = new Period(60L, 10000000000000000L, (Chronology) null);
    // Undeclared exception!
    try {
        period0.toStandardSeconds();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Seconds as this period contains months and months vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Converts this period to a period in seconds assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard seconds in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of seconds is too large to be represented
 * @since 1.5
 */"
"public Minutes toStandardMinutes() {
    checkYearsAndMonths(""Minutes"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;
    minutes = FieldUtils.safeAdd(minutes, getMinutes());
    minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));
    minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));
    minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));
    return Minutes.minutes(FieldUtils.safeToInt(minutes));
}","public void test05863() throws Throwable {
    Period period0 = Period.minutes(648);
    Period period1 = period0.plusMonths((-1437));
    // Undeclared exception!
    try {
        period1.toStandardMinutes();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Minutes as this period contains months and months vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Converts this period to a period in minutes assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard minutes in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of minutes is too large to be represented
 * @since 1.5
 */"
"public Minutes toStandardMinutes() {
    checkYearsAndMonths(""Minutes"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;
    minutes = FieldUtils.safeAdd(minutes, getMinutes());
    minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));
    minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));
    minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));
    return Minutes.minutes(FieldUtils.safeToInt(minutes));
}","public void test05964() throws Throwable {
    Period period0 = new Period(4341L, 4341L);
    PeriodType.YEAR_INDEX = 1925;
    // Undeclared exception!
    try {
        period0.ZERO.toStandardMinutes();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Converts this period to a period in minutes assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard minutes in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of minutes is too large to be represented
 * @since 1.5
 */"
"public Hours toStandardHours() {
    checkYearsAndMonths(""Hours"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;
    hours = FieldUtils.safeAdd(hours, getHours());
    hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));
    hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));
    return Hours.hours(FieldUtils.safeToInt(hours));
}","public void test06065() throws Throwable {
    Period period0 = new Period(3600000L, 3600000L);
    Period period1 = period0.minusYears(7593750);
    Period period2 = period1.plusMonths(0);
    // Undeclared exception!
    try {
        period2.toStandardHours();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Hours as this period contains years and years vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Converts this period to a period in hours assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard hours in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of hours is too large to be represented
 * @since 1.5
 */"
"public Hours toStandardHours() {
    checkYearsAndMonths(""Hours"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;
    hours = FieldUtils.safeAdd(hours, getHours());
    hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));
    hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));
    return Hours.hours(FieldUtils.safeToInt(hours));
}","public void test06166() throws Throwable {
    MockDate mockDate0 = new MockDate(0L);
    LocalDateTime localDateTime0 = LocalDateTime.fromDateFields(mockDate0);
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(localDateTime0, localDateTime0, periodType0);
    PeriodType.MONTH_INDEX = 61;
    // Undeclared exception!
    try {
        period0.ZERO.toStandardHours();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Converts this period to a period in hours assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard hours in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of hours is too large to be represented
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this period to a duration assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert from a period to a duration.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a duration equivalent to this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @since 1.5
 */
public Duration toStandardDuration() {
    checkYearsAndMonths(""Duration"");
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    return new Duration(millis);
}","public void test06267() throws Throwable {
    Period period0 = Period.hours(98);
    PeriodType.MINUTE_INDEX = (-935);
    // Undeclared exception!
    try {
        period0.toStandardDuration();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public Days toStandardDays() {
    checkYearsAndMonths(""Days"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    long days = millis / DateTimeConstants.MILLIS_PER_DAY;
    days = FieldUtils.safeAdd(days, getDays());
    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));
    return Days.days(FieldUtils.safeToInt(days));
}","public void test06368() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTime dateTime0 = DateTime.now((Chronology) gregorianChronology0);
    Period period0 = new Period(dateTime0, dateTime0);
    PeriodType.MILLI_INDEX = (-933);
    // Undeclared exception!
    try {
        period0.toStandardDays();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Converts this period to a period in days assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard days in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of days is too large to be represented
 * @since 1.5
 */"
"public Days toStandardDays() {
    checkYearsAndMonths(""Days"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    long days = millis / DateTimeConstants.MILLIS_PER_DAY;
    days = FieldUtils.safeAdd(days, getDays());
    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));
    return Days.days(FieldUtils.safeToInt(days));
}","public void test06469() throws Throwable {
    Period period0 = new Period((-41), (-3005), (-3005), (-41), (-3005), (-230), (-230), (-230));
    Period period1 = period0.ZERO.withWeeks(317351877);
    // Undeclared exception!
    try {
        period1.toStandardDays();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 2221463139
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Converts this period to a period in days assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard days in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of days is too large to be represented
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to add, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period plusYears(int years) {
    if (years == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);
    return new Period(values, getPeriodType());
}","public void test06570() throws Throwable {
    Period period0 = Period.minutes(648);
    PeriodType.YEAR_INDEX = 4289;
    // Undeclared exception!
    try {
        period0.plusYears((-2241));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4289
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"public Period plusSeconds(int seconds) {
    if (seconds == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);
    return new Period(values, getPeriodType());
}","public void test06671() throws Throwable {
    Instant instant0 = new Instant();
    Period period0 = Period.hours(361);
    Minutes minutes0 = period0.toStandardMinutes();
    PeriodType periodType0 = minutes0.getPeriodType();
    Period period1 = new Period(instant0, (ReadableDuration) null, periodType0);
    // Undeclared exception!
    try {
        period1.plusSeconds(361);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of seconds added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to add, may be negative
 * @return the new period plus the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusSeconds(int seconds) {
    if (seconds == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);
    return new Period(values, getPeriodType());
}","public void test06772() throws Throwable {
    Days days0 = Days.TWO;
    Weeks weeks0 = days0.toStandardWeeks();
    Duration duration0 = weeks0.toStandardDuration();
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) null);
    Period period0 = duration0.toPeriod((Chronology) iSOChronology0);
    PeriodType.SECOND_INDEX = (-1783);
    // Undeclared exception!
    try {
        period0.plusSeconds((-1783));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1783
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of seconds added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to add, may be negative
 * @return the new period plus the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMonths(int months) {
    if (months == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);
    return new Period(values, getPeriodType());
}","public void test06873() throws Throwable {
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(0L, 0L, periodType0);
    PeriodType.MONTH_INDEX = 61;
    // Undeclared exception!
    try {
        period0.plusMonths(61);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 61
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of months added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to add, may be negative
 * @return the new period plus the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMinutes(int minutes) {
    if (minutes == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test06974() throws Throwable {
    PeriodPrinter periodPrinter0 = mock(PeriodPrinter.class, new ViolatedAssumptionAnswer());
    PeriodParser periodParser0 = mock(PeriodParser.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(periodParser0).parseInto(any(org.joda.time.ReadWritablePeriod.class), anyString(), anyInt(), any(java.util.Locale.class));
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodPrinter0, periodParser0);
    PeriodType periodType0 = PeriodType.yearMonthDay();
    PeriodFormatter periodFormatter1 = periodFormatter0.withParseType(periodType0);
    Period period0 = Period.parse("""", periodFormatter1);
    // Undeclared exception!
    try {
        period0.plusMinutes((-1226));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of minutes added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period plus the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMillis(int millis) {
    if (millis == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);
    return new Period(values, getPeriodType());
}","public void test07075() throws Throwable {
    Minutes minutes0 = Minutes.THREE;
    PeriodType periodType0 = minutes0.getPeriodType();
    PeriodPrinter periodPrinter0 = mock(PeriodPrinter.class, new ViolatedAssumptionAnswer());
    PeriodParser periodParser0 = mock(PeriodParser.class, new ViolatedAssumptionAnswer());
    doReturn(2537).when(periodParser0).parseInto(any(org.joda.time.ReadWritablePeriod.class), anyString(), anyInt(), any(java.util.Locale.class));
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodPrinter0, periodParser0);
    PeriodFormatter periodFormatter1 = periodFormatter0.withParseType(periodType0);
    Period period0 = Period.parse("""", periodFormatter1);
    // Undeclared exception!
    try {
        period0.plusMillis((-90));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of millis added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to add, may be negative
 * @return the new period plus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMillis(int millis) {
    if (millis == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);
    return new Period(values, getPeriodType());
}","public void test07176() throws Throwable {
    Period period0 = Period.seconds(0);
    PeriodType.MILLI_INDEX = (-1506);
    // Undeclared exception!
    try {
        period0.plusMillis(366);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1506
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of millis added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to add, may be negative
 * @return the new period plus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusHours(int hours) {
    if (hours == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);
    return new Period(values, getPeriodType());
}","public void test07277() throws Throwable {
    Period period0 = Period.minutes(648);
    PeriodType.HOUR_INDEX = 4289;
    // Undeclared exception!
    try {
        period0.plusHours(648);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4289
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of hours added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to add, may be negative
 * @return the new period plus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusDays(int days) {
    if (days == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);
    return new Period(values, getPeriodType());
}","public void test07378() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    LocalTime localTime0 = new LocalTime((-763L), (Chronology) islamicChronology0);
    Period period0 = Period.fieldDifference(localTime0, localTime0);
    // Undeclared exception!
    try {
        period0.plusDays(1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of days added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to add, may be negative
 * @return the new period plus the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period added.
 * <p>
 * Each field of the period is added separately. Thus a period of
 * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result
 * of 5 hours 70 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period plus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test07479() throws Throwable {
    PeriodType periodType0 = PeriodType.yearDay();
    MutablePeriod mutablePeriod0 = new MutablePeriod(31536000000L, 413L, periodType0);
    Minutes minutes0 = Minutes.standardMinutesIn(mutablePeriod0);
    Period period0 = new Period(1440L, 604800L, periodType0);
    // Undeclared exception!
    try {
        period0.plus(minutes0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period added.
 * <p>
 * Each field of the period is added separately. Thus a period of
 * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result
 * of 5 hours 70 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period plus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test07580() throws Throwable {
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(0L, 0L, periodType0);
    PeriodType.HOUR_INDEX = 2351;
    Hours hours0 = Hours.EIGHT;
    // Undeclared exception!
    try {
        period0.ZERO.plus(hours0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2351
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"public static Period parse(String str, PeriodFormatter formatter) {
    return formatter.parsePeriod(str);
}","public void test07681() throws Throwable {
    PeriodPrinter periodPrinter0 = mock(PeriodPrinter.class, new ViolatedAssumptionAnswer());
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodPrinter0, (PeriodParser) null);
    // Undeclared exception!
    try {
        Period.parse(""q9@x}Ih6UM[t5o'F"", periodFormatter0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Parsing not supported
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Parses a {@code Period} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static Period parse(String str, PeriodFormatter formatter) {
    return formatter.parsePeriod(str);
}","public void test07782() throws Throwable {
    // Undeclared exception!
    try {
        Period.parse(""up$s./(0_%:"", (PeriodFormatter) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Parses a {@code Period} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static Period parse(String str, PeriodFormatter formatter) {
    return formatter.parsePeriod(str);
}","public void test07883() throws Throwable {
    PeriodPrinter periodPrinter0 = mock(PeriodPrinter.class, new ViolatedAssumptionAnswer());
    PeriodParser periodParser0 = mock(PeriodParser.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(periodParser0).parseInto(any(org.joda.time.ReadWritablePeriod.class), anyString(), anyInt(), any(java.util.Locale.class));
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodPrinter0, periodParser0);
    // Undeclared exception!
    try {
        Period.parse(""GNI:>qN7Jhe)V"", periodFormatter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""GNI:>qN7Jhe)V\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Parses a {@code Period} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code Period} from the specified string.
 * <p>
 * This uses {@link ISOPeriodFormat#standard()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static Period parse(String str) {
    return parse(str, ISOPeriodFormat.standard());
}","public void test07984() throws Throwable {
    // Undeclared exception!
    try {
        Period.parse((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder$Literal"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute,
 * providing control over how the result is split into fields.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The PeriodType parameter controls how the result is created. It allows
 * you to omit certain fields from the result if desired. For example,
 * you may not want the result to include weeks, in which case you pass
 * in <code>PeriodType.yearMonthDayTime()</code>.
 *
 * @param type  the period type of the new period, null means standard type
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @throws UnsupportedOperationException if this period contains non-zero
 *  years or months but the specified period type does not support them
 * @since 1.5
 */
public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();
    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        if (years != 0) {
            result = result.withYears(years);
        }
        if (months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}","public void test08085() throws Throwable {
    Period period0 = Period.months(8);
    PeriodType periodType0 = PeriodType.yearMonthDay();
    PeriodType.SECOND_INDEX = 8;
    // Undeclared exception!
    try {
        period0.normalizedStandard(periodType0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute,
 * providing control over how the result is split into fields.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The PeriodType parameter controls how the result is created. It allows
 * you to omit certain fields from the result if desired. For example,
 * you may not want the result to include weeks, in which case you pass
 * in <code>PeriodType.yearMonthDayTime()</code>.
 *
 * @param type  the period type of the new period, null means standard type
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @throws UnsupportedOperationException if this period contains non-zero
 *  years or months but the specified period type does not support them
 * @since 1.5
 */
public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();
    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        if (years != 0) {
            result = result.withYears(years);
        }
        if (months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}","public void test08186() throws Throwable {
    Period period0 = Period.minutes(10209375);
    Period period1 = period0.plusDays(10209375);
    PeriodType periodType0 = PeriodType.minutes();
    // Undeclared exception!
    try {
        period1.normalizedStandard(periodType0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 14711709375
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The result will always have a <code>PeriodType</code> of standard, thus
 * days will be grouped into weeks.
 *
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @since 1.5
 */
public Period normalizedStandard() {
    return normalizedStandard(PeriodType.standard());
}","public void test08287() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    Period period0 = new Period(576L, (Chronology) islamicChronology0);
    PeriodType.DAY_INDEX = (-1);
    // Undeclared exception!
    try {
        period0.normalizedStandard();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to take away, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period minusYears(int years) {
    return plusYears(-years);
}","public void test08388() throws Throwable {
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period((-2289L), (-2289L), periodType0);
    // Undeclared exception!
    try {
        period0.minusYears((-36));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to take away, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period minusYears(int years) {
    return plusYears(-years);
}","public void test08489() throws Throwable {
    Period period0 = Period.seconds((-5051));
    PeriodType.YEAR_INDEX = (-5051);
    // Undeclared exception!
    try {
        period0.ZERO.minusYears(1574);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -5051
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"public Period minusWeeks(int weeks) {
    return plusWeeks(-weeks);
}","public void test08590() throws Throwable {
    LocalTime localTime0 = LocalTime.now();
    PeriodType periodType0 = PeriodType.time();
    Period period0 = new Period(localTime0, localTime0, periodType0);
    // Undeclared exception!
    try {
        period0.minusWeeks(1525);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of weeks taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param weeks  the amount of weeks to take away, may be negative
 * @return the new period minus the increased weeks
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusSeconds(int seconds) {
    return plusSeconds(-seconds);
}","public void test08691() throws Throwable {
    LocalDate localDate0 = new LocalDate((Object) null);
    Period period0 = Period.fieldDifference(localDate0, localDate0);
    // Undeclared exception!
    try {
        period0.minusSeconds(4645);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of seconds taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to take away, may be negative
 * @return the new period minus the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusSeconds(int seconds) {
    return plusSeconds(-seconds);
}","public void test08792() throws Throwable {
    PeriodType.SECOND_INDEX = (-1783);
    Period period0 = new Period();
    // Undeclared exception!
    try {
        period0.minusSeconds(170);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1783
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of seconds taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param seconds  the amount of seconds to take away, may be negative
 * @return the new period minus the increased seconds
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMonths(int months) {
    return plusMonths(-months);
}","public void test08893() throws Throwable {
    MockDate mockDate0 = new MockDate();
    LocalDateTime localDateTime0 = LocalDateTime.fromDateFields(mockDate0);
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(localDateTime0, localDateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.minusMonths(1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of months taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to take away, may be negative
 * @return the new period minus the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMonths(int months) {
    return plusMonths(-months);
}","public void test08994() throws Throwable {
    Period period0 = Period.minutes(163);
    PeriodType.MONTH_INDEX = 163;
    // Undeclared exception!
    try {
        period0.ZERO.minusMonths(6);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 163
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of months taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to take away, may be negative
 * @return the new period minus the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMinutes(int minutes) {
    return plusMinutes(-minutes);
}","public void test09095() throws Throwable {
    LocalDate localDate0 = new LocalDate((Object) null);
    Period period0 = Period.fieldDifference(localDate0, localDate0);
    // Undeclared exception!
    try {
        period0.minusMinutes(3877);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of minutes taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to take away, may be negative
 * @return the new period minus the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMinutes(int minutes) {
    return plusMinutes(-minutes);
}","public void test09196() throws Throwable {
    DurationFieldType[] durationFieldTypeArray0 = new DurationFieldType[1];
    int[] intArray0 = new int[5];
    PeriodType periodType0 = new PeriodType(""cex7.&i]f^B5D{mU"", durationFieldTypeArray0, intArray0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Period period0 = new Period(0L, 0L, periodType0, gregorianChronology0);
    // Undeclared exception!
    try {
        period0.minusMinutes((-544));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of minutes taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to take away, may be negative
 * @return the new period minus the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMillis(int millis) {
    return plusMillis(-millis);
}","public void test09297() throws Throwable {
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = new Period((-4510L), 0L, periodType0);
    // Undeclared exception!
    try {
        period0.minusMillis(1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of millis taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to take away, may be negative
 * @return the new period minus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusMillis(int millis) {
    return plusMillis(-millis);
}","public void test09398() throws Throwable {
    Period period0 = Period.millis(50);
    PeriodType.MILLI_INDEX = 50;
    // Undeclared exception!
    try {
        period0.minusMillis((-934));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 50
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of millis taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to take away, may be negative
 * @return the new period minus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusHours(int hours) {
    return plusHours(-hours);
}","public void test09499() throws Throwable {
    Period period0 = new Period();
    PeriodType.HOUR_INDEX = (-1330);
    // Undeclared exception!
    try {
        period0.minusHours(12825000);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1330
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of hours taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to take away, may be negative
 * @return the new period minus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusDays(int days) {
    return plusDays(-days);
}","public void test095100() throws Throwable {
    PeriodType periodType0 = PeriodType.years();
    Period period0 = new Period(745L, 745L, periodType0);
    // Undeclared exception!
    try {
        period0.minusDays(2622);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of days taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to take away, may be negative
 * @return the new period minus the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period minusDays(int days) {
    return plusDays(-days);
}","public void test096101() throws Throwable {
    Period period0 = new Period();
    PeriodType.DAY_INDEX = (-5051);
    // Undeclared exception!
    try {
        period0.minusDays((-5051));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -5051
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of days taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to take away, may be negative
 * @return the new period minus the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period subtracted.
 * <p>
 * Each field of the period is subtracted separately. Thus a period of
 * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result
 * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period minus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test097102() throws Throwable {
    PeriodType periodType0 = PeriodType.standard();
    Period period0 = new Period((-1783), (-1783), (-990), (-1783), (-1783), (-1083), 805, 1783, periodType0);
    PeriodType.MINUTE_INDEX = 3514;
    // Undeclared exception!
    try {
        period0.ZERO.minus(period0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 3514
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period subtracted.
 * <p>
 * Each field of the period is subtracted separately. Thus a period of
 * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result
 * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period minus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test098103() throws Throwable {
    Period period0 = new Period((-3659), 445, 352, 0);
    Hours hours0 = Hours.MIN_VALUE;
    // Undeclared exception!
    try {
        period0.minus(hours0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: -3659 + -2147483648
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public int getWeeks() {
    return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);
}","public void test099104() throws Throwable {
    Period period0 = new Period((-3587L));
    PeriodType.WEEK_INDEX = 12;
    // Undeclared exception!
    try {
        period0.getWeeks();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the weeks field part of the period.
 *
 * @return the number of weeks in the period, zero if unsupported
 */"
"public int getSeconds() {
    return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);
}","public void test100105() throws Throwable {
    Period period0 = Period.months(8);
    PeriodType.SECOND_INDEX = 8;
    // Undeclared exception!
    try {
        period0.getSeconds();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the seconds field part of the period.
 *
 * @return the number of seconds in the period, zero if unsupported
 */"
"public int getMonths() {
    return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);
}","public void test101106() throws Throwable {
    Period period0 = Period.months(8);
    PeriodType.MONTH_INDEX = (-11);
    // Undeclared exception!
    try {
        period0.getMonths();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the months field part of the period.
 *
 * @return the number of months in the period, zero if unsupported
 */"
"public int getMillis() {
    return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);
}","public void test102107() throws Throwable {
    Period period0 = new Period((-41), (-3005), (-3005), (-41), (-3005), (-230), (-4053), (-230));
    PeriodType.MILLI_INDEX = 17;
    // Undeclared exception!
    try {
        period0.ZERO.getMillis();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the millis field part of the period.
 *
 * @return the number of millis in the period, zero if unsupported
 */"
"public int getDays() {
    return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);
}","public void test103108() throws Throwable {
    Period period0 = new Period();
    PeriodType.DAY_INDEX = (-5051);
    // Undeclared exception!
    try {
        period0.getDays();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the days field part of the period.
 *
 * @return the number of days in the period, zero if unsupported
 */"
"public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {
    super(duration, endInstant, type);
}","public void test104109() throws Throwable {
    Hours hours0 = Hours.TWO;
    Duration duration0 = hours0.toStandardDuration();
    Instant instant0 = Instant.now();
    MutableDateTime mutableDateTime0 = instant0.toMutableDateTime();
    DurationFieldType[] durationFieldTypeArray0 = new DurationFieldType[5];
    DurationFieldType durationFieldType0 = DurationFieldType.MONTHS_TYPE;
    durationFieldTypeArray0[0] = durationFieldType0;
    durationFieldTypeArray0[1] = durationFieldTypeArray0[0];
    durationFieldTypeArray0[2] = durationFieldType0;
    DurationFieldType durationFieldType1 = DurationFieldType.ERAS_TYPE;
    durationFieldTypeArray0[3] = durationFieldType1;
    int[] intArray0 = new int[3];
    PeriodType periodType0 = new PeriodType("""", durationFieldTypeArray0, intArray0);
    Period period0 = null;
    try {
        period0 = new Period(duration0, mutableDateTime0, periodType0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // eras field is unsupported
        //
        verifyException(""org.joda.time.field.UnsupportedDurationField"", e);
    }
}","/**
 * Creates a period from the given duration and end point.
 *
 * @param duration  the duration of the interval, null means zero-length
 * @param endInstant  the interval end, null means now
 * @param type  which set of fields this period supports, null means standard
 */"
"public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {
    super(duration, endInstant, type);
}","public void test105110() throws Throwable {
    Hours hours0 = Hours.TWO;
    Duration duration0 = hours0.toStandardDuration();
    Instant instant0 = Instant.now();
    MutableDateTime mutableDateTime0 = instant0.toMutableDateTime();
    DurationFieldType[] durationFieldTypeArray0 = new DurationFieldType[5];
    int[] intArray0 = new int[3];
    PeriodType periodType0 = new PeriodType("""", durationFieldTypeArray0, intArray0);
    Period period0 = null;
    try {
        period0 = new Period(duration0, mutableDateTime0, periodType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Creates a period from the given duration and end point.
 *
 * @param duration  the duration of the interval, null means zero-length
 * @param endInstant  the interval end, null means now
 * @param type  which set of fields this period supports, null means standard
 */"
"public Period(Object period, PeriodType type) {
    super(period, type, null);
}","public void test106111() throws Throwable {
    Object object0 = new Object();
    PeriodType periodType0 = PeriodType.time();
    Period period0 = null;
    try {
        period0 = new Period(object0, periodType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No period converter found for type: java.lang.Object
        //
        verifyException(""org.joda.time.convert.ConverterManager"", e);
    }
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @param type  which set of fields this period supports, null means use converter
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public Period(Object period) {
    super(period, null, null);
}","public void test107112() throws Throwable {
    Integer integer0 = new Integer((-1976));
    Period period0 = null;
    try {
        period0 = new Period((Object) integer0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No period converter found for type: java.lang.Integer
        //
        verifyException(""org.joda.time.convert.ConverterManager"", e);
    }
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public Period(long duration, PeriodType type, Chronology chronology) {
    super(duration, type, chronology);
}","public void test108113() throws Throwable {
    DurationFieldType[] durationFieldTypeArray0 = new DurationFieldType[6];
    DurationFieldType durationFieldType0 = DurationFieldType.HALFDAYS_TYPE;
    durationFieldTypeArray0[0] = durationFieldType0;
    durationFieldTypeArray0[1] = durationFieldTypeArray0[0];
    DurationFieldType durationFieldType1 = DurationFieldType.ERAS_TYPE;
    durationFieldTypeArray0[2] = durationFieldType1;
    int[] intArray0 = new int[0];
    PeriodType periodType0 = new PeriodType(""Qm]yIx,DJinY*CNh},"", durationFieldTypeArray0, intArray0);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Period period0 = null;
    try {
        period0 = new Period((-2523L), periodType0, (Chronology) gJChronology0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // eras field is unsupported
        //
        verifyException(""org.joda.time.field.UnsupportedDurationField"", e);
    }
}","/**
 * Creates a period from the given millisecond duration.
 * <p>
 * Only precise fields in the period type will be used.
 * Imprecise fields will not be populated.
 * <p>
 * If the duration is small then this method will perform
 * as you might expect and split the fields evenly.
 * <p>
 * If the duration is large then all the remaining duration will
 * be stored in the largest available precise field.
 * For details as to which fields are precise, review the period type javadoc.
 *
 * @param duration  the duration, in milliseconds
 * @param type  which set of fields this period supports, null means standard
 * @param chronology  the chronology to use to split the duration, null means ISO default
 */"
"public Period(long duration, PeriodType type) {
    super(duration, type, null);
}","public void test109114() throws Throwable {
    DurationFieldType[] durationFieldTypeArray0 = new DurationFieldType[5];
    DurationFieldType durationFieldType0 = DurationFieldType.MONTHS_TYPE;
    durationFieldTypeArray0[0] = durationFieldType0;
    durationFieldTypeArray0[1] = durationFieldType0;
    durationFieldTypeArray0[2] = durationFieldType0;
    DurationFieldType durationFieldType1 = DurationFieldType.ERAS_TYPE;
    durationFieldTypeArray0[3] = durationFieldType1;
    int[] intArray0 = new int[3];
    PeriodType periodType0 = new PeriodType("""", durationFieldTypeArray0, intArray0);
    Period period0 = null;
    try {
        period0 = new Period((long) 83, periodType0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // eras field is unsupported
        //
        verifyException(""org.joda.time.field.UnsupportedDurationField"", e);
    }
}","/**
 * Creates a period from the given millisecond duration.
 * <p>
 * Only precise fields in the period type will be used.
 * Imprecise fields will not be populated.
 * <p>
 * If the duration is small then this method will perform
 * as you might expect and split the fields evenly.
 * <p>
 * If the duration is large then all the remaining duration will
 * be stored in the largest available precise field.
 * For details as to which fields are precise, review the period type javadoc.
 *
 * @param duration  the duration, in milliseconds
 * @param type  which set of fields this period supports, null means standard
 */"
"public Period(long duration) {
    super(duration);
}","public void test110115() throws Throwable {
    Period period0 = null;
    try {
        period0 = new Period(1000000000000000000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 277777777777
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Creates a period from the given millisecond duration using the standard
 * set of fields.
 * <p>
 * Only precise fields in the period type will be used.
 * For the standard period type this is the time fields only.
 * Thus the year, month, week and day fields will not be populated.
 * <p>
 * If the duration is small, less than one day, then this method will perform
 * as you might expect and split the fields evenly.
 * <p>
 * If the duration is larger than one day then all the remaining duration will
 * be stored in the largest available precise field, hours in this case.
 * <p>
 * For example, a duration equal to (365 + 60 + 5) days will be converted to
 * ((365 + 60 + 5) * 24) hours by this constructor.
 * <p>
 * For more control over the conversion process, you have two options:
 * <ul>
 * <li>convert the duration to an {@link Interval}, and from there obtain the period
 * <li>specify a period type that contains precise definitions of the day and larger
 * fields, such as UTC
 * </ul>
 *
 * @param duration  the duration, in milliseconds
 */"
"public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {
    super(years, months, weeks, days, hours, minutes, seconds, millis, type);
}","public void test111116() throws Throwable {
    int[] intArray0 = new int[8];
    PeriodType periodType0 = new PeriodType(""7ht"", (DurationFieldType[]) null, intArray0);
    Period period0 = null;
    try {
        period0 = new Period((-2825), (-2825), 15271875, (-194), (-2825), (-2825), (-194), (-2825), periodType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Create a period from a set of field values.
 * <p>
 * There is usually little need to use this constructor.
 * The period type is used primarily to define how to split an interval into a period.
 * As this constructor already is split, the period type does no real work.
 *
 * @param years  amount of years in this period, which must be zero if unsupported
 * @param months  amount of months in this period, which must be zero if unsupported
 * @param weeks  amount of weeks in this period, which must be zero if unsupported
 * @param days  amount of days in this period, which must be zero if unsupported
 * @param hours  amount of hours in this period, which must be zero if unsupported
 * @param minutes  amount of minutes in this period, which must be zero if unsupported
 * @param seconds  amount of seconds in this period, which must be zero if unsupported
 * @param millis  amount of milliseconds in this period, which must be zero if unsupported
 * @param type  which set of fields this period supports, null means AllType
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */"
"public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {
    super(years, months, weeks, days, hours, minutes, seconds, millis, type);
}","public void test112117() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = null;
    try {
        period0 = new Period((-1391), (-1391), (-4172), 2532, 488, 2532, 7, (-3906), periodType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'weeks'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Create a period from a set of field values.
 * <p>
 * There is usually little need to use this constructor.
 * The period type is used primarily to define how to split an interval into a period.
 * As this constructor already is split, the period type does no real work.
 *
 * @param years  amount of years in this period, which must be zero if unsupported
 * @param months  amount of months in this period, which must be zero if unsupported
 * @param weeks  amount of weeks in this period, which must be zero if unsupported
 * @param days  amount of days in this period, which must be zero if unsupported
 * @param hours  amount of hours in this period, which must be zero if unsupported
 * @param minutes  amount of minutes in this period, which must be zero if unsupported
 * @param seconds  amount of seconds in this period, which must be zero if unsupported
 * @param millis  amount of milliseconds in this period, which must be zero if unsupported
 * @param type  which set of fields this period supports, null means AllType
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test113118() throws Throwable {
    Duration duration0 = Duration.standardMinutes(60L);
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = duration0.toPeriod(periodType0);
    Period period1 = period0.normalizedStandard(periodType0);
    assertTrue(period1.equals((Object) period0));
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new instance with each element in this period multiplied
 * by the specified scalar.
 *
 * @param scalar  the scalar to multiply by, not null
 * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null
 * @throws ArithmeticException if the capacity of any field is exceeded
 * @since 2.1
 */
public Period multipliedBy(int scalar) {
    if (this == ZERO || scalar == 1) {
        return this;
    }
    // cloned
    int[] values = getValues();
    for (int i = 0; i < values.length; i++) {
        values[i] = FieldUtils.safeMultiply(values[i], scalar);
    }
    return new Period(values, getPeriodType());
}","public void test114119() throws Throwable {
    Period period0 = Period.millis(0);
    Period period1 = period0.multipliedBy(0);
    assertNotSame(period1, period0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test114120() throws Throwable {
    Period period0 = Period.millis(0);
    Period period1 = period0.multipliedBy(0);
    assertTrue(period1.equals((Object) period0));
}",""
"public Period plusMillis(int millis) {
    if (millis == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);
    return new Period(values, getPeriodType());
}","public void test115121() throws Throwable {
    Period period0 = Period.seconds(2096);
    Period period1 = period0.plusMillis(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period plus the specified number of millis added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to add, may be negative
 * @return the new period plus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusHours(int hours) {
    if (hours == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);
    return new Period(values, getPeriodType());
}","public void test116122() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    MutablePeriod mutablePeriod0 = new MutablePeriod(3712L, 3712L, iSOChronology0);
    Period period0 = mutablePeriod0.toPeriod();
    Period period1 = period0.plusHours(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period plus the specified number of hours added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to add, may be negative
 * @return the new period plus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMonths(int months) {
    if (months == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);
    return new Period(values, getPeriodType());
}","public void test117123() throws Throwable {
    Duration duration0 = Duration.standardDays(86400L);
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = duration0.toPeriodTo((ReadableInstant) null, periodType0);
    // Undeclared exception!
    try {
        period0.plusMonths(63);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of months added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to add, may be negative
 * @return the new period plus the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to add, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period plusYears(int years) {
    if (years == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);
    return new Period(values, getPeriodType());
}","public void test118124() throws Throwable {
    Days days0 = Days.SEVEN;
    Duration duration0 = days0.toStandardDuration();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTime dateTime0 = new DateTime((DateTimeZone) fixedDateTimeZone0);
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = duration0.toPeriodFrom((ReadableInstant) dateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.plusYears(1203);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified number of years added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to add, may be negative
 * @return the new period with the increased years
 * @throws UnsupportedOperationException if the field is not supported
 */
public Period plusYears(int years) {
    if (years == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);
    return new Period(values, getPeriodType());
}","public void test119125() throws Throwable {
    Days days0 = Days.SEVEN;
    Duration duration0 = days0.toStandardDuration();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTime dateTime0 = new DateTime((DateTimeZone) fixedDateTimeZone0);
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = duration0.toPeriodFrom((ReadableInstant) dateTime0, periodType0);
    Period period1 = period0.plusYears(0);
    assertSame(period1, period0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the hours field part of the period.
 *
 * @return the number of hours in the period, zero if unsupported
 */
public int getHours() {
    return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);
}","public void test120126() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(0, 0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Period period0 = new Period((-1L), (Chronology) ethiopicChronology0);
    int int0 = period0.getHours();
    assertEquals(0, int0);
}",""
"public Period plusHours(int hours) {
    if (hours == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);
    return new Period(values, getPeriodType());
}","public void test121127() throws Throwable {
    Hours hours0 = Hours.SIX;
    Days days0 = hours0.toStandardDays();
    PeriodType periodType0 = days0.getPeriodType();
    Period period0 = new Period(4540L, periodType0);
    // Undeclared exception!
    try {
        period0.plusHours(2025);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of hours added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to add, may be negative
 * @return the new period plus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period(Object period) {
    super(period, null, null);
}","public void test122128() throws Throwable {
    Period period0 = new Period((Object) null);
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public int getWeeks() {
    return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);
}","public void test123129() throws Throwable {
    Period period0 = Period.months((-5051));
    int int0 = period0.getWeeks();
    assertEquals(0, int0);
}","/**
 * Gets the weeks field part of the period.
 *
 * @return the number of weeks in the period, zero if unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new instance with each element in this period multiplied
 * by the specified scalar.
 *
 * @param scalar  the scalar to multiply by, not null
 * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null
 * @throws ArithmeticException if the capacity of any field is exceeded
 * @since 2.1
 */
public Period multipliedBy(int scalar) {
    if (this == ZERO || scalar == 1) {
        return this;
    }
    // cloned
    int[] values = getValues();
    for (int i = 0; i < values.length; i++) {
        values[i] = FieldUtils.safeMultiply(values[i], scalar);
    }
    return new Period(values, getPeriodType());
}","public void test124130() throws Throwable {
    Period period0 = new Period((-2233L));
    // Undeclared exception!
    try {
        period0.multipliedBy((-292269337));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows an int: -233 * -292269337
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public Period(ReadableDuration duration, ReadableInstant endInstant) {
    super(duration, endInstant, null);
}","public void test125131() throws Throwable {
    Duration duration0 = new Duration(0L, 0L);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Instant instant0 = gJChronology0.getGregorianCutover();
    Period period0 = new Period(duration0, instant0);
}","/**
 * Creates a period from the given duration and end point.
 *
 * @param duration  the duration of the interval, null means zero-length
 * @param endInstant  the interval end, null means now
 */"
"public Period minusHours(int hours) {
    return plusHours(-hours);
}","public void test126132() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    DateTime dateTime0 = DateTime.now((Chronology) copticChronology0);
    PeriodType periodType0 = PeriodType.minutes();
    Period period0 = new Period(dateTime0, dateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.minusHours((-1522));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period minus the specified number of hours taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to take away, may be negative
 * @return the new period minus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the years field part of the period.
 *
 * @return the number of years in the period, zero if unsupported
 */
public int getYears() {
    return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);
}","public void test127133() throws Throwable {
    Period period0 = Period.hours(839);
    int int0 = period0.getYears();
    assertEquals(0, int0);
}",""
"public Period plusMinutes(int minutes) {
    if (minutes == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test128134() throws Throwable {
    Duration duration0 = Duration.millis(1000L);
    Seconds seconds0 = duration0.toStandardSeconds();
    PeriodType periodType0 = seconds0.getPeriodType();
    Period period0 = new Period(duration0, (ReadableInstant) null, periodType0);
    Period period1 = period0.ZERO.plusMinutes(0);
    assertNotSame(period0, period1);
}","/**
 * Returns a new period plus the specified number of minutes added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period plus the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period(Object period, PeriodType type) {
    super(period, type, null);
}","public void test129135() throws Throwable {
    PeriodType periodType0 = PeriodType.hours();
    Period period0 = new Period((Object) null, periodType0);
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @param type  which set of fields this period supports, null means use converter
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public int getDays() {
    return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);
}","public void test130136() throws Throwable {
    LocalTime localTime0 = new LocalTime(0L);
    Period period0 = new Period(localTime0, localTime0, (PeriodType) null);
    int int0 = period0.getDays();
    assertEquals(0, int0);
}","/**
 * Gets the days field part of the period.
 *
 * @return the number of days in the period, zero if unsupported
 */"
"public int getMinutes() {
    return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);
}","public void test131137() throws Throwable {
    Period period0 = Period.minutes(10209375);
    int int0 = period0.getMinutes();
    assertEquals(10209375, int0);
}","/**
 * Gets the minutes field part of the period.
 *
 * @return the number of minutes in the period, zero if unsupported
 */"
"public int getMonths() {
    return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);
}","public void test132138() throws Throwable {
    Period period0 = Period.minutes((-2229));
    int int0 = period0.getMonths();
    assertEquals(0, int0);
}","/**
 * Gets the months field part of the period.
 *
 * @return the number of months in the period, zero if unsupported
 */"
"public Period(long duration, PeriodType type, Chronology chronology) {
    super(duration, type, chronology);
}","public void test133139() throws Throwable {
    Period period0 = new Period(843L, (PeriodType) null, (Chronology) null);
}","/**
 * Creates a period from the given millisecond duration.
 * <p>
 * Only precise fields in the period type will be used.
 * Imprecise fields will not be populated.
 * <p>
 * If the duration is small then this method will perform
 * as you might expect and split the fields evenly.
 * <p>
 * If the duration is large then all the remaining duration will
 * be stored in the largest available precise field.
 * For details as to which fields are precise, review the period type javadoc.
 *
 * @param duration  the duration, in milliseconds
 * @param type  which set of fields this period supports, null means standard
 * @param chronology  the chronology to use to split the duration, null means ISO default
 */"
"public int getMillis() {
    return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);
}","public void test134140() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    int int0 = period0.ZERO.getMillis();
    assertEquals(0, int0);
}","/**
 * Gets the millis field part of the period.
 *
 * @return the number of millis in the period, zero if unsupported
 */"
"public Period(ReadablePartial start, ReadablePartial end) {
    super(start, end, null);
}","public void test135141() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) null);
    Period period0 = new Period(localDateTime0, localDateTime0);
}","/**
 * Creates a period from two partially specified times.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each.
 * As these are Partial objects, time zones have no effect on the result.
 * <p>
 * The two partials must also both be contiguous - see
 * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.
 * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.
 * <p>
 * Most calculations performed by this method have obvious results.
 * The special case is where the calculation is from a ""long"" month to a ""short"" month.
 * Here, the result favours increasing the months field rather than the days.
 * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.
 * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days
 * (exposed as 4 weeks and 2 days).
 * The results are explained by considering that the start date plus the
 * calculated period result in the end date.
 * <p>
 * An alternative way of constructing a Period from two Partials
 * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.
 * That method handles all kinds of partials.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of minutes that this period represents.
 *
 * @return the number of minutes in the period
 */
public int getMinutes() {
    return getValue();
}","public void test136142() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Minutes minutes0 = period0.toStandardMinutes();
    assertEquals(0, minutes0.getMinutes());
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test137143() throws Throwable {
    Period period0 = new Period();
    PeriodType periodType0 = PeriodType.yearWeekDay();
    Period period1 = period0.withYears(137);
    Period period2 = period1.normalizedStandard(periodType0);
    assertFalse(period2.equals((Object) period1));
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test138144() throws Throwable {
    Period period0 = Period.months(8);
    Period period1 = period0.normalizedStandard();
    assertTrue(period1.equals((Object) period0));
}",""
"//-----------------------------------------------------------------------
/**
 * Converts this period to a duration assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert from a period to a duration.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a duration equivalent to this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @since 1.5
 */
public Duration toStandardDuration() {
    checkYearsAndMonths(""Duration"");
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    return new Duration(millis);
}","public void test139145() throws Throwable {
    Period period0 = Period.years(4);
    // Undeclared exception!
    try {
        period0.toStandardDuration();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Duration as this period contains years and years vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"public Days toStandardDays() {
    checkYearsAndMonths(""Days"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    long days = millis / DateTimeConstants.MILLIS_PER_DAY;
    days = FieldUtils.safeAdd(days, getDays());
    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));
    return Days.days(FieldUtils.safeToInt(days));
}","public void test140146() throws Throwable {
    Period period0 = new Period((-41), (-3005), (-3005), (-41), (-3005), (-230), (-230), (-230));
    // Undeclared exception!
    try {
        period0.toStandardDays();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Cannot convert to Days as this period contains months and months vary in length
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Converts this period to a period in days assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard days in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of days is too large to be represented
 * @since 1.5
 */"
"public Seconds toStandardSeconds() {
    checkYearsAndMonths(""Seconds"");
    long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
    seconds = FieldUtils.safeAdd(seconds, getSeconds());
    seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));
    seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));
    seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));
    seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));
    return Seconds.seconds(FieldUtils.safeToInt(seconds));
}","public void test141147() throws Throwable {
    Period period0 = new Period();
    Period period1 = period0.plusDays(2527);
    Period period2 = period1.multipliedBy(2527);
    // Undeclared exception!
    try {
        period2.toStandardSeconds();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 551726985600
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Converts this period to a period in seconds assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard seconds in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of seconds is too large to be represented
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period subtracted.
 * <p>
 * Each field of the period is subtracted separately. Thus a period of
 * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result
 * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period minus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test142148() throws Throwable {
    MutableDateTime mutableDateTime0 = new MutableDateTime(10080L);
    Period period0 = new Period(mutableDateTime0, mutableDateTime0);
    Period period1 = period0.ZERO.minus((ReadablePeriod) null);
    assertNotSame(period0, period1);
}",""
"public Period minusMillis(int millis) {
    return plusMillis(-millis);
}","public void test143149() throws Throwable {
    Period period0 = Period.millis(0);
    Period period1 = period0.minusMillis(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period minus the specified number of millis taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to take away, may be negative
 * @return the new period minus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test144150() throws Throwable {
    Period period0 = Period.weeks(0);
    Period period1 = period0.ZERO.plusSeconds(0);
    assertTrue(period1.equals((Object) period0));
}",""
"public Period minusHours(int hours) {
    return plusHours(-hours);
}","public void test145151() throws Throwable {
    Duration duration0 = Duration.standardDays(86400L);
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = duration0.toPeriodTo((ReadableInstant) null, periodType0);
    Period period1 = period0.minusHours(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period minus the specified number of hours taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param hours  the amount of hours to take away, may be negative
 * @return the new period minus the increased hours
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusDays(int days) {
    if (days == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);
    return new Period(values, getPeriodType());
}","public void test146152() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Period period1 = period0.plusDays(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period plus the specified number of days added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to add, may be negative
 * @return the new period plus the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);
    return new Period(values, getPeriodType());
}","public void test147153() throws Throwable {
    Duration duration0 = Duration.standardDays(86400L);
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = duration0.toPeriodTo((ReadableInstant) null, periodType0);
    Period period1 = period0.plusWeeks(0);
    assertSame(period1, period0);
}","/**
 * Returns a new period plus the specified number of weeks added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new period plus the increased weeks
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period added.
 * <p>
 * Each field of the period is added separately. Thus a period of
 * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result
 * of 5 hours 70 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period plus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test148154() throws Throwable {
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(0L, 0L, periodType0);
    Period period1 = period0.ZERO.plus((ReadablePeriod) null);
    assertNotSame(period1, period0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new period with the specified period added.
 * <p>
 * Each field of the period is added separately. Thus a period of
 * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result
 * of 5 hours 70 minutes - see {@link #normalizedStandard()}.
 * <p>
 * If the period being added contains a non-zero amount for a field that
 * is not supported in this period then an exception is thrown.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to add, null adds zero and returns this
 * @return the new updated period
 * @throws UnsupportedOperationException if any field is not supported
 * @since 1.5
 */
public Period plus(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));
    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));
    return new Period(values, getPeriodType());
}","public void test149155() throws Throwable {
    Duration duration0 = Duration.standardDays(86400L);
    Minutes minutes0 = duration0.toStandardMinutes();
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = duration0.toPeriodTo((ReadableInstant) null, periodType0);
    Period period1 = period0.plus(minutes0);
    assertNotSame(period1, period0);
}",""
"public Period withFieldAdded(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (value == 0) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    super.addFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test150156() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(0, 0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Period period0 = new Period((-1L), (Chronology) ethiopicChronology0);
    DurationFieldType durationFieldType0 = DurationFieldType.WEEKS_TYPE;
    Period period1 = period0.withFieldAdded(durationFieldType0, 0);
    assertSame(period1, period0);
}","/**
 * Creates a new Period instance with the valueToAdd added to the specified field.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to add
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */"
"public Period withFieldAdded(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (value == 0) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    super.addFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test151157() throws Throwable {
    Days days0 = Days.TWO;
    Weeks weeks0 = days0.toStandardWeeks();
    Duration duration0 = weeks0.toStandardDuration();
    Period period0 = duration0.toPeriod();
    // Undeclared exception!
    try {
        period0.withFieldAdded((DurationFieldType) null, 683);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field must not be null
        //
        verifyException(""org.joda.time.Period"", e);
    }
}","/**
 * Creates a new Period instance with the valueToAdd added to the specified field.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to add
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */"
"public Period withFieldAdded(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (value == 0) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    super.addFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test152158() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Period period0 = new Period((Object) null, iSOChronology0);
    Years years0 = Years.MIN_VALUE;
    DurationFieldType durationFieldType0 = years0.getFieldType();
    Period period1 = period0.withFieldAdded(durationFieldType0, (-420));
    assertNotSame(period1, period0);
}","/**
 * Creates a new Period instance with the valueToAdd added to the specified field.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to add
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a new Period instance with the specified field set to a new value.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to set to
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public Period withField(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    // cloned
    int[] newValues = getValues();
    super.setFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test153159() throws Throwable {
    Period period0 = Period.millis((-1869));
    // Undeclared exception!
    try {
        period0.withField((DurationFieldType) null, (-1869));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field must not be null
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Period instance with the specified field set to a new value.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param field  the field to set, not null
 * @param value  the value to set to
 * @return the new period instance
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public Period withField(DurationFieldType field, int value) {
    if (field == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    // cloned
    int[] newValues = getValues();
    super.setFieldInto(newValues, field, value);
    return new Period(newValues, getPeriodType());
}","public void test154160() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(iSOChronology0);
    Period period0 = new Period((-870L), (-870L), lenientChronology0);
    DurationFieldType durationFieldType0 = DurationFieldType.HOURS_TYPE;
    Period period1 = period0.withField(durationFieldType0, 1000);
    assertNotSame(period1, period0);
}",""
"public Period withFields(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    newValues = super.mergePeriodInto(newValues, period);
    return new Period(newValues, getPeriodType());
}","public void test155161() throws Throwable {
    MutableDateTime mutableDateTime0 = new MutableDateTime(10080L);
    Period period0 = new Period(mutableDateTime0, mutableDateTime0);
    Period period1 = period0.ZERO.withFields((ReadablePeriod) null);
    assertNotSame(period0, period1);
}","/**
 * Creates a new Period instance with the fields from the specified period
 * copied on top of those from this period.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to copy from, null ignored
 * @return the new period instance
 * @throws IllegalArgumentException if a field type is unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a new Period instance with the same field values but
 * different PeriodType.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param type  the period type to use, null means standard
 * @return the new period instance
 * @throws IllegalArgumentException if the new period won't accept all of the current fields
 */
public Period withPeriodType(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    if (type.equals(getPeriodType())) {
        return this;
    }
    return new Period(this, type);
}","public void test156162() throws Throwable {
    MockDate mockDate0 = new MockDate(0L);
    LocalDateTime localDateTime0 = LocalDateTime.fromDateFields(mockDate0);
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(localDateTime0, localDateTime0, periodType0);
    Period period1 = period0.withPeriodType(periodType0);
    assertSame(period1, period0);
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a period from two partially specified times, calculating
 * by field difference.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each. Also, the partial may not contain overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 * <p>
 * Calculation by field difference works by extracting the difference
 * one field at a time and not wrapping into other fields.
 * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.
 * <p>
 * For example, you have an event that always runs from the 27th of
 * each month to the 2nd of the next month. If you calculate this
 * period using a standard constructor, then you will get between
 * P3D and P6D depending on the month. If you use this method, then
 * you will get P1M-25D. This field-difference based period can
 * be successfully applied to each month of the year to obtain the
 * correct end date for a given start date.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    DurationFieldType[] types = new DurationFieldType[start.size()];
    int[] values = new int[start.size()];
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        types[i] = start.getFieldType(i).getDurationType();
        if (i > 0 && types[i - 1] == types[i]) {
            throw new IllegalArgumentException(""ReadablePartial objects must not have overlapping fields"");
        }
        values[i] = end.getValue(i) - start.getValue(i);
    }
    return new Period(values, PeriodType.forFields(types));
}","public void test157163() throws Throwable {
    YearMonth yearMonth0 = new YearMonth(0L);
    MonthDay monthDay0 = new MonthDay();
    // Undeclared exception!
    try {
        Period.fieldDifference(yearMonth0, monthDay0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must have the same set of fields
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a period from two partially specified times, calculating
 * by field difference.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each. Also, the partial may not contain overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 * <p>
 * Calculation by field difference works by extracting the difference
 * one field at a time and not wrapping into other fields.
 * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.
 * <p>
 * For example, you have an event that always runs from the 27th of
 * each month to the 2nd of the next month. If you calculate this
 * period using a standard constructor, then you will get between
 * P3D and P6D depending on the month. If you use this method, then
 * you will get P1M-25D. This field-difference based period can
 * be successfully applied to each month of the year to obtain the
 * correct end date for a given start date.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    DurationFieldType[] types = new DurationFieldType[start.size()];
    int[] values = new int[start.size()];
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        types[i] = start.getFieldType(i).getDurationType();
        if (i > 0 && types[i - 1] == types[i]) {
            throw new IllegalArgumentException(""ReadablePartial objects must not have overlapping fields"");
        }
        values[i] = end.getValue(i) - start.getValue(i);
    }
    return new Period(values, PeriodType.forFields(types));
}","public void test158164() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    YearMonth yearMonth0 = YearMonth.now((Chronology) copticChronology0);
    LocalTime localTime0 = LocalTime.now();
    // Undeclared exception!
    try {
        Period.fieldDifference(yearMonth0, localTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must have the same set of fields
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a period from two partially specified times, calculating
 * by field difference.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each. Also, the partial may not contain overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 * <p>
 * Calculation by field difference works by extracting the difference
 * one field at a time and not wrapping into other fields.
 * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.
 * <p>
 * For example, you have an event that always runs from the 27th of
 * each month to the 2nd of the next month. If you calculate this
 * period using a standard constructor, then you will get between
 * P3D and P6D depending on the month. If you use this method, then
 * you will get P1M-25D. This field-difference based period can
 * be successfully applied to each month of the year to obtain the
 * correct end date for a given start date.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    DurationFieldType[] types = new DurationFieldType[start.size()];
    int[] values = new int[start.size()];
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        types[i] = start.getFieldType(i).getDurationType();
        if (i > 0 && types[i - 1] == types[i]) {
            throw new IllegalArgumentException(""ReadablePartial objects must not have overlapping fields"");
        }
        values[i] = end.getValue(i) - start.getValue(i);
    }
    return new Period(values, PeriodType.forFields(types));
}","public void test159165() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    ZoneOffset zoneOffset0 = ZoneOffset.MAX;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    LocalTime localTime0 = LocalTime.fromCalendarFields(calendar0);
    LocalDateTime localDateTime0 = localDate0.toLocalDateTime(localTime0);
    // Undeclared exception!
    try {
        Period.fieldDifference(localDateTime0, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"public Period plusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);
    return new Period(values, getPeriodType());
}","public void test160166() throws Throwable {
    LocalTime localTime0 = new LocalTime();
    Period period0 = Period.fieldDifference(localTime0, localTime0);
    // Undeclared exception!
    try {
        period0.plusWeeks(24);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of weeks added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new period plus the increased weeks
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a period from two partially specified times, calculating
 * by field difference.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each. Also, the partial may not contain overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 * <p>
 * Calculation by field difference works by extracting the difference
 * one field at a time and not wrapping into other fields.
 * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.
 * <p>
 * For example, you have an event that always runs from the 27th of
 * each month to the 2nd of the next month. If you calculate this
 * period using a standard constructor, then you will get between
 * P3D and P6D depending on the month. If you use this method, then
 * you will get P1M-25D. This field-difference based period can
 * be successfully applied to each month of the year to obtain the
 * correct end date for a given start date.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    DurationFieldType[] types = new DurationFieldType[start.size()];
    int[] values = new int[start.size()];
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        types[i] = start.getFieldType(i).getDurationType();
        if (i > 0 && types[i - 1] == types[i]) {
            throw new IllegalArgumentException(""ReadablePartial objects must not have overlapping fields"");
        }
        values[i] = end.getValue(i) - start.getValue(i);
    }
    return new Period(values, PeriodType.forFields(types));
}","public void test161167() throws Throwable {
    // Undeclared exception!
    try {
        Period.fieldDifference((ReadablePartial) null, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.Period"", e);
    }
}",""
"public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {
    super(startInstant, endInstant, type);
}","public void test162168() throws Throwable {
    int[] intArray0 = new int[3];
    PeriodType periodType0 = new PeriodType(""7ht"", (DurationFieldType[]) null, intArray0);
    Period period0 = null;
    try {
        period0 = new Period((ReadableInstant) null, (ReadableInstant) null, periodType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Creates a period between the given instants.
 * <p>
 * Most calculations performed by this method have obvious results.
 * The special case is where the calculation is from a ""long"" month to a ""short"" month.
 * Here, the result favours increasing the months field rather than the days.
 * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.
 * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.
 * The results are explained by considering that the start date plus the
 * calculated period result in the end date.
 *
 * @param startInstant  interval start, null means now
 * @param endInstant  interval end, null means now
 * @param type  which set of fields this period supports, null means standard
 */"
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The result will always have a <code>PeriodType</code> of standard, thus
 * days will be grouped into weeks.
 *
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @since 1.5
 */
public Period normalizedStandard() {
    return normalizedStandard(PeriodType.standard());
}","public void test163169() throws Throwable {
    Period period0 = new Period((-41), (-3005), (-3005), (-41), (-3005), (-230), (-230), (-230));
    Period period1 = period0.normalizedStandard();
    assertNotSame(period0, period1);
}",""
"public int getMonths() {
    return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);
}","public void test164170() throws Throwable {
    Period period0 = Period.years((-1877));
    PeriodType.MONTH_INDEX = 0;
    int int0 = period0.getMonths();
    assertEquals((-1877), int0);
}","/**
 * Gets the months field part of the period.
 *
 * @return the number of months in the period, zero if unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test165171() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(iSOChronology0);
    Period period0 = new Period((-870L), (-870L), lenientChronology0);
    Period period1 = period0.minusSeconds(1);
    Days days0 = period1.toStandardDays();
    assertEquals(0, days0.getDays());
}",""
"public Days toStandardDays() {
    checkYearsAndMonths(""Days"");
    // assign to a long
    long millis = getMillis();
    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;
    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;
    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;
    long days = millis / DateTimeConstants.MILLIS_PER_DAY;
    days = FieldUtils.safeAdd(days, getDays());
    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));
    return Days.days(FieldUtils.safeToInt(days));
}","public void test165172() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(iSOChronology0);
    Period period0 = new Period((-870L), (-870L), lenientChronology0);
    Period period1 = period0.minusSeconds(1);
    Days days0 = period1.toStandardDays();
    assertNotSame(period1, period0);
}","/**
 * Converts this period to a period in days assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard days in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of days is too large to be represented
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of seconds that this period represents.
 *
 * @return the number of seconds in the period
 */
public int getSeconds() {
    return getValue();
}","public void test166173() throws Throwable {
    Period period0 = new Period();
    Seconds seconds0 = period0.toStandardSeconds();
    assertEquals(0, seconds0.getSeconds());
}",""
"public int getDays() {
    return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);
}","public void test167174() throws Throwable {
    Period period0 = Period.months(8);
    Period period1 = period0.minusDays(8);
    int int0 = period1.getDays();
    assertEquals((-8), int0);
}","/**
 * Gets the days field part of the period.
 *
 * @return the number of days in the period, zero if unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Normalizes this period using standard rules, assuming a 12 month year,
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute,
 * providing control over how the result is split into fields.
 * <p>
 * This method allows you to normalize a period.
 * However to achieve this it makes the assumption that all years are
 * 12 months, all weeks are 7 days, all days are 24 hours,
 * all hours are 60 minutes and all minutes are 60 seconds. This is not
 * true when daylight savings time is considered, and may also not be true
 * for some chronologies. However, it is included as it is a useful operation
 * for many applications and business rules.
 * <p>
 * If the period contains years or months, then the months will be
 * normalized to be between 0 and 11. The days field and below will be
 * normalized as necessary, however this will not overflow into the months
 * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.
 * But a period of 1 month 40 days will remain as 1 month 40 days.
 * <p>
 * The PeriodType parameter controls how the result is created. It allows
 * you to omit certain fields from the result if desired. For example,
 * you may not want the result to include weeks, in which case you pass
 * in <code>PeriodType.yearMonthDayTime()</code>.
 *
 * @param type  the period type of the new period, null means standard type
 * @return a normalized period equivalent to this period
 * @throws ArithmeticException if any field is too large to be represented
 * @throws UnsupportedOperationException if this period contains non-zero
 *  years or months but the specified period type does not support them
 * @since 1.5
 */
public Period normalizedStandard(PeriodType type) {
    type = DateTimeUtils.getPeriodType(type);
    // no overflow can happen, even with Integer.MAX_VALUEs
    long millis = getMillis();
    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
    int years = getYears();
    int months = getMonths();
    if (years != 0 || months != 0) {
        years = FieldUtils.safeAdd(years, months / 12);
        months = months % 12;
        if (years != 0) {
            result = result.withYears(years);
        }
        if (months != 0) {
            result = result.withMonths(months);
        }
    }
    return result;
}","public void test168175() throws Throwable {
    Hours hours0 = Hours.TWO;
    Duration duration0 = hours0.toStandardDuration();
    Period period0 = duration0.toPeriod();
    Period period1 = period0.plusMonths(2);
    PeriodType periodType0 = PeriodType.yearDayTime();
    // Undeclared exception!
    try {
        period1.normalizedStandard(periodType0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}",""
"public Seconds toStandardSeconds() {
    checkYearsAndMonths(""Seconds"");
    long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
    seconds = FieldUtils.safeAdd(seconds, getSeconds());
    seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));
    seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));
    seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));
    seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));
    return Seconds.seconds(FieldUtils.safeToInt(seconds));
}","public void test169176() throws Throwable {
    Period period0 = new Period((-3624), 10, (-2171), (-3624));
    PeriodType.SECOND_INDEX = (-2066);
    // Undeclared exception!
    try {
        period0.ZERO.toStandardSeconds();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Converts this period to a period in seconds assuming a
 * 7 day week, 24 hour day, 60 minute hour and 60 second minute.
 * <p>
 * This method allows you to convert between different types of period.
 * However to achieve this it makes the assumption that all
 * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and
 * all minutes are 60 seconds. This is not true when daylight savings time
 * is considered, and may also not be true for some unusual chronologies.
 * However, it is included as it is a useful operation for many
 * applications and business rules.
 * <p>
 * If the period contains years or months, an exception will be thrown.
 *
 * @return a period representing the number of standard seconds in this period
 * @throws UnsupportedOperationException if the period contains years or months
 * @throws ArithmeticException if the number of seconds is too large to be represented
 * @since 1.5
 */"
"public Period(Object period, PeriodType type, Chronology chrono) {
    super(period, type, chrono);
}","public void test170177() throws Throwable {
    Object object0 = new Object();
    PeriodType periodType0 = PeriodType.standard();
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Period period0 = null;
    try {
        period0 = new Period(object0, periodType0, julianChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No period converter found for type: java.lang.Object
        //
        verifyException(""org.joda.time.convert.ConverterManager"", e);
    }
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @param type  which set of fields this period supports, null means use converter
 * @param chrono  the chronology to use, null means ISO in default zone
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public Period(ReadableInstant startInstant, ReadableDuration duration) {
    super(startInstant, duration, null);
}","public void test171178() throws Throwable {
    Weeks weeks0 = Weeks.ZERO;
    Duration duration0 = weeks0.toStandardDuration();
    Period period0 = new Period((ReadableInstant) null, duration0);
}","/**
 * Creates a period from the given start point and the duration.
 *
 * @param startInstant  the interval start, null means now
 * @param duration  the duration of the interval, null means zero-length
 */"
"public Period withMonths(int months) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);
    return new Period(values, getPeriodType());
}","public void test172179() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    Period period0 = new Period(576L, (Chronology) islamicChronology0);
    Period period1 = period0.withMonths(67);
    assertNotSame(period0, period1);
}","/**
 * Returns a new period with the specified number of months.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param months  the amount of months to add, may be negative
 * @return the new period with the increased months
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period plusMinutes(int minutes) {
    if (minutes == 0) {
        return this;
    }
    // cloned
    int[] values = getValues();
    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test173180() throws Throwable {
    MutableDateTime mutableDateTime0 = new MutableDateTime((-283L));
    DateTime dateTime0 = mutableDateTime0.toDateTimeISO();
    Period period0 = new Period(dateTime0, dateTime0);
    PeriodType.MINUTE_INDEX = 1960;
    // Undeclared exception!
    try {
        period0.plusMinutes(3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1960
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period plus the specified number of minutes added.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period plus the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code Period} from the specified string.
 * <p>
 * This uses {@link ISOPeriodFormat#standard()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static Period parse(String str) {
    return parse(str, ISOPeriodFormat.standard());
}","public void test174181() throws Throwable {
    // Undeclared exception!
    try {
        Period.parse(""Positive hours must not have negative minutes: "");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""Positive hours must not have nega...\"" is malformed at \""ositive hours must not have nega...\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of hours that this period represents.
 *
 * @return the number of hours in the period
 */
public int getHours() {
    return getValue();
}","public void test175182() throws Throwable {
    Period period0 = new Period();
    Hours hours0 = period0.toStandardHours();
    Period period1 = period0.withFields(hours0);
    assertEquals(0, hours0.getHours());
}",""
"public Period withFields(ReadablePeriod period) {
    if (period == null) {
        return this;
    }
    // cloned
    int[] newValues = getValues();
    newValues = super.mergePeriodInto(newValues, period);
    return new Period(newValues, getPeriodType());
}","public void test175183() throws Throwable {
    Period period0 = new Period();
    Hours hours0 = period0.toStandardHours();
    Period period1 = period0.withFields(hours0);
    assertNotSame(period1, period0);
}","/**
 * Creates a new Period instance with the fields from the specified period
 * copied on top of those from this period.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param period  the period to copy from, null ignored
 * @return the new period instance
 * @throws IllegalArgumentException if a field type is unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Get this period as an immutable <code>Period</code> object
 * by returning <code>this</code>.
 *
 * @return <code>this</code>
 */
public Period toPeriod() {
    return this;
}","public void test176184() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    Period period0 = new Period(576L, (Chronology) islamicChronology0);
    Period period1 = period0.toPeriod();
    assertSame(period0, period1);
}",""
"public Period withMillis(int millis) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);
    return new Period(values, getPeriodType());
}","public void test177185() throws Throwable {
    PeriodType periodType0 = PeriodType.standard();
    Period period0 = new Period((-1783), (-1783), (-990), (-1783), (-1783), (-1083), 805, 1783, periodType0);
    Period period1 = period0.withMillis((-919));
    assertNotSame(period0, period1);
}","/**
 * Returns a new period with the specified number of millis.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to add, may be negative
 * @return the new period with the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public int getSeconds() {
    return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);
}","public void test178186() throws Throwable {
    Duration duration0 = Duration.standardMinutes(60L);
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = duration0.toPeriod(periodType0);
    int int0 = period0.getSeconds();
    assertEquals(0, int0);
}","/**
 * Gets the seconds field part of the period.
 *
 * @return the number of seconds in the period, zero if unsupported
 */"
"public Period(Object period, Chronology chrono) {
    super(period, null, chrono);
}","public void test179187() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance((DateTimeZone) null);
    Period period0 = null;
    try {
        period0 = new Period("""", islamicChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Creates a period by converting or copying from another object.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePeriod, ReadableInterval and String.
 * The String formats are described by {@link ISOPeriodFormat#standard()}.
 *
 * @param period  period to convert
 * @param chrono  the chronology to use, null means ISO in default zone
 * @throws IllegalArgumentException if period is invalid
 * @throws UnsupportedOperationException if an unsupported field's value is non-zero
 */"
"public Period(ReadablePartial start, ReadablePartial end) {
    super(start, end, null);
}","public void test180188() throws Throwable {
    Period period0 = null;
    try {
        period0 = new Period((ReadablePartial) null, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Creates a period from two partially specified times.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each.
 * As these are Partial objects, time zones have no effect on the result.
 * <p>
 * The two partials must also both be contiguous - see
 * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.
 * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.
 * <p>
 * Most calculations performed by this method have obvious results.
 * The special case is where the calculation is from a ""long"" month to a ""short"" month.
 * Here, the result favours increasing the months field rather than the days.
 * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.
 * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days
 * (exposed as 4 weeks and 2 days).
 * The results are explained by considering that the start date plus the
 * calculated period result in the end date.
 * <p>
 * An alternative way of constructing a Period from two Partials
 * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.
 * That method handles all kinds of partials.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test181189() throws Throwable {
    Period period0 = Period.weeks(0);
    Period period1 = period0.ZERO.negated();
    assertTrue(period1.equals((Object) period0));
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based
 * on the value of each field. All ReadablePeriod instances are accepted.
 * <p>
 * Note that a period of 1 day is not equal to a period of 24 hours,
 * nor is 1 hour equal to 60 minutes. Only periods with the same amount
 * in each field are equal.
 * <p>
 * This is because periods represent an abstracted definition of a time
 * period (eg. a day may not actually be 24 hours, it might be 23 or 25
 * at daylight savings boundary).
 * <p>
 * To compare the actual duration of two periods, convert both to
 * {@link org.joda.time.Duration Duration}s, an operation that emphasises
 * that the result may differ according to the date you choose.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return true;
}","public void test182190() throws Throwable {
    Period period0 = Period.minutes(10209375);
    Period period1 = period0.withSeconds(10209375);
    assertFalse(period1.equals((Object) period0));
}",""
"public Period withMinutes(int minutes) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);
    return new Period(values, getPeriodType());
}","public void test183191() throws Throwable {
    Duration duration0 = Duration.standardDays(86400L);
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = duration0.toPeriodTo((ReadableInstant) null, periodType0);
    Period period1 = period0.withMinutes(0);
    assertNotSame(period0, period1);
}","/**
 * Returns a new period with the specified number of minutes.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param minutes  the amount of minutes to add, may be negative
 * @return the new period with the increased minutes
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period withDays(int days) {
    // cloned
    int[] values = getValues();
    getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);
    return new Period(values, getPeriodType());
}","public void test184192() throws Throwable {
    MockDate mockDate0 = new MockDate(0L);
    LocalDateTime localDateTime0 = LocalDateTime.fromDateFields(mockDate0);
    PeriodType periodType0 = PeriodType.millis();
    Period period0 = new Period(localDateTime0, localDateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.withDays(6);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Field is not supported
        //
        verifyException(""org.joda.time.PeriodType"", e);
    }
}","/**
 * Returns a new period with the specified number of days.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param days  the amount of days to add, may be negative
 * @return the new period with the increased days
 * @throws UnsupportedOperationException if the field is not supported
 */"
