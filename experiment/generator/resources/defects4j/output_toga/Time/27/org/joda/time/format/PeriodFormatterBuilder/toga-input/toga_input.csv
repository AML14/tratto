focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 *
 * @param text text to print after field only if field is printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */
public PeriodFormatterBuilder appendSuffix(String text) {
    if (text == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new SimpleAffix(text));
}","public void test0055() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendWeeks();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder0.appendDays();
    periodFormatterBuilder2.appendYears();
    PeriodFormatterBuilder periodFormatterBuilder3 = periodFormatterBuilder0.appendSuffix("""");
    assertSame(periodFormatterBuilder3, periodFormatterBuilder1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test0077() throws Throwable {
    PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal0 = new PeriodFormatterBuilder.Literal(""Invalid style specification: "");
    CharArrayWriter charArrayWriter0 = new CharArrayWriter(90);
    BufferedWriter bufferedWriter0 = new BufferedWriter(charArrayWriter0);
    MutablePeriod mutablePeriod0 = new MutablePeriod((-1433), 796, 90, (-1433), 2964, (-1433), 90, 1);
    Locale locale0 = Locale.GERMAN;
    periodFormatterBuilder_Literal0.printTo((Writer) bufferedWriter0, (ReadablePeriod) mutablePeriod0, locale0);
    assertEquals(8, mutablePeriod0.size());
}",""
"public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
    return appendSeparator(text, text, null, true, false);
}","public void test03030() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.appendSeparatorIfFieldsAfter(""F"");
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""F"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot have two adjacent separators
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output only if fields are printed before the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsBefore("","").appendHours()</code>
 * will only output the comma if the days fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
    return appendSeparator(text, text, null, false, true);
}","public void test03131() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix("""");
    // Undeclared exception!
    try {
        periodFormatterBuilder1.appendSeparatorIfFieldsAfter("""");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Prefix not followed by field
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output only if fields are printed after the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsAfter("","").appendHours()</code>
 * will only output the comma if the hours fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
    return appendSeparator(text, text, null, false, true);
}","public void test03232() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparatorIfFieldsAfter((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output only if fields are printed after the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsAfter("","").appendHours()</code>
 * will only output the comma if the hours fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) {
    return appendSeparator(text, finalText, variants, true, true);
}","public void test03333() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix(""4q"", ""4q"");
    String[] stringArray0 = new String[6];
    // Undeclared exception!
    try {
        periodFormatterBuilder1.appendSeparator(""4q"", """", stringArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Prefix not followed by field
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @param variants  set of text values which are also acceptable when parsed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText) {
    return appendSeparator(text, finalText, null, true, true);
}","public void test03434() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparator(""utvuVq7c!VhQ _"", (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"//-----------------------------------------------------------------------
/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","").appendHours()</code>
 * will only output the comma if both the days and hours fields are output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparator(String text) {
    return appendSeparator(text, text, null, true, true);
}","public void test03535() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparator((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}",""
"public PeriodFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    clearPrefix();
    Literal literal = new Literal(text);
    append0(literal, literal);
    return this;
}","public void test03636() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix(""V.(\u0006}-BeBAV&OK%lO"");
    // Undeclared exception!
    try {
        periodFormatterBuilder1.appendLiteral(""V.(\u0006}-BeBAV&OK%lO"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Prefix not followed by field
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit specific text, and the parser to expect it.
 * The parser is case-insensitive.
 *
 * @return this PeriodFormatterBuilder
 * @throws IllegalArgumentException if text is null
 */"
"public PeriodFormatterBuilder append(PeriodFormatter formatter) {
    if (formatter == null) {
        throw new IllegalArgumentException(""No formatter supplied"");
    }
    clearPrefix();
    append0(formatter.getPrinter(), formatter.getParser());
    return this;
}","public void test03737() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix(""org.joda.time.format.PeriodFormatterBuilder$CompositeAffix"");
    PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal0 = PeriodFormatterBuilder.Literal.EMPTY;
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodFormatterBuilder_Literal0, periodFormatterBuilder_Literal0);
    // Undeclared exception!
    try {
        periodFormatterBuilder1.append(periodFormatter0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Prefix not followed by field
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Appends another formatter.
 *
 * @return this PeriodFormatterBuilder
 */"
"int calculatePrintedLength(ReadablePeriod period, Locale locale);","public void test03838() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder1.printZeroIfSupported();
    periodFormatterBuilder1.appendYears();
    PeriodPrinter periodPrinter0 = periodFormatterBuilder2.toPrinter();
    PeriodType periodType0 = PeriodType.hours();
    MutablePeriod mutablePeriod0 = new MutablePeriod((long) (-1254), periodType0);
    Duration duration0 = mutablePeriod0.toDurationTo((ReadableInstant) null);
    Duration duration1 = duration0.withDurationAdded((-1589L), (-1254));
    Period period0 = duration1.toPeriodTo((ReadableInstant) null);
    Locale locale0 = Locale.CANADA_FRENCH;
    int int0 = periodPrinter0.calculatePrintedLength(period0, locale0);
    assertEquals(22, int0);
}","/**
 * Returns the exact number of characters produced for the given period.
 *
 * @param period  the period to use
 * @param locale  the locale to use
 * @return the estimated length
 */"
"public static Minutes parseMinutes(String periodStr) {
    if (periodStr == null) {
        return Minutes.ZERO;
    }
    Period p = PARSER.parsePeriod(periodStr);
    return Minutes.minutes(p.getMinutes());
}","public void test04040() throws Throwable {
    // Undeclared exception!
    try {
        Minutes.parseMinutes(""ytim"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""ytim\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Creates a new <code>Minutes</code> by parsing a string in the ISO8601 format 'PTnM'.
 * <p>
 * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the
 * minutes component may be non-zero. If any other component is non-zero, an exception
 * will be thrown.
 *
 * @param periodStr  the period string, null returns zero
 * @return the period in minutes
 * @throws IllegalArgumentException if the string format is invalid
 */"
"public MutablePeriod parseMutablePeriod(String text) {
    checkParser();
    MutablePeriod period = new MutablePeriod(0, iParseType);
    int newPos = getParser().parseInto(period, text, 0, iLocale);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return period;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test04545() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatter periodFormatter0 = periodFormatterBuilder0.toFormatter();
    // Undeclared exception!
    try {
        periodFormatter0.parseMutablePeriod(""No formatter supplied"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""No formatter supplied\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Parses a period from the given text, returning a new MutablePeriod.
 *
 * @param text  text to parse
 * @return parsed value in a MutablePeriod object
 * @throws IllegalArgumentException if any field is out of range
 */"
"public PeriodPrinter toPrinter() {
    if (iNotPrinter) {
        return null;
    }
    return toFormatter().getPrinter();
}","public void test04848() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder1.printZeroRarelyFirst();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    periodFormatterBuilder2.appendWeeks();
    PeriodPrinter periodPrinter0 = periodFormatterBuilder0.toPrinter();
    assertNotNull(periodPrinter0);
}","/**
 * Internal method to create a PeriodPrinter instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned printer.
 *
 * @return the newly created printer, null if builder cannot create a printer
 */"
"int calculatePrintedLength(ReadablePeriod period, Locale locale);","public void test04849() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder1.printZeroRarelyFirst();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    periodFormatterBuilder2.appendWeeks();
    PeriodPrinter periodPrinter0 = periodFormatterBuilder0.toPrinter();
    PeriodType periodType0 = PeriodType.hours();
    MutablePeriod mutablePeriod0 = new MutablePeriod((long) (-1254), periodType0);
    Duration duration0 = mutablePeriod0.toDurationTo((ReadableInstant) null);
    Duration duration1 = duration0.withDurationAdded((-1589L), (-1254));
    Period period0 = duration1.toPeriodTo((ReadableInstant) null);
    Locale locale0 = Locale.CANADA_FRENCH;
    int int0 = periodPrinter0.calculatePrintedLength(period0, locale0);
    assertEquals(21, int0);
}","/**
 * Returns the exact number of characters produced for the given period.
 *
 * @param period  the period to use
 * @param locale  the locale to use
 * @return the estimated length
 */"
"int calculatePrintedLength(ReadablePeriod period, Locale locale);","public void test04950() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder1.printZeroIfSupported();
    periodFormatterBuilder1.appendYears();
    PeriodPrinter periodPrinter0 = periodFormatterBuilder2.toPrinter();
    PeriodType periodType0 = PeriodType.hours();
    MutablePeriod mutablePeriod0 = new MutablePeriod((long) (-1254), periodType0);
    Duration duration0 = mutablePeriod0.toDurationTo((ReadableInstant) null);
    Period period0 = duration0.toPeriodTo((ReadableInstant) null);
    Locale locale0 = Locale.CANADA_FRENCH;
    int int0 = periodPrinter0.calculatePrintedLength(period0, locale0);
    assertEquals(21, int0);
}","/**
 * Returns the exact number of characters produced for the given period.
 *
 * @param period  the period to use
 * @param locale  the locale to use
 * @return the estimated length
 */"
"public MutablePeriod parseMutablePeriod(String text) {
    checkParser();
    MutablePeriod period = new MutablePeriod(0, iParseType);
    int newPos = getParser().parseInto(period, text, 0, iLocale);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return period;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test05051() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.appendSecondsWithMillis();
    PeriodFormatter periodFormatter0 = periodFormatterBuilder0.toFormatter();
    // Undeclared exception!
    try {
        periodFormatter0.parseMutablePeriod(""No formatter supplied"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""No formatter supplied\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Parses a period from the given text, returning a new MutablePeriod.
 *
 * @param text  text to parse
 * @return parsed value in a MutablePeriod object
 * @throws IllegalArgumentException if any field is out of range
 */"
"//-----------------------------------------------------------------------
/**
 * Uses the specified formatter to convert this period to a String.
 *
 * @param formatter  the formatter to use, null means use <code>toString()</code>.
 * @return the formatted string
 * @since 1.5
 */
public String toString(PeriodFormatter formatter) {
    if (formatter == null) {
        return toString();
    }
    return formatter.print(this);
}","public void test05152() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod();
    String string0 = mutablePeriod0.toString((PeriodFormatter) null);
    assertEquals(""PT0S"", string0);
}",""
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test06971() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    PeriodFormatterBuilder.Composite periodFormatterBuilder_Composite0 = new PeriodFormatterBuilder.Composite(linkedList0);
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.append((PeriodPrinter) null, (PeriodParser) periodFormatterBuilder_Composite0);
    PeriodFormatter periodFormatter0 = periodFormatterBuilder1.toFormatter();
    assertFalse(periodFormatter0.isPrinter());
}",""
"public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
    return appendSeparator(text, text, null, true, false);
}","public void test07072() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatter periodFormatter0 = new PeriodFormatter((PeriodPrinter) null, (PeriodParser) null);
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.append(periodFormatter0);
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder1.appendSeparatorIfFieldsBefore(""{]X`"");
    assertSame(periodFormatterBuilder2, periodFormatterBuilder1);
}","/**
 * Append a separator, which is output only if fields are printed before the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsBefore("","").appendHours()</code>
 * will only output the comma if the days fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {
    if (printer == null && parser == null) {
        throw new IllegalArgumentException(""No printer or parser supplied"");
    }
    clearPrefix();
    append0(printer, parser);
    return this;
}","public void test07173() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix(""'bdmY)A%N:MfW"");
    PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal0 = new PeriodFormatterBuilder.Literal("""");
    // Undeclared exception!
    try {
        periodFormatterBuilder1.append((PeriodPrinter) periodFormatterBuilder_Literal0, (PeriodParser) periodFormatterBuilder_Literal0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Prefix not followed by field
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Appends a printer parser pair.
 * <p>
 * Either the printer or the parser may be null, in which case the builder will
 * be unable to produce a parser or printer repectively.
 *
 * @param printer  appends a printer to the builder, null if printing is not supported
 * @param parser  appends a parser to the builder, null if parsing is not supported
 * @return this PeriodFormatterBuilder
 * @throws IllegalArgumentException if both the printer and parser are null
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText) {
    return appendSeparator(text, finalText, null, true, true);
}","public void test07274() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder1.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    periodFormatterBuilder2.appendWeeks();
    PeriodFormatterBuilder periodFormatterBuilder3 = periodFormatterBuilder0.appendSeparator(""DateTimeZone must not be null"", """");
    assertSame(periodFormatterBuilder3, periodFormatterBuilder1);
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText) {
    return appendSeparator(text, finalText, null, true, true);
}","public void test07375() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder1.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparator(""DateTimeZone must not be null"", """");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot have two adjacent separators
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
    return appendSeparator(text, text, null, true, false);
}","public void test07476() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""No formatter supplied"");
    assertSame(periodFormatterBuilder1, periodFormatterBuilder0);
}","/**
 * Append a separator, which is output only if fields are printed before the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsBefore("","").appendHours()</code>
 * will only output the comma if the days fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) {
    return appendSeparator(text, finalText, variants, true, true);
}","public void test07577() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    String[] stringArray0 = new String[2];
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparator(""O7WvU"", (String) null, stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @param variants  set of text values which are also acceptable when parsed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
    return appendSeparator(text, text, null, true, false);
}","public void test07678() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparatorIfFieldsBefore((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a separator, which is output only if fields are printed before the separator.
 * <p>
 * For example,
 * <code>builder.appendDays().appendSeparatorIfFieldsBefore("","").appendHours()</code>
 * will only output the comma if the days fields is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"//-----------------------------------------------------------------------
/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 *
 * @param text text to print after field only if field is printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */
public PeriodFormatterBuilder appendSuffix(String text) {
    if (text == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new SimpleAffix(text));
}","public void test07779() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal0 = PeriodFormatterBuilder.Literal.EMPTY;
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.append((PeriodPrinter) periodFormatterBuilder_Literal0, (PeriodParser) periodFormatterBuilder_Literal0);
    // Undeclared exception!
    try {
        periodFormatterBuilder1.appendSuffix(""Builder has created neither a printer nor a parser"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No field to apply suffix to
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}",""
"public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) {
    if (singularText == null || pluralText == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new PluralAffix(singularText, pluralText));
}","public void test07880() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSuffix("""", ""a-w:_'P#fU2u2;R"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No field to apply suffix to
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 * <p>
 * During parsing, the singular and plural versions are accepted whether or
 * not the actual value matches plurality.
 *
 * @param singularText text to print if field value is one
 * @param pluralText text to print if field value is not one
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */"
"public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) {
    if (singularText == null || pluralText == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new PluralAffix(singularText, pluralText));
}","public void test07981() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSuffix(""*dl2m["", (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 * <p>
 * During parsing, the singular and plural versions are accepted whether or
 * not the actual value matches plurality.
 *
 * @param singularText text to print if field value is one
 * @param pluralText text to print if field value is not one
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */"
"//-----------------------------------------------------------------------
/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 *
 * @param text text to print after field only if field is printed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */
public PeriodFormatterBuilder appendSuffix(String text) {
    if (text == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new SimpleAffix(text));
}","public void test08082() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSuffix((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Append a field prefix which applies only to the next appended field. If
 * the field is not printed, neither is the prefix.
 *
 * @param text text to print before field only if field is printed
 * @return this PeriodFormatterBuilder
 * @see #appendSuffix
 */
public PeriodFormatterBuilder appendPrefix(String text) {
    if (text == null) {
        throw new IllegalArgumentException();
    }
    return appendPrefix(new SimpleAffix(text));
}","public void test08183() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.appendPrefix(""org.joda.time.format.DateTimeFormatterBuilder$TextField"");
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendPrefix(""org.joda.time.format.DateTimeFormatterBuilder$TextField"");
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}",""
"public PeriodFormatterBuilder appendPrefix(String singularText, String pluralText) {
    if (singularText == null || pluralText == null) {
        throw new IllegalArgumentException();
    }
    return appendPrefix(new PluralAffix(singularText, pluralText));
}","public void test08284() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendPrefix("",5wk!J[l`"", (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a field prefix which applies only to the next appended field. If
 * the field is not printed, neither is the prefix.
 * <p>
 * During parsing, the singular and plural versions are accepted whether
 * or not the actual value matches plurality.
 *
 * @param singularText text to print if field value is one
 * @param pluralText text to print if field value is not one
 * @return this PeriodFormatterBuilder
 * @see #appendSuffix
 */"
"public PeriodFormatterBuilder appendPrefix(String singularText, String pluralText) {
    if (singularText == null || pluralText == null) {
        throw new IllegalArgumentException();
    }
    return appendPrefix(new PluralAffix(singularText, pluralText));
}","public void test08385() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendPrefix((String) null, ""Cannot have two adjacent separators"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a field prefix which applies only to the next appended field. If
 * the field is not printed, neither is the prefix.
 * <p>
 * During parsing, the singular and plural versions are accepted whether
 * or not the actual value matches plurality.
 *
 * @param singularText text to print if field value is one
 * @param pluralText text to print if field value is not one
 * @return this PeriodFormatterBuilder
 * @see #appendSuffix
 */"
"//-----------------------------------------------------------------------
/**
 * Append a field prefix which applies only to the next appended field. If
 * the field is not printed, neither is the prefix.
 *
 * @param text text to print before field only if field is printed
 * @return this PeriodFormatterBuilder
 * @see #appendSuffix
 */
public PeriodFormatterBuilder appendPrefix(String text) {
    if (text == null) {
        throw new IllegalArgumentException();
    }
    return appendPrefix(new SimpleAffix(text));
}","public void test08486() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendPrefix((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}",""
"public PeriodFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    clearPrefix();
    Literal literal = new Literal(text);
    append0(literal, literal);
    return this;
}","public void test08689() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendLiteral((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Literal must not be null
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit specific text, and the parser to expect it.
 * The parser is case-insensitive.
 *
 * @return this PeriodFormatterBuilder
 * @throws IllegalArgumentException if text is null
 */"
"public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {
    if (printer == null && parser == null) {
        throw new IllegalArgumentException(""No printer or parser supplied"");
    }
    clearPrefix();
    append0(printer, parser);
    return this;
}","public void test08790() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.append((PeriodPrinter) null, (PeriodParser) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No printer or parser supplied
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Appends a printer parser pair.
 * <p>
 * Either the printer or the parser may be null, in which case the builder will
 * be unable to produce a parser or printer repectively.
 *
 * @param printer  appends a printer to the builder, null if printing is not supported
 * @param parser  appends a parser to the builder, null if parsing is not supported
 * @return this PeriodFormatterBuilder
 * @throws IllegalArgumentException if both the printer and parser are null
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test08891() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    PeriodFormatterBuilder.Composite periodFormatterBuilder_Composite0 = new PeriodFormatterBuilder.Composite(linkedList0);
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.append((PeriodPrinter) periodFormatterBuilder_Composite0, (PeriodParser) periodFormatterBuilder_Composite0);
    PeriodFormatter periodFormatter0 = periodFormatterBuilder1.toFormatter();
    assertTrue(periodFormatter0.isPrinter());
}",""
"public boolean isParser() {
    return (iParser != null);
}","public void test08892() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    PeriodFormatterBuilder.Composite periodFormatterBuilder_Composite0 = new PeriodFormatterBuilder.Composite(linkedList0);
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.append((PeriodPrinter) periodFormatterBuilder_Composite0, (PeriodParser) periodFormatterBuilder_Composite0);
    PeriodFormatter periodFormatter0 = periodFormatterBuilder1.toFormatter();
    assertTrue(periodFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public PeriodFormatterBuilder append(PeriodFormatter formatter) {
    if (formatter == null) {
        throw new IllegalArgumentException(""No formatter supplied"");
    }
    clearPrefix();
    append0(formatter.getPrinter(), formatter.getParser());
    return this;
}","public void test08993() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    // Undeclared exception!
    try {
        periodFormatterBuilder0.append((PeriodFormatter) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No formatter supplied
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Appends another formatter.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) {
    if (singularText == null || pluralText == null) {
        throw new IllegalArgumentException();
    }
    return appendSuffix(new PluralAffix(singularText, pluralText));
}","public void test09094() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    String[] stringArray0 = new String[0];
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    PeriodFormatterBuilder.Composite periodFormatterBuilder_Composite0 = new PeriodFormatterBuilder.Composite(linkedList0);
    PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator0 = new PeriodFormatterBuilder.Separator(""ytim"", ""ytim"", stringArray0, (PeriodPrinter) null, periodFormatterBuilder_Composite0, true, true);
    PeriodFormatter periodFormatter0 = new PeriodFormatter(periodFormatterBuilder_Separator0, periodFormatterBuilder_Composite0);
    periodFormatterBuilder0.append(periodFormatter0);
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSuffix(""LLh!f3 \u0005>2Z1F/L_>"", ""ytim"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No field to apply suffix to
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}","/**
 * Append a field suffix which applies only to the last appended field. If
 * the field is not printed, neither is the suffix.
 * <p>
 * During parsing, the singular and plural versions are accepted whether or
 * not the actual value matches plurality.
 *
 * @param singularText text to print if field value is one
 * @param pluralText text to print if field value is not one
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if no field exists to append to
 * @see #appendPrefix
 */"
"//-----------------------------------------------------------------------
/**
 * Clears out all the appended elements, allowing this builder to be reused.
 */
public void clear() {
    iMinPrintedDigits = 1;
    iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;
    iMaxParsedDigits = 10;
    iRejectSignedValues = false;
    iPrefix = null;
    if (iElementPairs == null) {
        iElementPairs = new ArrayList<Object>();
    } else {
        iElementPairs.clear();
    }
    iNotPrinter = false;
    iNotParser = false;
    iFieldFormatters = new FieldFormatter[10];
}","public void test09195() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.clear();
}",""
"public PeriodParser toParser() {
    if (iNotParser) {
        return null;
    }
    return toFormatter().getParser();
}","public void test09296() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodParser periodParser0 = periodFormatterBuilder0.toParser();
    assertNotNull(periodParser0);
}","/**
 * Internal method to create a PeriodParser instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned parser.
 *
 * @return the newly created parser, null if builder cannot create a parser
 */"
"public PeriodPrinter toPrinter() {
    if (iNotPrinter) {
        return null;
    }
    return toFormatter().getPrinter();
}","public void test09397() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    PeriodFormatterBuilder.Composite periodFormatterBuilder_Composite0 = new PeriodFormatterBuilder.Composite(linkedList0);
    periodFormatterBuilder0.append((PeriodPrinter) null, (PeriodParser) periodFormatterBuilder_Composite0);
    PeriodPrinter periodPrinter0 = periodFormatterBuilder0.toPrinter();
    assertNull(periodPrinter0);
}","/**
 * Internal method to create a PeriodPrinter instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned printer.
 *
 * @return the newly created printer, null if builder cannot create a printer
 */"
"public PeriodFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    clearPrefix();
    Literal literal = new Literal(text);
    append0(literal, literal);
    return this;
}","public void test09599() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendLiteral("""");
    assertSame(periodFormatterBuilder1, periodFormatterBuilder0);
}","/**
 * Instructs the printer to emit specific text, and the parser to expect it.
 * The parser is case-insensitive.
 *
 * @return this PeriodFormatterBuilder
 * @throws IllegalArgumentException if text is null
 */"
"//-----------------------------------------------------------------------
/**
 * Uses the specified formatter to convert this period to a String.
 *
 * @param formatter  the formatter to use, null means use <code>toString()</code>.
 * @return the formatted string
 * @since 1.5
 */
public String toString(PeriodFormatter formatter) {
    if (formatter == null) {
        return toString();
    }
    return formatter.print(this);
}","public void test096100() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    MutablePeriod mutablePeriod0 = new MutablePeriod(30617280288L, 1230L, julianChronology0);
    String string0 = mutablePeriod0.toString((PeriodFormatter) null);
    assertEquals(""P-11M-2W-6DT-8H-47M-59.058S"", string0);
}",""
"public PeriodFormatterBuilder appendMillis3Digit() {
    appendField(7, 3);
    return this;
}","public void test097101() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMillis3Digit();
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Instruct the printer to emit an integer millis field, if supported.
 * <p>
 * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) {
    return appendSeparator(text, finalText, variants, true, true);
}","public void test098102() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    String[] stringArray0 = new String[1];
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendSeparator(""No formatter supplied"", ""No formatter supplied"", stringArray0);
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @param variants  set of text values which are also acceptable when parsed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) {
    return appendSeparator(text, finalText, variants, true, true);
}","public void test099103() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendSecondsWithOptionalMillis();
    String[] stringArray0 = new String[9];
    // Undeclared exception!
    try {
        periodFormatterBuilder1.appendSeparator("":< gl#+/t~.Lg"", """", stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * This method changes the separator depending on whether it is the last separator
 * to be output.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","", ""&"").appendHours().appendSeparator("","", ""&"").appendMinutes()</code>
 * will output '1,2&3' if all three fields are output, '1&2' if two fields are output
 * and '1' if just one field is output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @param finalText  the text used used if this is the final separator to be printed
 * @param variants  set of text values which are also acceptable when parsed
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */"
"public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {
    iMinPrintedDigits = minDigits;
    return this;
}","public void test100104() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.minimumPrintedDigits(76);
    assertSame(periodFormatterBuilder1, periodFormatterBuilder0);
}","/**
 * Set the minimum digits printed for the next and following appended
 * fields. By default, the minimum digits printed is one. If the field value
 * is zero, it is not printed unless a printZero rule is applied.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodFormatterBuilder appendMonths() {
    appendField(MONTHS);
    return this;
}","public void test101105() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMonths();
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Instruct the printer to emit an integer months field, if supported.
 * <p>
 * The number of printed and parsed digits can be controlled using
 * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodPrinter toPrinter() {
    if (iNotPrinter) {
        return null;
    }
    return toFormatter().getPrinter();
}","public void test102106() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMillis();
    periodFormatterBuilder1.appendSeparator(""zaa$Qq10T{]s{(\""1K"");
    PeriodPrinter periodPrinter0 = periodFormatterBuilder0.toPrinter();
    assertNotNull(periodPrinter0);
}","/**
 * Internal method to create a PeriodPrinter instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned printer.
 *
 * @return the newly created printer, null if builder cannot create a printer
 */"
"public PeriodFormatterBuilder printZeroNever() {
    iPrintZeroSetting = PRINT_ZERO_NEVER;
    return this;
}","public void test103109() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.printZeroNever();
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Never print zero values for the next and following appended fields,
 * unless no fields would be printed. If no fields are printed, the printer
 * forces the last ""printZeroRarely"" field to print a zero.
 * <p>
 * This field setting is the default.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {
    iMaxParsedDigits = maxDigits;
    return this;
}","public void test104110() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.maximumParsedDigits(623191204);
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Set the maximum digits parsed for the next and following appended
 * fields. By default, the maximum digits parsed is ten.
 *
 * @return this PeriodFormatterBuilder
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test105111() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.appendSecondsWithMillis();
    PeriodFormatter periodFormatter0 = periodFormatterBuilder0.toFormatter();
    assertTrue(periodFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test105112() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.appendSecondsWithMillis();
    PeriodFormatter periodFormatter0 = periodFormatterBuilder0.toFormatter();
    periodFormatter0.parseMutablePeriod("""");
    assertTrue(periodFormatter0.isPrinter());
}",""
"public PeriodFormatterBuilder appendSeconds() {
    appendField(SECONDS);
    return this;
}","public void test106113() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendSeconds();
    assertSame(periodFormatterBuilder0, periodFormatterBuilder1);
}","/**
 * Instruct the printer to emit an integer seconds field, if supported.
 * <p>
 * The number of printed and parsed digits can be controlled using
 * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
 *
 * @return this PeriodFormatterBuilder
 */"
"public PeriodFormatterBuilder rejectSignedValues(boolean v) {
    iRejectSignedValues = v;
    return this;
}","public void test107114() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.rejectSignedValues(false);
    assertSame(periodFormatterBuilder1, periodFormatterBuilder0);
}","/**
 * Reject signed values when parsing the next and following appended fields.
 *
 * @return this PeriodFormatterBuilder
 */"
"public MutablePeriod parseMutablePeriod(String text) {
    checkParser();
    MutablePeriod period = new MutablePeriod(0, iParseType);
    int newPos = getParser().parseInto(period, text, 0, iLocale);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return period;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test108115() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    periodFormatterBuilder0.printZeroAlways();
    periodFormatterBuilder0.appendSecondsWithOptionalMillis();
    PeriodFormatter periodFormatter0 = periodFormatterBuilder0.toFormatter();
    // Undeclared exception!
    try {
        periodFormatter0.parseMutablePeriod("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.PeriodFormatter"", e);
    }
}","/**
 * Parses a period from the given text, returning a new MutablePeriod.
 *
 * @param text  text to parse
 * @return parsed value in a MutablePeriod object
 * @throws IllegalArgumentException if any field is out of range
 */"
"public PeriodFormatterBuilder printZeroRarelyLast() {
    iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;
    return this;
}","public void test109116() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.printZeroRarelyLast();
    assertSame(periodFormatterBuilder1, periodFormatterBuilder0);
}","/**
 * Never print zero values for the next and following appended fields,
 * unless no fields would be printed. If no fields are printed, the printer
 * forces the last ""printZeroRarely"" field to print a zero.
 * <p>
 * This field setting is the default.
 *
 * @return this PeriodFormatterBuilder
 */"
"//-----------------------------------------------------------------------
/**
 * Append a separator, which is output if fields are printed both before
 * and after the separator.
 * <p>
 * For example, <code>builder.appendDays().appendSeparator("","").appendHours()</code>
 * will only output the comma if both the days and hours fields are output.
 * <p>
 * The text will be parsed case-insensitively.
 * <p>
 * Note: appending a separator discontinues any further work on the latest
 * appended field.
 *
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparator(String text) {
    return appendSeparator(text, text, null, true, true);
}","public void test110117() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendHours();
    periodFormatterBuilder1.appendSeparator(""org.joda.time.format.PeriodFormatterBuilder$Separator"", ""org.joda.time.format.PeriodFormatterBuilder$Separator"");
    // Undeclared exception!
    try {
        periodFormatterBuilder0.appendSeparator("""");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot have two adjacent separators
        //
        verifyException(""org.joda.time.format.PeriodFormatterBuilder"", e);
    }
}",""
"public PeriodPrinter toPrinter() {
    if (iNotPrinter) {
        return null;
    }
    return toFormatter().getPrinter();
}","public void test113120() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder1.printZeroRarelyFirst();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    periodFormatterBuilder2.appendWeeks();
    PeriodFormatterBuilder periodFormatterBuilder3 = periodFormatterBuilder0.appendSuffix(""*^xz(+2cnB\""NmOV{8"", ""No resource path provided"");
    PeriodFormatterBuilder periodFormatterBuilder4 = periodFormatterBuilder3.appendSuffix(""No resource path provided"");
    PeriodPrinter periodPrinter0 = periodFormatterBuilder4.toPrinter();
    assertNotNull(periodPrinter0);
}","/**
 * Internal method to create a PeriodPrinter instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned printer.
 *
 * @return the newly created printer, null if builder cannot create a printer
 */"
"int calculatePrintedLength(ReadablePeriod period, Locale locale);","public void test113121() throws Throwable {
    PeriodFormatterBuilder periodFormatterBuilder0 = new PeriodFormatterBuilder();
    PeriodFormatterBuilder periodFormatterBuilder1 = periodFormatterBuilder0.appendMinutes();
    periodFormatterBuilder1.printZeroRarelyFirst();
    PeriodFormatterBuilder periodFormatterBuilder2 = periodFormatterBuilder0.appendSeparatorIfFieldsBefore(""*^xz(+2cnB\""NmOV{8"");
    periodFormatterBuilder2.appendWeeks();
    PeriodFormatterBuilder periodFormatterBuilder3 = periodFormatterBuilder0.appendSuffix(""*^xz(+2cnB\""NmOV{8"", ""No resource path provided"");
    PeriodFormatterBuilder periodFormatterBuilder4 = periodFormatterBuilder3.appendSuffix(""No resource path provided"");
    PeriodPrinter periodPrinter0 = periodFormatterBuilder4.toPrinter();
    PeriodType periodType0 = PeriodType.hours();
    MutablePeriod mutablePeriod0 = new MutablePeriod((long) (-1254), periodType0);
    Duration duration0 = mutablePeriod0.toDurationTo((ReadableInstant) null);
    Period period0 = duration0.toPeriodTo((ReadableInstant) null);
    Locale locale0 = Locale.CANADA_FRENCH;
    int int0 = periodPrinter0.calculatePrintedLength(period0, locale0);
    assertEquals(71, int0);
}","/**
 * Returns the exact number of characters produced for the given period.
 *
 * @param period  the period to use
 * @param locale  the locale to use
 * @return the estimated length
 */"
