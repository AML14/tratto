focal_method,test_prefix,docstring
"@Deprecated
public Chronology getChronolgy() {
    return iChrono;
}","public void test0000() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.getPivotYear();
    UTCProvider uTCProvider0 = new UTCProvider();
    ZoneId.getAvailableZoneIds();
    StringWriter stringWriter0 = new StringWriter(2275);
    stringWriter0.append('O');
    MutableDateTime.now();
    dateTimeFormatter0.parseMutableDateTime(""O-Y1EtX /r)6t63A1{I"");
    dateTimeFormatter0.withZoneUTC();
    String string0 = """";
    LocalTime localTime0 = dateTimeFormatter0.parseLocalTime(string0);
    dateTimeFormatter0.printTo((Appendable) stringWriter0, (ReadablePartial) localTime0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.getChronolgy();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""O-Y1EtX /r)6t63A1{I\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 * @deprecated Use the method with the correct spelling
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test0033() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer(3);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology((Chronology) null);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeFormatter5.withZone(fixedDateTimeZone0);
    dateTimeFormatter5.isPrinter();
}",""
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test0044() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.monthOfYear();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DurationField durationField0 = buddhistChronology0.hours();
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, durationField0);
    DateTimeFieldType dateTimeFieldType2 = unsupportedDateTimeField0.getType();
    dateTimeFieldTypeArray0[4] = dateTimeFieldType2;
    DateTimeFieldType dateTimeFieldType3 = DateTimeFieldType.hourOfDay();
    dateTimeFieldTypeArray0[5] = dateTimeFieldType3;
    int[] intArray0 = new int[3];
    FileSystemHandling.shouldAllThrowIOExceptions();
    FileSystemHandling.shouldAllThrowIOExceptions();
    intArray0[0] = 1;
    intArray0[1] = 1;
    intArray0[2] = 1;
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(1, 1, (-1));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    Integer integer0 = new Integer((-2145318844));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(1);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(buddhistChronology0);
    Locale locale0 = Locale.CANADA;
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    Integer.sum(1, (-1408));
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale((Locale) null);
    dateTimeFormatter5.print((ReadablePartial) null);
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, buddhistChronology0);
    dateTimeFormatter3.withPivotYear(intArray0[0]);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public DateTimeParser getParser() {
    return iParser;
}","public void test0055() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2000, 2000);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    copticChronology0.withZone(dateTimeZone0);
    dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter0.withPivotYear((Integer) null);
    dateTimeFormatter3.printTo((Writer) null, (ReadableInstant) null);
    dateTimeFormatter0.withChronology(copticChronology0);
    dateTimeFormatter0.getParser();
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test0066() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2000, 2000);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    copticChronology0.withZone(dateTimeZone0);
    dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter0.withPivotYear((Integer) null);
    dateTimeFormatter3.printTo((Writer) null, (ReadableInstant) null);
    dateTimeFormatter0.withChronology(copticChronology0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test0088() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    dateTimeFormatter1.parseDateTime("""");
    StringBuffer stringBuffer0 = new StringBuffer(314);
    dateTimeFormatter0.printTo(stringBuffer0, (-2114L));
    DateTimeZone.getDefault();
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 314);
    LocalDate localDate0 = dateTimeFormatter1.parseLocalDate("""");
    stringBuffer0.setLength(314);
    FileSystemHandling.shouldAllThrowIOExceptions();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter1.isParser();
    dateTimeFormatter2.parseDateTime("""");
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_StringLiteral0.printTo((Writer) charArrayWriter0, (ReadablePartial) localDate0, locale0);
    Chronology chronology0 = null;
    dateTimeFormatter0.parseDateTime(""The datetime zone must not be null"");
    LenientChronology lenientChronology0 = LenientChronology.getInstance(chronology0);
    dateTimeFormatter0.withChronology(lenientChronology0);
}",""
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test0099() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-706), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    dateTimeFormatter0.withZoneUTC();
    Locale locale0 = Locale.FRANCE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-706));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear((-706));
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Integer integer0 = new Integer((-706));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-706), gJChronology0, locale0, integer0, (-706));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    doReturn((long) (-706)).when(dateTimeUtils_MillisProvider0).getMillis();
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeParserBucket0.computeMillis();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    dateTimeFormatter3.parseInto(mutableDateTime0, ""6?OG."", (-706));
    System.setCurrentTimeMillis(4121L);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""6?OG."", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    dateTimeFormatter1.printTo((Appendable) mockPrintWriter0, (long) 3);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test01212() throws Throwable {
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    byte[] byteArray0 = new byte[4];
    byteArray0[1] = (byte) 9;
    byteArray0[1] = (byte) 6;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-83);
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(1);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    CharArrayWriter charArrayWriter1 = charArrayWriter0.append('X');
    dateTimeFormatter3.printTo((Writer) charArrayWriter1, (ReadablePartial) null);
    dateTimeFormatter2.getParser();
    String string0 = """";
    dateTimeFormatter4.parseLocalDate(string0);
    String string1 = """";
    dateTimeFormatter3.parseMutableDateTime(string1);
    String string2 = """";
    MutableDateTime mutableDateTime0 = MutableDateTime.parse(string2, dateTimeFormatter0);
    String string3 = ""Ox\\M O:\\KqaO"";
    dateTimeFormatter4.parseInto(mutableDateTime0, string3, byteArray0[2]);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadableInstant) mutableDateTime0);
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test01313() throws Throwable {
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 9;
    byteArray0[1] = (byte) 6;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-83);
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(1);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    CharArrayWriter charArrayWriter1 = charArrayWriter0.append('X');
    dateTimeFormatter3.printTo((Writer) charArrayWriter1, (ReadablePartial) null);
    dateTimeFormatter2.getParser();
    String string0 = """";
    dateTimeFormatter4.parseLocalDate(string0);
    String string1 = """";
    MutableDateTime mutableDateTime0 = MutableDateTime.parse(string1, dateTimeFormatter0);
    String string2 = ""Ox\\M O:\\KqaO"";
    dateTimeFormatter4.parseInto(mutableDateTime0, string2, byteArray0[2]);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadableInstant) mutableDateTime0);
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test01414() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 12, true, 12);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    byte[] byteArray0 = new byte[1];
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-1483));
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = ethiopicChronology0.withUTC();
    DateTimeUtils.setCurrentMillisOffset((-1483));
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(chronology0);
    dateTimeFormatter4.print((-61L));
    dateTimeFormatter1.parseMutableDateTime(""000000000063"");
    dateTimeFormatter3.isParser();
    dateTimeFormatter4.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter3.withZone(dateTimeZone0);
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    LocalTime localTime0 = LocalTime.now();
    dateTimeFormatter5.print((ReadablePartial) localTime0);
    dateTimeFormatter3.print((-28799686L));
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test01515() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    dateTimeFormatter1.withDefaultYear(1470);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    Integer integer0 = new Integer((-1101));
    Integer integer1 = Integer.getInteger("""", integer0);
    Integer integer2 = Integer.getInteger(""~C'u?aC}:-~"", integer1);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer2);
    DateTimeUtils.setCurrentMillisOffset(0);
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.getChronology();
    dateTimeFormatter0.isOffsetParsed();
    dateTimeFormatter5.withZoneUTC();
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test01616() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('w');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(gregorianChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    FileSystemHandling.appendStringToFile((EvoSuiteFile) null, ""org.joda.time.chrono.ZonedChronology$ZonedDurationField"");
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((-148));
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZone((DateTimeZone) null);
    MutableDateTime mutableDateTime0 = MutableDateTime.now();
    MutableDateTime mutableDateTime1 = mutableDateTime0.toMutableDateTimeISO();
    dateTimeFormatter5.parseInto(mutableDateTime1, """", 3);
    dateTimeFormatter0.withZoneUTC();
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified default year.
 * <p>
 * The default year is used when parsing in the case where there is a
 * month or a day but not a year. Specifically, it is used if there is
 * a field parsed with a duration between the length of a month and the
 * length of a day inclusive.
 * <p>
 * This value is typically used to move the year from 1970 to a leap year
 * to enable February 29th to be parsed.
 * Unless customised, the year 2000 is used.
 * <p>
 * This setting has no effect when printing.
 *
 * @param defaultYear  the default year to use
 * @return the new formatter, not null
 * @since 2.0
 */
public DateTimeFormatter withDefaultYear(int defaultYear) {
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);
}","public void test01717() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 190, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(190);
    Locale locale0 = Locale.TAIWAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    Integer integer0 = new Integer(190);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(190);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withOffsetParsed();
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    mutableDateTime0.addSeconds((-2147483613));
    DateTimeUtils.setCurrentMillisSystem();
    dateTimeFormatter5.parseInto(mutableDateTime0, ""LxePfoH9K{<P[QT>"", 3);
    dateTimeFormatter1.parseLocalDateTime(""LxePfoH9K{<P[QT>"");
    String string0 = ""uKt@8'1K2taE);:TEX"";
    dateTimeFormatter2.parseLocalTime(string0);
    int int0 = 2000;
    dateTimeFormatter1.withDefaultYear(int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test01818() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) iSOChronology0);
    Partial partial0 = new Partial(localDate0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""w"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) ""|"";
    objectArray0[2] = (Object) ""|"";
    objectArray0[3] = (Object) ""w"";
    objectArray0[4] = (Object) localDate0;
    objectArray0[5] = (Object) ""w"";
    objectArray0[6] = (Object) dateTimeFormatter1;
    PrintStream printStream0 = mockPrintStream0.printf(""|"", objectArray0);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadablePartial) partial0);
    dateTimeFormatter1.getChronology();
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(printStream0);
    PrintWriter printWriter0 = mockPrintWriter0.append('Y');
    MockPrintWriter mockPrintWriter1 = new MockPrintWriter(printWriter0);
    dateTimeFormatter1.printTo((Writer) mockPrintWriter1, (ReadablePartial) localDate0);
    MutableDateTime mutableDateTime0 = new MutableDateTime(0L);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadableInstant) mutableDateTime0);
    dateTimeFormatter1.parseLocalTime(""w"");
    String string0 = """";
    dateTimeFormatter0.parseLocalTime(string0);
    StringBuffer stringBuffer0 = null;
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) partial0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""w\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test01919() throws Throwable {
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(ethiopicChronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Locale locale0 = Locale.PRC;
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withLocale(locale0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZone(dateTimeZone0);
    dateTimeFormatter5.parseMillis(""org.joda.time.DateTimeZone.NameProvider"");
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public ZoneInfoProvider(String resourcePath) throws IOException {
    this(resourcePath, null, false);
}","public void test02020() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    ZoneInfoProvider zoneInfoProvider0 = new ZoneInfoProvider(""r!nOfir>3qi9T!ms6"");
}","/**
 * ZoneInfoProvider searches the given ClassLoader resource path for
 * compiled data files. Resources are loaded from the ClassLoader that
 * loaded this class.
 *
 * @throws IOException if directory or map file cannot be read
 */"
"//-----------------------------------------------------------------------
/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param buf  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */
public void printTo(StringBuffer buf, long instant) {
    printTo(buf, instant, null);
}","public void test02121() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""ZoneInfoMap"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter1.printTo(stringBuffer0, 1L);
}",""
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test02222() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-889), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    dateTimeFormatter1.getPivotYear();
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test02323() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-2375), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(17);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    dateTimeFormatter1.withChronology(buddhistChronology0);
}",""
"public DateTimeParser getParser() {
    return iParser;
}","public void test02424() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('~');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_CharacterLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    Integer integer0 = new Integer(1207);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    dateTimeFormatter2.getParser();
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test02525() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(copticChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(1);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(1);
    Integer integer0 = new Integer(1);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear(integer0);
    dateTimeFormatter5.withChronology(copticChronology0);
}",""
"public LocalDateTime withYear(int year) {
    return withLocalMillis(getChronology().year().set(getLocalMillis(), year));
}","public void test02626() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    int int0 = 65;
    dateTimeFormatter0.withDefaultYear(65);
    StringWriter stringWriter0 = new StringWriter();
    stringWriter0.getBuffer();
    LocalDateTime localDateTime0 = LocalDateTime.parse("""");
    // Undeclared exception!
    try {
        localDateTime0.withYear(int0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Returns a copy of this datetime with the year field updated.
 * <p>
 * LocalDateTime is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * year changed.
 *
 * @param year  the year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public Chronology getChronology() {
    return iChrono;
}","public void test02727() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 228, 228);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    dateTimeFormatter0.getChronology();
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test02828() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) iSOChronology0);
    Partial partial0 = new Partial(localDate0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""w"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) ""|"";
    objectArray0[1] = (Object) ""w"";
    objectArray0[2] = (Object) ""|"";
    objectArray0[3] = (Object) ""w"";
    objectArray0[4] = (Object) localDate0;
    objectArray0[5] = (Object) ""w"";
    objectArray0[6] = (Object) dateTimeFormatter1;
    objectArray0[7] = (Object) dateTimeFormatter1;
    PrintStream printStream0 = mockPrintStream0.printf(""|"", objectArray0);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadablePartial) partial0);
    dateTimeFormatter1.getChronology();
    MutableDateTime mutableDateTime0 = new MutableDateTime(0L);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadableInstant) mutableDateTime0);
    dateTimeFormatter1.parseLocalTime(""w"");
    StringBuffer stringBuffer0 = null;
    dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) partial0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test02929() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('p');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    Integer integer0 = new Integer(15271875);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    dateTimeFormatter3.isParser();
    dateTimeFormatter0.withPivotYear(integer0);
}",""
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test03030() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 1, false, 1);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale((Locale) null);
    dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter1.parseLocalTime((String) null);
}","/**
 * Parses only the local time from the given text, returning a new LocalTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test03232() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Fraction0);
    Locale locale0 = Locale.UK;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    int int0 = (-1);
    dateTimeFormatter1.withLocale(locale0);
    dateTimeFormatter0.withDefaultYear((-1));
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-1));
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withZoneUTC();
    UTCProvider uTCProvider0 = new UTCProvider();
    String string0 = ""Parsing not supported"";
    dateTimeFormatter0.parseMutableDateTime(""Parsing not supported"");
    DateTimeZone dateTimeZone0 = uTCProvider0.getZone(string0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZone(dateTimeZone0);
    // Undeclared exception!
    try {
        dateTimeFormatter5.print((long) int0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""Parsing not supported\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public DateTimeFormatter withZone(DateTimeZone zone) {
    if (iZone == zone) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);
}","public void test03333() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer(0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology((Chronology) null);
    dateTimeFormatter5.withZone(fixedDateTimeZone0);
}","/**
 * Returns a new formatter that will use the specified zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, this zone will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this zone will be set on the parsed datetime.
 * <p>
 * A null zone means of no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param zone  the zone to use as an override
 * @return the new formatter
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified default year.
 * <p>
 * The default year is used when parsing in the case where there is a
 * month or a day but not a year. Specifically, it is used if there is
 * a field parsed with a duration between the length of a month and the
 * length of a day inclusive.
 * <p>
 * This value is typically used to move the year from 1970 to a leap year
 * to enable February 29th to be parsed.
 * Unless customised, the year 2000 is used.
 * <p>
 * This setting has no effect when printing.
 *
 * @param defaultYear  the default year to use
 * @return the new formatter, not null
 * @since 2.0
 */
public DateTimeFormatter withDefaultYear(int defaultYear) {
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);
}","public void test03636() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, (-2392), true, (-5267));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    Integer integer0 = new Integer(117);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    dateTimeFormatter2.withDefaultYear(117);
}",""
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test03737() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZone(dateTimeZone0);
    Integer integer0 = new Integer(0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    dateTimeFormatter4.parseLocalTime(""u]@Q"");
}","/**
 * Parses only the local time from the given text, returning a new LocalTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test03838() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((-6852));
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    DateTime dateTime0 = new DateTime(1235, 0, (-6852), (-135), 1571, 0, 1687, gregorianChronology0);
    int int0 = (-816);
    DateTime dateTime1 = dateTime0.plusMillis(int0);
    int int1 = 0;
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(int1);
    DateTime dateTime2 = dateTime1.toDateTime(dateTimeZone0);
    dateTimeFormatter4.print((ReadableInstant) dateTime2);
}",""
"public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long instantMillis = DateTimeUtils.currentTimeMillis();
    long resolved = chrono.set(this, instantMillis);
    return new DateTime(resolved, chrono);
}","public void test03939() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 47, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(47);
    Integer integer0 = new Integer(245);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    dateTimeFormatter3.withZone(fixedDateTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer();
    LocalDateTime localDateTime0 = LocalDateTime.parse(""E+b^jb2^~g<$<4v!-u|"");
    int int0 = 1;
    LocalDateTime localDateTime1 = localDateTime0.plusDays(int0);
    LocalDate localDate0 = localDateTime1.toLocalDate();
    // Undeclared exception!
    try {
        localDate0.toDateTimeAtCurrentTime((DateTimeZone) fixedDateTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""E+b^jb2^~g<$<4v!-u|\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Converts this LocalDate to a full datetime using the specified time zone
 * setting the date fields from this instance and the time fields from
 * the current time.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime with the time as the current time
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test04040() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2847, 2847);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(2847);
    Integer integer0 = new Integer(7593750);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    dateTimeFormatter3.print((long) 2847);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test04141() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    DurationFieldType durationFieldType0 = DurationFieldType.weekyears();
    PreciseDurationField preciseDurationField0 = new PreciseDurationField(durationFieldType0, 0L);
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, preciseDurationField0);
    DateTimeFieldType dateTimeFieldType1 = unsupportedDateTimeField0.getType();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType1, 1272, (-1425));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    dateTimeFormatter0.print(2450L);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test04242() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Chronology chronology0 = buddhistChronology0.withUTC();
    dateTimeFormatter1.withChronology(chronology0);
    dateTimeFormatter1.parseMillis(""Z*MA_Y|UT>`mbD"");
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test04343() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-969));
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZone(dateTimeZone0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(ethiopicChronology0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear(0);
    dateTimeFormatter5.print((long) 0);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test04545() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology((Chronology) null);
    Integer integer0 = new Integer(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    DateTimeUtils.setCurrentMillisOffset(0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withLocale(locale0);
    dateTimeFormatter4.withPivotYear(23);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public LocalDate parseLocalDate(String text) {
    return parseLocalDateTime(text).toLocalDate();
}","public void test04646() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-542), hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-635));
    Locale locale0 = Locale.KOREAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    dateTimeFormatter2.parseLocalDate(""="");
}","/**
 * Parses only the local date from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date will be used.
 * This means that any parsed time, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test04949() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-826), false);
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_TimeZoneId0);
    Locale locale0 = Locale.KOREAN;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Instant instant0 = new Instant((long) (-826));
    Chronology chronology0 = instant0.getChronology();
    DateTime dateTime0 = new DateTime(0L);
    instant0.isBefore(dateTime0);
    LocalDateTime localDateTime0 = LocalDateTime.now(chronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter0.withOffsetParsed();
    LocalDateTime localDateTime1 = localDateTime0.minusHours((-826));
    Integer integer0 = new Integer((-826));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-11L), chronology0, locale0, integer0, (-826));
    Integer.toUnsignedLong((-826));
    dateTimeParserBucket0.computeMillis(false);
    Integer.compare((-826), (-826));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatter3.withZone(dateTimeZone0);
    localDateTime1.toLocalDate();
    dateTimeFormatter2.print((ReadablePartial) localDateTime1);
    dateTimeFormatter2.print((ReadablePartial) localDateTime1);
    long long0 = 1L;
    dateTimeFormatter3.print(long0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.withChronology(chronology0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}",""
"public DateTimeZone getZone() {
    return iZone;
}","public void test05151() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-2180), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_UnpaddedNumber0);
    dateTimeFormatter0.withPivotYear((-2180));
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    dateTimeFormatter1.getZone();
}","/**
 * Gets the zone to use as an override.
 *
 * @return the zone to use as an override
 */"
"public DateTimeParser getParser() {
    return iParser;
}","public void test05252() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(12);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(byteArrayOutputStream0);
    StringBuffer stringBuffer0 = new StringBuffer(""rW;M,l*\""f"");
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) stringBuffer0);
    PrintWriter printWriter0 = mockPrintWriter0.append((CharSequence) charBuffer0, (-2147483572), 1);
    long long0 = 0L;
    dateTimeFormatter3.printTo((Appendable) printWriter0, long0);
    dateTimeFormatter2.getParser();
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant based on the chronology
 * and time-zone of the supplied instant.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test05353() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 1027, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    dateTimeFormatter0.withDefaultYear(10080);
    int int0 = 292271022;
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    fixedDateTimeZone0.getName((long) 10080);
    String string0 = ""5b`o@6e,FTZ0"";
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime(""5b`o@6e,FTZ0"");
    String string1 = ""org.joda.time.chrono.GJYearOfEraDateTimeField"";
    int int1 = 0;
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseInto(mutableDateTime0, string1, int1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""5b`o@6e,FTZ0\"" is malformed at \""b`o@6e,FTZ0\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {
    checkPermission();
    if (offsetMillis == 0) {
        cMillisProvider = SYSTEM_MILLIS_PROVIDER;
    } else {
        cMillisProvider = new OffsetMillisProvider(offsetMillis);
    }
}","public void test05555() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>(0);
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear((-1505));
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    int int0 = (-955);
    Integer integer0 = Integer.valueOf(""Instant must not be null"", (-955));
    dateTimeFormatter3.withPivotYear(integer0);
    long long0 = (-2836L);
    // Undeclared exception!
    try {
        DateTimeUtils.setCurrentMillisOffset(long0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // radix -955 less than Character.MIN_RADIX
        //
        verifyException(""java.lang.Integer"", e);
    }
}","/**
 * Sets the current time to return the system time plus an offset.
 * <p>
 * This method changes the behaviour of {@link #currentTimeMillis()}.
 * Whenever the current time is queried, {@link System#currentTimeMillis()} is used
 * and then offset by adding the millisecond value specified here.
 *
 * @param offsetMillis  the fixed millisecond time to use
 * @throws SecurityException if the application does not have sufficient security rights
 */"
"public Chronology getChronology() {
    return iChrono;
}","public void test05757() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer((-1101));
    Integer integer1 = Integer.getInteger("""", integer0);
    Integer integer2 = Integer.getInteger(""~C'u?aC}:-~"", integer1);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer2);
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.getChronology();
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 */"
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test05858() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    int int0 = 1;
    dateTimeFormatter0.withDefaultYear(1);
    String string0 = ""(>TC|[5nkz p1^"";
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalTime(""(>TC|[5nkz p1^"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses only the local time from the given text, returning a new LocalTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test05959() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    linkedList0.add((Object) dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    Chronology chronology0 = buddhistChronology0.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(chronology0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    linkedList0.forEach(consumer0);
    DefaultNameProvider defaultNameProvider0 = new DefaultNameProvider();
    DateTimeZone.setNameProvider(defaultNameProvider0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-527));
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter1.withPivotYear(2000);
    Locale locale0 = Locale.TAIWAN;
    DateTimeZone.forTimeZone((TimeZone) null);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter3.withLocale(locale0);
    dateTimeFormatter5.getLocale();
    DateTimeFormatter dateTimeFormatter6 = dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter0.getZone();
    dateTimeFormatter4.withPivotYear(1023);
    dateTimeFormatter6.isOffsetParsed();
    DateTimeFormatter dateTimeFormatter7 = dateTimeFormatter3.withChronology(buddhistChronology0);
    dateTimeFormatter7.parseLocalDateTime(""The datetime zone id '"");
    String string0 = ""VADxWbj"";
    dateTimeFormatter7.parseMutableDateTime(string0);
    Writer writer0 = null;
    Instant instant0 = Instant.now();
    // Undeclared exception!
    try {
        dateTimeFormatter1.printTo(writer0, (ReadableInstant) instant0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"@Deprecated
public Chronology getChronolgy() {
    return iChrono;
}","public void test06060() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    Locale locale0 = Locale.KOREAN;
    Integer integer0 = new Integer(1443);
    Integer integer1 = Integer.getInteger(""Z'XETJC>(;)qj'x'.-"", integer0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1687L, (Chronology) null, locale0, integer1, 1443);
    dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""2yGA3&5>{Ut5h$c"", (-974));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear((-845));
    dateTimeFormatter2.getChronolgy();
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 * @deprecated Use the method with the correct spelling
 */"
"public DateTimeParser getParser() {
    return iParser;
}","public void test06161() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 256, 256);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(256);
    Integer integer0 = new Integer(256);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withZone(dateTimeZone0);
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    UTCProvider uTCProvider0 = new UTCProvider();
    Set<String> set0 = uTCProvider0.getAvailableIDs();
    Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
    dateTimeFormatter5.getDefaultYear();
    dateTimeFormatter5.getParser();
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test06262() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""ik=evj=Ig"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    Locale locale0 = Locale.CHINA;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear((-1825));
    dateTimeFormatter3.isPrinter();
}",""
"public DateTime getUpperLimit() {
    return iUpperLimit;
}","public void test06363() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('J');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(copticChronology0);
    dateTimeFormatter1.getChronolgy();
    int int0 = 12740625;
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTime dateTime0 = DateTime.parse("""");
    LimitChronology limitChronology0 = LimitChronology.getInstance(copticChronology0, dateTime0, dateTime0);
    // Undeclared exception!
    try {
        limitChronology0.getUpperLimit();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Returns the inclusive upper limit instant.
 *
 * @return upper limit
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test06464() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('h');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    Integer integer0 = new Integer(3600000);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(ethiopicChronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(3600000);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(0);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    UTCProvider uTCProvider0 = new UTCProvider();
    Set<String> set0 = uTCProvider0.getAvailableIDs();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.MAP_EXTENDED_RANGES;
    Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0, locale_FilteringMode0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    dateTimeFormatter5.getDefaultYear();
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test06565() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 623191204, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, (DateTimeParser) null);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    dateTimeFieldType0.getRangeDurationType();
    fixedDateTimeZone0.getNameKey(623191204);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear((-311));
    dateTimeFormatter2.getChronolgy();
    Integer integer0 = new Integer(623191204);
    dateTimeFormatter1.withPivotYear(integer0);
    dateTimeFormatter0.withOffsetParsed();
    String string0 = ""Instant must not be null"";
    StringBuffer stringBuffer0 = new StringBuffer(""Instant must not be null"");
    LocalDateTime localDateTime0 = new LocalDateTime((-1699L));
    LocalDateTime localDateTime1 = localDateTime0.withYearOfCentury(192);
    String string1 = ""Parsing not supported"";
    Locale locale0 = new Locale(string1, string1, string0);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (ReadablePartial) localDateTime1, locale0);
    dateTimeFormatter1.getLocale();
    dateTimeFormatter0.getChronology();
    // Undeclared exception!
    try {
        dateTimeFormatter2.isOffsetParsed();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 192 for yearOfCentury must be in the range [0,99]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public Locale getLocale() {
    return iLocale;
}","public void test06666() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(1);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(1900);
    dateTimeFormatter4.parseDateTime((String) null);
    String string0 = ""subtrahend"";
    Locale locale0 = new Locale(string0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    dateTimeFormatter5.getDefaultYear();
    // Undeclared exception!
    try {
        dateTimeFormatter2.getLocale();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter"", e);
    }
}","/**
 * Gets the locale that will be used for printing and parsing.
 *
 * @return the locale to use; if null, formatter uses default locale at
 * invocation time
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test06868() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-2317));
    Integer.getInteger(""$BxB)A)a^.Zjn.5If-E"");
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((Integer) null);
    Locale locale0 = new Locale(""$BxB)A)a^.Zjn.5If-E"", (String) null);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    String string0 = null;
    // Undeclared exception!
    try {
        dateTimeFormatter5.parseMutableDateTime(string0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Locale"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test06969() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, (-1313), false, (-1313));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    LimitChronology limitChronology0 = LimitChronology.getInstance(iSOChronology0, (ReadableDateTime) null, (ReadableDateTime) null);
    StrictChronology strictChronology0 = StrictChronology.getInstance(limitChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(strictChronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale((Locale) null);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((-1313));
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withOffsetParsed();
    dateTimeFormatter5.getPivotYear();
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
    appendable.append(print(partial));
}","public void test07070() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.getPivotYear();
    UTCProvider uTCProvider0 = new UTCProvider();
    uTCProvider0.getAvailableIDs();
    uTCProvider0.getZone((String) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone((DateTimeZone) null);
    StringWriter stringWriter0 = new StringWriter(2275);
    StringWriter stringWriter1 = stringWriter0.append('O');
    StringBuffer stringBuffer0 = stringWriter1.getBuffer();
    MutableDateTime mutableDateTime0 = MutableDateTime.now();
    dateTimeFormatter1.printTo(stringBuffer0, (ReadableInstant) mutableDateTime0);
    dateTimeFormatter1.parseLocalTime((String) null);
    String string0 = ""O-Y1EtX /r)6t63A1{I"";
    dateTimeFormatter0.parseMutableDateTime(string0);
    String string1 = """";
    LocalTime localTime0 = dateTimeFormatter0.parseLocalTime(string1);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) stringWriter0, (ReadablePartial) localTime0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneName"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param appendable  the destination to format to, not null
 * @param partial  partial to format
 * @since 2.0
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test07272() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    MutableDateTime mutableDateTime0 = new MutableDateTime((-2785L));
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1), 692);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(12);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    dateTimeFormatter2.print((-2856L));
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public void printTo(Writer out, long instant) throws IOException {
    printTo(out, instant, null);
}","public void test07373() throws Throwable {
    int int0 = (-63);
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-63), hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    int int1 = 694;
    Integer integer0 = new Integer(694);
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    Integer.toUnsignedLong(694);
    Writer writer0 = null;
    GJChronology.getInstance();
    int int2 = 2700;
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) null, 694L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneName"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param out  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */"
"public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
    if (zone == null) {
        zone = DateTimeZone.getDefault();
    }
    EthiopicChronology chrono;
    synchronized (cCache) {
        EthiopicChronology[] chronos = cCache.get(zone);
        if (chronos == null) {
            chronos = new EthiopicChronology[7];
            cCache.put(zone, chronos);
        }
        try {
            chrono = chronos[minDaysInFirstWeek - 1];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException(""Invalid min days in first week: "" + minDaysInFirstWeek);
        }
        if (chrono == null) {
            if (zone == DateTimeZone.UTC) {
                // First create without a lower limit.
                chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);
                // Impose lower limit and make another EthiopicChronology.
                DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
                chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);
            } else {
                chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
                chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
            }
            chronos[minDaysInFirstWeek - 1] = chrono;
        }
    }
    return chrono;
}","public void test07474() throws Throwable {
    String string0 = ""8"";
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""8"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    int int0 = (-365);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    dateTimeFormatter0.parseLocalTime(""8"");
    // Undeclared exception!
    try {
        EthiopicChronology.getInstance((DateTimeZone) fixedDateTimeZone0, (-365));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid min days in first week: -365
        //
        verifyException(""org.joda.time.chrono.EthiopicChronology"", e);
    }
}","/**
 * Gets an instance of the EthiopicChronology in the given time zone.
 *
 * @param zone  the time zone to get the chronology in, null is default
 * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
 * @return a chronology in the specified time zone
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test07575() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer(3);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    Locale locale0 = Locale.KOREAN;
    dateTimeFormatter4.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology((Chronology) null);
    dateTimeFormatter5.withZone(fixedDateTimeZone0);
    dateTimeFormatter5.getPivotYear();
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test07676() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2000, 2000);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear((Integer) null);
    dateTimeFormatter5.printTo((Writer) null, (ReadableInstant) null);
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test07777() throws Throwable {
    DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""org.joda.time.JodaTimePermission"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalDateTime(""org.joda.time.JodaTimePermission"");
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDateTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {
    appendable.append(print(instant));
}","public void test07979() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""2VvSxU"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-3088));
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    StringWriter stringWriter0 = new StringWriter();
    Object object0 = new Object();
    char[] charArray0 = new char[6];
    charArray0[0] = 'S';
    charArray0[1] = 'C';
    charArray0[2] = '{';
    charArray0[3] = 'H';
    charArray0[4] = '#';
    charArray0[5] = '5';
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) (-1755), (Chronology) copticChronology0);
    dateTimeFormatter1.parseInto(mutableDateTime0, ""2VvSxU"", 4);
    stringWriter0.write(charArray0);
    MonthDay monthDay0 = new MonthDay(1, (-1755));
    dateTimeFormatter0.printTo((Appendable) stringWriter0, (ReadablePartial) monthDay0);
    Instant instant0 = new Instant(object0);
    Instant instant1 = instant0.withMillis(copticChronology0.AM);
    dateTimeFormatter2.printTo((Appendable) stringWriter0, (ReadableInstant) instant1);
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  instant to format, null means now
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant based on the chronology
 * and time-zone of the supplied instant.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test08080() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    dateTimeFieldType0.getRangeDurationType();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    EthiopicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    dateTimeFormatter2.withLocale(locale0);
    dateTimeFormatter2.isPrinter();
    dateTimeFormatter1.getPivotYear();
    dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter2.getLocale();
    dateTimeFormatter2.parseInto((ReadWritableInstant) null, """", 1154);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test08181() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.getParser();
    dateTimeFormatter0.getPrinter();
    DateTimeUtils.setCurrentMillisSystem();
    Integer integer0 = new Integer(45);
    dateTimeFormatter0.withPivotYear(integer0);
}",""
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test08383() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    dateTimeFormatter2.withOffsetParsed();
    String string0 = """";
    Integer integer0 = new Integer((-1101));
    Integer.getInteger("""", integer0);
    ISOChronology.getInstanceUTC();
    dateTimeFormatter1.parseDateTime(""25._0u"");
    dateTimeFormatter2.isPrinter();
    dateTimeFormatter1.parseMillis(string0);
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public DateTime parseDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            DateTime dt = new DateTime(millis, chrono);
            if (iZone != null) {
                dt = dt.withZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test08484() throws Throwable {
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(32);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    Integer integer0 = Integer.getInteger(""ALL_IDS"", 1894);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withZoneUTC();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withDefaultYear(2000);
    dateTimeFormatter5.parseDateTime((String) null);
}","/**
 * Parses a date-time from the given text, returning a new DateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test08585() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    Locale locale0 = Locale.JAPAN;
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-969));
    EthiopicChronology.getInstance(dateTimeZone0);
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('K');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    dateTimeFormatter2.isParser();
    dateTimeFormatter0.withZoneUTC();
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this datetime minus the specified number of years.
 * <p>
 * The calculation will do its best to only change the year field
 * retaining the same month of year.
 * However, in certain circumstances, it may be necessary to alter
 * smaller fields. For example, 2008-02-29 minus one year cannot result
 * in 2007-02-29, so the day of month is adjusted to 2007-02-28.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * DateTime subtracted = dt.minusYears(6);
 * DateTime subtracted = dt.minus(Period.years(6));
 * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);
 * </pre>
 * <p>
 * This datetime instance is immutable and unaffected by this method call.
 *
 * @param years  the amount of years to subtract, may be negative
 * @return the new datetime minus the increased years
 * @since 1.1
 */
public DateTime minusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().subtract(getMillis(), years);
    return withMillis(instant);
}","public void test08686() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    int int0 = 115;
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 115, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""No instant converter found for type: "");
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(115);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(115);
    Chronology chronology0 = ethiopicChronology0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(chronology0);
    dateTimeFormatter4.withChronology(chronology0);
    Locale locale0 = Locale.FRENCH;
    dateTimeFormatter4.withLocale(locale0);
    Object object0 = new Object();
    DateTime dateTime0 = new DateTime(object0);
    DateTime dateTime1 = dateTime0.plusMonths(int0);
    DateTime dateTime2 = dateTime1.withMillis(int0);
    int int1 = 86400;
    // Undeclared exception!
    try {
        dateTime2.minusYears(int1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No instant converter found for type: java.lang.Object
        //
        verifyException(""org.joda.time.convert.ConverterManager"", e);
    }
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test08787() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    dateTimeFormatter1.withDefaultYear(1470);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer((-1101));
    Integer integer1 = Integer.getInteger("""", integer0);
    Integer integer2 = Integer.getInteger(""~C'u?aC}:-~"", integer1);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer2);
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.getChronology();
    dateTimeFormatter0.isOffsetParsed();
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test08888() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2912));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear((Integer) null);
    Locale locale0 = new Locale(""ugN&'O"");
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear((-35));
    DateTimeFormatter dateTimeFormatter6 = dateTimeFormatter5.withOffsetParsed();
    dateTimeFormatter6.parseLocalDate((String) null);
    String string0 = ""YB"";
    dateTimeFormatter3.parseLocalDateTime(string0);
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDateTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public DateTimePrinter getPrinter() {
    return iPrinter;
}","public void test08989() throws Throwable {
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
    Integer integer0 = new Integer((-1980));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear((-641));
    dateTimeFormatter2.getPrinter();
}","/**
 * Gets the internal printer object that performs the real printing work.
 *
 * @return the internal printer; is null if printing not supported
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test09090() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    Integer integer0 = new Integer((-1101));
    Integer.getInteger("""", integer0);
    ISOChronology.getInstanceUTC();
    dateTimeFormatter2.getPivotYear();
    dateTimeFormatter0.withPivotYear((-1101));
    dateTimeFormatter0.parseMillis("""");
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public LocalDate withMonthOfYear(int monthOfYear) {
    return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));
}","public void test09292() throws Throwable {
    int int0 = 7;
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""^,"", """", false, 7, 7);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    Integer integer0 = new Integer(2128);
    dateTimeFormatter0.withPivotYear(integer0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    MonthDay monthDay0 = MonthDay.parse(""=1tR*"", dateTimeFormatter0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    int int1 = 0;
    MonthDay monthDay1 = monthDay0.withField(dateTimeFieldType0, int1);
    LocalDate localDate0 = monthDay1.toLocalDate(int0);
    // Undeclared exception!
    try {
        localDate0.withMonthOfYear(int0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""=1tR\\*\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Returns a copy of this date with the month of year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * month of year changed.
 *
 * @param monthOfYear  the month of year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public DateTimeZone getZone() {
    return iZone;
}","public void test09393() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-2180), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_UnpaddedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-2180));
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance((DateTimeZone) null);
    Chronology chronology0 = ethiopicChronology0.withZone((DateTimeZone) null);
    dateTimeFormatter1.withChronology(chronology0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter0.withZone(fixedDateTimeZone0);
    dateTimeFormatter2.withDefaultYear(409);
    dateTimeFormatter2.getZone();
}","/**
 * Gets the zone to use as an override.
 *
 * @return the zone to use as an override
 */"
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test09595() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-706), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    Locale locale0 = Locale.FRANCE;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((-706));
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Integer integer0 = new Integer(1411);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-706), gJChronology0, locale0, integer0, (-706));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    doReturn(0L).when(dateTimeUtils_MillisProvider0).getMillis();
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZone(dateTimeZone0);
    dateTimeParserBucket0.computeMillis();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    dateTimeFormatter5.parseInto(mutableDateTime0, """", (-706));
    System.setCurrentTimeMillis(4121L);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("""", true);
    boolean boolean0 = true;
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, boolean0);
    dateTimeFormatter2.printTo((Appendable) mockPrintWriter0, (long) mutableDateTime0.ROUND_HALF_FLOOR);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test09696() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    Locale locale0 = Locale.TAIWAN;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    dateTimeFormatter1.withOffsetParsed();
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('k');
    DateTimeFormatter dateTimeFormatter2 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withZone((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear(6);
    DateTimeFormatter dateTimeFormatter6 = dateTimeFormatter5.withDefaultYear(523);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter6.printTo((Appendable) charArrayWriter0, (-28801249L));
    LocalDateTime localDateTime0 = LocalDateTime.now((DateTimeZone) null);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    int int0 = 3116;
    Partial partial1 = partial0.withField(dateTimeFieldType0, int0);
    ReadablePeriod readablePeriod0 = null;
    // Undeclared exception!
    try {
        partial1.minus(readablePeriod0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Zone must not be null
        //
        verifyException(""org.joda.time.LocalDateTime"", e);
    }
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test09898() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2000, 2000);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withZoneUTC();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withPivotYear((Integer) null);
    dateTimeFormatter5.printTo((Writer) null, (ReadableInstant) null);
    dateTimeFormatter0.withZoneUTC();
}",""
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test09999() throws Throwable {
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""kdD|M1)SX/EebKI#Cfr"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    Locale locale0 = Locale.KOREAN;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((-1));
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(9);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((Integer) 1);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZone(dateTimeZone0);
    LocalTime localTime0 = new LocalTime((long) (-1), (Chronology) buddhistChronology0);
    dateTimeFormatter5.print((ReadablePartial) localTime0);
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test100100() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(0, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
    dateTimeFormatter0.getPivotYear();
    UTCProvider uTCProvider0 = new UTCProvider();
    uTCProvider0.getAvailableIDs();
    String string0 = null;
    uTCProvider0.getZone((String) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone((DateTimeZone) null);
    StringWriter stringWriter0 = new StringWriter(2275);
    StringWriter stringWriter1 = stringWriter0.append('O');
    StringBuffer stringBuffer0 = stringWriter1.getBuffer();
    MutableDateTime mutableDateTime0 = MutableDateTime.now();
    dateTimeFormatter1.printTo(stringBuffer0, (ReadableInstant) mutableDateTime0);
    dateTimeFormatter1.parseLocalTime(string0);
    String string1 = ""O-Y1EtX /r)6t63A1{I"";
    dateTimeFormatter0.parseMutableDateTime(string1);
    String string2 = """";
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalTime(string2);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses only the local time from the given text, returning a new LocalTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs an instance set to the local time defined by the specified
 * instant evaluated using ISO chronology in the default zone.
 * <p>
 * Once the constructor is completed, the zone is no longer used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z
 */
public LocalDate(long instant) {
    this(instant, ISOChronology.getInstance());
}","public void test101101() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 560, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    String string0 = ""Z"";
    int int0 = 9;
    Integer integer0 = Integer.getInteger(""Z"", 9);
    dateTimeFieldType0.getRangeDurationType();
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter0.printTo(stringBuffer0, 3L);
    dateTimeFormatter1.withPivotYear(integer0);
    int int1 = (-3298);
    long long0 = (-2492L);
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(long0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public DateTimePrinter getPrinter() {
    return iPrinter;
}","public void test102102() throws Throwable {
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-974), hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.IGNORE_EXTENDED_RANGES;
    List<Locale> list1 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) list0, locale_FilteringMode0);
    Locale.FilteringMode locale_FilteringMode1 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    List<Locale> list2 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) list1, locale_FilteringMode1);
    Locale.FilteringMode locale_FilteringMode2 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    List<Locale> list3 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) list2, locale_FilteringMode2);
    Locale.lookup(linkedList0, list3);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((-974));
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    dateTimeFormatter3.getPrinter();
}","/**
 * Gets the internal printer object that performs the real printing work.
 *
 * @return the internal printer; is null if printing not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test103103() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer(3);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    Locale locale0 = Locale.KOREAN;
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter2.printTo(stringBuffer0, (long) 3);
    dateTimeFormatter4.withLocale(locale0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    YearMonth yearMonth0 = YearMonth.now((Chronology) iSOChronology0);
    dateTimeFormatter2.printTo(stringBuffer0, (ReadablePartial) yearMonth0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology((Chronology) null);
    dateTimeFormatter5.withZone(fixedDateTimeZone0);
    dateTimeFormatter5.getPivotYear();
    LocalDateTime localDateTime0 = new LocalDateTime((long) 3, (DateTimeZone) fixedDateTimeZone0);
    DateTime dateTime0 = localDateTime0.toDateTime();
    DateTime dateTime1 = dateTime0.withTime((-1), 1705, (-3716), (-3716));
    dateTimeFormatter0.print((ReadableInstant) dateTime1);
}",""
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test104104() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-706), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    Locale locale0 = Locale.FRANCE;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear((-706));
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Integer integer0 = new Integer((-706));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-706), gJChronology0, locale0, integer0, (-706));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    doReturn((long) (-706)).when(dateTimeUtils_MillisProvider0).getMillis();
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeParserBucket0.computeMillis();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    dateTimeFormatter4.parseInto(mutableDateTime0, ""6?OG."", (-706));
    System.setCurrentTimeMillis(4121L);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""6?OG."", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    dateTimeFormatter2.printTo((Appendable) mockPrintWriter0, (long) 3);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public DateTimeParser getParser() {
    return iParser;
}","public void test106106() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldType0.getDurationType();
    int int0 = 2428;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2428, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(2428);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    MutableDateTime mutableDateTime0 = new MutableDateTime((Chronology) iSOChronology0);
    dateTimeFormatter1.parseInto(mutableDateTime0, ""Multiplication overflows a long: "", 17887500);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.withDefaultYear(2428);
    dateTimeFormatter3.parseLocalDateTime("""");
    dateTimeFormatter5.withLocale(locale0);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    // Undeclared exception!
    try {
        dateTimeFormatter2.getParser();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test107107() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2000, 2000);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(copticChronology0);
    dateTimeFormatter2.withZoneUTC();
    StringBuffer stringBuffer0 = new StringBuffer();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_Fraction0.printTo(stringBuffer0, (long) 2147483573, (Chronology) copticChronology0, (-745), dateTimeZone0, locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter0.withPivotYear((Integer) null);
    dateTimeFormatter3.printTo((Writer) null, (ReadableInstant) null);
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {
    super(years, months, weeks, days, hours, minutes, seconds, millis, type);
}","public void test108108() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    int int0 = 314;
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    dateTimeFormatter1.parseDateTime("""");
    int int1 = 0;
    StringBuffer stringBuffer0 = new StringBuffer(0);
    dateTimeFormatter0.printTo(stringBuffer0, 0L);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = gregorianChronology0.withUTC();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_StringLiteral0.printTo(stringBuffer0, (long) 314, chronology0, 0, dateTimeZone0, locale0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 0);
    stringBuffer0.setLength((-2714));
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    YearMonth yearMonth0 = new YearMonth((Chronology) julianChronology0);
    int int2 = 1;
    int int3 = 0;
    PeriodType periodType0 = PeriodType.yearMonthDay();
    Period period0 = null;
    try {
        period0 = new Period(int2, int0, int1, int2, yearMonth0.MONTH_OF_YEAR, int3, yearMonth0.MONTH_OF_YEAR, yearMonth0.YEAR, periodType0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2714
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Create a period from a set of field values.
 * <p>
 * There is usually little need to use this constructor.
 * The period type is used primarily to define how to split an interval into a period.
 * As this constructor already is split, the period type does no real work.
 *
 * @param years  amount of years in this period, which must be zero if unsupported
 * @param months  amount of months in this period, which must be zero if unsupported
 * @param weeks  amount of weeks in this period, which must be zero if unsupported
 * @param days  amount of days in this period, which must be zero if unsupported
 * @param hours  amount of hours in this period, which must be zero if unsupported
 * @param minutes  amount of minutes in this period, which must be zero if unsupported
 * @param seconds  amount of seconds in this period, which must be zero if unsupported
 * @param millis  amount of milliseconds in this period, which must be zero if unsupported
 * @param type  which set of fields this period supports, null means AllType
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this datetime minus the specified number of hours.
 * <p>
 * This LocalDateTime instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDateTime subtracted = dt.minusHours(6);
 * LocalDateTime subtracted = dt.minus(Period.hours(6));
 * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);
 * </pre>
 *
 * @param hours  the amount of hours to subtract, may be negative
 * @return the new LocalDateTime minus the increased hours
 */
public LocalDateTime minusHours(int hours) {
    if (hours == 0) {
        return this;
    }
    long instant = getChronology().hours().subtract(getLocalMillis(), hours);
    return withLocalMillis(instant);
}","public void test111111() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    int int0 = (-1480);
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1480), (-1480));
    dateTimeFieldType0.getDurationType();
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    Locale locale0 = Locale.ENGLISH;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    dateTimeFormatter1.getParser();
    int int1 = 1953;
    dateTimeFormatter1.withPivotYear(1953);
    StringWriter stringWriter0 = new StringWriter();
    StringWriter stringWriter1 = stringWriter0.append('u');
    stringWriter1.getBuffer();
    LocalDateTime localDateTime0 = LocalDateTime.now((DateTimeZone) null);
    LocalDateTime localDateTime1 = localDateTime0.withWeekOfWeekyear(int0);
    // Undeclared exception!
    try {
        localDateTime1.minusHours(int1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Zone must not be null
        //
        verifyException(""org.joda.time.LocalDateTime"", e);
    }
}",""
"public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {
    if (millisProvider == null) {
        throw new IllegalArgumentException(""The MillisProvider must not be null"");
    }
    checkPermission();
    cMillisProvider = millisProvider;
}","public void test113113() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldType0.getDurationType();
    int int0 = 2428;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2428, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(2428);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    MutableDateTime mutableDateTime0 = new MutableDateTime((Chronology) iSOChronology0);
    dateTimeFormatter1.parseInto(mutableDateTime0, ""Multiplication overflows a long: "", 17887500);
    dateTimeFormatter3.print((ReadablePartial) null);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.withDefaultYear(int0);
    String string0 = """";
    dateTimeFormatter3.parseLocalDateTime(string0);
    dateTimeFormatter5.withLocale(locale0);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Sets the provider of the current time to class specified.
 * <p>
 * This method changes the behaviour of {@link #currentTimeMillis()}.
 * Whenever the current time is queried, the specified class will be called.
 *
 * @param millisProvider  the provider of the current time to use, not null
 * @throws SecurityException if the application does not have sufficient security rights
 * @since 2.0
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test114114() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset("""", ""Q+S.Z"", true, 1244, 1244);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    Integer integer0 = new Integer(14);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    dateTimeFormatter1.getDefaultYear();
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    Integer.compare(2000, (-2881));
    MonthDay monthDay0 = MonthDay.fromCalendarFields(calendar0);
    MonthDay monthDay1 = monthDay0.plusMonths(2147483603);
    dateTimeFormatter1.print((ReadablePartial) monthDay1);
    dateTimeFormatter0.getParser();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter2.parseLocalDateTime(""Instant must not be null"");
    dateTimeFormatter2.print((long) monthDay1.MONTH_OF_YEAR);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public Period minusMillis(int millis) {
    return plusMillis(-millis);
}","public void test115115() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    int int0 = 314;
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    dateTimeFormatter1.parseDateTime("""");
    int int1 = 0;
    StringBuffer stringBuffer0 = new StringBuffer(0);
    dateTimeFormatter0.printTo(stringBuffer0, 0L);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = gregorianChronology0.withUTC();
    gJChronology0.withUTC();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_StringLiteral0.printTo(stringBuffer0, (long) 314, chronology0, 0, dateTimeZone0, locale0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 0);
    dateTimeFormatter1.parseLocalDate("""");
    stringBuffer0.setLength((-2714));
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    YearMonth yearMonth0 = new YearMonth((Chronology) julianChronology0);
    int int2 = 1;
    int int3 = 0;
    PeriodType periodType0 = PeriodType.yearMonthDay();
    Period period0 = new Period(int2, int0, int1, int2, yearMonth0.MONTH_OF_YEAR, int3, yearMonth0.MONTH_OF_YEAR, yearMonth0.YEAR, periodType0);
    // Undeclared exception!
    try {
        period0.minusMillis(int3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2714
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Returns a new period minus the specified number of millis taken away.
 * <p>
 * This period instance is immutable and unaffected by this method call.
 *
 * @param millis  the amount of millis to take away, may be negative
 * @return the new period minus the increased millis
 * @throws UnsupportedOperationException if the field is not supported
 */"
"public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {
    super(years, months, weeks, days, hours, minutes, seconds, millis, type);
}","public void test117117() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    int int0 = 314;
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    dateTimeFormatter1.parseDateTime("""");
    int int1 = 0;
    StringBuffer stringBuffer0 = new StringBuffer(0);
    dateTimeFormatter0.printTo(stringBuffer0, 0L);
    GJChronology.getInstanceUTC();
    dateTimeFormatter0.parseLocalTime("""");
    Locale locale0 = Locale.GERMANY;
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 0);
    stringBuffer0.setLength((-2714));
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    YearMonth yearMonth0 = new YearMonth((Chronology) julianChronology0);
    int int2 = 1;
    int int3 = 0;
    PeriodType periodType0 = PeriodType.yearMonthDay();
    Period period0 = null;
    try {
        period0 = new Period(int2, int0, int1, int2, yearMonth0.MONTH_OF_YEAR, int3, yearMonth0.MONTH_OF_YEAR, yearMonth0.YEAR, periodType0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2714
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Create a period from a set of field values.
 * <p>
 * There is usually little need to use this constructor.
 * The period type is used primarily to define how to split an interval into a period.
 * As this constructor already is split, the period type does no real work.
 *
 * @param years  amount of years in this period, which must be zero if unsupported
 * @param months  amount of months in this period, which must be zero if unsupported
 * @param weeks  amount of weeks in this period, which must be zero if unsupported
 * @param days  amount of days in this period, which must be zero if unsupported
 * @param hours  amount of hours in this period, which must be zero if unsupported
 * @param minutes  amount of minutes in this period, which must be zero if unsupported
 * @param seconds  amount of seconds in this period, which must be zero if unsupported
 * @param millis  amount of milliseconds in this period, which must be zero if unsupported
 * @param type  which set of fields this period supports, null means AllType
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */"
"public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {
    if (millisProvider == null) {
        throw new IllegalArgumentException(""The MillisProvider must not be null"");
    }
    checkPermission();
    cMillisProvider = millisProvider;
}","public void test118118() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldType0.getDurationType();
    int int0 = 2428;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2428, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withDefaultYear(2428);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    MutableDateTime mutableDateTime0 = new MutableDateTime((Chronology) iSOChronology0);
    dateTimeFormatter1.parseInto(mutableDateTime0, ""Multiplication overflows a long: "", 17887500);
    dateTimeFieldType0.getRangeDurationType();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(iSOChronology0);
    dateTimeFormatter5.withDefaultYear(2428);
    String string0 = """";
    StringBuffer stringBuffer0 = new StringBuffer(0);
    dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) null);
    dateTimeFormatter3.parseLocalDateTime(string0);
    dateTimeFormatter5.withLocale(locale0);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Sets the provider of the current time to class specified.
 * <p>
 * This method changes the behaviour of {@link #currentTimeMillis()}.
 * Whenever the current time is queried, the specified class will be called.
 *
 * @param millisProvider  the provider of the current time to use, not null
 * @throws SecurityException if the application does not have sufficient security rights
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test119119() throws Throwable {
    LocalTime localTime0 = LocalTime.MIDNIGHT;
    Partial partial0 = new Partial(localTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-1357));
    dateTimeFormatter1.print(31536000000L);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    dateTimeFormatter2.getDefaultYear();
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test121121() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    Integer integer0 = new Integer(3);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(3);
    Locale locale0 = Locale.PRC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(3);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = islamicChronology0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(chronology0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withZoneUTC();
    MutableDateTime mutableDateTime0 = MutableDateTime.now();
    DateTime dateTime0 = mutableDateTime0.toDateTime();
    DateTime dateTime1 = dateTime0.withDayOfYear(1);
    DateTime dateTime2 = dateTime1.plusMillis(0);
    DateTime dateTime3 = dateTime2.plusMinutes(1852);
    dateTimeFormatter5.print((ReadableInstant) dateTime3);
}",""
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test122122() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    dateTimeFormatter1.parseDateTime("""");
    StringBuffer stringBuffer0 = new StringBuffer(0);
    dateTimeFormatter0.printTo(stringBuffer0, 0L);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = gregorianChronology0.withUTC();
    gJChronology0.withUTC();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_StringLiteral0.printTo(stringBuffer0, (long) 314, chronology0, 0, dateTimeZone0, locale0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 0);
    dateTimeFormatter1.parseLocalDate("""");
    stringBuffer0.setLength(0);
    dateTimeFormatter0.print((long) 0);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test123123() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldType0.getDurationType();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2428, true);
    Locale locale0 = Locale.JAPAN;
    ISOChronology.getInstance();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    StringBuffer stringBuffer0 = new StringBuffer();
    Integer integer0 = new Integer(2428);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear(17);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(2041);
    dateTimeFormatter4.parseLocalDateTime((String) null);
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDateTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this datetime with the hour of day field updated.
 * <p>
 * LocalDateTime is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * hour of day changed.
 *
 * @param hour  the hour of day to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDateTime withHourOfDay(int hour) {
    return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));
}","public void test124124() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    dateTimeFieldType0.getRangeDurationType();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime(""5+5&Nq'Q=6Y_YwNr8?b"", ethiopicChronology0);
    dateTimeFormatter1.withZoneUTC();
    // Undeclared exception!
    try {
        localDateTime0.withHourOfDay(ethiopicChronology0.EE);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""5+5&Nq'Q=6Y_YwNr8?b\"" is malformed at \""+5&Nq'Q=6Y_YwNr8?b\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public DateTime parseDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            DateTime dt = new DateTime(millis, chrono);
            if (iZone != null) {
                dt = dt.withZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test127127() throws Throwable {
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
    PipedWriter pipedWriter0 = new PipedWriter();
    LocalTime localTime0 = new LocalTime(0, 0, 0);
    LocalTime localTime1 = localTime0.minusSeconds(0);
    int int0 = (-605);
    localTime1.plusHours((-605));
    localTime1.getFieldType(0);
    LocalTime localTime2 = localTime1.withFields(localTime0);
    LocalTime localTime3 = localTime2.minusMinutes(1512);
    dateTimeFormatter0.printTo((Writer) pipedWriter0, (ReadablePartial) localTime3);
    String string0 = ""-k[cc%:%@/z]&_"";
    dateTimeFormatter0.parseDateTime(string0);
    String string1 = ""HW|{3"";
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseDateTime(string1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new DateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public DateTimeParser getParser() {
    return iParser;
}","public void test128128() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldType0.getDurationType();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2428, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter0.withDefaultYear(2428);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(iSOChronology0);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withDefaultYear(2428);
    dateTimeFormatter4.withLocale(locale0);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeFormatter2.getParser();
    dateTimeFormatter5.isPrinter();
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter2.print((long) 2428);
    Integer integer0 = new Integer(2428);
    dateTimeFormatter4.withPivotYear(integer0);
    dateTimeFormatter2.isParser();
    dateTimeFormatter0.parseDateTime(""5i{(v"");
    dateTimeFormatter3.getParser();
}","/**
 * Gets the internal parser object that performs the real parsing work.
 *
 * @return the internal parser; is null if parsing not supported
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test129129() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    dateTimeFormatter1.parseDateTime("""");
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    gregorianChronology0.withUTC();
    Locale locale0 = Locale.GERMANY;
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 0);
    dateTimeFormatter1.parseLocalDate("""");
    dateTimeFormatter0.parseLocalDateTime(""`wQX;fRQu"");
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDateTime.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test131131() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    int int0 = 0;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_TwoDigitYear0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    dateTimeFieldType0.getRangeDurationType();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ethiopicChronology0.withZone(fixedDateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone.getDefault();
    dateTimeFormatter1.withPivotYear(1);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter0.withDefaultYear(1);
    MockFileWriter mockFileWriter0 = new MockFileWriter("".uUz1ti80"");
    MutableDateTime mutableDateTime0 = new MutableDateTime((-28799686L), (Chronology) ethiopicChronology0);
    dateTimeFormatter0.parseInto(mutableDateTime0, (String) null, 3081);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0);
    long long0 = 86400000L;
    DateTime dateTime0 = new DateTime(long0);
    dateTimeFormatter2.printTo((Appendable) mockPrintWriter0, (ReadableInstant) dateTime0);
    // Undeclared exception!
    try {
        dateTimeFormatter1.isOffsetParsed();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TwoDigitYear"", e);
    }
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test133133() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    LinkedList<Object> linkedList1 = new LinkedList<Object>(linkedList0);
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList1);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    Chronology chronology0 = null;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology((Chronology) null);
    String string0 = ""centuryOfEra"";
    // Undeclared exception!
    try {
        dateTimeFormatter1.parseMutableDateTime(""centuryOfEra"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test134134() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""Instant must not be null"");
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2013, 2013);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(2147483573);
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(""lxR(=S/;M;|gxVBbzh"");
    PrintWriter printWriter0 = mockPrintWriter0.append('D');
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Chronology chronology0 = gregorianChronology0.withUTC();
    LocalDateTime localDateTime0 = LocalDateTime.now(chronology0);
    Period period0 = new Period();
    Days days0 = period0.toStandardDays();
    LocalDateTime localDateTime1 = localDateTime0.plus((ReadablePeriod) days0);
    dateTimeFormatter0.printTo((Writer) printWriter0, (ReadablePartial) localDateTime1);
    DateTimeZone.forTimeZone(timeZone0);
    dateTimeFormatter0.withPivotYear((Integer) null);
    dateTimeFormatter1.print((-984L));
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test135135() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('.');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withOffsetParsed();
    Integer integer0 = new Integer(3);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withPivotYear(integer0);
    Chronology chronology0 = null;
    LocalDate localDate0 = new LocalDate(2325L, (Chronology) null);
    DateTime dateTime0 = localDate0.toDateTimeAtCurrentTime((DateTimeZone) fixedDateTimeZone0);
    DateTime dateTime1 = dateTime0.toDateTimeISO();
    DateTime dateTime2 = dateTime1.withYearOfCentury(13);
    DateTime dateTime3 = dateTime2.withDayOfMonth(13);
    dateTimeFormatter4.printTo((Appendable) null, (ReadableInstant) dateTime3);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withChronology(chronology0);
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeFormatter5.withZone(fixedDateTimeZone0);
    // Undeclared exception!
    try {
        dateTimeFormatter5.isPrinter();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test137137() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-706), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    dateTimeFormatter0.withZoneUTC();
    Locale locale0 = Locale.FRANCE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-706));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear((-706));
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Integer integer0 = new Integer((-706));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-706), gJChronology0, locale0, integer0, (-706));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    doReturn((long) (-706)).when(dateTimeUtils_MillisProvider0).getMillis();
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeParserBucket0.computeMillis();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    dateTimeFormatter3.parseInto(mutableDateTime0, ""6?OG."", (-706));
    mutableDateTime0.getZone();
    System.setCurrentTimeMillis(4121L);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""6?OG."", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    dateTimeFormatter1.getPrinter();
    dateTimeFormatter1.printTo((Appendable) mockPrintWriter0, (long) 3);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test139139() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 12, true, 12);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    byte[] byteArray0 = new byte[1];
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-1483));
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = ethiopicChronology0.withUTC();
    dateTimeFieldType0.getDurationType();
    DateTimeUtils.setCurrentMillisOffset((-1483));
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(chronology0);
    dateTimeFormatter4.print((-61L));
    dateTimeFormatter1.parseMutableDateTime(""000000000063"");
    dateTimeFormatter3.isParser();
    dateTimeFormatter4.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter3.withZone(dateTimeZone0);
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    LocalTime localTime0 = LocalTime.now();
    dateTimeFormatter5.print((ReadablePartial) localTime0);
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test140140() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.monthOfYear();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType1;
    DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DurationField durationField0 = buddhistChronology0.hours();
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, durationField0);
    DateTimeFieldType dateTimeFieldType2 = unsupportedDateTimeField0.getType();
    dateTimeFieldTypeArray0[4] = dateTimeFieldType2;
    DateTimeFieldType dateTimeFieldType3 = DateTimeFieldType.hourOfDay();
    dateTimeFieldTypeArray0[5] = dateTimeFieldType3;
    int[] intArray0 = new int[3];
    FileSystemHandling.shouldAllThrowIOExceptions();
    intArray0[0] = 1;
    intArray0[1] = 1;
    intArray0[2] = 1;
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(1, 1, (-1));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    Integer integer0 = new Integer(1);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(1);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(buddhistChronology0);
    Locale locale0 = Locale.CANADA;
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    StringBuffer stringBuffer0 = new StringBuffer(""gHht]{P>bzw^87h3`2"");
    dateTimeFormatter5.printTo(stringBuffer0, (ReadableInstant) null);
    ReadablePartial readablePartial0 = null;
    dateTimeFormatter5.print(readablePartial0);
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, buddhistChronology0);
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test141141() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.monthOfYear();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType1;
    DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DurationField durationField0 = buddhistChronology0.hours();
    UnsupportedDateTimeField unsupportedDateTimeField0 = UnsupportedDateTimeField.getInstance(dateTimeFieldType0, durationField0);
    DateTimeFieldType dateTimeFieldType2 = unsupportedDateTimeField0.getType();
    dateTimeFieldTypeArray0[4] = dateTimeFieldType2;
    DateTimeFieldType dateTimeFieldType3 = DateTimeFieldType.hourOfDay();
    dateTimeFieldTypeArray0[5] = dateTimeFieldType3;
    int[] intArray0 = new int[3];
    FileSystemHandling.shouldAllThrowIOExceptions();
    intArray0[0] = 1;
    intArray0[1] = 1;
    intArray0[2] = 1;
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(1, 1, (-1));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    Integer integer0 = new Integer((-2145318844));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(1);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withZoneUTC();
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(buddhistChronology0);
    Locale locale0 = Locale.CANADA;
    StringBuffer stringBuffer0 = new StringBuffer(1);
    StringBuffer stringBuffer1 = new StringBuffer(stringBuffer0);
    dateTimeFormatter4.printTo(stringBuffer1, 918518400000L);
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter4.withLocale(locale0);
    ReadablePartial readablePartial0 = null;
    dateTimeFormatter5.print(readablePartial0);
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, buddhistChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No datetime pattern for locale: en
        //
        verifyException(""org.joda.time.format.DateTimeFormat$StyleFormatter"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test142142() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, (-706), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    dateTimeFormatter0.withZoneUTC();
    Locale locale0 = Locale.FRANCE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear((-706));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear((-706));
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Integer integer0 = new Integer((-706));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-706), gJChronology0, locale0, integer0, (-706));
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    DateTimeUtils.MillisProvider dateTimeUtils_MillisProvider0 = mock(DateTimeUtils.MillisProvider.class, new ViolatedAssumptionAnswer());
    doReturn((long) (-706)).when(dateTimeUtils_MillisProvider0).getMillis();
    DateTimeUtils.setCurrentMillisProvider(dateTimeUtils_MillisProvider0);
    dateTimeParserBucket0.computeMillis();
    MutableDateTime mutableDateTime0 = new MutableDateTime(dateTimeZone0);
    dateTimeFormatter3.parseInto(mutableDateTime0, ""6?OG."", (-706));
    System.setCurrentTimeMillis(4121L);
    FileSystemHandling.shouldAllThrowIOExceptions();
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""6?OG."", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileOutputStream0, true);
    dateTimeFormatter0.print((ReadableInstant) mutableDateTime0);
    dateTimeFormatter1.printTo((Appendable) mockPrintWriter0, (long) mutableDateTime0.ROUND_HALF_FLOOR);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test143143() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 12, true, 12);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    byte[] byteArray0 = new byte[1];
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear((-1483));
    EthiopicChronology.getInstance(dateTimeZone0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0, 1);
    dateTimeFieldType0.getDurationType();
    DateTimeUtils.setCurrentMillisOffset((-1483));
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(ethiopicChronology0);
    dateTimeFormatter4.print((-61L));
    dateTimeFormatter1.parseMutableDateTime(""000000000063"");
    dateTimeFormatter3.isParser();
    dateTimeFormatter4.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter3.withZone(dateTimeZone0);
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    dateTimeFormatter5.parseMutableDateTime(""000000000063"");
    LocalTime localTime0 = LocalTime.now();
    dateTimeFormatter5.print((ReadablePartial) localTime0);
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test144144() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    Integer integer0 = new Integer(314);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    StringBuffer stringBuffer0 = new StringBuffer(314);
    dateTimeFormatter0.printTo(stringBuffer0, 0L);
    DateTimeZone.getDefault();
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    dateTimeFormatter1.printTo((Writer) charArrayWriter0, (long) 314);
    dateTimeFormatter1.parseLocalDate("""");
    stringBuffer0.setLength(314);
    dateTimeFormatter1.isParser();
    dateTimeFormatter1.print((ReadableInstant) dateTime0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    dateTimeFormatter1.isParser();
    dateTimeFormatter2.parseDateTime("""");
    LenientChronology lenientChronology0 = LenientChronology.getInstance((Chronology) null);
    dateTimeFormatter0.withChronology(lenientChronology0);
}",""
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test145145() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 12, true, 12);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    byte[] byteArray0 = new byte[1];
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withDefaultYear(2619);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Chronology chronology0 = ethiopicChronology0.withUTC();
    dateTimeFieldType0.getDurationType();
    DateTimeUtils.setCurrentMillisOffset(2619);
    DateTimeFormatter dateTimeFormatter4 = dateTimeFormatter3.withChronology(chronology0);
    dateTimeFormatter4.print((-61L));
    dateTimeFormatter1.parseMutableDateTime(""000000000004"");
    dateTimeFormatter3.isParser();
    dateTimeFormatter4.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter5 = dateTimeFormatter3.withZone(dateTimeZone0);
    dateTimeFormatter5.parseMutableDateTime(""000000000004"");
    dateTimeFormatter5.parseMutableDateTime(""000000000004"");
    LocalTime localTime0 = LocalTime.now();
    dateTimeFormatter5.print((ReadablePartial) localTime0);
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public LocalDate parseLocalDate(String text) {
    return parseLocalDateTime(text).toLocalDate();
}","public void test147147() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    dateTimeFormatter1.withOffsetParsed();
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    Integer integer0 = new Integer((-1101));
    Integer integer1 = new Integer((-1101));
    ISOChronology.getInstanceUTC();
    Integer integer2 = new Integer(0);
    dateTimeFormatter0.withPivotYear((-1101));
    long long0 = new Integer(0);
    dateTimeFormatter0.parseLocalDate(""Printing not supported"");
}","/**
 * Parses only the local date from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date will be used.
 * This means that any parsed time, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test148148() throws Throwable {
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2435, 3550);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTime dateTime0 = new DateTime((-1044L));
    DurationFieldType durationFieldType0 = DurationFieldType.halfdays();
    DateTime dateTime1 = dateTime0.withFieldAdded(durationFieldType0, 3550);
    dateTimeFormatter1.print((ReadableInstant) dateTime1);
}",""
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant based on the chronology
 * and time-zone of the supplied instant.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    int defaultYear = chrono.year().get(instantLocal);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test149149() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('{');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(90);
    MutableDateTime mutableDateTime0 = MutableDateTime.now();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    MutableDateTime mutableDateTime1 = mutableDateTime0.toMutableDateTime(dateTimeZone0);
    PipedWriter pipedWriter0 = new PipedWriter();
    BufferedWriter bufferedWriter0 = new BufferedWriter(pipedWriter0, 1);
    LocalDateTime localDateTime0 = new LocalDateTime((-1656L));
    dateTimeFormatter1.printTo((Appendable) bufferedWriter0, (ReadablePartial) localDateTime0);
    String string0 = """";
    int int0 = (-2866);
    // Undeclared exception!
    try {
        dateTimeFormatter1.parseInto(mutableDateTime1, string0, int0);
        fail(""Expecting exception: IOException"");
    } catch (Throwable e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedWriter"", e);
    }
}",""
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test151151() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) iSOChronology0);
    Partial partial0 = new Partial(localDate0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MockPrintStream mockPrintStream0 = new MockPrintStream(""w"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) ""|"";
    objectArray0[2] = (Object) ""|"";
    objectArray0[3] = (Object) ""w"";
    objectArray0[4] = (Object) localDate0;
    objectArray0[5] = (Object) ""w"";
    objectArray0[6] = (Object) dateTimeFormatter1;
    PrintStream printStream0 = mockPrintStream0.printf(""|"", objectArray0);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadablePartial) partial0);
    dateTimeFormatter1.getChronology();
    MutableDateTime mutableDateTime0 = new MutableDateTime(0L);
    dateTimeFormatter1.printTo((Appendable) printStream0, (ReadableInstant) mutableDateTime0);
    dateTimeFormatter0.printTo((StringBuffer) null, (ReadablePartial) partial0);
    dateTimeFormatter1.printTo((Appendable) mockPrintStream0, (long) mutableDateTime0.ROUND_HALF_FLOOR);
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
