focal_method,test_prefix,docstring
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test0000() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = partial0.getFieldType(0);
    Partial partial1 = partial0.withField(dateTimeFieldType0, 0);
    boolean boolean0 = partial1.isMatch((ReadablePartial) partial0);
    assertFalse(boolean0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test0011() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 106);
    Instant instant0 = new Instant((Object) null);
    boolean boolean0 = partial0.isMatch((ReadableInstant) instant0);
    assertFalse(boolean0);
}",""
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test0022() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[7];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    DurationFieldType durationFieldType0 = dateTimeFieldTypeArray0[1].getDurationType();
    int[] intArray0 = new int[21];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.withFieldAddWrapped(durationFieldType0, 86400);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test0033() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[8];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[3];
    Partial partial0 = new Partial(buddhistChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.without(dateTimeFieldTypeArray0[6]);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"int size();","public void test0077() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Partial partial0 = new Partial(gregorianChronology0);
    Partial.Property partial_Property0 = new Partial.Property(partial0, 1334);
    ReadablePartial readablePartial0 = partial_Property0.getReadablePartial();
    assertEquals(0, readablePartial0.size());
}","/**
 * Gets the number of fields that this partial supports.
 *
 * @return the number of fields supported
 */"
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test0099() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    Partial partial0 = new Partial(dateTimeFieldTypeArray0[0], 2390, (Chronology) null);
    Partial partial1 = partial0.withFieldAdded(durationFieldType0, 256);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test00910() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    Partial partial0 = new Partial(dateTimeFieldTypeArray0[0], 2390, (Chronology) null);
    Partial partial1 = partial0.withFieldAdded(durationFieldType0, 256);
    assertFalse(partial1.equals((Object) partial0));
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test01011() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Partial partial0 = new Partial(dateTimeFieldType0, 0, copticChronology0);
    Partial partial1 = partial0.with(dateTimeFieldType0, 1);
    assertEquals(1, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test01112() throws Throwable {
    Partial partial0 = new Partial();
    int int0 = partial0.size();
    assertEquals(0, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test01213() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-883));
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, dateTimeZone0);
    Partial partial0 = new Partial(dateTimeFieldType0, (-883), zonedChronology0);
    Partial.Property partial_Property0 = partial0.property(dateTimeFieldType0);
    Partial partial1 = partial_Property0.setCopy((-883));
    assertTrue(partial1.equals((Object) partial0));
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test01314() throws Throwable {
    Partial partial0 = new Partial();
    Period period0 = Period.seconds(3198);
    Seconds seconds0 = Seconds.standardSecondsIn(period0);
    Partial partial1 = partial0.plus(seconds0);
    assertTrue(partial1.equals((Object) partial0));
}",""
"public Partial plus(ReadablePeriod period) {
    return withPeriodAdded(period, 1);
}","public void test01315() throws Throwable {
    Partial partial0 = new Partial();
    Period period0 = Period.seconds(3198);
    Seconds seconds0 = Seconds.standardSecondsIn(period0);
    Partial partial1 = partial0.plus(seconds0);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this instance with the specified period added.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the duration to add to this one, null means zero
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test01416() throws Throwable {
    Partial partial0 = new Partial();
    PeriodType periodType0 = PeriodType.hours();
    Period period0 = new Period(493L, periodType0);
    Partial partial1 = partial0.minus(period0);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test01417() throws Throwable {
    Partial partial0 = new Partial();
    PeriodType periodType0 = PeriodType.hours();
    Period period0 = new Period(493L, periodType0);
    Partial partial1 = partial0.minus(period0);
    assertTrue(partial1.equals((Object) partial0));
}",""
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test01518() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Days days0 = Days.ZERO;
    Minutes minutes0 = days0.toStandardMinutes();
    Weeks weeks0 = minutes0.toStandardWeeks();
    Partial partial1 = partial0.minus(weeks0);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test01519() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Days days0 = Days.ZERO;
    Minutes minutes0 = days0.toStandardMinutes();
    Weeks weeks0 = minutes0.toStandardWeeks();
    Partial partial1 = partial0.minus(weeks0);
    assertTrue(partial1.equals((Object) partial0));
}",""
"public int[] getValues() {
    return (int[]) iValues.clone();
}","public void test01620() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Partial partial0 = new Partial(buddhistChronology0);
    int[] intArray0 = partial0.getValues();
    assertEquals(0, intArray0.length);
}","/**
 * Gets an array of the value of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 * Each value corresponds to the same array index as <code>getFieldTypes()</code>
 *
 * @return the current values of each field (cloned), largest to smallest
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the value of the field at the specifed index.
 *
 * @param index  the index
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index) {
    return iValues[index];
}","public void test01721() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    int int0 = partial0.getValue(0);
    assertEquals(1970, int0);
}",""
"public DateTimeFieldType[] getFieldTypes() {
    return (DateTimeFieldType[]) iTypes.clone();
}","public void test01822() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = partial0.getFieldTypes();
    assertEquals(0, dateTimeFieldTypeArray0.length);
}","/**
 * Gets an array of the field type of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 *
 * @return the array of field types (cloned), largest to smallest
 */"
"protected DateTimeField getField(int index, Chronology chrono) {
    return iTypes[index].getField(chrono);
}","public void test01923() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 271);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeField dateTimeField0 = partial0.getField(0, (Chronology) buddhistChronology0);
    assertNotNull(dateTimeField0);
}","/**
 * Gets the field for a specific index in the chronology specified.
 *
 * @param index  the index to retrieve
 * @param chrono  the chronology to use
 * @return the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test02024() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    int[] intArray0 = new int[8];
    Partial partial0 = new Partial(gJChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.without(dateTimeFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for weekOfWeekyear must not be smaller than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test02125() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[7];
    int[] intArray0 = new int[21];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.without(dateTimeFieldTypeArray0[0]);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test02226() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    int[] intArray0 = new int[5];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    Months months0 = Months.EIGHT;
    // Undeclared exception!
    try {
        partial0.withPeriodAdded(months0, 1000);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test02327() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    int[] intArray0 = new int[1];
    Partial partial0 = new Partial(gregorianChronology0, dateTimeFieldTypeArray0, intArray0);
    Minutes minutes0 = Minutes.minutesIn((ReadableInterval) null);
    DurationFieldType durationFieldType0 = minutes0.getFieldType();
    // Undeclared exception!
    try {
        partial0.withFieldAdded(durationFieldType0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test02428() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[20];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.era();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    int[] intArray0 = new int[5];
    intArray0[1] = 105;
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.withFieldAddWrapped(durationFieldType0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 104 for era must be in the range [0,1]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test02529() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    DurationFieldType durationFieldType0 = DurationFieldType.millis();
    // Undeclared exception!
    try {
        partial0.withFieldAddWrapped(durationFieldType0, 3600);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'millis' is not supported
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test02630() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[2];
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfYear();
    dateTimeFieldTypeArray0[4] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[4];
    DurationFieldType durationFieldType0 = dateTimeFieldType1.getRangeDurationType();
    int[] intArray0 = new int[5];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.withFieldAddWrapped(durationFieldType0, (-1));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test02731() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    // Undeclared exception!
    try {
        partial0.withField(dateTimeFieldType0, 7593750);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 7593750 for halfdayOfDay must be in the range [0,1]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test02832() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    StrictChronology strictChronology0 = StrictChronology.getInstance(buddhistChronology0);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(strictChronology0);
    LocalDateTime localDateTime0 = new LocalDateTime(995, 482, 995, (-1346), 0, 1526, 2358, lenientChronology0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    // Undeclared exception!
    try {
        partial0.withField(dateTimeFieldType0, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'halfdayOfDay' is not supported
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test02933() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    int[] intArray0 = new int[1];
    Partial partial0 = new Partial(copticChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.withField(dateTimeFieldType0, 1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test03034() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.clockhourOfHalfday();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    int[] intArray0 = new int[8];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.withChronologyRetainFields((Chronology) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for clockhourOfHalfday must not be smaller than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test03135() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    Partial partial0 = new Partial(iSOChronology0, dateTimeFieldTypeArray0, (int[]) null);
    // Undeclared exception!
    try {
        partial0.withChronologyRetainFields(iSOChronology0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test03236() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[1];
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[5];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldTypeArray0[0], 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}",""
"public String toStringList() {
    int size = size();
    StringBuilder buf = new StringBuilder(20 * size);
    buf.append('[');
    for (int i = 0; i < size; i++) {
        if (i > 0) {
            buf.append(',').append(' ');
        }
        buf.append(iTypes[i].getName());
        buf.append('=');
        buf.append(iValues[i]);
    }
    buf.append(']');
    return buf.toString();
}","public void test03337() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[7];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[2] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[2];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.toStringList();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Gets a string version of the partial that lists all the fields.
 * <p>
 * This method exists to provide a better debugging toString than
 * the standard toString. This method lists all the fields and their
 * values in a style similar to the collections framework.
 *
 * @return a toString format that lists all the fields
 */"
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test03438() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forID((String) null);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[0];
    Partial partial0 = new Partial(copticChronology0, dateTimeFieldTypeArray0, intArray0);
    Locale locale0 = Locale.ITALY;
    // Undeclared exception!
    try {
        partial0.toString((String) null, locale0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test03539() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    // Undeclared exception!
    try {
        partial0.toString(""The field type must not be null"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test03640() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[1];
    Partial partial0 = new Partial(gregorianChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.toString();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains
 * many useful methods for getting and manipulating the partial.
 * <p>
 * See also {@link ReadablePartial#get(DateTimeFieldType)}.
 *
 * @param type  the field type to get the property for, not null
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType type) {
    return new Property(this, indexOfSupported(type));
}","public void test03741() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    // Undeclared exception!
    try {
        partial0.property(dateTimeFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'minuteOfDay' is not supported
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test03842() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    int[] intArray0 = new int[8];
    Partial partial0 = new Partial(gregorianChronology0, (DateTimeFieldType[]) null, intArray0);
    Instant instant0 = new Instant();
    // Undeclared exception!
    try {
        partial0.isMatch((ReadableInstant) instant0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"public int[] getValues() {
    return (int[]) iValues.clone();
}","public void test03943() throws Throwable {
    Partial partial0 = new Partial();
    Partial partial1 = new Partial(partial0, (int[]) null);
    // Undeclared exception!
    try {
        partial1.getValues();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Gets an array of the value of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 * Each value corresponds to the same array index as <code>getFieldTypes()</code>
 *
 * @return the current values of each field (cloned), largest to smallest
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the value of the field at the specifed index.
 *
 * @param index  the index
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index) {
    return iValues[index];
}","public void test04044() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(1);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    Partial partial0 = new Partial(ethiopicChronology0, dateTimeFieldTypeArray0, (int[]) null);
    // Undeclared exception!
    try {
        partial0.getValue(1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the value of the field at the specifed index.
 *
 * @param index  the index
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index) {
    return iValues[index];
}","public void test04145() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-857));
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    Partial partial0 = new Partial(gregorianChronology0);
    // Undeclared exception!
    try {
        partial0.getValue(2335);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2335
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"public DateTimeFieldType[] getFieldTypes() {
    return (DateTimeFieldType[]) iTypes.clone();
}","public void test04246() throws Throwable {
    int[] intArray0 = new int[2];
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    Partial partial0 = new Partial(gregorianChronology0, (DateTimeFieldType[]) null, intArray0);
    // Undeclared exception!
    try {
        partial0.getFieldTypes();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Gets an array of the field type of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 *
 * @return the array of field types (cloned), largest to smallest
 */"
"public DateTimeFieldType getFieldType(int index) {
    return iTypes[index];
}","public void test04347() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Partial partial0 = new Partial(dateTimeFieldType0, 0, copticChronology0);
    // Undeclared exception!
    try {
        partial0.getFieldType(90);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the field type at the specified index.
 *
 * @param index  the index to retrieve
 * @return the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"protected DateTimeField getField(int index, Chronology chrono) {
    return iTypes[index].getField(chrono);
}","public void test04448() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    int[] intArray0 = new int[3];
    Partial partial0 = new Partial(julianChronology0, (DateTimeFieldType[]) null, intArray0);
    // Undeclared exception!
    try {
        partial0.getField((-4493), (Chronology) julianChronology0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the field for a specific index in the chronology specified.
 *
 * @param index  the index to retrieve
 * @param chrono  the chronology to use
 * @return the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"protected DateTimeField getField(int index, Chronology chrono) {
    return iTypes[index].getField(chrono);
}","public void test04549() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Partial partial0 = new Partial(buddhistChronology0);
    // Undeclared exception!
    try {
        partial0.getField(238, (Chronology) buddhistChronology0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the field for a specific index in the chronology specified.
 *
 * @param index  the index to retrieve
 * @param chrono  the chronology to use
 * @return the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test04650() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    int[] intArray0 = new int[2];
    intArray0[1] = 1095;
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 1095 for weekyearOfCentury must not be larger than 99
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test04751() throws Throwable {
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    MonthDay monthDay0 = new MonthDay((Chronology) julianChronology0);
    int[] intArray0 = new int[1];
    MonthDay monthDay1 = new MonthDay(monthDay0, intArray0);
    Partial partial0 = null;
    try {
        partial0 = new Partial(monthDay1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.joda.time.base.BasePartial"", e);
    }
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"Partial(Partial partial, int[] values) {
    super();
    iChronology = partial.iChronology;
    iTypes = partial.iTypes;
    iValues = values;
}","public void test04852() throws Throwable {
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial((Partial) null, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified values.
 * This constructor assigns and performs no validation.
 *
 * @param partial  the partial to copy
 * @param values  the values to store
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType type, int value, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (type == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    iTypes = new DateTimeFieldType[] { type };
    iValues = new int[] { value };
    chronology.validate(this, iValues);
}","public void test04953() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldType0, 0, iSOChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for dayOfYear must not be smaller than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"public Partial(DateTimeFieldType type, int value) {
    this(type, value, null);
}","public void test05054() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldType0, (-965));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -965 for minuteOfHour must not be smaller than 0
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the default ISO chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"public String toStringList() {
    int size = size();
    StringBuilder buf = new StringBuilder(20 * size);
    buf.append('[');
    for (int i = 0; i < size; i++) {
        if (i > 0) {
            buf.append(',').append(' ');
        }
        buf.append(iTypes[i].getName());
        buf.append('=');
        buf.append(iValues[i]);
    }
    buf.append(']');
    return buf.toString();
}","public void test05155() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[7];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[1];
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[6] = dateTimeFieldTypeArray0[1];
    int[] intArray0 = new int[21];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    String string0 = partial0.toStringList();
    assertEquals(""[weekyearOfCentury=0, weekyearOfCentury=0, weekyearOfCentury=0, weekyearOfCentury=0, weekyearOfCentury=0, weekyearOfCentury=0, weekyearOfCentury=0]"", string0);
}","/**
 * Gets a string version of the partial that lists all the fields.
 * <p>
 * This method exists to provide a better debugging toString than
 * the standard toString. This method lists all the fields and their
 * values in a style similar to the collections framework.
 *
 * @return a toString format that lists all the fields
 */"
"public String toStringList() {
    int size = size();
    StringBuilder buf = new StringBuilder(20 * size);
    buf.append('[');
    for (int i = 0; i < size; i++) {
        if (i > 0) {
            buf.append(',').append(' ');
        }
        buf.append(iTypes[i].getName());
        buf.append('=');
        buf.append(iValues[i]);
    }
    buf.append(']');
    return buf.toString();
}","public void test05256() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[7];
    int[] intArray0 = new int[21];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.toStringList();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Gets a string version of the partial that lists all the fields.
 * <p>
 * This method exists to provide a better debugging toString than
 * the standard toString. This method lists all the fields and their
 * values in a style similar to the collections framework.
 *
 * @return a toString format that lists all the fields
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test05357() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    String string0 = partial0.toString();
    assertEquals(""--00"", string0);
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test05458() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[8];
    int[] intArray0 = new int[8];
    Partial partial0 = new Partial(buddhistChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.toString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test05559() throws Throwable {
    YearMonth yearMonth0 = new YearMonth((Object) null);
    Partial partial0 = new Partial(yearMonth0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test05660() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertNull(dateTimeFormatter0);
}",""
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test05761() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    Months months0 = Months.NINE;
    Partial partial0 = new Partial(buddhistChronology0);
    Partial partial1 = partial0.withPeriodAdded(months0, 1);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test05762() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    Months months0 = Months.NINE;
    Partial partial0 = new Partial(buddhistChronology0);
    Partial partial1 = partial0.withPeriodAdded(months0, 1);
    assertTrue(partial1.equals((Object) partial0));
}",""
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test05863() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType0;
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(543);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[2];
    dateTimeFieldTypeArray0[4] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[1];
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, iSOChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: yearOfCentury < weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test05964() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType0;
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(543);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[1];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[2];
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, iSOChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain duplicate: weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06065() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekOfWeekyear();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[2] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[3];
    dateTimeFieldTypeArray0[5] = dateTimeFieldType1;
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, (Chronology) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: weekOfWeekyear < weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06166() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[1];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[1];
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, gJChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for weekyearOfCentury must not be smaller than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06267() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[3];
    int[] intArray0 = new int[3];
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, ethiopicChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain null: index 0
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06368() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    int[] intArray0 = new int[3];
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, ethiopicChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Values array must be the same length as the types array
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06469() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[1];
    Instant instant0 = Instant.now();
    Chronology chronology0 = instant0.getChronology();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, (int[]) null, chronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Values array must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test06570() throws Throwable {
    int[] intArray0 = new int[5];
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial((DateTimeFieldType[]) null, intArray0, julianChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType type, int value, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (type == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    iTypes = new DateTimeFieldType[] { type };
    iValues = new int[] { value };
    chronology.validate(this, iValues);
}","public void test06671() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    Partial partial0 = null;
    try {
        partial0 = new Partial((DateTimeFieldType) null, 0, buddhistChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field type must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"public Chronology getChronology() {
    return iChronology;
}","public void test06772() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Partial partial0 = new Partial(copticChronology0);
    CopticChronology copticChronology1 = (CopticChronology) partial0.getChronology();
    assertEquals(1, CopticChronology.AM);
}","/**
 * Gets the chronology of the partial which is never null.
 * <p>
 * The {@link Chronology} is the calculation engine behind the partial and
 * provides conversion and validation of the fields in a particular calendar system.
 *
 * @return the chronology, never null
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test06873() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    Partial partial0 = new Partial(dateTimeFieldType0, 120);
    int int0 = partial0.size();
    assertEquals(1, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the value of the field at the specifed index.
 *
 * @param index  the index
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index) {
    return iValues[index];
}","public void test06974() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    int int0 = partial0.getValue(0);
    assertEquals(0, int0);
}",""
"public int[] getValues() {
    return (int[]) iValues.clone();
}","public void test07075() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    int[] intArray0 = partial0.getValues();
    assertEquals(4, intArray0.length);
}","/**
 * Gets an array of the value of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 * Each value corresponds to the same array index as <code>getFieldTypes()</code>
 *
 * @return the current values of each field (cloned), largest to smallest
 */"
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test07176() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Partial partial0 = new Partial(ethiopicChronology0);
    String string0 = partial0.toString((String) null, (Locale) null);
    assertEquals(""[]"", string0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test07277() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    Partial partial0 = new Partial(dateTimeFieldTypeArray0[0], 2390, (Chronology) null);
    Locale locale0 = Locale.ITALY;
    // Undeclared exception!
    try {
        partial0.toString(""Cj;=GD8F8"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: j
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test07378() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    int[] intArray0 = new int[1];
    Partial partial0 = new Partial(gregorianChronology0, dateTimeFieldTypeArray0, intArray0);
    String string0 = partial0.toString(""/"");
    assertEquals(""/"", string0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test07479() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter1 = partial0.getFormatter();
    assertNotNull(dateTimeFormatter1);
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test07480() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter1 = partial0.getFormatter();
    String string0 = partial0.toString();
    assertEquals(""[year=1970, monthOfYear=1, dayOfMonth=1, millisOfDay=0]"", string0);
}",""
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test07581() throws Throwable {
    LocalTime localTime0 = LocalTime.MIDNIGHT;
    Partial partial0 = new Partial(localTime0);
    String string0 = partial0.toString((String) null);
    assertEquals(""00:00:00.000"", string0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test07682() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    int[] intArray0 = new int[0];
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
    String string0 = partial0.toString();
    assertEquals(""[]"", string0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test07783() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    partial0.getFormatter();
    DateTimeFormatter dateTimeFormatter1 = partial0.getFormatter();
    assertNotSame(dateTimeFormatter0, dateTimeFormatter1);
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test07884() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 44);
    boolean boolean0 = partial0.isMatch((ReadablePartial) partial0);
    assertTrue(boolean0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test07985() throws Throwable {
    MockDate mockDate0 = new MockDate(2066, 11, 2284, 91, 11);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    Partial partial0 = new Partial(localDate0);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    Instant instant0 = gJChronology0.getGregorianCutover();
    boolean boolean0 = partial0.isMatch((ReadableInstant) instant0);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test08086() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Instant instant0 = new Instant((long) 0);
    boolean boolean0 = partial0.isMatch((ReadableInstant) instant0);
    assertTrue(boolean0);
}",""
"public Partial plus(ReadablePeriod period) {
    return withPeriodAdded(period, 1);
}","public void test08187() throws Throwable {
    LocalTime localTime0 = new LocalTime(0L, (DateTimeZone) null);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance((DateTimeZone) null);
    StrictChronology strictChronology0 = StrictChronology.getInstance(gregorianChronology0);
    Period period0 = new Period(0L, 0L, strictChronology0);
    Partial partial0 = new Partial(localTime0);
    Partial partial1 = partial0.plus(period0);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this instance with the specified period added.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the duration to add to this one, null means zero
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test08188() throws Throwable {
    LocalTime localTime0 = new LocalTime(0L, (DateTimeZone) null);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance((DateTimeZone) null);
    StrictChronology strictChronology0 = StrictChronology.getInstance(gregorianChronology0);
    Period period0 = new Period(0L, 0L, strictChronology0);
    Partial partial0 = new Partial(localTime0);
    Partial partial1 = partial0.plus(period0);
    assertTrue(partial1.equals((Object) partial0));
}",""
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test08289() throws Throwable {
    Partial partial0 = new Partial();
    Hours hours0 = Hours.TWO;
    Partial partial1 = partial0.withPeriodAdded(hours0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test08390() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    int[] intArray0 = new int[1];
    Partial partial0 = new Partial(gregorianChronology0, dateTimeFieldTypeArray0, intArray0);
    Partial partial1 = partial0.withPeriodAdded((ReadablePeriod) null, (-1964));
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test08491() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.era();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    DurationFieldType durationFieldType0 = dateTimeFieldTypeArray0[0].getRangeDurationType();
    int[] intArray0 = new int[5];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    Partial partial1 = partial0.withFieldAddWrapped(durationFieldType0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test08592() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfYear();
    DurationFieldType durationFieldType0 = dateTimeFieldType1.getRangeDurationType();
    Partial partial0 = new Partial(dateTimeFieldType0, 3405, (Chronology) null);
    Partial partial1 = partial0.withFieldAddWrapped(durationFieldType0, (-1));
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test08593() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfYear();
    DurationFieldType durationFieldType0 = dateTimeFieldType1.getRangeDurationType();
    Partial partial0 = new Partial(dateTimeFieldType0, 3405, (Chronology) null);
    Partial partial1 = partial0.withFieldAddWrapped(durationFieldType0, (-1));
    assertFalse(partial1.equals((Object) partial0));
}",""
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test08694() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    Partial partial0 = new Partial(dateTimeFieldTypeArray0[0], 1, (Chronology) null);
    Partial partial1 = partial0.withFieldAdded(durationFieldType0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test08795() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    Partial partial0 = new Partial(dateTimeFieldType0, 1, (Chronology) null);
    // Undeclared exception!
    try {
        partial0.withFieldAdded(durationFieldType0, (-603));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Maximum value exceeded for add
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test08896() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 2881);
    Partial partial1 = partial0.withField(dateTimeFieldType0, 2881);
    assertSame(partial1, partial0);
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test08997() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = partial0.getFieldType(0);
    Partial partial1 = partial0.withField(dateTimeFieldType0, 0);
    boolean boolean0 = partial0.isMatch((ReadablePartial) partial1);
    assertFalse(boolean0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test09098() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 2881);
    Partial partial1 = partial0.without(dateTimeFieldType0);
    assertEquals(0, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test09199() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 2881);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.yearOfEra();
    Partial partial1 = partial0.without(dateTimeFieldType1);
    assertEquals(1, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test092100() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[1];
    intArray0[0] = (-1964);
    Partial partial0 = new Partial(gregorianChronology0, dateTimeFieldTypeArray0, intArray0);
    Partial partial1 = partial0.with(dateTimeFieldType0, (-1964));
    assertSame(partial0, partial1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test093101() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTime dateTime0 = new DateTime();
    LocalDate localDate0 = dateTime0.toLocalDate();
    Partial partial0 = new Partial(localDate0);
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType0, 1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test094102() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekOfWeekyear();
    dateTimeFieldTypeArray0[3] = dateTimeFieldType1;
    Partial partial0 = new Partial(dateTimeFieldTypeArray0[0], 1, (Chronology) null);
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldTypeArray0[3], 543);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 543 for weekOfWeekyear must not be larger than 53
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test095103() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    Partial partial0 = new Partial();
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType0, 8);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 8 for era must not be larger than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test096104() throws Throwable {
    Partial partial0 = new Partial();
    // Undeclared exception!
    try {
        partial0.with((DateTimeFieldType) null, 2355);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field type must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test097105() throws Throwable {
    MockDate mockDate0 = new MockDate(2066, 11, 2284, 91, 11);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    Partial partial0 = new Partial(localDate0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    Partial partial1 = partial0.with(dateTimeFieldType0, 2066);
    assertEquals(4, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test098106() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    Partial partial0 = new Partial(dateTimeFieldType0, 93);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Partial partial1 = partial0.withChronologyRetainFields(iSOChronology0);
    assertSame(partial1, partial0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test099107() throws Throwable {
    Partial partial0 = new Partial();
    assertEquals(0, partial0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test099108() throws Throwable {
    Partial partial0 = new Partial();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gregorianChronology0);
    Partial partial1 = partial0.withChronologyRetainFields(lenientChronology0);
    assertNotSame(partial1, partial0);
}",""
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test100109() throws Throwable {
    Partial partial0 = null;
    try {
        partial0 = new Partial((ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test101110() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    DateTimeFieldType dateTimeFieldType2 = DateTimeFieldType.dayOfYear();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType2;
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(543);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    DateTimeFieldType dateTimeFieldType3 = DateTimeFieldType.dayOfWeek();
    dateTimeFieldTypeArray0[3] = dateTimeFieldType3;
    dateTimeFieldTypeArray0[4] = dateTimeFieldType3;
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[1];
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, iSOChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain duplicate: dayOfWeek
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test102111() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[9];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.hourOfDay();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[1];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[4];
    dateTimeFieldTypeArray0[6] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[7] = dateTimeFieldTypeArray0[5];
    dateTimeFieldTypeArray0[8] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[9];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, (Chronology) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: clockhourOfHalfday < hourOfDay
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test103112() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[6];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[3] = dateTimeFieldTypeArray0[2];
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[2];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[6];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: yearOfCentury < weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test104113() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.era();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    int[] intArray0 = new int[2];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: centuryOfEra < era
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test105114() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekyearOfCentury();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    int[] intArray0 = new int[2];
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
    assertEquals(2, partial0.size());
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test106115() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    int[] intArray0 = new int[0];
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, copticChronology0);
    // Undeclared exception!
    try {
        partial0.isMatch((ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"public Partial(DateTimeFieldType type, int value) {
    this(type, value, null);
}","public void test107116() throws Throwable {
    Partial partial0 = null;
    try {
        partial0 = new Partial((DateTimeFieldType) null, 74);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field type must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the default ISO chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test111120() throws Throwable {
    Partial partial0 = new Partial();
    Partial.Property partial_Property0 = new Partial.Property(partial0, (-447));
    Partial partial1 = partial_Property0.getPartial();
    assertEquals(0, partial1.size());
}",""
"public DateTimeFieldType[] getFieldTypes() {
    return (DateTimeFieldType[]) iTypes.clone();
}","public void test112121() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(52).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDateTime localDateTime0 = LocalDateTime.parse("""", dateTimeFormatter0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = partial0.getFieldTypes();
    assertEquals(4, dateTimeFieldTypeArray0.length);
}","/**
 * Gets an array of the field type of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 *
 * @return the array of field types (cloned), largest to smallest
 */"
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test113122() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    int[] intArray0 = new int[5];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    Hours hours0 = Hours.SIX;
    Duration duration0 = hours0.toStandardDuration();
    MutableDateTime mutableDateTime0 = new MutableDateTime(0L, (Chronology) null);
    DateTime dateTime0 = mutableDateTime0.toDateTimeISO();
    PeriodType periodType0 = PeriodType.days();
    MutablePeriod mutablePeriod0 = new MutablePeriod(duration0, dateTime0, periodType0);
    // Undeclared exception!
    try {
        partial0.minus(mutablePeriod0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains
 * many useful methods for getting and manipulating the partial.
 * <p>
 * See also {@link ReadablePartial#get(DateTimeFieldType)}.
 *
 * @param type  the field type to get the property for, not null
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType type) {
    return new Property(this, indexOfSupported(type));
}","public void test116125() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    Partial partial0 = new Partial(buddhistChronology0, (DateTimeFieldType[]) null, (int[]) null);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    // Undeclared exception!
    try {
        partial0.property(dateTimeFieldType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
