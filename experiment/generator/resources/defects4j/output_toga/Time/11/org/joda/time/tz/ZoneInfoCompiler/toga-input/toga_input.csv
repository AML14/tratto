focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * Launches the ZoneInfoCompiler tool.
 *
 * <pre>
 * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;
 * where possible options include:
 *   -src &lt;directory&gt;    Specify where to read source files
 *   -dst &lt;directory&gt;    Specify where to write generated files
 *   -verbose            Output verbosely (default false)
 * </pre>
 */
public static void main(String[] args) throws Exception {
    if (args.length == 0) {
        printUsage();
        return;
    }
    File inputDir = null;
    File outputDir = null;
    boolean verbose = false;
    int i;
    for (i = 0; i < args.length; i++) {
        try {
            if (""-src"".equals(args[i])) {
                inputDir = new File(args[++i]);
            } else if (""-dst"".equals(args[i])) {
                outputDir = new File(args[++i]);
            } else if (""-verbose"".equals(args[i])) {
                verbose = true;
            } else if (""-?"".equals(args[i])) {
                printUsage();
                return;
            } else {
                break;
            }
        } catch (IndexOutOfBoundsException e) {
            printUsage();
            return;
        }
    }
    if (i >= args.length) {
        printUsage();
        return;
    }
    File[] sources = new File[args.length - i];
    for (int j = 0; i < args.length; i++, j++) {
        sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);
    }
    cVerbose.set(verbose);
    ZoneInfoCompiler zic = new ZoneInfoCompiler();
    zic.compile(outputDir, sources);
}","public void test022() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = ""-dst"";
    stringArray0[1] = """";
    try {
        ZoneInfoCompiler.main(stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.File"", e);
    }
}",""
"static String parseOptional(String str) {
    return (str.equals(""-"")) ? null : str;
}","public void test033() throws Throwable {
    String string0 = ZoneInfoCompiler.parseOptional(""-\""ew~P?7_k;Xpg"");
    assertEquals(""-\""ew~P?7_k;Xpg"", string0);
}",""
"static int parseDayOfWeek(String str) {
    DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();
    return field.get(field.set(0, str, Locale.ENGLISH));
}","public void test044() throws Throwable {
    int int0 = ZoneInfoCompiler.parseDayOfWeek(""3"");
    assertEquals(3, int0);
}",""
"static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {
    // Build the string pool.
    Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());
    TreeMap<Short, String> indexToId = new TreeMap<Short, String>();
    short count = 0;
    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {
        String id = (String) entry.getKey();
        if (!idToIndex.containsKey(id)) {
            Short index = Short.valueOf(count);
            idToIndex.put(id, index);
            indexToId.put(index, id);
            if (++count == 0) {
                throw new InternalError(""Too many time zone ids"");
            }
        }
        id = ((DateTimeZone) entry.getValue()).getID();
        if (!idToIndex.containsKey(id)) {
            Short index = Short.valueOf(count);
            idToIndex.put(id, index);
            indexToId.put(index, id);
            if (++count == 0) {
                throw new InternalError(""Too many time zone ids"");
            }
        }
    }
    // Write the string pool, ordered by index.
    dout.writeShort(indexToId.size());
    for (String id : indexToId.values()) {
        dout.writeUTF(id);
    }
    // Write the mappings.
    dout.writeShort(zimap.size());
    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {
        String id = entry.getKey();
        dout.writeShort(idToIndex.get(id).shortValue());
        id = entry.getValue().getID();
        dout.writeShort(idToIndex.get(id).shortValue());
    }
}","public void test055() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    DataOutputStream dataOutputStream0 = new DataOutputStream(pipedOutputStream0);
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    try {
        ZoneInfoCompiler.writeZoneInfoMap(dataOutputStream0, hashMap0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedOutputStream"", e);
    }
}","/**
 * @param zimap maps string ids to DateTimeZone objects.
 */"
"static boolean test(String id, DateTimeZone tz) {
    if (!id.equals(tz.getID())) {
        return true;
    }
    // Test to ensure that reported transitions are not duplicated.
    long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);
    long end = ISOChronology.getInstanceUTC().year().set(0, 2050);
    int offset = tz.getOffset(millis);
    String key = tz.getNameKey(millis);
    List<Long> transitions = new ArrayList<Long>();
    while (true) {
        long next = tz.nextTransition(millis);
        if (next == millis || next > end) {
            break;
        }
        millis = next;
        int nextOffset = tz.getOffset(millis);
        String nextKey = tz.getNameKey(millis);
        if (offset == nextOffset && key.equals(nextKey)) {
            System.out.println(""*d* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()));
            return false;
        }
        if (nextKey == null || (nextKey.length() < 3 && !""??"".equals(nextKey))) {
            System.out.println(""*s* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()) + "", nameKey="" + nextKey);
            return false;
        }
        transitions.add(Long.valueOf(millis));
        offset = nextOffset;
        key = nextKey;
    }
    // Now verify that reverse transitions match up.
    millis = ISOChronology.getInstanceUTC().year().set(0, 2050);
    end = ISOChronology.getInstanceUTC().year().set(0, 1850);
    for (int i = transitions.size(); --i >= 0; ) {
        long prev = tz.previousTransition(millis);
        if (prev == millis || prev < end) {
            break;
        }
        millis = prev;
        long trans = transitions.get(i).longValue();
        if (trans - 1 != millis) {
            System.out.println(""*r* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()) + "" != "" + new DateTime(trans - 1, ISOChronology.getInstanceUTC()));
            return false;
        }
    }
    return true;
}","public void test066() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.test(""o"", (DateTimeZone) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}","/**
 * @return false if error.
 */"
"static int parseYear(String str, int def) {
    str = str.toLowerCase();
    if (str.equals(""minimum"") || str.equals(""min"")) {
        return Integer.MIN_VALUE;
    } else if (str.equals(""maximum"") || str.equals(""max"")) {
        return Integer.MAX_VALUE;
    } else if (str.equals(""only"")) {
        return def;
    }
    return Integer.parseInt(str);
}","public void test077() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseYear((String) null, 2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}",""
"static int parseTime(String str) {
    DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();
    MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
    int pos = 0;
    if (str.startsWith(""-"")) {
        pos = 1;
    }
    int newPos = p.parseInto(mdt, str, pos);
    if (newPos == ~pos) {
        throw new IllegalArgumentException(str);
    }
    int millis = (int) mdt.getMillis();
    if (pos == 1) {
        millis = -millis;
    }
    return millis;
}","public void test088() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseTime((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"static String parseOptional(String str) {
    return (str.equals(""-"")) ? null : str;
}","public void test099() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseOptional((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"static int parseMonth(String str) {
    DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();
    return field.get(field.set(0, str, Locale.ENGLISH));
}","public void test1010() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseMonth((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"static int parseDayOfWeek(String str) {
    DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();
    return field.get(field.set(0, str, Locale.ENGLISH));
}","public void test1111() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseDayOfWeek((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public void parseDataFile(BufferedReader in) throws IOException {
    Zone zone = null;
    String line;
    while ((line = in.readLine()) != null) {
        String trimmed = line.trim();
        if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
            continue;
        }
        int index = line.indexOf('#');
        if (index >= 0) {
            line = line.substring(0, index);
        }
        //System.out.println(line);
        StringTokenizer st = new StringTokenizer(line, "" \t"");
        if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {
            if (zone != null) {
                // Zone continuation
                zone.chain(st);
            }
            continue;
        } else {
            if (zone != null) {
                iZones.add(zone);
            }
            zone = null;
        }
        if (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (token.equalsIgnoreCase(""Rule"")) {
                Rule r = new Rule(st);
                RuleSet rs = iRuleSets.get(r.iName);
                if (rs == null) {
                    rs = new RuleSet(r);
                    iRuleSets.put(r.iName, rs);
                } else {
                    rs.addRule(r);
                }
            } else if (token.equalsIgnoreCase(""Zone"")) {
                zone = new Zone(st);
            } else if (token.equalsIgnoreCase(""Link"")) {
                iLinks.add(st.nextToken());
                iLinks.add(st.nextToken());
            } else {
                System.out.println(""Unknown line: "" + line);
            }
        }
    }
    if (zone != null) {
        iZones.add(zone);
    }
}","public void test1212() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    // Undeclared exception!
    try {
        zoneInfoCompiler0.parseDataFile((BufferedReader) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}",""
"public void parseDataFile(BufferedReader in) throws IOException {
    Zone zone = null;
    String line;
    while ((line = in.readLine()) != null) {
        String trimmed = line.trim();
        if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
            continue;
        }
        int index = line.indexOf('#');
        if (index >= 0) {
            line = line.substring(0, index);
        }
        //System.out.println(line);
        StringTokenizer st = new StringTokenizer(line, "" \t"");
        if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {
            if (zone != null) {
                // Zone continuation
                zone.chain(st);
            }
            continue;
        } else {
            if (zone != null) {
                iZones.add(zone);
            }
            zone = null;
        }
        if (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (token.equalsIgnoreCase(""Rule"")) {
                Rule r = new Rule(st);
                RuleSet rs = iRuleSets.get(r.iName);
                if (rs == null) {
                    rs = new RuleSet(r);
                    iRuleSets.put(r.iName, rs);
                } else {
                    rs.addRule(r);
                }
            } else if (token.equalsIgnoreCase(""Zone"")) {
                zone = new Zone(st);
            } else if (token.equalsIgnoreCase(""Link"")) {
                iLinks.add(st.nextToken());
                iLinks.add(st.nextToken());
            } else {
                System.out.println(""Unknown line: "" + line);
            }
        }
    }
    if (zone != null) {
        iZones.add(zone);
    }
}","public void test1313() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    PipedReader pipedReader0 = new PipedReader();
    BufferedReader bufferedReader0 = new BufferedReader(pipedReader0);
    try {
        zoneInfoCompiler0.parseDataFile(bufferedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}",""
"public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
    if (sources != null) {
        for (int i = 0; i < sources.length; i++) {
            BufferedReader in = new BufferedReader(new FileReader(sources[i]));
            parseDataFile(in);
            in.close();
        }
    }
    if (outputDir != null) {
        if (!outputDir.exists()) {
            if (!outputDir.mkdirs()) {
                throw new IOException(""Destination directory doesn't exist and cannot be created: "" + outputDir);
            }
        }
        if (!outputDir.isDirectory()) {
            throw new IOException(""Destination is not a directory: "" + outputDir);
        }
    }
    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();
    System.out.println(""Writing zoneinfo files"");
    for (int i = 0; i < iZones.size(); i++) {
        Zone zone = iZones.get(i);
        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
        zone.addToBuilder(builder, iRuleSets);
        final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
        DateTimeZone tz = original;
        if (test(tz.getID(), tz)) {
            map.put(tz.getID(), tz);
            if (outputDir != null) {
                if (ZoneInfoCompiler.verbose()) {
                    System.out.println(""Writing "" + tz.getID());
                }
                File file = new File(outputDir, tz.getID());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                OutputStream out = new FileOutputStream(file);
                try {
                    builder.writeTo(zone.iName, out);
                } finally {
                    out.close();
                }
                // Test if it can be read back.
                InputStream in = new FileInputStream(file);
                DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                in.close();
                if (!original.equals(tz2)) {
                    System.out.println(""*e* Error in "" + tz.getID() + "": Didn't read properly from file"");
                }
            }
        }
    }
    for (int pass = 0; pass < 2; pass++) {
        for (int i = 0; i < iLinks.size(); i += 2) {
            String id = iLinks.get(i);
            String alias = iLinks.get(i + 1);
            DateTimeZone tz = map.get(id);
            if (tz == null) {
                if (pass > 0) {
                    System.out.println(""Cannot find time zone '"" + id + ""' to link alias '"" + alias + ""' to"");
                }
            } else {
                map.put(alias, tz);
            }
        }
    }
    if (outputDir != null) {
        System.out.println(""Writing ZoneInfoMap"");
        File file = new File(outputDir, ""ZoneInfoMap"");
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        OutputStream out = new FileOutputStream(file);
        DataOutputStream dout = new DataOutputStream(out);
        try {
            // Sort and filter out any duplicates that match case.
            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
            zimap.putAll(map);
            writeZoneInfoMap(dout, zimap);
        } finally {
            dout.close();
        }
    }
    return map;
}","public void test1414() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    File[] fileArray0 = new File[3];
    // Undeclared exception!
    try {
        zoneInfoCompiler0.compile((File) null, fileArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Returns a map of ids to DateTimeZones.
 *
 * @param outputDir optional directory to write compiled data files to
 * @param sources optional list of source files to parse
 */"
"public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
    if (sources != null) {
        for (int i = 0; i < sources.length; i++) {
            BufferedReader in = new BufferedReader(new FileReader(sources[i]));
            parseDataFile(in);
            in.close();
        }
    }
    if (outputDir != null) {
        if (!outputDir.exists()) {
            if (!outputDir.mkdirs()) {
                throw new IOException(""Destination directory doesn't exist and cannot be created: "" + outputDir);
            }
        }
        if (!outputDir.isDirectory()) {
            throw new IOException(""Destination is not a directory: "" + outputDir);
        }
    }
    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();
    System.out.println(""Writing zoneinfo files"");
    for (int i = 0; i < iZones.size(); i++) {
        Zone zone = iZones.get(i);
        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
        zone.addToBuilder(builder, iRuleSets);
        final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
        DateTimeZone tz = original;
        if (test(tz.getID(), tz)) {
            map.put(tz.getID(), tz);
            if (outputDir != null) {
                if (ZoneInfoCompiler.verbose()) {
                    System.out.println(""Writing "" + tz.getID());
                }
                File file = new File(outputDir, tz.getID());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                OutputStream out = new FileOutputStream(file);
                try {
                    builder.writeTo(zone.iName, out);
                } finally {
                    out.close();
                }
                // Test if it can be read back.
                InputStream in = new FileInputStream(file);
                DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                in.close();
                if (!original.equals(tz2)) {
                    System.out.println(""*e* Error in "" + tz.getID() + "": Didn't read properly from file"");
                }
            }
        }
    }
    for (int pass = 0; pass < 2; pass++) {
        for (int i = 0; i < iLinks.size(); i += 2) {
            String id = iLinks.get(i);
            String alias = iLinks.get(i + 1);
            DateTimeZone tz = map.get(id);
            if (tz == null) {
                if (pass > 0) {
                    System.out.println(""Cannot find time zone '"" + id + ""' to link alias '"" + alias + ""' to"");
                }
            } else {
                map.put(alias, tz);
            }
        }
    }
    if (outputDir != null) {
        System.out.println(""Writing ZoneInfoMap"");
        File file = new File(outputDir, ""ZoneInfoMap"");
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        OutputStream out = new FileOutputStream(file);
        DataOutputStream dout = new DataOutputStream(out);
        try {
            // Sort and filter out any duplicates that match case.
            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
            zimap.putAll(map);
            writeZoneInfoMap(dout, zimap);
        } finally {
            dout.close();
        }
    }
    return map;
}","public void test1515() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    MockFile mockFile0 = new MockFile(""-I%rwfe}24G>O&M1H"", ""-I%rwfe}24G>O&M1H"");
    File[] fileArray0 = new File[6];
    fileArray0[0] = (File) mockFile0;
    try {
        zoneInfoCompiler0.compile(mockFile0, fileArray0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Returns a map of ids to DateTimeZones.
 *
 * @param outputDir optional directory to write compiled data files to
 * @param sources optional list of source files to parse
 */"
"static Chronology getLenientISOChronology() {
    if (cLenientISO == null) {
        cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());
    }
    return cLenientISO;
}","public void test1616() throws Throwable {
    Chronology chronology0 = ZoneInfoCompiler.getLenientISOChronology();
    Chronology chronology1 = ZoneInfoCompiler.getLenientISOChronology();
    assertSame(chronology1, chronology0);
}",""
"public void parseDataFile(BufferedReader in) throws IOException {
    Zone zone = null;
    String line;
    while ((line = in.readLine()) != null) {
        String trimmed = line.trim();
        if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
            continue;
        }
        int index = line.indexOf('#');
        if (index >= 0) {
            line = line.substring(0, index);
        }
        //System.out.println(line);
        StringTokenizer st = new StringTokenizer(line, "" \t"");
        if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {
            if (zone != null) {
                // Zone continuation
                zone.chain(st);
            }
            continue;
        } else {
            if (zone != null) {
                iZones.add(zone);
            }
            zone = null;
        }
        if (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (token.equalsIgnoreCase(""Rule"")) {
                Rule r = new Rule(st);
                RuleSet rs = iRuleSets.get(r.iName);
                if (rs == null) {
                    rs = new RuleSet(r);
                    iRuleSets.put(r.iName, rs);
                } else {
                    rs.addRule(r);
                }
            } else if (token.equalsIgnoreCase(""Zone"")) {
                zone = new Zone(st);
            } else if (token.equalsIgnoreCase(""Link"")) {
                iLinks.add(st.nextToken());
                iLinks.add(st.nextToken());
            } else {
                System.out.println(""Unknown line: "" + line);
            }
        }
    }
    if (zone != null) {
        iZones.add(zone);
    }
}","public void test1818() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    StringReader stringReader0 = new StringReader(""\nFormat: "");
    BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 47);
    zoneInfoCompiler0.parseDataFile(bufferedReader0);
}",""
"public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
    if (sources != null) {
        for (int i = 0; i < sources.length; i++) {
            BufferedReader in = new BufferedReader(new FileReader(sources[i]));
            parseDataFile(in);
            in.close();
        }
    }
    if (outputDir != null) {
        if (!outputDir.exists()) {
            if (!outputDir.mkdirs()) {
                throw new IOException(""Destination directory doesn't exist and cannot be created: "" + outputDir);
            }
        }
        if (!outputDir.isDirectory()) {
            throw new IOException(""Destination is not a directory: "" + outputDir);
        }
    }
    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();
    System.out.println(""Writing zoneinfo files"");
    for (int i = 0; i < iZones.size(); i++) {
        Zone zone = iZones.get(i);
        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
        zone.addToBuilder(builder, iRuleSets);
        final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
        DateTimeZone tz = original;
        if (test(tz.getID(), tz)) {
            map.put(tz.getID(), tz);
            if (outputDir != null) {
                if (ZoneInfoCompiler.verbose()) {
                    System.out.println(""Writing "" + tz.getID());
                }
                File file = new File(outputDir, tz.getID());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                OutputStream out = new FileOutputStream(file);
                try {
                    builder.writeTo(zone.iName, out);
                } finally {
                    out.close();
                }
                // Test if it can be read back.
                InputStream in = new FileInputStream(file);
                DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                in.close();
                if (!original.equals(tz2)) {
                    System.out.println(""*e* Error in "" + tz.getID() + "": Didn't read properly from file"");
                }
            }
        }
    }
    for (int pass = 0; pass < 2; pass++) {
        for (int i = 0; i < iLinks.size(); i += 2) {
            String id = iLinks.get(i);
            String alias = iLinks.get(i + 1);
            DateTimeZone tz = map.get(id);
            if (tz == null) {
                if (pass > 0) {
                    System.out.println(""Cannot find time zone '"" + id + ""' to link alias '"" + alias + ""' to"");
                }
            } else {
                map.put(alias, tz);
            }
        }
    }
    if (outputDir != null) {
        System.out.println(""Writing ZoneInfoMap"");
        File file = new File(outputDir, ""ZoneInfoMap"");
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        OutputStream out = new FileOutputStream(file);
        DataOutputStream dout = new DataOutputStream(out);
        try {
            // Sort and filter out any duplicates that match case.
            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
            zimap.putAll(map);
            writeZoneInfoMap(dout, zimap);
        } finally {
            dout.close();
        }
    }
    return map;
}","public void test1919() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    File file0 = MockFile.createTempFile(""Mont>KhOfear: "", "")m)4=>MAYq@Lw]7"");
    File[] fileArray0 = new File[1];
    fileArray0[0] = file0;
    try {
        zoneInfoCompiler0.compile(file0, fileArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Destination is not a directory: /var/folders/vv/c7q6vm8920vc7d5p_87011w40000gn/T/Mont>KhOfear: 0)m)4=>MAYq@Lw]7
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}","/**
 * Returns a map of ids to DateTimeZones.
 *
 * @param outputDir optional directory to write compiled data files to
 * @param sources optional list of source files to parse
 */"
"public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
    if (sources != null) {
        for (int i = 0; i < sources.length; i++) {
            BufferedReader in = new BufferedReader(new FileReader(sources[i]));
            parseDataFile(in);
            in.close();
        }
    }
    if (outputDir != null) {
        if (!outputDir.exists()) {
            if (!outputDir.mkdirs()) {
                throw new IOException(""Destination directory doesn't exist and cannot be created: "" + outputDir);
            }
        }
        if (!outputDir.isDirectory()) {
            throw new IOException(""Destination is not a directory: "" + outputDir);
        }
    }
    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();
    System.out.println(""Writing zoneinfo files"");
    for (int i = 0; i < iZones.size(); i++) {
        Zone zone = iZones.get(i);
        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
        zone.addToBuilder(builder, iRuleSets);
        final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
        DateTimeZone tz = original;
        if (test(tz.getID(), tz)) {
            map.put(tz.getID(), tz);
            if (outputDir != null) {
                if (ZoneInfoCompiler.verbose()) {
                    System.out.println(""Writing "" + tz.getID());
                }
                File file = new File(outputDir, tz.getID());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                OutputStream out = new FileOutputStream(file);
                try {
                    builder.writeTo(zone.iName, out);
                } finally {
                    out.close();
                }
                // Test if it can be read back.
                InputStream in = new FileInputStream(file);
                DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                in.close();
                if (!original.equals(tz2)) {
                    System.out.println(""*e* Error in "" + tz.getID() + "": Didn't read properly from file"");
                }
            }
        }
    }
    for (int pass = 0; pass < 2; pass++) {
        for (int i = 0; i < iLinks.size(); i += 2) {
            String id = iLinks.get(i);
            String alias = iLinks.get(i + 1);
            DateTimeZone tz = map.get(id);
            if (tz == null) {
                if (pass > 0) {
                    System.out.println(""Cannot find time zone '"" + id + ""' to link alias '"" + alias + ""' to"");
                }
            } else {
                map.put(alias, tz);
            }
        }
    }
    if (outputDir != null) {
        System.out.println(""Writing ZoneInfoMap"");
        File file = new File(outputDir, ""ZoneInfoMap"");
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        OutputStream out = new FileOutputStream(file);
        DataOutputStream dout = new DataOutputStream(out);
        try {
            // Sort and filter out any duplicates that match case.
            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
            zimap.putAll(map);
            writeZoneInfoMap(dout, zimap);
        } finally {
            dout.close();
        }
    }
    return map;
}","public void test2020() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    FileSystemHandling.shouldAllThrowIOExceptions();
    MockFile mockFile0 = new MockFile(""E4kq\""mEi2kIZ?m(Zw#a"", ""Tho many time zon ids"");
    File[] fileArray0 = new File[0];
    try {
        zoneInfoCompiler0.compile(mockFile0, fileArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Destination directory doesn't exist and cannot be created: /Users/elliottzackrone/IdeaProjects/defects4jprefix/E4kq\""mEi2kIZ?m(Zw#a/Tho many time zon ids
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}","/**
 * Returns a map of ids to DateTimeZones.
 *
 * @param outputDir optional directory to write compiled data files to
 * @param sources optional list of source files to parse
 */"
"public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
    if (sources != null) {
        for (int i = 0; i < sources.length; i++) {
            BufferedReader in = new BufferedReader(new FileReader(sources[i]));
            parseDataFile(in);
            in.close();
        }
    }
    if (outputDir != null) {
        if (!outputDir.exists()) {
            if (!outputDir.mkdirs()) {
                throw new IOException(""Destination directory doesn't exist and cannot be created: "" + outputDir);
            }
        }
        if (!outputDir.isDirectory()) {
            throw new IOException(""Destination is not a directory: "" + outputDir);
        }
    }
    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();
    System.out.println(""Writing zoneinfo files"");
    for (int i = 0; i < iZones.size(); i++) {
        Zone zone = iZones.get(i);
        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
        zone.addToBuilder(builder, iRuleSets);
        final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
        DateTimeZone tz = original;
        if (test(tz.getID(), tz)) {
            map.put(tz.getID(), tz);
            if (outputDir != null) {
                if (ZoneInfoCompiler.verbose()) {
                    System.out.println(""Writing "" + tz.getID());
                }
                File file = new File(outputDir, tz.getID());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                OutputStream out = new FileOutputStream(file);
                try {
                    builder.writeTo(zone.iName, out);
                } finally {
                    out.close();
                }
                // Test if it can be read back.
                InputStream in = new FileInputStream(file);
                DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                in.close();
                if (!original.equals(tz2)) {
                    System.out.println(""*e* Error in "" + tz.getID() + "": Didn't read properly from file"");
                }
            }
        }
    }
    for (int pass = 0; pass < 2; pass++) {
        for (int i = 0; i < iLinks.size(); i += 2) {
            String id = iLinks.get(i);
            String alias = iLinks.get(i + 1);
            DateTimeZone tz = map.get(id);
            if (tz == null) {
                if (pass > 0) {
                    System.out.println(""Cannot find time zone '"" + id + ""' to link alias '"" + alias + ""' to"");
                }
            } else {
                map.put(alias, tz);
            }
        }
    }
    if (outputDir != null) {
        System.out.println(""Writing ZoneInfoMap"");
        File file = new File(outputDir, ""ZoneInfoMap"");
        if (!file.getParentFile().exists()) {
            file.getParentFile().mkdirs();
        }
        OutputStream out = new FileOutputStream(file);
        DataOutputStream dout = new DataOutputStream(out);
        try {
            // Sort and filter out any duplicates that match case.
            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
            zimap.putAll(map);
            writeZoneInfoMap(dout, zimap);
        } finally {
            dout.close();
        }
    }
    return map;
}","public void test2222() throws Throwable {
    ZoneInfoCompiler zoneInfoCompiler0 = new ZoneInfoCompiler();
    File file0 = MockFile.createTempFile(""maximum"", ""co!"");
    try {
        zoneInfoCompiler0.compile(file0, (File[]) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Destination is not a directory: /var/folders/vv/c7q6vm8920vc7d5p_87011w40000gn/T/maximum0co!
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}","/**
 * Returns a map of ids to DateTimeZones.
 *
 * @param outputDir optional directory to write compiled data files to
 * @param sources optional list of source files to parse
 */"
"static boolean test(String id, DateTimeZone tz) {
    if (!id.equals(tz.getID())) {
        return true;
    }
    // Test to ensure that reported transitions are not duplicated.
    long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);
    long end = ISOChronology.getInstanceUTC().year().set(0, 2050);
    int offset = tz.getOffset(millis);
    String key = tz.getNameKey(millis);
    List<Long> transitions = new ArrayList<Long>();
    while (true) {
        long next = tz.nextTransition(millis);
        if (next == millis || next > end) {
            break;
        }
        millis = next;
        int nextOffset = tz.getOffset(millis);
        String nextKey = tz.getNameKey(millis);
        if (offset == nextOffset && key.equals(nextKey)) {
            System.out.println(""*d* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()));
            return false;
        }
        if (nextKey == null || (nextKey.length() < 3 && !""??"".equals(nextKey))) {
            System.out.println(""*s* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()) + "", nameKey="" + nextKey);
            return false;
        }
        transitions.add(Long.valueOf(millis));
        offset = nextOffset;
        key = nextKey;
    }
    // Now verify that reverse transitions match up.
    millis = ISOChronology.getInstanceUTC().year().set(0, 2050);
    end = ISOChronology.getInstanceUTC().year().set(0, 1850);
    for (int i = transitions.size(); --i >= 0; ) {
        long prev = tz.previousTransition(millis);
        if (prev == millis || prev < end) {
            break;
        }
        millis = prev;
        long trans = transitions.get(i).longValue();
        if (trans - 1 != millis) {
            System.out.println(""*r* Error in "" + tz.getID() + "" "" + new DateTime(millis, ISOChronology.getInstanceUTC()) + "" != "" + new DateTime(trans - 1, ISOChronology.getInstanceUTC()));
            return false;
        }
    }
    return true;
}","public void test2323() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(3);
    boolean boolean0 = ZoneInfoCompiler.test(""MonthOfYear: 1\nDayOfMonth: 1\nDayOfWeek: 0\nAdvanceDayOfWeek: false\nMillisOfDay: 0\nZoneChar: w\n"", dateTimeZone0);
    assertTrue(boolean0);
}","/**
 * @return false if error.
 */"
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2424() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('Q');
    assertEquals('w', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2525() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('w');
    assertEquals('w', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2626() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('u');
    assertEquals('u', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2727() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('g');
    assertEquals('u', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2828() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('U');
    assertEquals('u', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test2929() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('S');
    assertEquals('s', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test3030() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('W');
    assertEquals('w', char0);
}",""
"static char parseZoneChar(char c) {
    switch(c) {
        case 's':
        case 'S':
            // Standard time
            return 's';
        case 'u':
        case 'U':
        case 'g':
        case 'G':
        case 'z':
        case 'Z':
            // UTC
            return 'u';
        case 'w':
        case 'W':
        default:
            // Wall time
            return 'w';
    }
}","public void test3131() throws Throwable {
    char char0 = ZoneInfoCompiler.parseZoneChar('G');
    assertEquals('u', char0);
}",""
"static int parseTime(String str) {
    DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();
    MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
    int pos = 0;
    if (str.startsWith(""-"")) {
        pos = 1;
    }
    int newPos = p.parseInto(mdt, str, pos);
    if (newPos == ~pos) {
        throw new IllegalArgumentException(str);
    }
    int millis = (int) mdt.getMillis();
    if (pos == 1) {
        millis = -millis;
    }
    return millis;
}","public void test3232() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseTime(""qJagA79?:"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // qJagA79?:
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}",""
"static int parseTime(String str) {
    DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();
    MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
    int pos = 0;
    if (str.startsWith(""-"")) {
        pos = 1;
    }
    int newPos = p.parseInto(mdt, str, pos);
    if (newPos == ~pos) {
        throw new IllegalArgumentException(str);
    }
    int millis = (int) mdt.getMillis();
    if (pos == 1) {
        millis = -millis;
    }
    return millis;
}","public void test3333() throws Throwable {
    int int0 = ZoneInfoCompiler.parseTime(""-0L0K)xA"");
    assertEquals(0, int0);
}",""
"static String parseOptional(String str) {
    return (str.equals(""-"")) ? null : str;
}","public void test3434() throws Throwable {
    String string0 = ZoneInfoCompiler.parseOptional("""");
    assertEquals("""", string0);
}",""
"static int parseYear(String str, int def) {
    str = str.toLowerCase();
    if (str.equals(""minimum"") || str.equals(""min"")) {
        return Integer.MIN_VALUE;
    } else if (str.equals(""maximum"") || str.equals(""max"")) {
        return Integer.MAX_VALUE;
    } else if (str.equals(""only"")) {
        return def;
    }
    return Integer.parseInt(str);
}","public void test3535() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseYear(""zone"", 83);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \""zone\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}",""
"static int parseYear(String str, int def) {
    str = str.toLowerCase();
    if (str.equals(""minimum"") || str.equals(""min"")) {
        return Integer.MIN_VALUE;
    } else if (str.equals(""maximum"") || str.equals(""max"")) {
        return Integer.MAX_VALUE;
    } else if (str.equals(""only"")) {
        return def;
    }
    return Integer.parseInt(str);
}","public void test3636() throws Throwable {
    int int0 = ZoneInfoCompiler.parseYear(""minimum"", (-76));
    assertEquals(Integer.MIN_VALUE, int0);
}",""
"static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {
    // Build the string pool.
    Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());
    TreeMap<Short, String> indexToId = new TreeMap<Short, String>();
    short count = 0;
    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {
        String id = (String) entry.getKey();
        if (!idToIndex.containsKey(id)) {
            Short index = Short.valueOf(count);
            idToIndex.put(id, index);
            indexToId.put(index, id);
            if (++count == 0) {
                throw new InternalError(""Too many time zone ids"");
            }
        }
        id = ((DateTimeZone) entry.getValue()).getID();
        if (!idToIndex.containsKey(id)) {
            Short index = Short.valueOf(count);
            idToIndex.put(id, index);
            indexToId.put(index, id);
            if (++count == 0) {
                throw new InternalError(""Too many time zone ids"");
            }
        }
    }
    // Write the string pool, ordered by index.
    dout.writeShort(indexToId.size());
    for (String id : indexToId.values()) {
        dout.writeUTF(id);
    }
    // Write the mappings.
    dout.writeShort(zimap.size());
    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {
        String id = entry.getKey();
        dout.writeShort(idToIndex.get(id).shortValue());
        id = entry.getValue().getID();
        dout.writeShort(idToIndex.get(id).shortValue());
    }
}","public void test3737() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    hashMap0.put(""-*r* Error in "", dateTimeZone0);
    hashMap0.put("""", dateTimeZone0);
    // Undeclared exception!
    try {
        ZoneInfoCompiler.writeZoneInfoMap((DataOutputStream) null, hashMap0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.tz.ZoneInfoCompiler"", e);
    }
}","/**
 * @param zimap maps string ids to DateTimeZone objects.
 */"
"static Chronology getLenientISOChronology() {
    if (cLenientISO == null) {
        cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());
    }
    return cLenientISO;
}","public void test3838() throws Throwable {
    Chronology chronology0 = ZoneInfoCompiler.getLenientISOChronology();
    assertNotNull(chronology0);
}",""
"static int parseTime(String str) {
    DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();
    MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
    int pos = 0;
    if (str.startsWith(""-"")) {
        pos = 1;
    }
    int newPos = p.parseInto(mdt, str, pos);
    if (newPos == ~pos) {
        throw new IllegalArgumentException(str);
    }
    int millis = (int) mdt.getMillis();
    if (pos == 1) {
        millis = -millis;
    }
    return millis;
}","public void test3839() throws Throwable {
    Chronology chronology0 = ZoneInfoCompiler.getLenientISOChronology();
    int int0 = ZoneInfoCompiler.parseTime(""24,G0"");
    assertEquals(86400000, int0);
}",""
"static DateTimeOfYear getStartOfYear() {
    if (cStartOfYear == null) {
        cStartOfYear = new DateTimeOfYear();
    }
    return cStartOfYear;
}","public void test3940() throws Throwable {
    ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear0 = ZoneInfoCompiler.getStartOfYear();
    ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear1 = ZoneInfoCompiler.getStartOfYear();
    assertSame(zoneInfoCompiler_DateTimeOfYear1, zoneInfoCompiler_DateTimeOfYear0);
}",""
"//-----------------------------------------------------------------------
/**
 * Launches the ZoneInfoCompiler tool.
 *
 * <pre>
 * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;
 * where possible options include:
 *   -src &lt;directory&gt;    Specify where to read source files
 *   -dst &lt;directory&gt;    Specify where to write generated files
 *   -verbose            Output verbosely (default false)
 * </pre>
 */
public static void main(String[] args) throws Exception {
    if (args.length == 0) {
        printUsage();
        return;
    }
    File inputDir = null;
    File outputDir = null;
    boolean verbose = false;
    int i;
    for (i = 0; i < args.length; i++) {
        try {
            if (""-src"".equals(args[i])) {
                inputDir = new File(args[++i]);
            } else if (""-dst"".equals(args[i])) {
                outputDir = new File(args[++i]);
            } else if (""-verbose"".equals(args[i])) {
                verbose = true;
            } else if (""-?"".equals(args[i])) {
                printUsage();
                return;
            } else {
                break;
            }
        } catch (IndexOutOfBoundsException e) {
            printUsage();
            return;
        }
    }
    if (i >= args.length) {
        printUsage();
        return;
    }
    File[] sources = new File[args.length - i];
    for (int j = 0; i < args.length; i++, j++) {
        sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);
    }
    cVerbose.set(verbose);
    ZoneInfoCompiler zic = new ZoneInfoCompiler();
    zic.compile(outputDir, sources);
}","public void test4041() throws Throwable {
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""o"";
    stringArray0[1] = ""o"";
    stringArray0[2] = ""minimum"";
    try {
        ZoneInfoCompiler.main(stringArray0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}",""
"static int parseDayOfWeek(String str) {
    DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();
    return field.get(field.set(0, str, Locale.ENGLISH));
}","public void test4142() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseDayOfWeek(""MonthOfYear: 1\nDayOfMonth: 1\nDayOfWeek: 0\nAdvanceDayOfWeek: false\nMillisOfDay: 0\nZoneChar: w\n"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value \""MonthOfYear: 1
        // DayOfMonth: 1
        // DayOfWeek: 0
        // AdvanceDayOfWeek: false
        // MillisOfDay: 0
        // ZoneChar: w
        // \"" for dayOfWeek is not supported
        //
        verifyException(""org.joda.time.chrono.GJLocaleSymbols"", e);
    }
}",""
"static int parseMonth(String str) {
    DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();
    return field.get(field.set(0, str, Locale.ENGLISH));
}","public void test4243() throws Throwable {
    // Undeclared exception!
    try {
        ZoneInfoCompiler.parseMonth("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value \""\"" for monthOfYear is not supported
        //
        verifyException(""org.joda.time.chrono.GJLocaleSymbols"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Launches the ZoneInfoCompiler tool.
 *
 * <pre>
 * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;
 * where possible options include:
 *   -src &lt;directory&gt;    Specify where to read source files
 *   -dst &lt;directory&gt;    Specify where to write generated files
 *   -verbose            Output verbosely (default false)
 * </pre>
 */
public static void main(String[] args) throws Exception {
    if (args.length == 0) {
        printUsage();
        return;
    }
    File inputDir = null;
    File outputDir = null;
    boolean verbose = false;
    int i;
    for (i = 0; i < args.length; i++) {
        try {
            if (""-src"".equals(args[i])) {
                inputDir = new File(args[++i]);
            } else if (""-dst"".equals(args[i])) {
                outputDir = new File(args[++i]);
            } else if (""-verbose"".equals(args[i])) {
                verbose = true;
            } else if (""-?"".equals(args[i])) {
                printUsage();
                return;
            } else {
                break;
            }
        } catch (IndexOutOfBoundsException e) {
            printUsage();
            return;
        }
    }
    if (i >= args.length) {
        printUsage();
        return;
    }
    File[] sources = new File[args.length - i];
    for (int j = 0; i < args.length; i++, j++) {
        sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);
    }
    cVerbose.set(verbose);
    ZoneInfoCompiler zic = new ZoneInfoCompiler();
    zic.compile(outputDir, sources);
}","public void test4445() throws Throwable {
    String[] stringArray0 = new String[0];
    ZoneInfoCompiler.main(stringArray0);
    assertEquals(0, stringArray0.length);
}",""
