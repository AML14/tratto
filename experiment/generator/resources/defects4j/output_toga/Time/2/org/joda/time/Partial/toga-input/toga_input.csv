focal_method,test_prefix,docstring
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test000() throws Throwable {
    Partial partial0 = new Partial();
    Partial partial1 = new Partial(partial0);
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test011() throws Throwable {
    Partial partial0 = new Partial();
    Days days0 = Days.MAX_VALUE;
    partial0.minus(days0);
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"public static DateTimeFieldType year() {
    return YEAR_TYPE;
}","public void test033() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    Partial partial1 = new Partial(partial0);
    DateTimeFieldType.year();
}","/**
 * Get the year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public int[] getValues() {
    return (int[]) iValues.clone();
}","public void test044() throws Throwable {
    Partial partial0 = new Partial();
    partial0.getValues();
}","/**
 * Gets an array of the value of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 * Each value corresponds to the same array index as <code>getFieldTypes()</code>
 *
 * @return the current values of each field (cloned), largest to smallest
 */"
"public boolean isSupported(DateTimeFieldType type) {
    return (indexOf(type) != -1);
}","public void test055() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    LocalDateTime localDateTime0 = LocalDateTime.now();
    Partial partial0 = new Partial(localDateTime0);
    partial0.isSupported(dateTimeFieldType0);
}","/**
 * Checks whether the field specified is supported by this partial.
 *
 * @param type  the type to check, may be null which returns false
 * @return true if the field is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains
 * many useful methods for getting and manipulating the partial.
 * <p>
 * See also {@link ReadablePartial#get(DateTimeFieldType)}.
 *
 * @param type  the field type to get the property for, not null
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType type) {
    return new Property(this, indexOfSupported(type));
}","public void test088() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    // Undeclared exception!
    try {
        partial0.property(dateTimeFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'minuteOfHour' is not supported
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}",""
"public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {
    checkPermission();
    cMillisProvider = new FixedMillisProvider(fixedMillis);
}","public void test099() throws Throwable {
    long long0 = 0L;
    LocalTime localTime0 = new LocalTime(0L);
    Partial partial0 = new Partial(localTime0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    Partial.Property partial_Property0 = partial0.property(dateTimeFieldType0);
    int int0 = 5;
    partial_Property0.setCopy(5);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    partial_Property0.setCopy("""", locale0);
    // Undeclared exception!
    try {
        DateTimeUtils.setCurrentMillisFixed(long0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value \""\"" for hourOfDay is not supported
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Sets the current time to return a fixed millisecond time.
 * <p>
 * This method changes the behaviour of {@link #currentTimeMillis()}.
 * Whenever the current time is queried, the same millisecond time will be returned.
 *
 * @param fixedMillis  the fixed millisecond time to use
 * @throws SecurityException if the application does not have sufficient security rights
 */"
"public Partial(DateTimeFieldType type, int value) {
    this(type, value, null);
}","public void test1010() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the default ISO chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test1111() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    partial0.with(dateTimeFieldType0, 1792);
}",""
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test1212() throws Throwable {
    Partial partial0 = new Partial();
    DurationFieldType durationFieldType0 = DurationFieldType.HALFDAYS_TYPE;
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    int[] intArray0 = new int[0];
    Partial partial1 = new Partial(dateTimeFieldTypeArray0, intArray0);
    DurationFieldType durationFieldType1 = DurationFieldType.hours();
    partial0.withFieldAddWrapped(durationFieldType1, 2416);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test1313() throws Throwable {
    int int0 = 0;
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    int[] intArray0 = new int[0];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Values array must be the same length as the types array
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test1414() throws Throwable {
    Partial partial0 = new Partial();
    Hours hours0 = Hours.THREE;
    hours0.toString();
    Partial partial1 = partial0.plus(hours0);
    partial1.toString();
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test1515() throws Throwable {
    Partial partial0 = new Partial();
    partial0.toString();
}",""
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test1616() throws Throwable {
    Partial partial0 = new Partial();
    Locale locale0 = new Locale(""Types array must not contain null: index "");
    partial0.toString(""Types array must not contain null: index "", locale0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test1717() throws Throwable {
    Partial partial0 = new Partial();
    partial0.getFieldTypes();
    ISOChronology.getInstance();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    partial0.with(dateTimeFieldType0, (-2135));
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test1818() throws Throwable {
    Partial partial0 = new Partial();
    LocalDateTime localDateTime0 = LocalDateTime.now();
    partial0.isMatch((ReadablePartial) localDateTime0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test1919() throws Throwable {
    DateTimeFieldType.millisOfSecond();
    LocalDateTime localDateTime0 = LocalDateTime.now();
    Partial partial0 = new Partial(localDateTime0);
    partial0.isMatch((ReadablePartial) localDateTime0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test2020() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Partial partial1 = new Partial();
    partial0.without(dateTimeFieldType0);
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test2222() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    partial0.withChronologyRetainFields(iSOChronology0);
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test2525() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType.dayOfYear();
    partial0.toString();
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test2727() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    DurationFieldType.months();
    partial0.toString();
}",""
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test2828() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    ZonedDateTime zonedDateTime0 = MockZonedDateTime.now(zoneId0);
    GregorianCalendar gregorianCalendar0 = MockGregorianCalendar.from(zonedDateTime0);
    LocalDate localDate0 = LocalDate.fromCalendarFields(gregorianCalendar0);
    Partial partial0 = new Partial(localDate0);
    partial0.isMatch((ReadableInstant) null);
}",""
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test2929() throws Throwable {
    Partial partial0 = new Partial();
    partial0.isMatch((ReadableInstant) null);
}",""
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test3030() throws Throwable {
    Partial partial0 = new Partial();
    partial0.withPeriodAdded((ReadablePeriod) null, 23034375);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test3131() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    ZonedDateTime zonedDateTime0 = MockZonedDateTime.now(zoneId0);
    GregorianCalendar gregorianCalendar0 = MockGregorianCalendar.from(zonedDateTime0);
    LocalDate localDate0 = LocalDate.fromCalendarFields(gregorianCalendar0);
    localDate0.getDayOfYear();
    Partial partial0 = new Partial(localDate0);
    partial0.getValues();
    partial0.toString();
    partial0.getFormatter();
}",""
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test3232() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    partial0.without(dateTimeFieldType0);
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test3434() throws Throwable {
    Days days0 = Days.SIX;
    Partial partial0 = new Partial((ReadablePartial) null);
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test3535() throws Throwable {
    Months months0 = Months.FOUR;
    Partial partial0 = new Partial();
    partial0.with((DateTimeFieldType) null, 2351);
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test3737() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    ZonedDateTime zonedDateTime0 = MockZonedDateTime.now(zoneId0);
    GregorianCalendar gregorianCalendar0 = MockGregorianCalendar.from(zonedDateTime0);
    LocalDate localDate0 = LocalDate.fromCalendarFields(gregorianCalendar0);
    localDate0.getDayOfYear();
    Locale locale0 = Locale.GERMAN;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 45);
    Partial.Property partial_Property0 = new Partial.Property(partial0, 1852);
    partial_Property0.addWrapFieldToCopy(123);
    partial0.isMatch((ReadablePartial) localDate0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test3838() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    MutableDateTime mutableDateTime0 = new MutableDateTime(1272L);
    partial0.isMatch((ReadableInstant) mutableDateTime0);
    Months months0 = Months.FOUR;
    months0.minus(3);
    Partial partial1 = partial0.withPeriodAdded(months0, 529);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    partial1.with(dateTimeFieldType0, 529);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test3939() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    partial0.with(dateTimeFieldType0, 1509);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test4040() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType.dayOfYear();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    partial0.with(dateTimeFieldType0, 1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test4141() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    partial0.with(dateTimeFieldType0, 0);
}",""
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test4242() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, (int[]) null, (Chronology) null);
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test4545() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    MutablePeriod mutablePeriod0 = new MutablePeriod(2629800000L, 2629800000L);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    dateTimeFieldType0.isSupported(buddhistChronology0);
    Partial partial0 = new Partial(dateTimeFieldType0, 20);
    Partial partial1 = partial0.plus(mutablePeriod0);
    partial1.getFormatter();
    partial1.toString();
}",""
"public Partial(DateTimeFieldType type, int value) {
    this(type, value, null);
}","public void test4646() throws Throwable {
    DurationFieldType.months();
    Partial partial0 = new Partial((DateTimeFieldType) null, 168);
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the default ISO chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test4848() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    partial0.with(dateTimeFieldType0, 58);
}",""
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test4949() throws Throwable {
    Partial partial0 = new Partial();
    Days days0 = Days.MIN_VALUE;
    partial0.withPeriodAdded(days0, 0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test5050() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    LocalDateTime localDateTime0 = LocalDateTime.now();
    partial0.isMatch((ReadablePartial) localDateTime0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test5151() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    partial0.with(dateTimeFieldType0, 529);
}",""
"public static DurationFieldType hours() {
    return HOURS_TYPE;
}","public void test5252() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    int[] intArray0 = new int[2];
    intArray0[1] = 0;
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        DurationFieldType.hours();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain duplicate: millisOfSecond and millisOfSecond
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Get the hours field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test5454() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(2629800000L, 2629800000L);
    Partial partial1 = new Partial();
    DateTimeFieldType.hourOfDay();
    Partial partial2 = new Partial(partial0);
    DateTimeFieldType.hourOfDay();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    partial2.with(dateTimeFieldType0, 529);
}",""
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test5555() throws Throwable {
    Days days0 = Days.MAX_VALUE;
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.secondOfMinute();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    DateTimeFieldType dateTimeFieldType2 = DateTimeFieldType.centuryOfEra();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType2;
    DateTimeFieldType dateTimeFieldType3 = DateTimeFieldType.yearOfCentury();
    dateTimeFieldTypeArray0[3] = dateTimeFieldType3;
    int[] intArray0 = new int[4];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: secondOfMinute < centuryOfEra
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public static DurationFieldType hours() {
    return HOURS_TYPE;
}","public void test5656() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    dateTimeFieldTypeArray0[1] = dateTimeFieldTypeArray0[0];
    int[] intArray0 = new int[2];
    intArray0[1] = 0;
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        DurationFieldType.hours();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain null: index 0
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Get the hours field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test5858() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.secondOfDay();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    int[] intArray0 = new int[2];
    int int0 = 0;
    intArray0[1] = 0;
    Partial partial1 = null;
    try {
        partial1 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: secondOfMinute < secondOfDay
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test5959() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod(0L, 2629800000L);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    Partial partial0 = new Partial(dateTimeFieldType0, 1);
    partial0.plus(mutablePeriod0);
    DateTimeFieldType.hourOfDay();
    Partial partial1 = new Partial(partial0);
    DateTimeZone.getDefault();
    DateTimeFieldType.hourOfDay();
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfYear();
    Partial partial2 = partial0.with(dateTimeFieldType1, 58);
    Hours hours0 = Hours.TWO;
    partial2.toString();
}",""
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test6060() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType.hourOfDay();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    partial0.withFieldAdded(durationFieldType0, (-1527));
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public static DateTimeFieldType weekyearOfCentury() {
    return WEEKYEAR_OF_CENTURY_TYPE;
}","public void test6161() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(2629800000L, 2629800000L);
    partial0.isEqual(partial0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    partial0.withFieldAddWrapped(durationFieldType0, (-454));
    DateTimeFieldType.weekyearOfCentury();
}","/**
 * Get the year of a week based year within a century field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test6262() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(2629800000L, 2629800000L);
    partial0.isEqual(partial0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    partial0.withFieldAdded(durationFieldType0, 0);
    partial0.withFieldAddWrapped(durationFieldType0, (-454));
    partial0.with(dateTimeFieldType0, (-1422));
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test6363() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(2629800000L, 2629800000L);
    partial0.isEqual(partial0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    int int0 = 20;
    Partial partial1 = partial0.withFieldAddWrapped(durationFieldType0, 0);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekyearOfCentury();
    partial0.with(dateTimeFieldType1, 20);
    partial1.with(dateTimeFieldType1, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test6565() throws Throwable {
    LocalDateTime localDateTime0 = new LocalDateTime();
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFieldType.dayOfYear();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    partial0.with(dateTimeFieldType0, 2307);
}",""
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test6666() throws Throwable {
    long long0 = 1017L;
    System.setCurrentTimeMillis(1017L);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[3];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.year();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    DateTimeFieldType dateTimeFieldType2 = DateTimeFieldType.dayOfMonth();
    dateTimeFieldTypeArray0[2] = dateTimeFieldType2;
    int[] intArray0 = new int[3];
    int int0 = 32;
    int int1 = (-1892);
    intArray0[1] = (-1892);
    int int2 = 1552;
    intArray0[2] = 1552;
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, buddhistChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: yearOfEra < year
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
