focal_method,test_prefix,docstring
"public abstract long set(long instant, int value);","public void test00() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeField dateTimeField0 = buddhistChronology0.era();
    DateTimeField dateTimeField1 = LenientDateTimeField.getInstance(dateTimeField0, buddhistChronology0);
    // Undeclared exception!
    try {
        dateTimeField1.set((long) 1, 1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // eras field is unsupported
        //
        verifyException(""org.joda.time.field.UnsupportedDurationField"", e);
    }
}","/**
 * Sets a value in the milliseconds supplied.
 * <p>
 * The value of this field will be set.
 * If the value is invalid, an exception if thrown.
 * <p>
 * If setting this field would make other fields invalid, then those fields
 * may be changed. For example if the current date is the 31st January, and
 * the month is set to February, the day would be invalid. Instead, the day
 * would be changed to the closest value - the 28th/29th February as appropriate.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
 * @param value  the value to set, in the units of the field
 * @return the updated milliseconds
 * @throws IllegalArgumentException if the value is invalid
 */"
"public static DateTimeField getInstance(DateTimeField field, Chronology base) {
    if (field == null) {
        return null;
    }
    if (field instanceof StrictDateTimeField) {
        field = ((StrictDateTimeField) field).getWrappedField();
    }
    if (field.isLenient()) {
        return field;
    }
    return new LenientDateTimeField(field, base);
}","public void test11() throws Throwable {
    DateTimeField dateTimeField0 = LenientDateTimeField.getInstance((DateTimeField) null, (Chronology) null);
    assertNull(dateTimeField0);
}","/**
 * Returns a lenient version of the given field. If it is already lenient,
 * then it is returned as-is. Otherwise, a new LenientDateTimeField is
 * returned.
 */"
"public static DateTimeField getInstance(DateTimeField field, Chronology base) {
    if (field == null) {
        return null;
    }
    if (field instanceof StrictDateTimeField) {
        field = ((StrictDateTimeField) field).getWrappedField();
    }
    if (field.isLenient()) {
        return field;
    }
    return new LenientDateTimeField(field, base);
}","public void test22() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeField dateTimeField0 = buddhistChronology0.halfdayOfDay();
    LenientDateTimeField lenientDateTimeField0 = new LenientDateTimeField(dateTimeField0, buddhistChronology0);
    StrictDateTimeField strictDateTimeField0 = new StrictDateTimeField(lenientDateTimeField0);
    DateTimeField dateTimeField1 = LenientDateTimeField.getInstance(strictDateTimeField0, buddhistChronology0);
    assertSame(dateTimeField1, lenientDateTimeField0);
}","/**
 * Returns a lenient version of the given field. If it is already lenient,
 * then it is returned as-is. Otherwise, a new LenientDateTimeField is
 * returned.
 */"
