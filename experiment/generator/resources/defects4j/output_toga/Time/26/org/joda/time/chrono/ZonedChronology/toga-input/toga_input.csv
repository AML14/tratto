focal_method,test_prefix,docstring
"public abstract long remainder(long instant);","public void test011() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.centuryOfEra();
    long long0 = dateTimeField0.remainder(1);
    assertEquals(3660001L, long0);
}","/**
 * Returns the fractional duration milliseconds of this field. In other
 * words, calling remainder returns the duration that roundFloor would
 * subtract.
 * <p>
 * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
 * hour is 34 minutes and 56.789 seconds.
 *
 * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the
 * remainder
 * @return remainder duration, in milliseconds
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test022() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateMidnight dateMidnight0 = new DateMidnight((-2760L), dateTimeZone0);
    assertEquals((-57600000L), dateMidnight0.getMillis());
}",""
"public abstract int getDifference(long minuendInstant, long subtrahendInstant);","public void test033() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.forID(""Asia/Shanghai"");
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.secondOfMinute();
    int int0 = dateTimeField0.getDifference(0L, 60000L);
    assertEquals((-60), int0);
}","/**
 * Computes the difference between two instants, as measured in the units
 * of this field. Any fractional units are dropped from the result. Calling
 * getDifference reverses the effect of calling add. In the following code:
 *
 * <pre>
 * long instant = ...
 * int v = ...
 * int age = getDifference(add(instant, v), instant);
 * </pre>
 *
 * The value 'age' is the same as the value 'v'.
 *
 * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract from
 * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract off the minuend
 * @return the difference in the units of this field
 */"
"public abstract long add(long instant, long value);","public void test066() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""@LNr`+O6Q$"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gregorianChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.weekOfWeekyear();
    long long0 = dateTimeField0.add(0L, (long) 3);
    assertEquals(1814400000L, long0);
}","/**
 * Adds a value (which may be negative) to the millis value,
 * overflowing into larger fields if necessary.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the long value to add, in the units of the field
 * @return the updated milliseconds
 * @throws IllegalArgumentException if value is too large
 * @see #add(long,int)
 */"
"public abstract String getAsShortText(long instant, Locale locale);","public void test088() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.forID(""Asia/Shanghai"");
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.secondOfMinute();
    Locale locale0 = Locale.CHINESE;
    String string0 = dateTimeField0.getAsShortText((long) 1, locale0);
    assertEquals(""0"", string0);
}","/**
 * Get the human-readable, short text value of this field from the
 * milliseconds.  If the specified locale is null, the default locale is used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
 * @param locale the locale to use for selecting a text symbol, null for default
 * @return the short text value of the field
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the values of a period from an interval.
 *
 * @param period  the period instant to use
 * @param startInstant  the start instant of an interval to query
 * @param endInstant  the start instant of an interval to query
 * @return the values of the period extracted from the interval
 */
public int[] get(ReadablePeriod period, long startInstant, long endInstant) {
    int size = period.size();
    int[] values = new int[size];
    if (startInstant != endInstant) {
        for (int i = 0; i < size; i++) {
            DurationField field = period.getFieldType(i).getField(this);
            int value = field.getDifference(endInstant, startInstant);
            startInstant = field.add(startInstant, value);
            values[i] = value;
        }
    }
    return values;
}","public void test099() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    LocalTime localTime0 = new LocalTime((Chronology) julianChronology0);
    Period period0 = new Period(localTime0, localTime0);
    int[] intArray0 = zonedChronology0.get((ReadablePeriod) period0, (-18L), (-1L));
    assertArrayEquals(new int[] { 0, 0, 0, 0, 0, 0, 0, 17 }, intArray0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the values of a period from an interval.
 *
 * @param period  the period instant to use
 * @param startInstant  the start instant of an interval to query
 * @param endInstant  the start instant of an interval to query
 * @return the values of the period extracted from the interval
 */
public int[] get(ReadablePeriod period, long startInstant, long endInstant) {
    int size = period.size();
    int[] values = new int[size];
    if (startInstant != endInstant) {
        for (int i = 0; i < size; i++) {
            DurationField field = period.getFieldType(i).getField(this);
            int value = field.getDifference(endInstant, startInstant);
            startInstant = field.add(startInstant, value);
            values[i] = value;
        }
    }
    return values;
}","public void test1010() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    LocalTime localTime0 = new LocalTime((Chronology) julianChronology0);
    Period period0 = new Period(localTime0, localTime0);
    int[] intArray0 = zonedChronology0.get((ReadablePeriod) period0, 1L, (-1L));
    assertArrayEquals(new int[] { 0, 0, 0, 0, 0, 0, 0, (-2) }, intArray0);
}",""
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test1111() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(julianChronology0, fixedDateTimeZone0);
    try {
        zonedChronology0.getDateTimeMillis(1, (-292275054), (-2303), 1, 0, (-292275054), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -292275054 for secondOfMinute must be in the range [0,59]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay));
}","public void test1212() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, fixedDateTimeZone0);
    try {
        zonedChronology0.getDateTimeMillis(5306, 0, 7, (-4616));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -4616 for millisOfDay must be in the range [0,86400000]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public abstract long set(long instant, int value);","public void test1313() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    long long0 = dateTimeField0.set(3214L, 1);
    assertEquals((-21599999L), long0);
}","/**
 * Sets a value in the milliseconds supplied.
 * <p>
 * The value of this field will be set.
 * If the value is invalid, an exception if thrown.
 * <p>
 * If setting this field would make other fields invalid, then those fields
 * may be changed. For example if the current date is the 31st January, and
 * the month is set to February, the day would be invalid. Instead, the day
 * would be changed to the closest value - the 28th/29th February as appropriate.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
 * @param value  the value to set, in the units of the field
 * @return the updated milliseconds
 * @throws IllegalArgumentException if the value is invalid
 */"
"public abstract boolean isPrecise();","public void test1414() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(2740);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DurationField durationField0 = zonedChronology0.minutes();
    boolean boolean0 = durationField0.isPrecise();
    assertTrue(boolean0);
}","/**
 * Is this field precise. A precise field can calculate its value from
 * milliseconds without needing a reference date. Put another way, a
 * precise field's unit size is not variable.
 *
 * @return true if precise
 * @see #getUnitMillis()
 */"
"public abstract int getDifference(long minuendInstant, long subtrahendInstant);","public void test1616() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gregorianChronology0, dateTimeZone0);
    DurationField durationField0 = zonedChronology0.years();
    int int0 = durationField0.getDifference(1, 0L);
    assertEquals(0, int0);
}","/**
 * Computes the difference between two instants, as measured in the units
 * of this field. Any fractional units are dropped from the result. Calling
 * getDifference reverses the effect of calling add. In the following code:
 *
 * <pre>
 * long instant = ...
 * int v = ...
 * int age = getDifference(add(instant, v), instant);
 * </pre>
 *
 * The value 'age' is the same as the value 'v'.
 *
 * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract from
 * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract off the minuend
 * @return the difference in the units of this field
 */"
"public abstract String getName();","public void test1919() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(886);
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(julianChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.hourOfHalfday();
    DurationField durationField0 = dateTimeField0.getRangeDurationField();
    assertEquals(""halfdays"", durationField0.getName());
}","/**
 * Get the name of the field.
 * <p>
 * By convention, names are plural.
 *
 * @return field name
 */"
"public abstract DurationField getRangeDurationField();","public void test1920() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(886);
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(julianChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.hourOfHalfday();
    DurationField durationField0 = dateTimeField0.getRangeDurationField();
    assertNotNull(durationField0);
}","/**
 * Returns the range duration of this field. For example, if this field
 * represents ""hour of day"", then the range duration is a day.
 *
 * @return the range duration of this field, or null if field has no range
 */"
"public abstract int getMinimumValue();","public void test2021() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    int int0 = dateTimeField0.getMinimumValue();
    assertEquals(1, int0);
}","/**
 * Get the minimum allowable value for this field.
 *
 * @return the minimum valid value for this field, in the units of the
 * field
 */"
"public abstract String getName();","public void test2122() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-1765));
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.secondOfMinute();
    DurationField durationField0 = dateTimeField0.getDurationField();
    assertEquals(""seconds"", durationField0.getName());
}","/**
 * Get the name of the field.
 * <p>
 * By convention, names are plural.
 *
 * @return field name
 */"
"// Extra information API
//------------------------------------------------------------------------
/**
 * Returns the duration per unit value of this field. For example, if this
 * field represents ""hour of day"", then the duration is an hour.
 *
 * @return the duration of this field, or UnsupportedDurationField if field
 * has no duration
 */
public abstract DurationField getDurationField();","public void test2123() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-1765));
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.secondOfMinute();
    DurationField durationField0 = dateTimeField0.getDurationField();
    assertNotNull(durationField0);
}",""
"static boolean useTimeArithmetic(DurationField field) {
    // Use time of day arithmetic rules for unit durations less than
    // typical time zone offsets.
    return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
}","public void test2325() throws Throwable {
    boolean boolean0 = ZonedChronology.useTimeArithmetic((DurationField) null);
    assertFalse(boolean0);
}",""
"public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test2426() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, fixedDateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis(1660L, 0, 0, 0, 0);
    assertEquals(0L, long0);
}",""
"public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test2527() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gregorianChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone((TimeZone) null);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(lenientChronology0, dateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis(3155760000000L, 2147483061, (-1882), (-1529), (-1529));
    assertEquals(7734094603949471L, long0);
}",""
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test2628() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis(1, 1, 1, 0, 1, 1, 0);
    assertEquals((-42521522339000L), long0);
}",""
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay));
}","public void test2729() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone((TimeZone) null);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(buddhistChronology0, dateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis(3864, 1, 1, 0);
    assertEquals(42633504000000L, long0);
}",""
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay));
}","public void test2830() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(lenientChronology0, dateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis(1, 1, 1, 1073741824);
    assertEquals((-42520513458176L), long0);
}",""
"public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test2931() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    try {
        zonedChronology0.getDateTimeMillis((long) 1, 4100, 0, 1, (-2673));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 4100 for hourOfDay must be in the range [0,23]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public abstract long roundHalfFloor(long instant);","public void test3032() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    long long0 = dateTimeField0.roundHalfFloor(10L);
    assertEquals(10L, long0);
}","/**
 * Round to the nearest whole unit of this field. If the given millisecond
 * value is closer to the floor or is exactly halfway, this function
 * behaves like roundFloor. If the millisecond value is closer to the
 * ceiling, this function behaves like roundCeiling.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
 * @return rounded milliseconds
 */"
"// Calculation API
//------------------------------------------------------------------------
/**
 * Round to the lowest whole unit of this field. After rounding, the value
 * of this field and all fields of a higher magnitude are retained. The
 * fractional millis that cannot be expressed in whole increments of this
 * field are set to minimum.
 * <p>
 * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
 * lowest whole hour is 2002-11-02T23:00:00.000.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
 * @return rounded milliseconds
 */
public abstract long roundFloor(long instant);","public void test3133() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    DateTimeZone dateTimeZone0 = DateTimeZone.forID(""Asia/Shanghai"");
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.secondOfMinute();
    long long0 = dateTimeField0.roundFloor(1);
    assertEquals(0L, long0);
}",""
"public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);","public void test3234() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    long long0 = dateTimeField0.getDifferenceAsLong(0L, 1107L);
    assertEquals((-1107L), long0);
}","/**
 * Computes the difference between two instants, as measured in the units
 * of this field. Any fractional units are dropped from the result. Calling
 * getDifference reverses the effect of calling add. In the following code:
 *
 * <pre>
 * long instant = ...
 * long v = ...
 * long age = getDifferenceAsLong(add(instant, v), instant);
 * </pre>
 *
 * The value 'age' is the same as the value 'v'.
 *
 * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract from
 * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract off the minuend
 * @return the difference in the units of this field
 */"
"public abstract int getDifference(long minuendInstant, long subtrahendInstant);","public void test3335() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    int int0 = dateTimeField0.getDifference(0, 30);
    assertEquals(0, int0);
}","/**
 * Computes the difference between two instants, as measured in the units
 * of this field. Any fractional units are dropped from the result. Calling
 * getDifference reverses the effect of calling add. In the following code:
 *
 * <pre>
 * long instant = ...
 * int v = ...
 * int age = getDifference(add(instant, v), instant);
 * </pre>
 *
 * The value 'age' is the same as the value 'v'.
 *
 * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract from
 * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract off the minuend
 * @return the difference in the units of this field
 */"
"public Chronology withUTC() {
    return getBase();
}","public void test3537() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_15_BASED;
    IslamicChronology islamicChronology0 = new IslamicChronology(gregorianChronology0, gregorianChronology0, islamicChronology_LeapYearPatternType0);
    StrictChronology strictChronology0 = StrictChronology.getInstance(islamicChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(strictChronology0, dateTimeZone0);
    Chronology chronology0 = zonedChronology0.withUTC();
    assertSame(chronology0, strictChronology0);
}",""
"public DateTimeZone getZone() {
    return (DateTimeZone) getParam();
}","public void test3638() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_15_BASED;
    IslamicChronology islamicChronology0 = new IslamicChronology(gregorianChronology0, gregorianChronology0, islamicChronology_LeapYearPatternType0);
    StrictChronology strictChronology0 = StrictChronology.getInstance(islamicChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(strictChronology0, dateTimeZone0);
    DateTimeZone dateTimeZone1 = zonedChronology0.getZone();
    assertSame(dateTimeZone0, dateTimeZone1);
}",""
"public abstract long addWrapField(long instant, int value);","public void test3941() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    long long0 = dateTimeField0.addWrapField(10L, 1);
    assertEquals(11L, long0);
}","/**
 * Adds a value (which may be negative) to the millis value,
 * wrapping within this field.
 * <p>
 * The value will be added to this field. If the value is too large to be
 * added solely to this field then it wraps. Larger fields are always
 * unaffected. Smaller fields should be unaffected, except where the
 * result would be an invalid value for a smaller field. In this case the
 * smaller field is adjusted to be in range.
 * <p>
 * For example, in the ISO chronology:<br>
 * 2000-08-20 addWrapField six months is 2000-02-20<br>
 * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
 * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
 * 2001-01-31 addWrapField one month  is 2001-02-28<br>
 * 2001-01-31 addWrapField two months is 2001-03-31<br>
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the value to add, in the units of the field
 * @return the updated milliseconds
 */"
"public abstract long addWrapField(long instant, int value);","public void test4042() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(23118750);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gJChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.monthOfYear();
    long long0 = dateTimeField0.addWrapField((long) 23118750, 23118750);
    assertEquals(15661518750L, long0);
}","/**
 * Adds a value (which may be negative) to the millis value,
 * wrapping within this field.
 * <p>
 * The value will be added to this field. If the value is too large to be
 * added solely to this field then it wraps. Larger fields are always
 * unaffected. Smaller fields should be unaffected, except where the
 * result would be an invalid value for a smaller field. In this case the
 * smaller field is adjusted to be in range.
 * <p>
 * For example, in the ISO chronology:<br>
 * 2000-08-20 addWrapField six months is 2000-02-20<br>
 * 2000-08-20 addWrapField twenty months is 2000-04-20<br>
 * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>
 * 2001-01-31 addWrapField one month  is 2001-02-28<br>
 * 2001-01-31 addWrapField two months is 2001-03-31<br>
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the value to add, in the units of the field
 * @return the updated milliseconds
 */"
"public abstract long add(long instant, int value);","public void test4143() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    long long0 = dateTimeField0.add(1000L, 4);
    assertEquals(1004L, long0);
}","/**
 * Adds a value (which may be negative) to the millis value,
 * overflowing into larger fields if necessary.
 * <p>
 * The value will be added to this field. If the value is too large to be
 * added solely to this field, larger fields will increase as required.
 * Smaller fields should be unaffected, except where the result would be
 * an invalid value for a smaller field. In this case the smaller field is
 * adjusted to be in range.
 * <p>
 * For example, in the ISO chronology:<br>
 * 2000-08-20 add six months is 2001-02-20<br>
 * 2000-08-20 add twenty months is 2002-04-20<br>
 * 2000-08-20 add minus nine months is 1999-11-20<br>
 * 2001-01-31 add one month  is 2001-02-28<br>
 * 2001-01-31 add two months is 2001-03-31<br>
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the value to add, in the units of the field
 * @return the updated milliseconds
 */"
"public abstract long add(long instant, int value);","public void test4244() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.centuryOfEra();
    long long0 = dateTimeField0.add((long) 0, 0);
    assertEquals(0L, long0);
}","/**
 * Adds a value (which may be negative) to the millis value,
 * overflowing into larger fields if necessary.
 * <p>
 * The value will be added to this field. If the value is too large to be
 * added solely to this field, larger fields will increase as required.
 * Smaller fields should be unaffected, except where the result would be
 * an invalid value for a smaller field. In this case the smaller field is
 * adjusted to be in range.
 * <p>
 * For example, in the ISO chronology:<br>
 * 2000-08-20 add six months is 2001-02-20<br>
 * 2000-08-20 add twenty months is 2002-04-20<br>
 * 2000-08-20 add minus nine months is 1999-11-20<br>
 * 2001-01-31 add one month  is 2001-02-28<br>
 * 2001-01-31 add two months is 2001-03-31<br>
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the value to add, in the units of the field
 * @return the updated milliseconds
 */"
"public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);","public void test4547() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, fixedDateTimeZone0);
    DurationField durationField0 = zonedChronology0.centuries();
    long long0 = durationField0.getDifferenceAsLong(0L, (-1278L));
    assertEquals(0L, long0);
}","/**
 * Computes the difference between two instants, as measured in the units
 * of this field. Any fractional units are dropped from the result. Calling
 * getDifference reverses the effect of calling add. In the following code:
 *
 * <pre>
 * long instant = ...
 * long v = ...
 * long age = getDifferenceAsLong(add(instant, v), instant);
 * </pre>
 *
 * The value 'age' is the same as the value 'v'.
 *
 * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract from
 * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
 * subtract off the minuend
 * @return the difference in the units of this field
 */"
"public long add(ReadablePeriod period, long instant, int scalar) {
    if (scalar != 0 && period != null) {
        for (int i = 0, isize = period.size(); i < isize; i++) {
            // use long to allow for multiplication (fits OK)
            long value = period.getValue(i);
            if (value != 0) {
                instant = period.getFieldType(i).getField(this).add(instant, value * scalar);
            }
        }
    }
    return instant;
}","public void test4648() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, fixedDateTimeZone0);
    Weeks weeks0 = Weeks.weeks(2515);
    Duration duration0 = weeks0.toStandardDuration();
    Period period0 = duration0.toPeriod();
    long long0 = zonedChronology0.add((ReadablePeriod) period0, 0L, 1427);
    assertEquals(2170569744000000L, long0);
}","/**
 * Adds the period to the instant, specifying the number of times to add.
 *
 * @param period  the period to add, null means add nothing
 * @param instant  the instant to add to
 * @param scalar  the number of times to add
 * @return the updated instant
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test4749() throws Throwable {
    Weeks weeks0 = Weeks.weeks(2515);
    PeriodType periodType0 = weeks0.getPeriodType();
    Period period0 = new Period(0L, 816L, periodType0);
    assertEquals(1, period0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * A zoned chronology is only equal to a zoned chronology with the
 * same base chronology and zone.
 *
 * @param obj  the object to compare to
 * @return true if equal
 * @since 1.4
 */
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof ZonedChronology == false) {
        return false;
    }
    ZonedChronology chrono = (ZonedChronology) obj;
    return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone());
}","public void test4951() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_15_BASED;
    IslamicChronology islamicChronology0 = new IslamicChronology(gregorianChronology0, gregorianChronology0, islamicChronology_LeapYearPatternType0);
    StrictChronology strictChronology0 = StrictChronology.getInstance(islamicChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(strictChronology0, dateTimeZone0);
    boolean boolean0 = zonedChronology0.equals((Object) null);
    assertFalse(boolean0);
}",""
"protected void assemble(Fields fields) {
    // Keep a local cache of converted fields so as not to create redundant
    // objects.
    HashMap<Object, Object> converted = new HashMap<Object, Object>();
    // Convert duration fields...
    fields.eras = convertField(fields.eras, converted);
    fields.centuries = convertField(fields.centuries, converted);
    fields.years = convertField(fields.years, converted);
    fields.months = convertField(fields.months, converted);
    fields.weekyears = convertField(fields.weekyears, converted);
    fields.weeks = convertField(fields.weeks, converted);
    fields.days = convertField(fields.days, converted);
    fields.halfdays = convertField(fields.halfdays, converted);
    fields.hours = convertField(fields.hours, converted);
    fields.minutes = convertField(fields.minutes, converted);
    fields.seconds = convertField(fields.seconds, converted);
    fields.millis = convertField(fields.millis, converted);
    // Convert datetime fields...
    fields.year = convertField(fields.year, converted);
    fields.yearOfEra = convertField(fields.yearOfEra, converted);
    fields.yearOfCentury = convertField(fields.yearOfCentury, converted);
    fields.centuryOfEra = convertField(fields.centuryOfEra, converted);
    fields.era = convertField(fields.era, converted);
    fields.dayOfWeek = convertField(fields.dayOfWeek, converted);
    fields.dayOfMonth = convertField(fields.dayOfMonth, converted);
    fields.dayOfYear = convertField(fields.dayOfYear, converted);
    fields.monthOfYear = convertField(fields.monthOfYear, converted);
    fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);
    fields.weekyear = convertField(fields.weekyear, converted);
    fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);
    fields.millisOfSecond = convertField(fields.millisOfSecond, converted);
    fields.millisOfDay = convertField(fields.millisOfDay, converted);
    fields.secondOfMinute = convertField(fields.secondOfMinute, converted);
    fields.secondOfDay = convertField(fields.secondOfDay, converted);
    fields.minuteOfHour = convertField(fields.minuteOfHour, converted);
    fields.minuteOfDay = convertField(fields.minuteOfDay, converted);
    fields.hourOfDay = convertField(fields.hourOfDay, converted);
    fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);
    fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);
    fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);
    fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);
}","public void test5052() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(buddhistChronology0, dateTimeZone0);
    AssembledChronology.Fields assembledChronology_Fields0 = new AssembledChronology.Fields();
    zonedChronology0.assemble(assembledChronology_Fields0);
}",""
"public abstract Chronology withZone(DateTimeZone zone);","public void test5153() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, dateTimeZone0);
    Chronology chronology0 = zonedChronology0.withZone((DateTimeZone) null);
    chronology0.withZone(dateTimeZone0);
    assertNotSame(chronology0, zonedChronology0);
}","/**
 * Returns an instance of this Chronology that operates in any time zone.
 *
 * @return a version of this chronology with a specific time zone
 * @param zone to use, or default if null
 * @see org.joda.time.chrono.ZonedChronology
 */"
"public Chronology withZone(DateTimeZone zone) {
    if (zone == null) {
        zone = DateTimeZone.getDefault();
    }
    if (zone == getParam()) {
        return this;
    }
    if (zone == DateTimeZone.UTC) {
        return getBase();
    }
    return new ZonedChronology(getBase(), zone);
}","public void test5254() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    Chronology chronology0 = zonedChronology0.withZone(dateTimeZone0);
    assertSame(chronology0, zonedChronology0);
}",""
"public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {
    if (base == null) {
        throw new IllegalArgumentException(""Must supply a chronology"");
    }
    base = base.withUTC();
    if (base == null) {
        throw new IllegalArgumentException(""UTC chronology must not be null"");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""DateTimeZone must not be null"");
    }
    return new ZonedChronology(base, zone);
}","public void test5355() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    // Undeclared exception!
    try {
        ZonedChronology.getInstance((Chronology) null, dateTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must supply a chronology
        //
        verifyException(""org.joda.time.chrono.ZonedChronology"", e);
    }
}","/**
 * Create a ZonedChronology for any chronology, overriding any time zone it
 * may already have.
 *
 * @param base base chronology to wrap
 * @param zone the time zone
 * @throws IllegalArgumentException if chronology or time zone is null
 */"
"public abstract long getMillis(int value, long instant);","public void test5557() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(buddhistChronology0, dateTimeZone0);
    DurationField durationField0 = zonedChronology0.years();
    long long0 = durationField0.getMillis((-302), 43200000L);
    assertEquals((-9530179200000L), long0);
}","/**
 * Get the millisecond duration of this field from its value relative to an
 * instant. For precise fields this method produces the same result as for
 * the single argument getMillis method.
 * <p>
 * If the value is positive, then the instant is treated as a ""start
 * instant"". If negative, the instant is treated as an ""end instant"".
 *
 * @param value  the value of the field, which may be negative
 * @param instant  the instant to calculate relative to
 * @return the millisecond duration that the field represents, which may be
 * negative
 */"
"public abstract long getMillis(long value, long instant);","public void test5658() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_15_BASED;
    IslamicChronology islamicChronology0 = new IslamicChronology(gregorianChronology0, gregorianChronology0, islamicChronology_LeapYearPatternType0);
    StrictChronology strictChronology0 = StrictChronology.getInstance(islamicChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(strictChronology0, dateTimeZone0);
    DurationField durationField0 = zonedChronology0.halfdays();
    long long0 = durationField0.getMillis(103507202396L, (long) 1);
    assertEquals(4471511143507200000L, long0);
}","/**
 * Get the millisecond duration of this field from its value relative to an
 * instant. For precise fields this method produces the same result as for
 * the single argument getMillis method.
 * <p>
 * If the value is positive, then the instant is treated as a ""start
 * instant"". If negative, the instant is treated as an ""end instant"".
 *
 * @param value  the value of the field, which may be negative
 * @param instant  the instant to calculate relative to
 * @return the millisecond duration that the field represents, which may be
 * negative
 */"
"public abstract int getMinimumValue(ReadablePartial instant, int[] values);","public void test6062() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.minuteOfHour();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null);
    int[] intArray0 = new int[4];
    int int0 = dateTimeField0.getMinimumValue((ReadablePartial) localDateTime0, intArray0);
    assertEquals(0, int0);
}","/**
 * Get the minimum value for this field using the partial instant and
 * the specified values.
 *
 * @param instant  the partial instant to query
 * @param values  the values to use
 * @return the minimum value for this field, in the units of the field
 */"
"public abstract String getAsText(long instant, Locale locale);","public void test6163() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.minuteOfHour();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = dateTimeField0.getAsText(1000000L, locale0);
    assertEquals(""16"", string0);
}","/**
 * Get the human-readable, text value of this field from the milliseconds.
 * If the specified locale is null, the default locale is used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
 * @param locale the locale to use for selecting a text symbol, null for default
 * @return the text value of the field
 */"
"public abstract long set(long instant, String text, Locale locale);","public void test6264() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, fixedDateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.year();
    Locale locale0 = Locale.KOREA;
    long long0 = dateTimeField0.set((long) 1, ""7"", locale0);
    assertEquals((-52985231999999L), long0);
}","/**
 * Sets a value in the milliseconds supplied from a human-readable, text value.
 * If the specified locale is null, the default locale is used.
 * <p>
 * If setting this field would make other fields invalid, then those fields
 * may be changed. For example if the current date is the 31st January, and
 * the month is set to February, the day would be invalid. Instead, the day
 * would be changed to the closest value - the 28th/29th February as appropriate.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
 * @param text  the text value to set
 * @param locale the locale to use for selecting a text symbol, null for default
 * @return the updated milliseconds
 * @throws IllegalArgumentException if the text value is invalid
 */"
"public abstract int getMaximumValue(ReadablePartial instant, int[] values);","public void test6365() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.centuryOfEra();
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    LocalTime localTime0 = new LocalTime((Chronology) julianChronology0);
    int[] intArray0 = new int[2];
    int int0 = dateTimeField0.getMaximumValue((ReadablePartial) localTime0, intArray0);
    assertEquals(2922730, int0);
}","/**
 * Get the maximum value for this field using the partial instant and
 * the specified values.
 *
 * @param instant  the partial instant to query
 * @param values  the values to use
 * @return the maximum value for this field, in the units of the field
 */"
"public abstract int getMaximumValue(ReadablePartial instant);","public void test6466() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    LocalTime localTime0 = new LocalTime(dateTimeZone0);
    int int0 = dateTimeField0.getMaximumValue((ReadablePartial) localTime0);
    assertEquals(30, int0);
}","/**
 * Get the maximum value for this field evaluated at the specified time.
 *
 * @param instant  the partial instant to query
 * @return the maximum value for this field, in the units of the field
 */"
"public abstract int getMinimumValue(long instant);","public void test6567() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.millisOfDay();
    int int0 = dateTimeField0.getMinimumValue((long) 1);
    assertEquals(0, int0);
}","/**
 * Get the minimum value for this field evaluated at the specified time.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
 * @return the minimum value for this field, in the units of the field
 */"
"public DurationField getLeapDurationField() {
    return iField.getLeapDurationField();
}","public void test6668() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gJChronology0, fixedDateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.yearOfCentury();
    SkipDateTimeField skipDateTimeField0 = new SkipDateTimeField(gJChronology0, dateTimeField0);
    DurationField durationField0 = skipDateTimeField0.getLeapDurationField();
    assertNull(durationField0);
}",""
"public DurationField getDurationField() {
    return iField.getDurationField();
}","public void test6769() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    GJYearOfEraDateTimeField gJYearOfEraDateTimeField0 = new GJYearOfEraDateTimeField(dateTimeField0, copticChronology0);
    DurationField durationField0 = gJYearOfEraDateTimeField0.getDurationField();
    assertNotNull(durationField0);
}",""
"public abstract long add(long instant, int value);","public void test6770() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    GJYearOfEraDateTimeField gJYearOfEraDateTimeField0 = new GJYearOfEraDateTimeField(dateTimeField0, copticChronology0);
    DurationField durationField0 = gJYearOfEraDateTimeField0.getDurationField();
    long long0 = durationField0.add((long) 30, 1);
    assertEquals(86400030L, long0);
}","/**
 * Adds a duration value (which may be negative) to the instant.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
 * @param value  the value to add, in the units of the field
 * @return the updated milliseconds
 */"
"public abstract int getLeapAmount(long instant);","public void test6972() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.centuryOfEra();
    int int0 = dateTimeField0.getLeapAmount(0);
    assertEquals(0, int0);
}","/**
 * Gets the amount by which this field is 'leap' for the specified instant.
 * <p>
 * For example, a leap year would return one, a non leap year would return
 * zero.
 *
 * @param instant  the instant to check for leap status
 * @return the amount, in units of the leap duration field, that the field is leap
 */"
"public abstract boolean isLenient();","public void test7073() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.centuryOfEra();
    boolean boolean0 = dateTimeField0.isLenient();
    assertFalse(boolean0);
}","/**
 * Returns true if the set method is lenient. If so, it accepts values that
 * are out of bounds. For example, a lenient day of month field accepts 32
 * for January, converting it to February 1.
 *
 * @return true if this field is lenient
 */"
"static boolean useTimeArithmetic(DurationField field) {
    // Use time of day arithmetic rules for unit durations less than
    // typical time zone offsets.
    return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
}","public void test7275() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.minuteOfHour();
    SkipDateTimeField skipDateTimeField0 = new SkipDateTimeField(zonedChronology0, dateTimeField0, 0);
    DurationField durationField0 = skipDateTimeField0.getRangeDurationField();
    boolean boolean0 = ZonedChronology.useTimeArithmetic(durationField0);
    assertTrue(boolean0);
}",""
"public abstract String getName();","public void test7276() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.minuteOfHour();
    SkipDateTimeField skipDateTimeField0 = new SkipDateTimeField(zonedChronology0, dateTimeField0, 0);
    DurationField durationField0 = skipDateTimeField0.getRangeDurationField();
    boolean boolean0 = ZonedChronology.useTimeArithmetic(durationField0);
    assertEquals(""hours"", durationField0.getName());
}","/**
 * Get the name of the field.
 * <p>
 * By convention, names are plural.
 *
 * @return field name
 */"
"public abstract String getAsText(int fieldValue, Locale locale);","public void test7377() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    TimeZone timeZone0 = TimeZone.getTimeZone(""]H(%=&g"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(copticChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.dayOfMonth();
    Locale locale0 = Locale.GERMANY;
    String string0 = dateTimeField0.getAsText(0, locale0);
    assertEquals(""0"", string0);
}","/**
 * Get the human-readable, text value of this field from the field value.
 * If the specified locale is null, the default locale is used.
 *
 * @param fieldValue  the numeric value to convert to text
 * @param locale the locale to use for selecting a text symbol, null for default
 * @return the text value of the field
 */"
"public abstract int getMaximumValue();","public void test7478() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gJChronology0, fixedDateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.yearOfCentury();
    int int0 = dateTimeField0.getMaximumValue();
    assertEquals(100, int0);
}","/**
 * Get the maximum allowable value for this field.
 *
 * @return the maximum valid value for this field, in the units of the
 * field
 */"
"public abstract boolean isLeap(long instant);","public void test7579() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    DateTimeField dateTimeField0 = zonedChronology0.minuteOfHour();
    boolean boolean0 = dateTimeField0.isLeap(0);
    assertFalse(boolean0);
}","/**
 * Returns whether this field is 'leap' for the specified instant.
 * <p>
 * For example, a leap year would return true, a non leap year would return
 * false.
 *
 * @param instant  the instant to check for leap status
 * @return true if the field is 'leap'
 */"
"public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test7680() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(islamicChronology0, dateTimeZone0);
    long long0 = zonedChronology0.getDateTimeMillis((long) 1, 0, 0, 1, 0);
    assertEquals((-57599000L), long0);
}",""
"public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {
    if (base == null) {
        throw new IllegalArgumentException(""Must supply a chronology"");
    }
    base = base.withUTC();
    if (base == null) {
        throw new IllegalArgumentException(""UTC chronology must not be null"");
    }
    if (zone == null) {
        throw new IllegalArgumentException(""DateTimeZone must not be null"");
    }
    return new ZonedChronology(base, zone);
}","public void test7781() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gregorianChronology0, dateTimeZone0);
    // Undeclared exception!
    try {
        ZonedChronology.getInstance(zonedChronology0, (DateTimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DateTimeZone must not be null
        //
        verifyException(""org.joda.time.chrono.ZonedChronology"", e);
    }
}","/**
 * Create a ZonedChronology for any chronology, overriding any time zone it
 * may already have.
 *
 * @param base base chronology to wrap
 * @param zone the time zone
 * @throws IllegalArgumentException if chronology or time zone is null
 */"
"public int hashCode() {
    return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;
}","public void test7882() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(gregorianChronology0, dateTimeZone0);
    zonedChronology0.hashCode();
}","/**
 * A suitable hashcode for the chronology.
 *
 * @return the hashcode
 * @since 1.4
 */"
"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {
    return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
}","public void test7983() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(ethiopicChronology0, dateTimeZone0);
    try {
        zonedChronology0.getDateTimeMillis(292272708, 1000, 292272708, 0, 292272708, 3122, 1000);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 292272708 for minuteOfHour must be in the range [0,59]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public String toString() {
    return ""ZonedChronology["" + getBase() + "", "" + getZone().getID() + ']';
}","public void test8084() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(buddhistChronology0, dateTimeZone0);
    String string0 = zonedChronology0.toString();
    assertEquals(""ZonedChronology[BuddhistChronology[UTC], America/Los_Angeles]"", string0);
}","/**
 * A debugging string for the chronology.
 *
 * @return the debugging string
 */"
