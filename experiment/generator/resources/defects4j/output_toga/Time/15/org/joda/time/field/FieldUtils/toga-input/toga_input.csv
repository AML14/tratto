focal_method,test_prefix,docstring
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test000() throws Throwable {
    int int0 = FieldUtils.getWrappedValue((-2206), (-1), 1);
    assertEquals((-1), int0);
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) {
    return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
}","public void test011() throws Throwable {
    int int0 = FieldUtils.getWrappedValue(0, 0, Integer.MIN_VALUE, 0);
    assertEquals(2, int0);
}","/**
 * Utility method used by addWrapField implementations to ensure the new
 * value lies within the field's legal value range.
 *
 * @param currentValue the current value of the data, which may lie outside
 * the wrapped value range
 * @param wrapValue  the value to add to current value before
 *  wrapping.  This may be negative.
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) {
    return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
}","public void test022() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.getWrappedValue(3912, 3349, 3912, 3349);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MIN > MAX
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Utility method used by addWrapField implementations to ensure the new
 * value lies within the field's legal value range.
 *
 * @param currentValue the current value of the data, which may lie outside
 * the wrapped value range
 * @param wrapValue  the value to add to current value before
 *  wrapping.  This may be negative.
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test033() throws Throwable {
    FieldUtils.verifyValueBounds(""Multiplication overflows an int: "", 3349, 3349, 3912);
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */"
"public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test044() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds(""*<"", 3566, (-495), (-495));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 3566 for *< must be in the range [-495,-495]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */"
"public String toString() {
    return getName();
}","public void test055() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    FieldUtils.verifyValueBounds(dateTimeFieldType0, 0, 0, 2022);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test066() throws Throwable {
    FieldUtils.verifyValueBounds((DateTimeField) null, Integer.MIN_VALUE, Integer.MIN_VALUE, (-1));
}",""
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test077() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply(1605L, 10000000000000000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: 1605 * 10000000000000000
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test088() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply((-9223372036854775808L), (-851));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: -9223372036854775808 * -851
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static int safeMultiply(int val1, int val2) {
    long total = (long) val1 * (long) val2;
    if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Multiplication overflows an int: "" + val1 + "" * "" + val2);
    }
    return (int) total;
}","public void test099() throws Throwable {
    int int0 = FieldUtils.safeMultiply((-1), (-2147483647));
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static int safeMultiply(int val1, int val2) {
    long total = (long) val1 * (long) val2;
    if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Multiplication overflows an int: "" + val1 + "" * "" + val2);
    }
    return (int) total;
}","public void test1010() throws Throwable {
    int int0 = FieldUtils.safeMultiply(1, Integer.MIN_VALUE);
    assertEquals(Integer.MIN_VALUE, int0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static long safeSubtract(long val1, long val2) {
    long diff = val1 - val2;
    // If there is a sign change, but the two values have different signs...
    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" - "" + val2);
    }
    return diff;
}","public void test1111() throws Throwable {
    long long0 = FieldUtils.safeSubtract((-861L), (-861L));
    assertEquals(0L, long0);
}","/**
 * Subtracts two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value, to be taken away from
 * @param val2  the second value, the amount to take away
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeAdd(long val1, long val2) {
    long sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test1212() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeAdd((-9223372036854775808L), (-9223372036854775808L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: -9223372036854775808 + -9223372036854775808
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeAdd(int val1, int val2) {
    int sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test1313() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeAdd((-200), Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: -200 + -2147483648
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeToInt(long value) {
    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
        return (int) value;
    }
    throw new ArithmeticException(""Value cannot fit in an int: "" + value);
}","public void test1414() throws Throwable {
    int int0 = FieldUtils.safeToInt(0L);
    assertEquals(0, int0);
}","/**
 * Casts to an int throwing an exception if overflow occurs.
 *
 * @param value  the value
 * @return the value as an int
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeToInt(long value) {
    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
        return (int) value;
    }
    throw new ArithmeticException(""Value cannot fit in an int: "" + value);
}","public void test1515() throws Throwable {
    int int0 = FieldUtils.safeToInt((-2147483648L));
    assertEquals(Integer.MIN_VALUE, int0);
}","/**
 * Casts to an int throwing an exception if overflow occurs.
 *
 * @param value  the value
 * @return the value as an int
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeSubtract(long val1, long val2) {
    long diff = val1 - val2;
    // If there is a sign change, but the two values have different signs...
    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" - "" + val2);
    }
    return diff;
}","public void test1616() throws Throwable {
    long long0 = FieldUtils.safeSubtract(0L, 0L);
    assertEquals(0L, long0);
}","/**
 * Subtracts two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value, to be taken away from
 * @param val2  the second value, the amount to take away
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"//------------------------------------------------------------------------
/**
 * Negates the input throwing an exception if it can't negate it.
 *
 * @param value  the value to negate
 * @return the negated value
 * @throws ArithmeticException if the value is Integer.MIN_VALUE
 * @since 1.1
 */
public static int safeNegate(int value) {
    if (value == Integer.MIN_VALUE) {
        throw new ArithmeticException(""Integer.MIN_VALUE cannot be negated"");
    }
    return -value;
}","public void test1717() throws Throwable {
    int int0 = FieldUtils.safeNegate((-1126));
    assertEquals(1126, int0);
}",""
"//------------------------------------------------------------------------
/**
 * Negates the input throwing an exception if it can't negate it.
 *
 * @param value  the value to negate
 * @return the negated value
 * @throws ArithmeticException if the value is Integer.MIN_VALUE
 * @since 1.1
 */
public static int safeNegate(int value) {
    if (value == Integer.MIN_VALUE) {
        throw new ArithmeticException(""Integer.MIN_VALUE cannot be negated"");
    }
    return -value;
}","public void test1818() throws Throwable {
    int int0 = FieldUtils.safeNegate(231);
    assertEquals((-231), int0);
}",""
"public static int safeMultiplyToInt(long val1, long val2) {
    long val = FieldUtils.safeMultiply(val1, val2);
    return FieldUtils.safeToInt(val);
}","public void test1919() throws Throwable {
    int int0 = FieldUtils.safeMultiplyToInt(0L, 0L);
    assertEquals(0, int0);
}","/**
 * Multiply two values to return an int throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeMultiplyToInt(long val1, long val2) {
    long val = FieldUtils.safeMultiply(val1, val2);
    return FieldUtils.safeToInt(val);
}","public void test2020() throws Throwable {
    int int0 = FieldUtils.safeMultiplyToInt((-1440L), 2856L);
    assertEquals((-4112640), int0);
}","/**
 * Multiply two values to return an int throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test2121() throws Throwable {
    long long0 = FieldUtils.safeMultiply(63L, (long) (-2206));
    assertEquals((-138978L), long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test2222() throws Throwable {
    long long0 = FieldUtils.safeMultiply((-1L), 2031);
    assertEquals((-2031L), long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static int safeMultiply(int val1, int val2) {
    long total = (long) val1 * (long) val2;
    if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Multiplication overflows an int: "" + val1 + "" * "" + val2);
    }
    return (int) total;
}","public void test2323() throws Throwable {
    int int0 = FieldUtils.safeMultiply(0, 0);
    assertEquals(0, int0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static long safeAdd(long val1, long val2) {
    long sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test2424() throws Throwable {
    long long0 = FieldUtils.safeAdd(0L, 0L);
    assertEquals(0L, long0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeAdd(int val1, int val2) {
    int sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test2525() throws Throwable {
    int int0 = FieldUtils.safeAdd(365, 365);
    assertEquals(730, int0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) {
    return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
}","public void test2626() throws Throwable {
    int int0 = FieldUtils.getWrappedValue(0, 0, 0, 412);
    assertEquals(0, int0);
}","/**
 * Utility method used by addWrapField implementations to ensure the new
 * value lies within the field's legal value range.
 *
 * @param currentValue the current value of the data, which may lie outside
 * the wrapped value range
 * @param wrapValue  the value to add to current value before
 *  wrapping.  This may be negative.
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) {
    return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
}","public void test2727() throws Throwable {
    int int0 = FieldUtils.getWrappedValue((-2283), Integer.MIN_VALUE, Integer.MIN_VALUE, 2);
    assertEquals((-2280), int0);
}","/**
 * Utility method used by addWrapField implementations to ensure the new
 * value lies within the field's legal value range.
 *
 * @param currentValue the current value of the data, which may lie outside
 * the wrapped value range
 * @param wrapValue  the value to add to current value before
 *  wrapping.  This may be negative.
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test2828() throws Throwable {
    int int0 = FieldUtils.getWrappedValue(Integer.MIN_VALUE, Integer.MIN_VALUE, (-1));
    assertEquals(Integer.MIN_VALUE, int0);
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test2929() throws Throwable {
    int int0 = FieldUtils.getWrappedValue((-417), 231, 898);
    assertEquals(251, int0);
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test3030() throws Throwable {
    int int0 = FieldUtils.getWrappedValue(1430, (-1), 17971875);
    assertEquals(1430, int0);
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test3131() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.getWrappedValue(16, 16, 16);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MIN > MAX
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static int safeToInt(long value) {
    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
        return (int) value;
    }
    throw new ArithmeticException(""Value cannot fit in an int: "" + value);
}","public void test3232() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeToInt(9223372036854775807L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 9223372036854775807
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Casts to an int throwing an exception if overflow occurs.
 *
 * @param value  the value
 * @return the value as an int
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeToInt(long value) {
    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
        return (int) value;
    }
    throw new ArithmeticException(""Value cannot fit in an int: "" + value);
}","public void test3333() throws Throwable {
    int int0 = FieldUtils.safeToInt(2147483647L);
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Casts to an int throwing an exception if overflow occurs.
 *
 * @param value  the value
 * @return the value as an int
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test3434() throws Throwable {
    long long0 = FieldUtils.safeMultiply(2147483647L, (long) 3224);
    assertEquals(6923487277928L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test3535() throws Throwable {
    long long0 = FieldUtils.safeMultiply(1L, 1L);
    assertEquals(1L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test3636() throws Throwable {
    long long0 = FieldUtils.safeMultiply((-2359L), (-1));
    assertEquals(2359L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"//-----------------------------------------------------------------------
/**
 * Compares two objects as equals handling null.
 *
 * @param object1  the first object
 * @param object2  the second object
 * @return true if equal
 * @since 1.4
 */
public static boolean equals(Object object1, Object object2) {
    if (object1 == object2) {
        return true;
    }
    if (object1 == null || object2 == null) {
        return false;
    }
    return object1.equals(object2);
}","public void test3737() throws Throwable {
    Integer integer0 = new Integer(271);
    boolean boolean0 = FieldUtils.equals((Object) integer0, (Object) null);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares two objects as equals handling null.
 *
 * @param object1  the first object
 * @param object2  the second object
 * @return true if equal
 * @since 1.4
 */
public static boolean equals(Object object1, Object object2) {
    if (object1 == object2) {
        return true;
    }
    if (object1 == null || object2 == null) {
        return false;
    }
    return object1.equals(object2);
}","public void test3838() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeField dateTimeField0 = dateTimeFieldType0.getField((Chronology) null);
    Object object0 = new Object();
    boolean boolean0 = FieldUtils.equals((Object) dateTimeField0, object0);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares two objects as equals handling null.
 *
 * @param object1  the first object
 * @param object2  the second object
 * @return true if equal
 * @since 1.4
 */
public static boolean equals(Object object1, Object object2) {
    if (object1 == object2) {
        return true;
    }
    if (object1 == null || object2 == null) {
        return false;
    }
    return object1.equals(object2);
}","public void test3939() throws Throwable {
    Object object0 = new Object();
    boolean boolean0 = FieldUtils.equals(object0, object0);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares two objects as equals handling null.
 *
 * @param object1  the first object
 * @param object2  the second object
 * @return true if equal
 * @since 1.4
 */
public static boolean equals(Object object1, Object object2) {
    if (object1 == object2) {
        return true;
    }
    if (object1 == null || object2 == null) {
        return false;
    }
    return object1.equals(object2);
}","public void test4040() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    boolean boolean0 = FieldUtils.equals((Object) null, (Object) durationFieldType0);
    assertFalse(boolean0);
}",""
"public static int getWrappedValue(int value, int minValue, int maxValue) {
    if (minValue >= maxValue) {
        throw new IllegalArgumentException(""MIN > MAX"");
    }
    int wrapRange = maxValue - minValue + 1;
    value -= minValue;
    if (value >= 0) {
        return (value % wrapRange) + minValue;
    }
    int remByRange = (-value) % wrapRange;
    if (remByRange == 0) {
        return 0 + minValue;
    }
    return (wrapRange - remByRange) + minValue;
}","public void test4141() throws Throwable {
    int int0 = FieldUtils.getWrappedValue((-2146907296), 0, 31);
    assertEquals(0, int0);
}","/**
 * Utility method that ensures the given value lies within the field's
 * legal value range.
 *
 * @param value  the value to fit into the wrapped value range
 * @param minValue the wrap range minimum value.
 * @param maxValue the wrap range maximum value.  This must be
 *  greater than minValue (checked by the method).
 * @return the wrapped value
 * @throws IllegalArgumentException if minValue is greater
 *  than or equal to maxValue
 */"
"public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4242() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds(""U:b"", 0, 0, (-97));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for U:b must be in the range [0,-97]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */"
"public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4343() throws Throwable {
    FieldUtils.verifyValueBounds(""YearMonthDay"", Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */"
"public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4444() throws Throwable {
    Integer integer0 = new Integer(0);
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds("" * "", (int) integer0, 3654, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for  *  must be in the range [3654,0]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */"
"public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4545() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds(dateTimeFieldType0, (-1), (-1570), (-1570));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -1 for dayOfMonth must be in the range [-1570,-1570]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test4646() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    FieldUtils.verifyValueBounds(dateTimeFieldType0, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4747() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds((DateTimeFieldType) null, (-1958), 100, (-1958));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.IllegalFieldValueException"", e);
    }
}","/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4848() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds((DateTimeField) null, 841, (-251526), (-3169));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test4949() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeField dateTimeField0 = dateTimeFieldType0.getField((Chronology) null);
    FieldUtils.verifyValueBounds(dateTimeField0, 0, 0, 0);
}",""
"//-----------------------------------------------------------------------
/**
 * Verify that input values are within specified bounds.
 *
 * @param value  the value to check
 * @param lowerBound  the lower bound allowed for value
 * @param upperBound  the upper bound allowed for value
 * @throws IllegalFieldValueException if value is not in the specified bounds
 */
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) {
    if ((value < lowerBound) || (value > upperBound)) {
        throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));
    }
}","public void test5050() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeField dateTimeField0 = buddhistChronology0.millisOfSecond();
    // Undeclared exception!
    try {
        FieldUtils.verifyValueBounds(dateTimeField0, 1, 1776, (-1207));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 1 for millisOfSecond must be in the range [1776,-1207]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public static int safeMultiplyToInt(long val1, long val2) {
    long val = FieldUtils.safeMultiply(val1, val2);
    return FieldUtils.safeToInt(val);
}","public void test5151() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiplyToInt((-761L), (-2147483648L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 1634235056128
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values to return an int throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeToInt(long value) {
    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
        return (int) value;
    }
    throw new ArithmeticException(""Value cannot fit in an int: "" + value);
}","public void test5252() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeToInt((-9223372036854775808L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: -9223372036854775808
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Casts to an int throwing an exception if overflow occurs.
 *
 * @param value  the value
 * @return the value as an int
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5353() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply((-1L), (-9223372036854775800L));
        //  fail(""Expecting exception: ArithmeticException"");
        // Unstable assertion
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: -1 * -9223372036854775800
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5454() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply((-9223372036854775808L), (-1L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: -9223372036854775808 * -1
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5555() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply((-3520L), 1000000000000000000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: -3520 * 1000000000000000000
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5656() throws Throwable {
    long long0 = FieldUtils.safeMultiply((-801L), 0L);
    assertEquals(0L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5757() throws Throwable {
    long long0 = FieldUtils.safeMultiply((long) 0, (long) 0);
    assertEquals(0L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeMultiplyToInt(long val1, long val2) {
    long val = FieldUtils.safeMultiply(val1, val2);
    return FieldUtils.safeToInt(val);
}","public void test5858() throws Throwable {
    int int0 = FieldUtils.safeMultiplyToInt(10L, 10L);
    assertEquals(100, int0);
}","/**
 * Multiply two values to return an int throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, long val2) {
    if (val2 == 1) {
        return val1;
    }
    if (val1 == 1) {
        return val2;
    }
    if (val1 == 0 || val2 == 0) {
        return 0;
    }
    long total = val1 * val2;
    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test5959() throws Throwable {
    long long0 = FieldUtils.safeMultiply(1L, 170L);
    assertEquals(170L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test6060() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply(9223372036854775805L, 1017);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows a long: 9223372036854775805 * 1017
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test6161() throws Throwable {
    Integer integer0 = new Integer(25);
    long long0 = FieldUtils.safeMultiply((long) integer0, 1);
    assertEquals(25L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static long safeMultiply(long val1, int val2) {
    switch(val2) {
        case -1:
            return -val1;
        case 0:
            return 0L;
        case 1:
            return val1;
    }
    long total = val1 * val2;
    if (total / val2 != val1) {
        throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
    }
    return total;
}","public void test6262() throws Throwable {
    long long0 = FieldUtils.safeMultiply((long) 0, 0);
    assertEquals(0L, long0);
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"//-----------------------------------------------------------------------
/**
 * Adds the duration to the instant, specifying the number of times to add.
 *
 * @param instant  the instant to add to
 * @param duration  the duration to add
 * @param scalar  the number of times to add
 * @return the updated instant
 */
public long add(long instant, long duration, int scalar) {
    if (duration == 0 || scalar == 0) {
        return instant;
    }
    long add = FieldUtils.safeMultiply(duration, scalar);
    return FieldUtils.safeAdd(instant, add);
}","public void test6363() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance((DateTimeZone) null);
    long long0 = ethiopicChronology0.add((-313L), (-1556L), (-1));
    assertEquals(1243L, long0);
}",""
"public static int safeMultiply(int val1, int val2) {
    long total = (long) val1 * (long) val2;
    if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Multiplication overflows an int: "" + val1 + "" * "" + val2);
    }
    return (int) total;
}","public void test6464() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply(Integer.MIN_VALUE, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows an int: -2147483648 * -2147483648
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static int safeMultiply(int val1, int val2) {
    long total = (long) val1 * (long) val2;
    if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Multiplication overflows an int: "" + val1 + "" * "" + val2);
    }
    return (int) total;
}","public void test6565() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeMultiply(25, (-2145181949));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows an int: 25 * -2145181949
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Multiply two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 * @since 1.2
 */"
"public static long safeSubtract(long val1, long val2) {
    long diff = val1 - val2;
    // If there is a sign change, but the two values have different signs...
    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" - "" + val2);
    }
    return diff;
}","public void test6666() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeSubtract((-9223372036854775776L), 21600000L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: -9223372036854775776 - 21600000
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Subtracts two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value, to be taken away from
 * @param val2  the second value, the amount to take away
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeSubtract(long val1, long val2) {
    long diff = val1 - val2;
    // If there is a sign change, but the two values have different signs...
    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" - "" + val2);
    }
    return diff;
}","public void test6767() throws Throwable {
    long long0 = FieldUtils.safeSubtract(0L, 10L);
    assertEquals((-10L), long0);
}","/**
 * Subtracts two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value, to be taken away from
 * @param val2  the second value, the amount to take away
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeSubtract(long val1, long val2) {
    long diff = val1 - val2;
    // If there is a sign change, but the two values have different signs...
    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" - "" + val2);
    }
    return diff;
}","public void test6868() throws Throwable {
    long long0 = FieldUtils.safeSubtract(1907, (-1267));
    assertEquals(3174L, long0);
}","/**
 * Subtracts two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value, to be taken away from
 * @param val2  the second value, the amount to take away
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeAdd(long val1, long val2) {
    long sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test6969() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeAdd((-1504L), (-9223372036854775808L));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: -1504 + -9223372036854775808
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeAdd(long val1, long val2) {
    long sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test7070() throws Throwable {
    long long0 = FieldUtils.safeAdd(10L, (-1958L));
    assertEquals((-1948L), long0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static long safeAdd(long val1, long val2) {
    long sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test7171() throws Throwable {
    long long0 = FieldUtils.safeAdd((long) 170, 1L);
    assertEquals(171L, long0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeAdd(int val1, int val2) {
    int sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test7272() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeAdd(2147483639, 2147483639);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: 2147483639 + 2147483639
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeAdd(int val1, int val2) {
    int sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test7373() throws Throwable {
    int int0 = FieldUtils.safeAdd(0, (-2456));
    assertEquals((-2456), int0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"public static int safeAdd(int val1, int val2) {
    int sum = val1 + val2;
    // If there is a sign change, but the two values have the same sign...
    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {
        throw new ArithmeticException(""The calculation caused an overflow: "" + val1 + "" + "" + val2);
    }
    return sum;
}","public void test7474() throws Throwable {
    int int0 = FieldUtils.safeAdd(0, 0);
    assertEquals(0, int0);
}","/**
 * Add two values throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
"//------------------------------------------------------------------------
/**
 * Negates the input throwing an exception if it can't negate it.
 *
 * @param value  the value to negate
 * @return the negated value
 * @throws ArithmeticException if the value is Integer.MIN_VALUE
 * @since 1.1
 */
public static int safeNegate(int value) {
    if (value == Integer.MIN_VALUE) {
        throw new ArithmeticException(""Integer.MIN_VALUE cannot be negated"");
    }
    return -value;
}","public void test7575() throws Throwable {
    // Undeclared exception!
    try {
        FieldUtils.safeNegate(Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Integer.MIN_VALUE cannot be negated
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"//------------------------------------------------------------------------
/**
 * Negates the input throwing an exception if it can't negate it.
 *
 * @param value  the value to negate
 * @return the negated value
 * @throws ArithmeticException if the value is Integer.MIN_VALUE
 * @since 1.1
 */
public static int safeNegate(int value) {
    if (value == Integer.MIN_VALUE) {
        throw new ArithmeticException(""Integer.MIN_VALUE cannot be negated"");
    }
    return -value;
}","public void test7676() throws Throwable {
    int int0 = FieldUtils.safeNegate(0);
    assertEquals(0, int0);
}",""
"public static int safeMultiplyToInt(long val1, long val2) {
    long val = FieldUtils.safeMultiply(val1, val2);
    return FieldUtils.safeToInt(val);
}","public void test7777() throws Throwable {
    int int0 = FieldUtils.safeMultiplyToInt(170L, 1L);
    assertEquals(170, int0);
}","/**
 * Multiply two values to return an int throwing an exception if overflow occurs.
 *
 * @param val1  the first value
 * @param val2  the second value
 * @return the new total
 * @throws ArithmeticException if the value is too big or too small
 */"
