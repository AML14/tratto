focal_method,test_prefix,docstring
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test0000() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime(""~oxM[4"");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test0001() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime(""~oxM[4"");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test0002() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime(""~oxM[4"");
    assertEquals(28800000L, mutableDateTime0.getMillis());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test0013() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    long long0 = dateTimeFormatter0.parseMillis(""~oxM[4"");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test0014() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    long long0 = dateTimeFormatter0.parseMillis(""~oxM[4"");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test0015() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""~oxM[4"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    long long0 = dateTimeFormatter0.parseMillis(""~oxM[4"");
    assertEquals(28800000L, long0);
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test0027() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) fixedDateTimeZone0, 1);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(julianChronology0);
    StringWriter stringWriter0 = new StringWriter();
    dateTimeFormatter1.printTo((Writer) stringWriter0, 0L);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test0038() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    Partial partial0 = new Partial(dateTimeFieldType0, 1);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) partial0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test0039() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    Partial partial0 = new Partial(dateTimeFieldType0, 1);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    StringBuffer stringBuffer0 = new StringBuffer();
    dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) partial0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00410() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    StringBuffer stringBuffer0 = new StringBuffer(0);
    MockDate mockDate0 = new MockDate();
    YearMonth yearMonth0 = YearMonth.fromDateFields(mockDate0);
    dateTimeFormatter0.printTo((Appendable) stringBuffer0, (ReadablePartial) yearMonth0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00411() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    StringBuffer stringBuffer0 = new StringBuffer(0);
    MockDate mockDate0 = new MockDate();
    YearMonth yearMonth0 = YearMonth.fromDateFields(mockDate0);
    dateTimeFormatter0.printTo((Appendable) stringBuffer0, (ReadablePartial) yearMonth0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00512() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    StringWriter stringWriter0 = new StringWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 0);
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    MutableDateTime mutableDateTime0 = new MutableDateTime();
    DateTime dateTime0 = mutableDateTime0.toDateTime(dateTimeZone0);
    dateTimeFormatter0.printTo((Appendable) stringWriter0, (ReadableInstant) dateTime0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00513() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    StringWriter stringWriter0 = new StringWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(1, 0);
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    MutableDateTime mutableDateTime0 = new MutableDateTime();
    DateTime dateTime0 = mutableDateTime0.toDateTime(dateTimeZone0);
    dateTimeFormatter0.printTo((Appendable) stringWriter0, (ReadableInstant) dateTime0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00614() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""America/Los_Angeles"");
    dateTimeFormatter0.printTo((Appendable) mockPrintStream0, (long) 0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00615() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""America/Los_Angeles"");
    dateTimeFormatter0.printTo((Appendable) mockPrintStream0, (long) 0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00716() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(191);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter(3600);
    DateMidnight dateMidnight0 = new DateMidnight(4294967295L, dateTimeZone0);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadableInstant) dateMidnight0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00717() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(191);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter(3600);
    DateMidnight dateMidnight0 = new DateMidnight(4294967295L, dateTimeZone0);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadableInstant) dateMidnight0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00819() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    StringWriter stringWriter0 = new StringWriter();
    dateTimeFormatter0.printTo((Writer) stringWriter0, 0L);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00920() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertEquals(0, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00921() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00922() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test00923() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00924() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01025() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01026() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01027() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertEquals((-10), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01028() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertEquals((-10), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the UTC zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, UTC will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, UTC will be set on the parsed datetime.
 * <p>
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @return the new formatter, never null
 * @since 2.0
 */
public DateTimeFormatter withZoneUTC() {
    return withZone(DateTimeZone.UTC);
}","public void test01029() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01030() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZoneUTC();
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01131() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone((DateTimeZone) null);
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01132() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone((DateTimeZone) null);
    assertTrue(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01133() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone((DateTimeZone) null);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public DateTimeFormatter withZone(DateTimeZone zone) {
    if (iZone == zone) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);
}","public void test01234() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}","/**
 * Returns a new formatter that will use the specified zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, this zone will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this zone will be set on the parsed datetime.
 * <p>
 * A null zone means of no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param zone  the zone to use as an override
 * @return the new formatter
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01235() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertEquals(0, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01236() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01237() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01238() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01339() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertEquals((-2754), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public DateTimeFormatter withZone(DateTimeZone zone) {
    if (iZone == zone) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);
}","public void test01340() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}","/**
 * Returns a new formatter that will use the specified zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, this zone will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this zone will be set on the parsed datetime.
 * <p>
 * A null zone means of no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param zone  the zone to use as an override
 * @return the new formatter
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01341() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01342() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01343() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01344() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(dateTimeZone0);
    assertEquals((-2754), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01445() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) islamicChronology0.AH);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01446() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) islamicChronology0.AH);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test01447() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) islamicChronology0.AH);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01448() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) islamicChronology0.AH);
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01449() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) islamicChronology0.AH);
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01550() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(222);
    Integer integer0 = new Integer(222);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test01551() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(222);
    Integer integer0 = new Integer(222);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    assertSame(dateTimeFormatter3, dateTimeFormatter2);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01552() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(222);
    Integer integer0 = new Integer(222);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    assertEquals(0, dateTimeFormatter3.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01554() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(222);
    Integer integer0 = new Integer(222);
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withPivotYear(integer0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01655() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(19, 19);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-5299));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) buddhistChronology0.BE);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01656() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(19, 19);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-5299));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) buddhistChronology0.BE);
    assertEquals((-5299), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01657() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(19, 19);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-5299));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) buddhistChronology0.BE);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01658() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(19, 19);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-5299));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) buddhistChronology0.BE);
    assertEquals((-5299), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test01659() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(19, 19);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-5299));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((Integer) buddhistChronology0.BE);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01760() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01761() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test01762() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertEquals(4, (int) dateTimeFormatter2.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test01763() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01764() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01765() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(4);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test01866() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertEquals(0, (int) dateTimeFormatter2.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01867() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertEquals((-10), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test01868() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01869() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01870() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertEquals((-10), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01871() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01972() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test01973() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertTrue(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test01974() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals(0, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will create a datetime with a time zone
 * equal to that of the offset of the parsed string.
 * <p>
 * After calling this method, a string '2004-06-09T10:20:30-08:00' will
 * create a datetime with a zone of -08:00 (a fixed zone, with no daylight
 * savings rules). If the parsed string represents a local time (no zone
 * offset) the parsed datetime will be in the default zone.
 * <p>
 * Calling this method sets the override zone to null.
 * Calling the override zone method sets this flag off.
 *
 * @return the new formatter
 */
public DateTimeFormatter withOffsetParsed() {
    if (iOffsetParsed == true) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear);
}","public void test01975() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02076() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will create a datetime with a time zone
 * equal to that of the offset of the parsed string.
 * <p>
 * After calling this method, a string '2004-06-09T10:20:30-08:00' will
 * create a datetime with a zone of -08:00 (a fixed zone, with no daylight
 * savings rules). If the parsed string represents a local time (no zone
 * offset) the parsed datetime will be in the default zone.
 * <p>
 * Calling this method sets the override zone to null.
 * Calling the override zone method sets this flag off.
 *
 * @return the new formatter
 */
public DateTimeFormatter withOffsetParsed() {
    if (iOffsetParsed == true) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear);
}","public void test02077() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02078() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals((-10), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02079() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals((-10), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02080() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, 0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-10));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertTrue(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter with a different locale that will be used
 * for printing and parsing.
 * <p>
 * A DateTimeFormatter is immutable, so a new instance is returned,
 * and the original is unaltered and still usable.
 *
 * @param locale the locale to use; if null, formatter uses default locale
 * at invocation time
 * @return the new formatter
 */
public DateTimeFormatter withLocale(Locale locale) {
    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}","public void test02181() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(331, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    Locale locale0 = Locale.ENGLISH;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02182() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(331, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    Locale locale0 = Locale.ENGLISH;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02183() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(331, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    Locale locale0 = Locale.ENGLISH;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertEquals(0, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02184() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(331, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    Locale locale0 = Locale.ENGLISH;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter with a different locale that will be used
 * for printing and parsing.
 * <p>
 * A DateTimeFormatter is immutable, so a new instance is returned,
 * and the original is unaltered and still usable.
 *
 * @param locale the locale to use; if null, formatter uses default locale
 * at invocation time
 * @return the new formatter
 */
public DateTimeFormatter withLocale(Locale locale) {
    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}","public void test02285() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02286() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertEquals((-13), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02287() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02288() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02289() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    Locale locale0 = Locale.JAPAN;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withLocale(locale0);
    assertEquals((-13), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02390() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2147483582, (-5530));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(16);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02391() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2147483582, (-5530));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(16);
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02392() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2147483582, (-5530));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(16);
    assertEquals(16, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02393() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2147483582, (-5530));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withDefaultYear(16);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02494() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 6);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(buddhistChronology0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02495() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 6);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(buddhistChronology0);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test02496() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 6);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(buddhistChronology0);
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test02497() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 6);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(buddhistChronology0);
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test02498() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 6);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(buddhistChronology0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test02599() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0, islamicChronology_LeapYearPatternType0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(islamicChronology0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test025100() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0, islamicChronology_LeapYearPatternType0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(islamicChronology0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test025101() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0, islamicChronology_LeapYearPatternType0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(islamicChronology0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test025102() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear(0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(0);
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance(dateTimeZone0, islamicChronology_LeapYearPatternType0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(islamicChronology0);
    assertEquals(0, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test026103() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(julianChronology0);
    assertEquals((-13), dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test026104() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(julianChronology0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test026105() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(julianChronology0);
    assertEquals((-13), dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test026106() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(julianChronology0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test026107() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-13));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withChronology(julianChronology0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test027108() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(1);
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    dateTimeFormatter0.print((ReadablePartial) localDate0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test027109() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(1);
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    dateTimeFormatter0.print((ReadablePartial) localDate0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test028110() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    LocalDateTime localDateTime0 = LocalDateTime.now();
    dateTimeFormatter0.print((ReadablePartial) localDateTime0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test028111() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    LocalDateTime localDateTime0 = LocalDateTime.now();
    dateTimeFormatter0.print((ReadablePartial) localDateTime0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test029112() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTime dateTime0 = DateTime.now();
    dateTimeFormatter0.print((ReadableInstant) dateTime0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test029113() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    DateTime dateTime0 = DateTime.now();
    dateTimeFormatter0.print((ReadableInstant) dateTime0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test030114() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    String string0 = dateTimeFormatter0.print(24L);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test030115() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    String string0 = dateTimeFormatter0.print(24L);
    assertEquals(""America/Los_Angeles"", string0);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test030116() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    String string0 = dateTimeFormatter0.print(24L);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test031117() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.print(0L);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test031118() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.print(0L);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test032119() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test032120() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(0L, mutableDateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test032121() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test032122() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test033123() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset("""", """", false, 191, 20587500);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    long long0 = dateTimeFormatter0.parseMillis("""");
    assertEquals(0L, long0);
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test033124() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset("""", """", false, 191, 20587500);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    long long0 = dateTimeFormatter0.parseMillis("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test033125() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset("""", """", false, 191, 20587500);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    long long0 = dateTimeFormatter0.parseMillis("""");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test034126() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""k9<{u8vhJc,4\"""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalDate(""k9<{u8vhJc,4\"""");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test034127() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""k9<{u8vhJc,4\"""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalDate(""k9<{u8vhJc,4\"""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test035128() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter0.parseInto(mutableDateTime0, ""The partial must not be null"", (-1));
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test035129() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter0.parseInto(mutableDateTime0, ""The partial must not be null"", (-1));
    assertEquals(0, int0);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test035130() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter0.parseInto(mutableDateTime0, ""The partial must not be null"", (-1));
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test035131() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter0.parseInto(mutableDateTime0, ""The partial must not be null"", (-1));
    assertEquals(28800000L, mutableDateTime0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test036132() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2280, false, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTime dateTime0 = dateTimeFormatter0.parseDateTime(""19"");
    assertEquals((-2208960000000L), dateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test036133() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2280, false, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTime dateTime0 = dateTimeFormatter0.parseDateTime(""19"");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test036134() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2280, false, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateTime dateTime0 = dateTimeFormatter0.parseDateTime(""19"");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test037135() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    boolean boolean0 = dateTimeFormatter1.isOffsetParsed();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test037136() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    boolean boolean0 = dateTimeFormatter1.isOffsetParsed();
    assertTrue(boolean0);
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test037137() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    boolean boolean0 = dateTimeFormatter1.isOffsetParsed();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test038138() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.getPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test038139() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.getPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test039140() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    dateTimeFormatter0.getPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test039141() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    dateTimeFormatter0.getPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test040142() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-696), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    dateTimeFormatter0.getPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test040143() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-696), true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    dateTimeFormatter0.getPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test041144() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(19);
    Integer integer0 = dateTimeFormatter1.getPivotYear();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test041145() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(19);
    Integer integer0 = dateTimeFormatter1.getPivotYear();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test041146() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 19, 19);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(19);
    Integer integer0 = dateTimeFormatter1.getPivotYear();
    assertEquals(19, (int) integer0);
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test042148() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    Integer integer0 = Integer.valueOf((-9));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    Integer integer1 = dateTimeFormatter1.getPivotYear();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test042149() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    Integer integer0 = Integer.valueOf((-9));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    Integer integer1 = dateTimeFormatter1.getPivotYear();
    assertNotNull(integer1);
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test042150() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    Integer integer0 = Integer.valueOf((-9));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    Integer integer1 = dateTimeFormatter1.getPivotYear();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test043151() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('/');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, (DateTimeParser) null);
    dateTimeFormatter0.getParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test043152() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('/');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, (DateTimeParser) null);
    dateTimeFormatter0.getParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test044153() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    dateTimeFormatter0.getParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test044154() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    dateTimeFormatter0.getParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test045155() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1038), (-1038));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    dateTimeFormatter0.getParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test045156() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1038), (-1038));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    dateTimeFormatter0.getParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Locale getLocale() {
    return iLocale;
}","public void test046157() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    Locale locale0 = Locale.JAPANESE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    Locale locale1 = dateTimeFormatter1.getLocale();
    assertNotNull(locale1);
}","/**
 * Gets the locale that will be used for printing and parsing.
 *
 * @return the locale to use; if null, formatter uses default locale at
 * invocation time
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test046158() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    Locale locale0 = Locale.JAPANESE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    Locale locale1 = dateTimeFormatter1.getLocale();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test046159() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    Locale locale0 = Locale.JAPANESE;
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale(locale0);
    Locale locale1 = dateTimeFormatter1.getLocale();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test047160() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    int int0 = dateTimeFormatter1.getDefaultYear();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test047161() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    int int0 = dateTimeFormatter1.getDefaultYear();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test047162() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-1544), (-1542));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withDefaultYear((-2754));
    int int0 = dateTimeFormatter1.getDefaultYear();
    assertEquals((-2754), int0);
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Chronology getChronology() {
    return iChrono;
}","public void test048163() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    Chronology chronology0 = dateTimeFormatter1.getChronology();
    assertNotNull(chronology0);
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test048164() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    Chronology chronology0 = dateTimeFormatter1.getChronology();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test048165() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    Chronology chronology0 = dateTimeFormatter1.getChronology();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"@Deprecated
public Chronology getChronolgy() {
    return iChrono;
}","public void test049166() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    Locale locale0 = Locale.GERMAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    Chronology chronology0 = dateTimeFormatter3.getChronolgy();
    assertNotSame(dateTimeFormatter3, dateTimeFormatter2);
}","/**
 * Gets the chronology to use as an override.
 *
 * @return the chronology to use as an override
 * @deprecated Use the method with the correct spelling
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test049168() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    Locale locale0 = Locale.GERMAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    Chronology chronology0 = dateTimeFormatter3.getChronolgy();
    assertTrue(dateTimeFormatter3.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test049169() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    Locale locale0 = Locale.GERMAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    Chronology chronology0 = dateTimeFormatter3.getChronolgy();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test049170() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(buddhistChronology0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    Locale locale0 = Locale.GERMAN;
    DateTimeFormatter dateTimeFormatter3 = dateTimeFormatter2.withLocale(locale0);
    Chronology chronology0 = dateTimeFormatter3.getChronolgy();
    assertEquals(2000, dateTimeFormatter3.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test050171() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer(719527);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    JulianChronology julianChronology0 = JulianChronology.getInstance((DateTimeZone) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    YearMonth yearMonth0 = new YearMonth((-28800926L), (Chronology) julianChronology0);
    // Undeclared exception!
    dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) yearMonth0);
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test051172() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(65);
    LocalDateTime localDateTime0 = LocalDateTime.now(dateTimeZone0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo(stringBuffer0, (ReadablePartial) localDateTime0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param buf  the destination to format to, not null
 * @param instant  instant to format, null means now
 */
public void printTo(StringBuffer buf, ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(buf, millis, chrono);
}","public void test052173() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((StringBuffer) null, (ReadableInstant) mutableDateTime0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param buf  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */
public void printTo(StringBuffer buf, long instant) {
    printTo(buf, instant, null);
}","public void test053174() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer(719527);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    // Undeclared exception!
    dateTimeFormatter0.printTo(stringBuffer0, 59737472L);
}",""
"//-----------------------------------------------------------------------
/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param buf  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */
public void printTo(StringBuffer buf, long instant) {
    printTo(buf, instant, null);
}","public void test054175() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    StringBuffer stringBuffer0 = new StringBuffer(""5/=("");
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo(stringBuffer0, 1089L);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param buf  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */
public void printTo(StringBuffer buf, long instant) {
    printTo(buf, instant, null);
}","public void test055176() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((StringBuffer) null, (-2065L));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TextField"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param buf  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */
public void printTo(StringBuffer buf, long instant) {
    printTo(buf, instant, null);
}","public void test056177() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(0, 0, 1665);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo(stringBuffer0, (long) 1665);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No datetime pattern for locale: en
        //
        verifyException(""org.joda.time.format.DateTimeFormat$StyleFormatter"", e);
    }
}",""
"public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
    appendable.append(print(partial));
}","public void test057178() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer(719527);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    LocalTime localTime0 = new LocalTime((long) 20503125, dateTimeZone0);
    // Undeclared exception!
    dateTimeFormatter0.printTo((Appendable) stringBuffer0, (ReadablePartial) localTime0);
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param appendable  the destination to format to, not null
 * @param partial  partial to format
 * @since 2.0
 */"
"public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
    appendable.append(print(partial));
}","public void test058179() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (byte) 89, (byte) 89);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Fraction0);
    MockFileWriter mockFileWriter0 = new MockFileWriter("" %.4|+"");
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) mockFileWriter0, (ReadablePartial) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param appendable  the destination to format to, not null
 * @param partial  partial to format
 * @since 2.0
 */"
"public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {
    appendable.append(print(instant));
}","public void test059180() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) charArrayWriter0, (ReadableInstant) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  instant to format, null means now
 * @since 2.0
 */"
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test060181() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    CharBuffer charBuffer0 = CharBuffer.allocate(2000);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) charBuffer0, (long) 1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test061182() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter((-748), 1029, 1029);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter(0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) charArrayWriter0, 1338L);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No datetime pattern for locale: en
        //
        verifyException(""org.joda.time.format.DateTimeFormat$StyleFormatter"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public void printTo(Writer out, ReadablePartial partial) throws IOException {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(out, partial, iLocale);
}","public void test062183() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    StringWriter stringWriter0 = new StringWriter(1);
    LocalDate localDate0 = new LocalDate((Chronology) islamicChronology0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) stringWriter0, (ReadablePartial) localDate0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param out  the destination to format to, not null
 * @param partial  partial to format
 */"
"public void printTo(Writer out, long instant) throws IOException {
    printTo(out, instant, null);
}","public void test063184() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(byteArrayOutputStream0);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0, 2534);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) bufferedWriter0, (-25271661L));
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param out  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */"
"public void printTo(Writer out, long instant) throws IOException {
    printTo(out, instant, null);
}","public void test064185() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('+');
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_CharacterLiteral0, dateTimeFormatterBuilder_CharacterLiteral0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) null, 3600000L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param out  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test065186() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    Locale locale0 = Locale.GERMAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    MonthDay monthDay0 = MonthDay.fromDateFields(date0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadablePartial) monthDay0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test066187() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral((String) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    LocalDate localDate0 = LocalDate.now();
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadablePartial) localDate0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$StringLiteral"", e);
    }
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test067188() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-1150), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = LocalDateTime.now((Chronology) buddhistChronology0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadablePartial) localDateTime0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test068189() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2146327844, true, 2146327844);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_PaddedNumber0, dateTimeFormatterBuilder_PaddedNumber0);
    DateMidnight dateMidnight0 = new DateMidnight((long) 4317);
    // Undeclared exception!
    dateTimeFormatter0.print((ReadableInstant) dateMidnight0);
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test069190() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadableInstant) mutableDateTime0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test070191() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 24, (-37));
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_MatchingParser0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadableInstant) null);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test071192() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(122, 122, 122);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    DateTime dateTime0 = new DateTime();
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadableInstant) dateTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No datetime pattern for locale: en
        //
        verifyException(""org.joda.time.format.DateTimeFormat$StyleFormatter"", e);
    }
}",""
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test072193() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((long) 2771);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test073194() throws Throwable {
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, 0, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print(2043L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Fraction"", e);
    }
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test074195() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 2147483582, (-5530));
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((long) 16);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test075196() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(1789, 0, 0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormat_StyleFormatter0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((-1L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1789
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test076197() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMutableDateTime(""h"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test077198() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 13, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMutableDateTime((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test078199() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMillis(""org.joda.time.base.AbstractDuration"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Parsing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test079200() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, (Map<String, DateTimeZone>) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMillis("""");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneName"", e);
    }
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test080201() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalTime(""(n"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses only the local time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test081202() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalTime(""h)\""Zj\""#2k}rK"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""h)\""Zj\""#2k}rK\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses only the local time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test082203() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDateTime("" instant,"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test083204() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 20, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDateTime((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TwoDigitYear"", e);
    }
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalDate parseLocalDate(String text) {
    return parseLocalDateTime(text).toLocalDate();
}","public void test084205() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDate(""H"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses only the local date from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date will be used.
 * This means that any parsed time, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalDate parseLocalDate(String text) {
    return parseLocalDateTime(text).toLocalDate();
}","public void test085206() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDate((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$StringLiteral"", e);
    }
}","/**
 * Parses only the local date from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date will be used.
 * This means that any parsed time, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test086207() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    MutableDateTime mutableDateTime0 = new MutableDateTime((DateTimeZone) null);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseInto(mutableDateTime0, "")!K"", 5);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test087208() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseInto(mutableDateTime0, (String) null, (-1958));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter"", e);
    }
}",""
"public DateTime parseDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            DateTime dt = new DateTime(millis, chrono);
            if (iZone != null) {
                dt = dt.withZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test088209() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseDateTime(""Printing not supported"");
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$Composite"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new DateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public DateTime parseDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            DateTime dt = new DateTime(millis, chrono);
            if (iZone != null) {
                dt = dt.withZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test089210() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseDateTime((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneName"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new DateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test090211() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalDateTime("""");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test090212() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test091213() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 1900, 39);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDateTime(""0XA#n\"".,NH[{~R}r"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""0XA#n\"".,NH[{~R}r\"" is malformed at \""XA#n\"".,NH[{~R}r\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test092214() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    LocalDate localDate0 = LocalDate.now();
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((StringBuffer) null, (ReadablePartial) localDate0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TextField"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param buf  the destination to format to, not null
 * @param partial  partial to format
 */
public void printTo(StringBuffer buf, ReadablePartial partial) {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(buf, partial, iLocale);
}","public void test093215() throws Throwable {
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter((-2147483562), (-1035), 2147483603);
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormat_StyleFormatter0, dateTimeFormatterBuilder_Composite0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((StringBuffer) null, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test094216() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 13, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(13);
    Integer integer0 = new Integer((-572));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test094217() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 13, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(13);
    Integer integer0 = new Integer((-572));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    assertEquals(13, (int) dateTimeFormatter1.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test094218() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 13, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(13);
    Integer integer0 = new Integer((-572));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used. Null means no-override.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */
public DateTimeFormatter withPivotYear(Integer pivotYear) {
    if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
}","public void test094219() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 13, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(13);
    Integer integer0 = new Integer((-572));
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear(integer0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test095221() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    StringBuffer stringBuffer0 = new StringBuffer(0);
    Instant instant0 = Instant.now();
    dateTimeFormatter0.printTo(stringBuffer0, (ReadableInstant) instant0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test096222() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    dateTimeFormatter0.getParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test096223() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    dateTimeFormatter0.getParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public String print(long instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test097224() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2147483627, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    // Undeclared exception!
    dateTimeFormatter0.print(1L);
}","/**
 * Prints a millisecond instant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the ISO chronology and default zone.
 *
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @return the printed result
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test099227() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test099228() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public String print(ReadablePartial partial) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, partial);
    return buf.toString();
}","public void test100229() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.print((ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial to a new String.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param partial  partial to format
 * @return the printed result
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test101230() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.getLocale();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test101231() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    dateTimeFormatter0.getLocale();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test102232() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseInto((ReadWritableInstant) null, "":t"", 270);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Parsing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test103233() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(28800000L, mutableDateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test103234() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test103235() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test103236() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertNotSame(dateTimeFormatter1, dateTimeFormatter0);
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test103237() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test104238() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test104239() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(28800000L, mutableDateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test104240() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test104241() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = dateTimeFormatter1.parseMutableDateTime("""");
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test105242() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMutableDateTime(""]f]VFRlp%._{{.<q8<"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""]f]VFRlp%._{{.<q8<\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public MutableDateTime parseMutableDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            MutableDateTime dt = new MutableDateTime(millis, chrono);
            if (iZone != null) {
                dt.setZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test106243() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMutableDateTime(""wm3$+) RGKCU!k"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""wm3$+) RGKCU!k\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new MutableDateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test107244() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test107245() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test107246() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertEquals(0L, dateTime0.getMillis());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test107247() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test108248() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test108249() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertEquals(28800000L, dateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test108250() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test108251() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTime dateTime0 = dateTimeFormatter1.parseDateTime("""");
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public DateTime parseDateTime(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(null);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (iOffsetParsed && bucket.getOffsetInteger() != null) {
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            DateTime dt = new DateTime(millis, chrono);
            if (iZone != null) {
                dt = dt.withZone(iZone);
            }
            return dt;
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test109252() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TimeZoneName0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseDateTime(""]L7^x"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""]L7^x\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a date-time from the given text, returning a new DateTime.
 * <p>
 * The parse will use the zone and chronology specified on this formatter.
 * <p>
 * If the text contains a time zone string then that will be taken into
 * account in adjusting the time of day as follows.
 * If the {@link #withOffsetParsed()} has been called, then the resulting
 * DateTime will have a fixed offset based on the parsed time zone.
 * Otherwise the resulting DateTime will have the zone of this formatter,
 * but the parsed zone may have caused the time to be adjusted.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test110253() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""i@,+Nw"", """", false, 5, 5);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    dateTimeFormatter0.parseLocalDateTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test110254() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""i@,+Nw"", """", false, 5, 5);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    dateTimeFormatter0.parseLocalDateTime("""");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test111255() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalTime("""");
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test111256() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    dateTimeFormatter0.parseLocalTime("""");
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public LocalDateTime parseLocalDateTime(String text) {
    DateTimeParser parser = requireParser();
    // always use UTC, avoiding DST gaps
    Chronology chrono = selectChronology(null).withUTC();
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            long millis = bucket.computeMillis(true, text);
            if (bucket.getOffsetInteger() != null) {
                // treat withOffsetParsed() as being true
                int parsedOffset = bucket.getOffsetInteger();
                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
                chrono = chrono.withZone(parsedZone);
            } else if (bucket.getZone() != null) {
                chrono = chrono.withZone(bucket.getZone());
            }
            return new LocalDateTime(millis, chrono);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test112257() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeFormatterBuilder_UnpaddedNumber0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDateTime(""cn"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""cn\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses only the local date-time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date-time will be used.
 * This means that any parsed time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date-time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test113258() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMillis(""nUJUkqCh6"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""nUJUkqCh6\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"public long parseMillis(String text) {
    DateTimeParser parser = requireParser();
    Chronology chrono = selectChronology(iChrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, 0);
    if (newPos >= 0) {
        if (newPos >= text.length()) {
            return bucket.computeMillis(true, text);
        }
    } else {
        newPos = ~newPos;
    }
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
}","public void test114259() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(929, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseMillis("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a datetime from the given text, returning the number of
 * milliseconds since the epoch, 1970-01-01T00:00:00Z.
 * <p>
 * The parse will use the ISO chronology, and the default time zone.
 * If the text contains a time zone string then that will be taken into account.
 *
 * @param text  text to parse
 * @return parsed value expressed in milliseconds since the epoch
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test115260() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, """", (-2147483572));
    assertEquals(28800000L, mutableDateTime0.getMillis());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test115261() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, """", (-2147483572));
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test115262() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, """", (-2147483572));
    assertNotSame(dateTimeFormatter1, dateTimeFormatter0);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test115263() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, """", (-2147483572));
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test115264() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZone(dateTimeZone0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, """", (-2147483572));
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test116266() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, ""wm3$+) RGKCU!k"", 65);
    assertTrue(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test116267() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, ""wm3$+) RGKCU!k"", 65);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test116268() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, ""wm3$+) RGKCU!k"", 65);
    assertEquals((-66), int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test116269() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, ""wm3$+) RGKCU!k"", 65);
    assertEquals(2000L, mutableDateTime0.getMillis());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test116270() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    MutableDateTime mutableDateTime0 = new MutableDateTime((long) 2000, (Chronology) null);
    int int0 = dateTimeFormatter1.parseInto(mutableDateTime0, ""wm3$+) RGKCU!k"", 65);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","public void test117271() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseInto((ReadWritableInstant) null, ""$[EY F5L9K-zf"", (-9));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Instant must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test118272() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateMidnight dateMidnight0 = new DateMidnight((long) 1900, (Chronology) null);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) null, (ReadableInstant) dateMidnight0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId"", e);
    }
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public void printTo(Writer out, ReadablePartial partial) throws IOException {
    DateTimePrinter printer = requirePrinter();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    printer.printTo(out, partial, iLocale);
}","public void test119273() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Composite0, dateTimeFormatterBuilder_Composite0);
    MockFile mockFile0 = new MockFile("""", ""/0YOV(t"");
    MockFileWriter mockFileWriter0 = new MockFileWriter(mockFile0, true);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) mockFileWriter0, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param out  the destination to format to, not null
 * @param partial  partial to format
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test120274() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""y&wP.N_\""3T.(S(5 F\""'"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-12L), (Chronology) iSOChronology0);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadablePartial) localTime0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test120275() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""y&wP.N_\""3T.(S(5 F\""'"");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-12L), (Chronology) iSOChronology0);
    dateTimeFormatter0.printTo((Writer) charArrayWriter0, (ReadablePartial) localTime0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
    appendable.append(print(partial));
}","public void test121276() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (byte) 73, (byte) 73);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_Fraction0, dateTimeFormatterBuilder_Fraction0);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""The partial must not be null"");
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) mockFileWriter0, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param appendable  the destination to format to, not null
 * @param partial  partial to format
 * @since 2.0
 */"
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test122277() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    Integer integer0 = Integer.valueOf((-1227));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((-1227));
    assertSame(dateTimeFormatter2, dateTimeFormatter1);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test122278() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    Integer integer0 = Integer.valueOf((-1227));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((-1227));
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test122279() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    Integer integer0 = Integer.valueOf((-1227));
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(integer0);
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withPivotYear((-1227));
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test123281() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test123282() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    assertFalse(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public DateTimeFormatter withZone(DateTimeZone zone) {
    if (iZone == zone) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);
}","public void test123283() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    assertNotSame(dateTimeFormatter2, dateTimeFormatter0);
}","/**
 * Returns a new formatter that will use the specified zone in preference
 * to the zone of the printed object, or default zone on a parse.
 * <p>
 * When printing, this zone will be used in preference to the zone
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this zone will be set on the parsed datetime.
 * <p>
 * A null zone means of no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param zone  the zone to use as an override
 * @return the new formatter
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test123284() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withZone(fixedDateTimeZone0);
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test124285() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology((Chronology) null);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will use the specified chronology in
 * preference to that of the printed object, or ISO on a parse.
 * <p>
 * When printing, this chronolgy will be used in preference to the chronology
 * from the datetime that would otherwise be used.
 * <p>
 * When parsing, this chronology will be set on the parsed datetime.
 * <p>
 * A null chronology means no-override.
 * If both an override chronology and an override zone are set, the
 * override zone will take precedence over the zone in the chronology.
 *
 * @param chrono  the chronology to use as an override
 * @return the new formatter
 */
public DateTimeFormatter withChronology(Chronology chrono) {
    if (iChrono == chrono) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
}","public void test124286() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology((Chronology) null);
    assertSame(dateTimeFormatter1, dateTimeFormatter0);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test124287() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_StringLiteral0, dateTimeFormatterBuilder_StringLiteral0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology((Chronology) null);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test125288() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertEquals(2000, dateTimeFormatter2.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test125289() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter that will create a datetime with a time zone
 * equal to that of the offset of the parsed string.
 * <p>
 * After calling this method, a string '2004-06-09T10:20:30-08:00' will
 * create a datetime with a zone of -08:00 (a fixed zone, with no daylight
 * savings rules). If the parsed string represents a local time (no zone
 * offset) the parsed datetime will be in the default zone.
 * <p>
 * Calling this method sets the override zone to null.
 * Calling the override zone method sets this flag off.
 *
 * @return the new formatter
 */
public DateTimeFormatter withOffsetParsed() {
    if (iOffsetParsed == true) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear);
}","public void test125290() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertSame(dateTimeFormatter2, dateTimeFormatter1);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test125291() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withOffsetParsed();
    DateTimeFormatter dateTimeFormatter2 = dateTimeFormatter1.withOffsetParsed();
    assertTrue(dateTimeFormatter2.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test126292() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale((Locale) null);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a new formatter with a different locale that will be used
 * for printing and parsing.
 * <p>
 * A DateTimeFormatter is immutable, so a new instance is returned,
 * and the original is unaltered and still usable.
 *
 * @param locale the locale to use; if null, formatter uses default locale
 * at invocation time
 * @return the new formatter
 */
public DateTimeFormatter withLocale(Locale locale) {
    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
        return this;
    }
    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}","public void test126293() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale((Locale) null);
    assertSame(dateTimeFormatter1, dateTimeFormatter0);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test126294() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withLocale((Locale) null);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test127295() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test127296() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test127297() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertTrue(boolean0);
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test128298() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test128299() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertFalse(boolean0);
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test128300() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 20503125, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, (DateTimeParser) null);
    boolean boolean0 = dateTimeFormatter0.isParser();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test129301() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test129302() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test129303() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertTrue(boolean0);
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test130304() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test130305() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertFalse(boolean0);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test130306() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(592, hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_TimeZoneName0);
    boolean boolean0 = dateTimeFormatter0.isPrinter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test131307() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getZone();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test131308() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getZone();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test132309() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getPivotYear();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test132310() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getPivotYear();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test133311() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getChronolgy();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test133312() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    dateTimeFormatter0.getChronolgy();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test134313() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeZone dateTimeZone0 = dateTimeFormatter1.getZone();
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test134314() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeZone dateTimeZone0 = dateTimeFormatter1.getZone();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public DateTimeZone getZone() {
    return iZone;
}","public void test134315() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeZone dateTimeZone0 = dateTimeFormatter1.getZone();
    assertNotNull(dateTimeZone0);
}","/**
 * Gets the zone to use as an override.
 *
 * @return the zone to use as an override
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test134316() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withZoneUTC();
    DateTimeZone dateTimeZone0 = dateTimeFormatter1.getZone();
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {
    appendable.append(print(instant));
}","public void test135317() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    Instant instant0 = new Instant((-1L));
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) null, (ReadableInstant) instant0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  instant to format, null means now
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test136318() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-477), hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    int int0 = dateTimeFormatter0.getDefaultYear();
    assertEquals(2000, int0);
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test136319() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-477), hashMap0);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneName0, dateTimeFormatterBuilder_TimeZoneName0);
    int int0 = dateTimeFormatter0.getDefaultYear();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
    appendable.append(print(partial));
}","public void test137320() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) null, (ReadablePartial) localDate0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadablePartial.
 * <p>
 * Neither the override chronology nor the override zone are used
 * by this method.
 *
 * @param appendable  the destination to format to, not null
 * @param partial  partial to format
 * @since 2.0
 */"
"public void printTo(Appendable appendable, long instant) throws IOException {
    appendable.append(print(instant));
}","public void test138321() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Appendable) null, (long) 1900);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param appendable  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test139322() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    boolean boolean0 = dateTimeFormatter0.isOffsetParsed();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test139323() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 1, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_FixedNumber0, dateTimeFormatterBuilder_FixedNumber0);
    boolean boolean0 = dateTimeFormatter0.isOffsetParsed();
    assertFalse(boolean0);
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Prints a ReadableInstant to a String.
 * <p>
 * This method will use the override zone and the override chronololgy if
 * they are set. Otherwise it will use the chronology and zone of the instant.
 *
 * @param instant  instant to format, null means now
 * @return the printed result
 */
public String print(ReadableInstant instant) {
    StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
    printTo(buf, instant);
    return buf.toString();
}","public void test140324() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateMidnight dateMidnight0 = new DateMidnight((long) 1900, (Chronology) null);
    String string0 = dateTimeFormatter0.print((ReadableInstant) dateMidnight0);
    assertEquals(""America/Los_Angeles"", string0);
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test140325() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateMidnight dateMidnight0 = new DateMidnight((long) 1900, (Chronology) null);
    String string0 = dateTimeFormatter0.print((ReadableInstant) dateMidnight0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test140326() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    DateMidnight dateMidnight0 = new DateMidnight((long) 1900, (Chronology) null);
    String string0 = dateTimeFormatter0.print((ReadableInstant) dateMidnight0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public DateTimeFormatter withPivotYear(int pivotYear) {
    return withPivotYear(Integer.valueOf(pivotYear));
}","public void test141327() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(2000);
    assertNotSame(dateTimeFormatter1, dateTimeFormatter0);
}","/**
 * Returns a new formatter that will use the specified pivot year for two
 * digit year parsing in preference to that stored in the parser.
 * <p>
 * This setting is useful for changing the pivot year of formats built
 * using a pattern - {@link DateTimeFormat#forPattern(String)}.
 * <p>
 * When parsing, this pivot year is used.
 * There is no effect when printing.
 * <p>
 * The pivot year enables a two digit year to be converted to a four
 * digit year. The pivot represents the year in the middle of the
 * supported range of years. Thus the full range of years that will
 * be built is <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivotYear  the pivot year to use as an override when parsing
 * @return the new formatter
 * @since 1.1
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test141328() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(2000);
    assertFalse(dateTimeFormatter1.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test141329() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(2000);
    assertEquals(2000, dateTimeFormatter1.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test141330() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, (-631), false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_FixedNumber0);
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withPivotYear(2000);
    assertEquals(2000, (int) dateTimeFormatter1.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public void printTo(Writer out, ReadableInstant instant) throws IOException {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    printTo(out, millis, chrono);
}","public void test142331() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral("""");
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter((DateTimePrinter) null, dateTimeFormatterBuilder_StringLiteral0);
    MutableDateTime mutableDateTime0 = dateTimeFormatter0.parseMutableDateTime("""");
    // Undeclared exception!
    try {
        dateTimeFormatter0.printTo((Writer) null, (ReadableInstant) mutableDateTime0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Printing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Prints a ReadableInstant, using the chronology supplied by the instant.
 *
 * @param out  the destination to format to, not null
 * @param instant  instant to format, null means now
 */"
"public void printTo(Writer out, long instant) throws IOException {
    printTo(out, instant, null);
}","public void test143332() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneId0, dateTimeFormatterBuilder_TimeZoneId0);
    PipedWriter pipedWriter0 = new PipedWriter();
    try {
        dateTimeFormatter0.printTo((Writer) pipedWriter0, 1L);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedWriter"", e);
    }
}","/**
 * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
 * using ISO chronology in the default DateTimeZone.
 *
 * @param out  the destination to format to, not null
 * @param instant  millis since 1970-01-01T00:00:00Z
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code MutableDateTime} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#dateTimeParser()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static MutableDateTime parse(String str) {
    return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());
}","public void test144333() throws Throwable {
    // Undeclared exception!
    try {
        MutableDateTime.parse(""6`'Jp"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""6`'Jp\"" is malformed at \""`'Jp\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public LocalDate parseLocalDate(String text) {
    return parseLocalDateTime(text).toLocalDate();
}","public void test145334() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""i@,+Nw"", """", false, 5, 5);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TimeZoneOffset0, dateTimeFormatterBuilder_TimeZoneOffset0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalDate(""org.joda.time.field.DividedDateTimeField"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""org.joda.time.field.DividedDateT...\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses only the local date from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local date will be used.
 * This means that any parsed time, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed date, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public LocalTime parseLocalTime(String text) {
    return parseLocalDateTime(text).toLocalTime();
}","public void test146335() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    // Undeclared exception!
    try {
        dateTimeFormatter0.parseLocalTime((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TextField"", e);
    }
}","/**
 * Parses only the local time from the given text, returning a new LocalDate.
 * <p>
 * This will parse the text fully according to the formatter, using the UTC zone.
 * Once parsed, only the local time will be used.
 * This means that any parsed date, time-zone or offset field is completely ignored.
 * It also means that the zone and offset-parsed settings are ignored.
 *
 * @param text  the text to parse, not null
 * @return the parsed time, never null
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the text to parse is invalid
 * @since 2.0
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test147336() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 20, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    dateTimeFormatter0.getChronology();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test147337() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfYear();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 20, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TwoDigitYear0, dateTimeFormatterBuilder_TwoDigitYear0);
    dateTimeFormatter0.getChronology();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
