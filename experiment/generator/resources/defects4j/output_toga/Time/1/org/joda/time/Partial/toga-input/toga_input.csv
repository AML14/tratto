focal_method,test_prefix,docstring
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test000() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[1];
    int[] intArray0 = new int[1];
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain null: index 0
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test011() throws Throwable {
    Partial partial0 = new Partial();
    assertEquals(0, partial0.size());
}",""
"public Partial plus(ReadablePeriod period) {
    return withPeriodAdded(period, 1);
}","public void test012() throws Throwable {
    Partial partial0 = new Partial();
    Minutes minutes0 = Minutes.minutes(20);
    Weeks weeks0 = minutes0.toStandardWeeks();
    Partial partial1 = partial0.plus(weeks0);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this instance with the specified period added.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the duration to add to this one, null means zero
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test013() throws Throwable {
    Partial partial0 = new Partial();
    Minutes minutes0 = Minutes.minutes(20);
    Weeks weeks0 = minutes0.toStandardWeeks();
    Partial partial1 = partial0.plus(weeks0);
    assertTrue(partial1.equals((Object) partial0));
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test024() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 23);
    Partial partial1 = partial0.without(dateTimeFieldType0);
    assertEquals(0, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test035() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Partial partial1 = partial0.withField(dateTimeFieldType0, 0);
    assertSame(partial1, partial0);
}",""
"public Partial minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test046() throws Throwable {
    Partial partial0 = new Partial();
    Partial partial1 = partial0.minus((ReadablePeriod) null);
    assertSame(partial0, partial1);
}","/**
 * Gets a copy of this instance with the specified period take away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this instance with the period taken away
 * @throws ArithmeticException if the new datetime exceeds the capacity of a long
 */"
"public DateTimeFieldType[] getFieldTypes() {
    return (DateTimeFieldType[]) iTypes.clone();
}","public void test057() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = partial0.getFieldTypes();
    assertEquals(0, dateTimeFieldTypeArray0.length);
}","/**
 * Gets an array of the field type of each of the fields that
 * this partial supports.
 * <p>
 * The fields are returned largest to smallest.
 *
 * @return the array of field types (cloned), largest to smallest
 */"
"public Partial(DateTimeFieldType type, int value) {
    this(type, value, null);
}","public void test1315() throws Throwable {
    Partial partial0 = null;
    try {
        partial0 = new Partial((DateTimeFieldType) null, (-101));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field type must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the default ISO chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values) {
    this(types, values, null);
}","public void test1416() throws Throwable {
    int[] intArray0 = new int[0];
    Partial partial0 = null;
    try {
        partial0 = new Partial((DateTimeFieldType[]) null, intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test1517() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[1];
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(julianChronology0);
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, (int[]) null, lenientChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Values array must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test1618() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[1];
    int[] intArray0 = new int[0];
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(35);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, ethiopicChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Values array must be the same length as the types array
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test1719() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[0];
    int[] intArray0 = new int[0];
    Partial partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, iSOChronology0);
    assertEquals(0, partial0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test1820() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 23);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekyearOfCentury();
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType1, 23);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain duplicate: yearOfCentury and weekyearOfCentury
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test1921() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 23);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.yearOfEra();
    Partial partial1 = partial0.with(dateTimeFieldType1, 23);
    assertEquals(2, partial1.size());
}",""
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test2022() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfWeek();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[4] = dateTimeFieldType0;
    int[] intArray0 = new int[5];
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, copticChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: dayOfWeek < year
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test2123() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.weekyear();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[3];
    dateTimeFieldTypeArray0[0] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[1] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[2] = dateTimeFieldType1;
    int[] intArray0 = new int[4];
    Partial partial0 = new Partial(buddhistChronology0, dateTimeFieldTypeArray0, intArray0);
    DateTimeFieldType dateTimeFieldType2 = DateTimeFieldType.halfdayOfDay();
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType2, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: yearOfCentury < weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test2224() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.year();
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType1, 255);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must not contain duplicate: year and weekyear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (types == null) {
        throw new IllegalArgumentException(""Types array must not be null"");
    }
    if (values == null) {
        throw new IllegalArgumentException(""Values array must not be null"");
    }
    if (values.length != types.length) {
        throw new IllegalArgumentException(""Values array must be the same length as the types array"");
    }
    if (types.length == 0) {
        iTypes = types;
        iValues = values;
        return;
    }
    for (int i = 0; i < types.length; i++) {
        if (types[i] == null) {
            throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
        }
    }
    DurationField lastUnitField = null;
    for (int i = 0; i < types.length; i++) {
        DateTimeFieldType loopType = types[i];
        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
        if (i > 0) {
            int compare = lastUnitField.compareTo(loopUnitField);
            if (compare < 0) {
                throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
            } else if (compare == 0) {
                if (types[i - 1].getRangeDurationType() == null) {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                } else {
                    if (loopType.getRangeDurationType() == null) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                    if (lastRangeField.compareTo(loopRangeField) < 0) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" + types[i - 1].getName() + "" < "" + loopType.getName());
                    }
                    if (lastRangeField.compareTo(loopRangeField) == 0) {
                        throw new IllegalArgumentException(""Types array must not contain duplicate: "" + types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
            }
        }
        lastUnitField = loopUnitField;
    }
    iTypes = (DateTimeFieldType[]) types.clone();
    chronology.validate(this, values);
    iValues = (int[]) values.clone();
}","public void test2325() throws Throwable {
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[8];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfYear();
    dateTimeFieldTypeArray0[1] = dateTimeFieldType1;
    dateTimeFieldTypeArray0[2] = dateTimeFieldTypeArray0[0];
    dateTimeFieldTypeArray0[3] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[4] = dateTimeFieldTypeArray0[2];
    dateTimeFieldTypeArray0[5] = dateTimeFieldTypeArray0[2];
    dateTimeFieldTypeArray0[6] = dateTimeFieldType0;
    dateTimeFieldTypeArray0[7] = dateTimeFieldTypeArray0[4];
    int[] intArray0 = new int[8];
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    IslamicChronology.LeapYearPatternType islamicChronology_LeapYearPatternType0 = IslamicChronology.LEAP_YEAR_INDIAN;
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance((DateTimeZone) fixedDateTimeZone0, islamicChronology_LeapYearPatternType0);
    Partial partial0 = null;
    try {
        partial0 = new Partial(dateTimeFieldTypeArray0, intArray0, islamicChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Types array must be in order largest-smallest: dayOfMonth < dayOfYear
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial with the specified fields and values.
 * The fields must be specified in the order largest to smallest.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param types  the types to create the partial from, not null
 * @param values  the values to store, not null
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the types or values are invalid
 */"
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test2426() throws Throwable {
    Partial partial0 = null;
    try {
        partial0 = new Partial((ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test2527() throws Throwable {
    Partial partial0 = new Partial();
    GJChronology gJChronology0 = GJChronology.getInstance();
    Partial partial1 = partial0.withChronologyRetainFields(gJChronology0);
    assertNotSame(partial1, partial0);
}",""
"//-----------------------------------------------------------------------
/**
 * Creates a new Partial instance with the specified chronology.
 * This instance is immutable and unaffected by this method call.
 * <p>
 * This method retains the values of the fields, thus the result will
 * typically refer to a different instant.
 * <p>
 * The time zone of the specified chronology is ignored, as Partial
 * operates without a time zone.
 *
 * @param newChronology  the new chronology, null means ISO
 * @return a copy of this datetime with a different chronology
 * @throws IllegalArgumentException if the values are invalid for the new chronology
 */
public Partial withChronologyRetainFields(Chronology newChronology) {
    newChronology = DateTimeUtils.getChronology(newChronology);
    newChronology = newChronology.withUTC();
    if (newChronology == getChronology()) {
        return this;
    } else {
        Partial newPartial = new Partial(newChronology, iTypes, iValues);
        newChronology.validate(newPartial, iValues);
        return newPartial;
    }
}","public void test2628() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Partial partial1 = partial0.withChronologyRetainFields(iSOChronology0);
    assertSame(partial1, partial0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test2729() throws Throwable {
    Partial partial0 = new Partial();
    // Undeclared exception!
    try {
        partial0.with((DateTimeFieldType) null, 256);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field type must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test2830() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Partial partial1 = partial0.with(dateTimeFieldType0, 0);
    assertSame(partial0, partial1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test2931() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType0, 1375);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 1375 for era must not be larger than 1
        //
        verifyException(""org.joda.time.chrono.BaseChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this date with the specified field set to a new value.
 * <p>
 * If this partial did not previously support the field, the new one will.
 * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed/added in the returned instance.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial with(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    int index = indexOf(fieldType);
    if (index == -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
        int[] newValues = new int[newTypes.length];
        // find correct insertion point to keep largest-smallest order
        int i = 0;
        DurationField unitField = fieldType.getDurationType().getField(iChronology);
        if (unitField.isSupported()) {
            for (; i < iTypes.length; i++) {
                DateTimeFieldType loopType = iTypes[i];
                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                if (loopUnitField.isSupported()) {
                    int compare = unitField.compareTo(loopUnitField);
                    if (compare > 0) {
                        break;
                    } else if (compare == 0) {
                        if (fieldType.getRangeDurationType() == null) {
                            break;
                        }
                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (rangeField.compareTo(loopRangeField) > 0) {
                            break;
                        }
                    }
                }
            }
        }
        System.arraycopy(iTypes, 0, newTypes, 0, i);
        System.arraycopy(iValues, 0, newValues, 0, i);
        newTypes[i] = fieldType;
        newValues[i] = value;
        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
        // use public constructor to ensure full validation
        // this isn't overly efficient, but is safe
        Partial newPartial = new Partial(newTypes, newValues, iChronology);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test3032() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.dayOfMonth();
    GJChronology gJChronology0 = GJChronology.getInstance((DateTimeZone) null, (-1L), 2);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[4];
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[2];
    Partial partial0 = new Partial(gJChronology0, dateTimeFieldTypeArray0, intArray0);
    // Undeclared exception!
    try {
        partial0.with(dateTimeFieldType1, (-460));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test3133() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    Partial partial0 = new Partial(dateTimeFieldType0, 8);
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.year();
    Partial partial1 = partial0.with(dateTimeFieldType1, 8);
    assertEquals(2, partial1.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test3234() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Partial partial1 = partial0.with(dateTimeFieldType0, 37);
    assertEquals(1, partial1.size());
}",""
"public Partial without(DateTimeFieldType fieldType) {
    int index = indexOf(fieldType);
    if (index != -1) {
        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];
        int[] newValues = new int[size() - 1];
        System.arraycopy(iTypes, 0, newTypes, 0, index);
        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);
        System.arraycopy(iValues, 0, newValues, 0, index);
        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);
        Partial newPartial = new Partial(iChronology, newTypes, newValues);
        iChronology.validate(newPartial, newValues);
        return newPartial;
    }
    return this;
}","public void test3335() throws Throwable {
    Partial partial0 = new Partial();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    Partial partial1 = partial0.without(dateTimeFieldType0);
    assertSame(partial0, partial1);
}","/**
 * Gets a copy of this date with the specified field removed.
 * <p>
 * If this partial did not previously support the field, no error occurs.
 *
 * @param fieldType  the field type to remove, may be null
 * @return a copy of this instance with the field removed
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a copy of this Partial with the specified field set to a new value.
 * <p>
 * If this partial does not support the field, an exception is thrown.
 * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.
 * <p>
 * For example, if the field type is <code>dayOfMonth</code> then the day
 * would be changed in the returned instance if supported.
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public Partial withField(DateTimeFieldType fieldType, int value) {
    int index = indexOfSupported(fieldType);
    if (value == getValue(index)) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).set(this, index, newValues, value);
    return new Partial(this, newValues);
}","public void test3436() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    // Undeclared exception!
    try {
        partial0.withField(dateTimeFieldType0, (-3596));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -3596 for yearOfCentury must be in the range [0,99]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test3537() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.era();
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[5];
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    int[] intArray0 = new int[0];
    Partial partial0 = new Partial((Chronology) null, dateTimeFieldTypeArray0, intArray0);
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    // Undeclared exception!
    try {
        partial0.withFieldAdded(durationFieldType0, 333);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.joda.time.field.BaseDateTimeField"", e);
    }
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).add(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test3638() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getDurationType();
    Partial partial1 = partial0.withFieldAdded(durationFieldType0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * However, it will not wrap around if the top maximum is reached.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {
    int index = indexOfSupported(fieldType);
    if (amount == 0) {
        return this;
    }
    int[] newValues = getValues();
    newValues = getField(index).addWrapPartial(this, index, newValues, amount);
    return new Partial(this, newValues);
}","public void test3739() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    JulianChronology julianChronology0 = JulianChronology.getInstance(dateTimeZone0);
    DateTimeFieldType[] dateTimeFieldTypeArray0 = new DateTimeFieldType[2];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    dateTimeFieldTypeArray0[0] = dateTimeFieldType0;
    DateTimeFieldType dateTimeFieldType1 = DateTimeFieldType.minuteOfHour();
    int[] intArray0 = new int[9];
    DurationFieldType durationFieldType0 = dateTimeFieldType1.getRangeDurationType();
    Partial partial0 = new Partial(julianChronology0, dateTimeFieldTypeArray0, intArray0);
    Partial partial1 = partial0.withFieldAddWrapped(durationFieldType0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the value of the specified field increased.
 * If this partial does not support the field, an exception is thrown.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * The addition will overflow into larger fields (eg. minute to hour).
 * If the maximum is reached, the addition will wra.
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test3840() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Hours hours0 = Hours.FIVE;
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Partial partial1 = partial0.withPeriodAdded(hours0, 0);
    assertSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    if (this == partial) {
        return true;
    }
    if (partial instanceof ReadablePartial == false) {
        return false;
    }
    ReadablePartial other = (ReadablePartial) partial;
    if (size() != other.size()) {
        return false;
    }
    for (int i = 0, isize = size(); i < isize; i++) {
        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {
            return false;
        }
    }
    return FieldUtils.equals(getChronology(), other.getChronology());
}","public void test3941() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) ethiopicChronology0);
    Partial partial0 = new Partial(localDateTime0);
    Days days0 = Days.SEVEN;
    Partial partial1 = partial0.withPeriodAdded(days0, 1);
    assertFalse(partial1.equals((Object) partial0));
}",""
"public Partial withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    int[] newValues = getValues();
    for (int i = 0; i < period.size(); i++) {
        DurationFieldType fieldType = period.getFieldType(i);
        int index = indexOf(fieldType);
        if (index >= 0) {
            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));
        }
    }
    return new Partial(this, newValues);
}","public void test3942() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) ethiopicChronology0);
    Partial partial0 = new Partial(localDateTime0);
    Days days0 = Days.SEVEN;
    Partial partial1 = partial0.withPeriodAdded(days0, 1);
    assertNotSame(partial1, partial0);
}","/**
 * Gets a copy of this Partial with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * Fields in the period that aren't present in the partial are ignored.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using the method
 * {@link #withFieldAdded(DurationFieldType, int)}.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this instance with the period added
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */"
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test4043() throws Throwable {
    Instant instant0 = new Instant();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    Partial partial0 = new Partial(dateTimeFieldType0, 8, (Chronology) null);
    boolean boolean0 = partial0.isMatch((ReadableInstant) instant0);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Does this partial match the specified instant.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified instant.
 *
 * @param instant  an instant to check against, null means now in default zone
 * @return true if this partial matches the specified instant
 */
public boolean isMatch(ReadableInstant instant) {
    long millis = DateTimeUtils.getInstantMillis(instant);
    Chronology chrono = DateTimeUtils.getInstantChronology(instant);
    for (int i = 0; i < iTypes.length; i++) {
        int value = iTypes[i].getField(chrono).get(millis);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test4144() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 8);
    Instant instant0 = new Instant();
    boolean boolean0 = partial0.isMatch((ReadableInstant) instant0);
    assertFalse(boolean0);
}",""
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test4245() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 15);
    boolean boolean0 = partial0.isMatch((ReadablePartial) partial0);
    assertTrue(boolean0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test4346() throws Throwable {
    Partial partial0 = new Partial();
    // Undeclared exception!
    try {
        partial0.isMatch((ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The partial must not be null
        //
        verifyException(""org.joda.time.Partial"", e);
    }
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"public boolean isMatch(ReadablePartial partial) {
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    for (int i = 0; i < iTypes.length; i++) {
        int value = partial.get(iTypes[i]);
        if (value != iValues[i]) {
            return false;
        }
    }
    return true;
}","public void test4447() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    Partial partial0 = new Partial(dateTimeFieldType0, 91);
    LocalDate localDate0 = new LocalDate();
    boolean boolean0 = partial0.isMatch((ReadablePartial) localDate0);
    assertFalse(boolean0);
}","/**
 * Does this partial match the specified partial.
 * <p>
 * A match occurs when all the fields of this partial are the same as the
 * corresponding fields on the specified partial.
 *
 * @param partial  a partial to check against, must not be null
 * @return true if this partial matches the specified partial
 * @throws IllegalArgumentException if the partial is null
 * @throws IllegalArgumentException if the fields of the two partials do not match
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test4548() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Locale locale0 = Locale.CANADA_FRENCH;
    partial0.toString((String) null, locale0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertNull(dateTimeFormatter0);
}",""
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test4649() throws Throwable {
    Partial partial0 = new Partial();
    String string0 = partial0.toString((String) null);
    assertEquals(""[]"", string0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test4750() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) ethiopicChronology0);
    Partial partial0 = new Partial(localDateTime0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = partial0.toString((String) null, locale0);
    assertEquals(""[year=2006, monthOfYear=6, dayOfMonth=7, millisOfDay=44481320]"", string0);
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test4851() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    Partial partial0 = new Partial(dateTimeFieldType0, 1647);
    String string0 = partial0.toString();
    assertEquals(""1647"", string0);
}",""
"//-----------------------------------------------------------------------
/**
 * Output the date in an appropriate ISO8601 format.
 * <p>
 * This method will output the partial in one of two ways.
 * If {@link #getFormatter()}
 * <p>
 * If there is no appropriate ISO format a dump of the fields is output
 * via {@link #toStringList()}.
 *
 * @return ISO8601 formatted string
 */
public String toString() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        getFormatter();
        f = iFormatter;
        if (f == null) {
            return toStringList();
        }
    }
    DateTimeFormatter f1 = f[1];
    if (f1 == null) {
        return toStringList();
    }
    return f1.print(this);
}","public void test4952() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    Partial partial0 = new Partial(dateTimeFieldType0, 0);
    Locale locale0 = Locale.UK;
    partial0.toString((String) null, locale0);
    String string0 = partial0.toString();
    assertEquals(""[yearOfCentury=0]"", string0);
}",""
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test5053() throws Throwable {
    Partial partial0 = new Partial();
    // Undeclared exception!
    try {
        partial0.toString(""Vh|w2kb2{.\""W9"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: V
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern, Locale locale) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test5154() throws Throwable {
    Partial partial0 = new Partial();
    Locale locale0 = Locale.CANADA_FRENCH;
    // Undeclared exception!
    try {
        partial0.toString(""A0P"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: A
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 * Unsupported fields will appear as special unicode characters.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
