focal_method,test_prefix,docstring
"public static GregorianChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, 4);
}","public void test00011() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName(2224, hashMap0);
    StringBuffer stringBuffer0 = new StringBuffer(2224);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance((DateTimeZone) null);
    assertNotNull(gregorianChronology0);
}","/**
 * Gets an instance of the GregorianChronology in the given time zone.
 *
 * @param zone  the time zone to get the chronology in, null is default
 * @return a chronology in the specified time zone
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a DateTimeFormatterBuilder.
 */
public DateTimeFormatterBuilder() {
    super();
    iElementPairs = new ArrayList<Object>();
}","public void test00131() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    assertNotNull(dateTimeFormatterBuilder0);
}",""
"public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);
}","public void test00132() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1862, 10);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends the print/parse of a fractional second.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 230 milliseconds.
 * Contrast this behaviour to {@link #appendMillisOfSecond}.
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) {
    return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));
}","public void test00135() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1862, 10);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder0.appendTimeZoneOffset(""vRAX$:X}6FxLJ"", true, 1862, 1862);
    assertNotNull(dateTimeFormatterBuilder2);
}","/**
 * Instructs the printer to emit text and numbers to display time zone
 * offset from UTC. A parser will use the parsed time zone offset to adjust
 * the datetime.
 * <p>
 * If zero offset text is supplied, then it will be printed when the zone is zero.
 * During parsing, either the zero offset text, or the offset will be parsed.
 *
 * @param zeroOffsetText  the text to use if time zone offset is zero. If
 * null, offset is always shown.
 * @param showSeparators  if true, prints ':' separator before minute and
 * second field and prints '.' separator before fraction field.
 * @param minFields  minimum number of fields to print, stopping when no
 * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
 * @param maxFields  maximum number of fields to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public boolean canBuildPrinter() {
    return isPrinter(getFormatter());
}","public void test00140() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1862, 10);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder0.appendTimeZoneOffset(""vRAX$:X}6FxLJ"", true, 1862, 1862);
    boolean boolean0 = dateTimeFormatterBuilder1.canBuildPrinter();
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder2);
}","/**
 * Returns true if toPrinter can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a printer can be built
 */"
"public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
    return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);
}","public void test00246() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric clockhourOfHalfday field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimePrinter toPrinter() {
    Object f = getFormatter();
    if (isPrinter(f)) {
        return (DateTimePrinter) f;
    }
    throw new UnsupportedOperationException(""Printing is not supported"");
}","public void test00249() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    assertNotNull(dateTimeFormatterBuilder_UnpaddedNumber0);
}","/**
 * Internal method to create a DateTimePrinter instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a printer in an application, call {@link #toFormatter()}
 * and just use the printing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned printer.
 *
 * @throws UnsupportedOperationException if printing is not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Get the millis of second field type.
 *
 * @return the DateTimeFieldType constant
 */
public static DateTimeFieldType millisOfSecond() {
    return MILLIS_OF_SECOND_TYPE;
}","public void test00254() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertNotNull(dateTimeFieldType0);
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test00255() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertEquals(""millisOfSecond"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test00256() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertEquals(""millisOfSecond"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test00258() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    assertEquals(""millisOfSecond"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test00259() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    assertEquals(""millisOfSecond"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatter(DateTimePrinter printer, DateTimeParser parser) {
    super();
    iPrinter = printer;
    iParser = parser;
    iLocale = null;
    iOffsetParsed = false;
    iChrono = null;
    iZone = null;
    iPivotYear = null;
    iDefaultYear = 2000;
}","public void test00262() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertNotNull(dateTimeFormatter0);
}","/**
 * Creates a new formatter, however you will normally use the factory
 * or the builder.
 *
 * @param printer  the internal printer, null if cannot print
 * @param parser  the internal parser, null if cannot parse
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test00266() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test00267() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertTrue(dateTimeFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test00268() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test00269() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test00270() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    assertNull(dateTimeFormatter0.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public static Instant parse(String str, DateTimeFormatter formatter) {
    return formatter.parseDateTime(str).toInstant();
}","public void test00271() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfHalfday(0);
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = (DateTimeFormatterBuilder.UnpaddedNumber) dateTimeFormatterBuilder1.toPrinter();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[5];
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 0);
    dateTimeParserArray0[1] = (DateTimeParser) dateTimeFormatterBuilder_Fraction0;
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_UnpaddedNumber0, dateTimeParserArray0[1]);
    // Undeclared exception!
    try {
        Instant.parse(""coIRk'*JYu"", dateTimeFormatter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""coIRk'*JYu\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a {@code Instant} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static GJChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
}","public void test00372() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the default GJ cutover
 * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
 * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
 * October 15, 1582 (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * <p>The returned chronology is in the default time zone.
 */"
"public static DateTimeFieldType weekOfWeekyear() {
    return WEEK_OF_WEEKYEAR_TYPE;
}","public void test00380() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the week of a week based year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test00381() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test00382() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test00385() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test00392() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    assertEquals((-1027), (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test00393() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test00394() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public String toString() {
    return getName();
}","public void test00396() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test00397() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test003107() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    int int0 = dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""org.joda.time.format.DateTimeFormatterBuilder"", 1440);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test003108() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    int int0 = dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""org.joda.time.format.DateTimeFormatterBuilder"", 1440);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test003109() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    int int0 = dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""org.joda.time.format.DateTimeFormatterBuilder"", 1440);
    assertEquals((-1027), (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test003110() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    int int0 = dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""org.joda.time.format.DateTimeFormatterBuilder"", 1440);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test003111() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    Integer integer0 = new Integer((-1027));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(100, gJChronology0, locale0, integer0, 1440);
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    int int0 = dateTimeFormatterBuilder_TextField0.parseInto(dateTimeParserBucket0, ""org.joda.time.format.DateTimeFormatterBuilder"", 1440);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the default time zone.
 * <p>
 * The default time zone is derived from the system property {@code user.timezone}.
 * If that is {@code null} or is not a valid identifier, then the value of the
 * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.
 * <p>
 * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this
 * method, then the change will not be picked up here.
 *
 * @return the default datetime zone object
 */
public static DateTimeZone getDefault() {
    DateTimeZone zone = cDefault;
    if (zone == null) {
        synchronized (DateTimeZone.class) {
            zone = cDefault;
            if (zone == null) {
                DateTimeZone temp = null;
                try {
                    try {
                        String id = System.getProperty(""user.timezone"");
                        if (id != null) {
                            // null check avoids stack overflow
                            temp = forID(id);
                        }
                    } catch (RuntimeException ex) {
                        // ignored
                    }
                    if (temp == null) {
                        temp = forTimeZone(TimeZone.getDefault());
                    }
                } catch (IllegalArgumentException ex) {
                    // ignored
                }
                if (temp == null) {
                    temp = UTC;
                }
                cDefault = zone = temp;
            }
        }
    }
    return zone;
}","public void test004117() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertNotNull(dateTimeZone0);
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test004118() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test004119() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static DateTimeFieldType hourOfHalfday() {
    return HOUR_OF_HALFDAY_TYPE;
}","public void test004127() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of am/pm (0-11) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test004128() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test004129() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test004131() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test004132() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static BuddhistChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test004135() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 * <p>
 * The time zone of the returned instance is UTC.
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test004140() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, 1757L, (Chronology) buddhistChronology0, 60, dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test004141() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, 1757L, (Chronology) buddhistChronology0, 60, dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test004148() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, 1757L, (Chronology) buddhistChronology0, 60, dateTimeZone0, locale0);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test004149() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.FRANCE;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 60, false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, 1757L, (Chronology) buddhistChronology0, 60, dateTimeZone0, locale0);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public Instant(Object instant) {
    super();
    InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
    iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());
}","public void test005152() throws Throwable {
    Instant instant0 = null;
    try {
        instant0 = new Instant(""DFdI~^pqIY$sv"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""DFdI~^pqIY$sv\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Constructs an instance from an Object that represents a datetime.
 * <p>
 * The recognised object types are defined in {@link ConverterManager} and
 * include String, Calendar and Date.
 *
 * @param instant  the datetime object, null means now
 * @throws IllegalArgumentException if the instant is invalid
 */"
"public Instant(Object instant) {
    super();
    InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
    iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());
}","public void test006153() throws Throwable {
    Instant instant0 = null;
    try {
        instant0 = new Instant("""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Constructs an instance from an Object that represents a datetime.
 * <p>
 * The recognised object types are defined in {@link ConverterManager} and
 * include String, Calendar and Date.
 *
 * @param instant  the datetime object, null means now
 * @throws IllegalArgumentException if the instant is invalid
 */"
"public static DateTimeFieldType yearOfCentury() {
    return YEAR_OF_CENTURY_TYPE;
}","public void test008158() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year of century field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test008159() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test008160() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, true));
}","public void test008161() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFixedSignedDecimal(dateTimeFieldType0, (-2537));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal number of digits: -2537
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an signed decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public static DateTimeFieldType halfdayOfDay() {
    return HALFDAY_OF_DAY_TYPE;
}","public void test009163() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the AM(0) PM(1) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test009164() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test009165() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, false));
}","public void test009166() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFixedDecimal(dateTimeFieldType0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal number of digits: 0
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an unsigned decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public static DateTimeFieldType yearOfCentury() {
    return YEAR_OF_CENTURY_TYPE;
}","public void test010167() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year of century field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test010168() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test010169() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test010171() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    assertEquals(""yearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test010172() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    assertEquals(""yearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test010176() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.estimatePrintedLength();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test010177() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.estimatePrintedLength();
    assertEquals(""yearOfCentury"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType hourOfHalfday() {
    return HOUR_OF_HALFDAY_TYPE;
}","public void test011180() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of am/pm (0-11) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test011181() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test011182() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test011184() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test011185() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test011189() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.estimatePrintedLength();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test011190() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.estimatePrintedLength();
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType centuryOfEra() {
    return CENTURY_OF_ERA_TYPE;
}","public void test014205() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the century of era field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test014206() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    assertEquals(""centuryOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test014207() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    assertEquals(""centuryOfEra"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test014209() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""centuryOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test014210() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""centuryOfEra"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test014214() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    int int0 = dateTimeFormatterBuilder_TextField0.estimatePrintedLength();
    assertEquals(""centuryOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test014215() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    int int0 = dateTimeFormatterBuilder_TextField0.estimatePrintedLength();
    assertEquals(""centuryOfEra"", dateTimeFieldType0.getName());
}",""
"public static GJChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
}","public void test015221() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the default GJ cutover
 * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
 * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
 * October 15, 1582 (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * <p>The returned chronology is in the default time zone.
 */"
"public static LenientChronology getInstance(Chronology base) {
    if (base == null) {
        throw new IllegalArgumentException(""Must supply a chronology"");
    }
    return new LenientChronology(base);
}","public void test015222() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    assertNotNull(lenientChronology0);
}","/**
 * Create a LenientChronology for any chronology.
 *
 * @param base the chronology to wrap
 * @throws IllegalArgumentException if chronology is null
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test015232() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test015239() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test015240() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test015241() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    assertEquals(0, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test015251() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    int int0 = dateTimeFormatterBuilder_StringLiteral0.parseInto(dateTimeParserBucket0, ""9LwO4!^S6wB"", (-1054));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test015252() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    int int0 = dateTimeFormatterBuilder_StringLiteral0.parseInto(dateTimeParserBucket0, ""9LwO4!^S6wB"", (-1054));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test015253() throws Throwable {
    DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral0 = new DateTimeFormatterBuilder.StringLiteral(""&ac/"");
    GJChronology gJChronology0 = GJChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(gJChronology0);
    Locale locale0 = Locale.GERMAN;
    Integer integer0 = new Integer(0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1000L, lenientChronology0, locale0, integer0, 16);
    int int0 = dateTimeFormatterBuilder_StringLiteral0.parseInto(dateTimeParserBucket0, ""9LwO4!^S6wB"", (-1054));
    assertEquals(0, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public static DateTimeFieldType hourOfDay() {
    return HOUR_OF_DAY_TYPE;
}","public void test018266() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of day (0-23) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test018267() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test018268() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test018270() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 57, true, 1);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test018271() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 57, true, 1);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test018275() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 57, true, 1);
    int int0 = dateTimeFormatterBuilder_PaddedNumber0.estimatePrintedLength();
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test018276() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 57, true, 1);
    int int0 = dateTimeFormatterBuilder_PaddedNumber0.estimatePrintedLength();
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static DateTimeFieldType minuteOfHour() {
    return MINUTE_OF_HOUR_TYPE;
}","public void test019279() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the minute of hour field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test019280() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test019281() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test019283() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 45, true, 0);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test019284() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 45, true, 0);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test019288() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 45, true, 0);
    int int0 = dateTimeFormatterBuilder_PaddedNumber0.estimateParsedLength();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test019289() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 45, true, 0);
    int int0 = dateTimeFormatterBuilder_PaddedNumber0.estimateParsedLength();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
    if (zone == null) {
        zone = DateTimeZone.getDefault();
    }
    BuddhistChronology chrono = cCache.get(zone);
    if (chrono == null) {
        // First create without a lower limit.
        chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
        // Impose lower limit and make another BuddhistChronology.
        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
        chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), """");
        cCache.put(zone, chrono);
    }
    return chrono;
}","public void test020302() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 *
 * @param zone  the time zone to use, null is default
 */"
"public static LenientChronology getInstance(Chronology base) {
    if (base == null) {
        throw new IllegalArgumentException(""Must supply a chronology"");
    }
    return new LenientChronology(base);
}","public void test020304() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    assertNotNull(lenientChronology0);
}","/**
 * Create a LenientChronology for any chronology.
 *
 * @param base the chronology to wrap
 * @throws IllegalArgumentException if chronology is null
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test020306() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test020314() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test020315() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test020316() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test020327() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    int int0 = dateTimeFormatterBuilder_MatchingParser0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 23);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test020328() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    int int0 = dateTimeFormatterBuilder_MatchingParser0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 23);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test020329() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[3];
    DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser0 = new DateTimeFormatterBuilder.MatchingParser(dateTimeParserArray0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance((DateTimeZone) null);
    LenientChronology lenientChronology0 = LenientChronology.getInstance(buddhistChronology0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1043L, lenientChronology0, locale0, (Integer) 1, 155);
    int int0 = dateTimeFormatterBuilder_MatchingParser0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 23);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public String toString() {
    return getName();
}","public void test021334() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test021335() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test021339() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    int int0 = dateTimeFormatterBuilder_Fraction0.estimatePrintedLength();
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test021340() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    int int0 = dateTimeFormatterBuilder_Fraction0.estimatePrintedLength();
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType halfdayOfDay() {
    return HALFDAY_OF_DAY_TYPE;
}","public void test027385() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the AM(0) PM(1) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test027386() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test027387() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test027389() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test027390() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public LocalTime(long instant, DateTimeZone zone) {
    this(instant, ISOChronology.getInstance(zone));
}","public void test027396() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    StringBuffer stringBuffer0 = new StringBuffer(58);
    LocalTime localTime0 = new LocalTime((long) 84, (DateTimeZone) null);
    assertNotNull(localTime0);
}","/**
 * Constructs an instance set to the local time defined by the specified
 * instant evaluated using ISO chronology in the specified zone.
 * <p>
 * If the specified time zone is null, the default zone is used.
 * Once the constructor is completed, the zone is no longer used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z
 * @param zone  the time zone, null means default zone
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute
 * and MillisOfSecond.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test027397() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    StringBuffer stringBuffer0 = new StringBuffer(58);
    LocalTime localTime0 = new LocalTime((long) 84, (DateTimeZone) null);
    assertEquals(4, localTime0.size());
}",""
"public String toString() {
    return getName();
}","public void test027405() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    StringBuffer stringBuffer0 = new StringBuffer(58);
    LocalTime localTime0 = new LocalTime((long) 84, (DateTimeZone) null);
    Locale locale0 = Locale.CHINA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) localTime0, locale0);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test027406() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    StringBuffer stringBuffer0 = new StringBuffer(58);
    LocalTime localTime0 = new LocalTime((long) 84, (DateTimeZone) null);
    Locale locale0 = Locale.CHINA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) localTime0, locale0);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute
 * and MillisOfSecond.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test027411() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 84, false);
    StringBuffer stringBuffer0 = new StringBuffer(58);
    LocalTime localTime0 = new LocalTime((long) 84, (DateTimeZone) null);
    Locale locale0 = Locale.CHINA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) localTime0, locale0);
    assertEquals(4, localTime0.size());
}",""
"public static GregorianChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), 4);
}","public void test028454() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    assertNotNull(gregorianChronology0);
}","/**
 * Gets an instance of the GregorianChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test028464() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test028471() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test028472() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    assertEquals((-1816), (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test028473() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone used by computeMillis.
 */
public DateTimeZone getZone() {
    return iZone;
}","public void test028474() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertNotNull(dateTimeZone0);
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test028481() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test028482() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals((-1816), (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test028483() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public String toString() {
    return getID();
}","public void test028484() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test028485() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test028503() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) outputStreamWriter0, (long) 0, (Chronology) gregorianChronology0, 0, dateTimeZone0, locale0);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test028504() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) outputStreamWriter0, (long) 0, (Chronology) gregorianChronology0, 0, dateTimeZone0, locale0);
    assertEquals((-1816), (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test028505() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) outputStreamWriter0, (long) 0, (Chronology) gregorianChronology0, 0, dateTimeZone0, locale0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public String toString() {
    return getID();
}","public void test028506() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) outputStreamWriter0, (long) 0, (Chronology) gregorianChronology0, 0, dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test028507() throws Throwable {
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber((DateTimeFieldType) null, 0, false);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    FilterOutputStream filterOutputStream0 = new FilterOutputStream(byteArrayOutputStream0);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(filterOutputStream0);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(objectOutputStream0, charsetEncoder0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstance();
    Locale locale0 = Locale.ITALY;
    Integer integer0 = new Integer((-1816));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(0, gregorianChronology0, locale0, integer0, 0);
    DateTimeZone dateTimeZone0 = dateTimeParserBucket0.getZone();
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) outputStreamWriter0, (long) 0, (Chronology) gregorianChronology0, 0, dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public static DateTimeFieldType weekyearOfCentury() {
    return WEEKYEAR_OF_CENTURY_TYPE;
}","public void test029508() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year of a week based year within a century field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test029509() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test029510() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets an instance of the EthiopicChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */
public static EthiopicChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test029514() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    assertNotNull(ethiopicChronology0);
}",""
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test029516() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"public String toString() {
    return getID();
}","public void test029517() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertEquals(""+00:00:00.445"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test029518() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test029519() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertEquals(""+00:00:00.445"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test029528() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test029529() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test029533() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (-5336536147L), (Chronology) ethiopicChronology0, 2526, dateTimeZone0, locale0);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test029534() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (-5336536147L), (Chronology) ethiopicChronology0, 2526, dateTimeZone0, locale0);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public String toString() {
    return getID();
}","public void test029537() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (-5336536147L), (Chronology) ethiopicChronology0, 2526, dateTimeZone0, locale0);
    assertEquals(""+00:00:00.445"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test029538() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (-5336536147L), (Chronology) ethiopicChronology0, 2526, dateTimeZone0, locale0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test029539() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65, true);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (-5336536147L), (Chronology) ethiopicChronology0, 2526, dateTimeZone0, locale0);
    assertEquals(""+00:00:00.445"", dateTimeZone0.getID());
}",""
"public static EthiopicChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), 4);
}","public void test030556() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-403), hashMap0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    assertNotNull(ethiopicChronology0);
}","/**
 * Gets an instance of the EthiopicChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test030565() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-403), hashMap0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.FRENCH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(48L, ethiopicChronology0, locale0, (Integer) null, (-403));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test030573() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-403), hashMap0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.FRENCH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(48L, ethiopicChronology0, locale0, (Integer) null, (-403));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test030574() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-403), hashMap0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.FRENCH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(48L, ethiopicChronology0, locale0, (Integer) null, (-403));
    assertNull(dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test030575() throws Throwable {
    HashMap<String, DateTimeZone> hashMap0 = new HashMap<String, DateTimeZone>();
    DateTimeFormatterBuilder.TimeZoneName dateTimeFormatterBuilder_TimeZoneName0 = new DateTimeFormatterBuilder.TimeZoneName((-403), hashMap0);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    Locale locale0 = Locale.FRENCH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(48L, ethiopicChronology0, locale0, (Integer) null, (-403));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"public String toString() {
    return getName();
}","public void test031581() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test031582() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {
    return forOffsetHoursMinutes(hoursOffset, 0);
}","public void test031588() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in hours.
 * This method assumes standard length hours.
 * <p>
 * This factory is a convenient way of constructing zones with a fixed offset.
 *
 * @param hoursOffset  the offset in hours from UTC
 * @return the DateTimeZone object for the offset
 * @throws IllegalArgumentException if the offset is too large or too small
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test031589() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test031590() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    assertEquals(""+02:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test031591() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    assertEquals(""+02:00"", dateTimeZone0.getID());
}",""
"public YearMonth(DateTimeZone zone) {
    super(ISOChronology.getInstance(zone));
}","public void test031592() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertNotNull(yearMonth0);
}","/**
 * Constructs a YearMonth with the current year-month, using ISOChronology in
 * the specified zone to extract the fields.
 * <p>
 * The constructor uses the specified time zone to obtain the current year-month.
 * Once the constructor is complete, all further calculations
 * are performed without reference to a time-zone (by switching to UTC).
 *
 * @param zone  the zone to use, null means default zone
 * @see #now(DateTimeZone)
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test031595() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test031596() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertEquals(""+02:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test031597() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertEquals(""+02:00"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the year field value.
 *
 * @return the year
 */
public int getYear() {
    return getValue(YEAR);
}","public void test031598() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertEquals(2014, yearMonth0.getYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are Year and MonthOfYear.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test031599() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertEquals(2, yearMonth0.size());
}",""
"public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test031600() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    assertEquals(2, yearMonth0.getMonthOfYear());
}","/**
 * Get the month of year field value.
 *
 * @return the month of year
 */"
"public String toString() {
    return getName();
}","public void test031610() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test031611() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test031616() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test031617() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""+02:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test031618() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""+02:00"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the year field value.
 *
 * @return the year
 */
public int getYear() {
    return getValue(YEAR);
}","public void test031619() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(2014, yearMonth0.getYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are Year and MonthOfYear.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test031620() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(2, yearMonth0.size());
}",""
"public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test031621() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    StringBuffer stringBuffer0 = new StringBuffer(""56YZ0]vD<'tk9?n0L"");
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(2);
    YearMonth yearMonth0 = new YearMonth(dateTimeZone0);
    Locale locale0 = Locale.TAIWAN;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(2, yearMonth0.getMonthOfYear());
}","/**
 * Get the month of year field value.
 *
 * @return the month of year
 */"
"public String toString() {
    return getName();
}","public void test032632() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test032633() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"public static BuddhistChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test032666() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 * <p>
 * The time zone of the returned instance is UTC.
 */"
"public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {
    return forOffsetHoursMinutes(hoursOffset, 0);
}","public void test032668() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in hours.
 * This method assumes standard length hours.
 * <p>
 * This factory is a convenient way of constructing zones with a fixed offset.
 *
 * @param hoursOffset  the offset in hours from UTC
 * @return the DateTimeZone object for the offset
 * @throws IllegalArgumentException if the offset is too large or too small
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test032669() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test032670() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test032671() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public String toString() {
    return getName();
}","public void test032682() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    Locale locale0 = Locale.US;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, 2814L, (Chronology) buddhistChronology0, (-1858), dateTimeZone0, locale0);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test032683() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    Locale locale0 = Locale.US;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, 2814L, (Chronology) buddhistChronology0, (-1858), dateTimeZone0, locale0);
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test032699() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    Locale locale0 = Locale.US;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, 2814L, (Chronology) buddhistChronology0, (-1858), dateTimeZone0, locale0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test032700() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    Locale locale0 = Locale.US;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, 2814L, (Chronology) buddhistChronology0, (-1858), dateTimeZone0, locale0);
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test032701() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, false);
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    Locale locale0 = Locale.US;
    dateTimeFormatterBuilder_TextField0.printTo(stringBuffer0, 2814L, (Chronology) buddhistChronology0, (-1858), dateTimeZone0, locale0);
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test033712() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test033713() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets an instance of the EthiopicChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */
public static EthiopicChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test033719() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    assertNotNull(ethiopicChronology0);
}",""
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test033721() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"public String toString() {
    return getID();
}","public void test033722() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertEquals(""+00:00:00.445"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test033723() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertEquals(""+00:00:00.445"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test033724() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    assertTrue(dateTimeZone0.isFixed());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test033733() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    dateTimeFormatterBuilder_PaddedNumber0.printTo(stringBuffer0, (long) 2300, (Chronology) ethiopicChronology0, (-1611), dateTimeZone0, locale0);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test033734() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    dateTimeFormatterBuilder_PaddedNumber0.printTo(stringBuffer0, (long) 2300, (Chronology) ethiopicChronology0, (-1611), dateTimeZone0, locale0);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public String toString() {
    return getID();
}","public void test033739() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    dateTimeFormatterBuilder_PaddedNumber0.printTo(stringBuffer0, (long) 2300, (Chronology) ethiopicChronology0, (-1611), dateTimeZone0, locale0);
    assertEquals(""+00:00:00.445"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test033740() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    dateTimeFormatterBuilder_PaddedNumber0.printTo(stringBuffer0, (long) 2300, (Chronology) ethiopicChronology0, (-1611), dateTimeZone0, locale0);
    assertEquals(""+00:00:00.445"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test033741() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 2300, false, 85);
    StringBuffer stringBuffer0 = new StringBuffer(85);
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(445);
    Locale locale0 = Locale.CHINESE;
    dateTimeFormatterBuilder_PaddedNumber0.printTo(stringBuffer0, (long) 2300, (Chronology) ethiopicChronology0, (-1611), dateTimeZone0, locale0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
    return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);
}","public void test034749() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendSecondOfMinute(34);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric secondOfMinute field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);
}","public void test035753() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendSecondOfDay(6);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric secondOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Calls upon {@link DateTimeFormat} to parse the pattern and append the
 * results into this builder.
 *
 * @param pattern  pattern specification
 * @throws IllegalArgumentException if the pattern is invalid
 * @see DateTimeFormat
 */
public DateTimeFormatterBuilder appendPattern(String pattern) {
    DateTimeFormat.appendPatternTo(this, pattern);
    return this;
}","public void test036757() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendPattern("""");
    assertNotNull(dateTimeFormatterBuilder1);
}",""
"public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);
}","public void test037761() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMillisOfDay(329);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric millisOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);
}","public void test038765() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfMinute(2224, 2);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends the print/parse of a fractional minute.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);
}","public void test039769() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfHour(5, (-309));
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends the print/parse of a fractional hour.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);
}","public void test040773() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfDay(366, 366);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends the print/parse of a fractional day.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 days (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);
}","public void test041777() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfYear(0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric dayOfYear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);
}","public void test042781() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfWeek(2139);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric dayOfWeek field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);
}","public void test043785() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendClockhourOfDay(65533);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric clockhourOfDay field.
 *
 * @param minDigits minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);
}","public void test044789() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendCenturyOfEra(366, 15356250);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric century of era field.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {
    return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);
}","public void test045793() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendYearOfCentury((-2450), 2986);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric year of century field.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);
}","public void test046795() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendYear(0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric year field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);
}","public void test047797() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendWeekyear(0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric weekyear field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
    return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);
}","public void test048799() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendWeekOfWeekyear((-758));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric weekOfWeekyear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) {
    return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));
}","public void test049801() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendTimeZoneOffset((String) null, true, (-1293), 913);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset"", e);
    }
}","/**
 * Instructs the printer to emit text and numbers to display time zone
 * offset from UTC. A parser will use the parsed time zone offset to adjust
 * the datetime.
 * <p>
 * If zero offset text is supplied, then it will be printed when the zone is zero.
 * During parsing, either the zero offset text, or the offset will be parsed.
 *
 * @param zeroOffsetText  the text to use if time zone offset is zero. If
 * null, offset is always shown.
 * @param showSeparators  if true, prints ':' separator before minute and
 * second field and prints '.' separator before fraction field.
 * @param minFields  minimum number of fields to print, stopping when no
 * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
 * @param maxFields  maximum number of fields to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Calls upon {@link DateTimeFormat} to parse the pattern and append the
 * results into this builder.
 *
 * @param pattern  pattern specification
 * @throws IllegalArgumentException if the pattern is invalid
 * @see DateTimeFormat
 */
public DateTimeFormatterBuilder appendPattern(String pattern) {
    DateTimeFormat.appendPatternTo(this, pattern);
    return this;
}","public void test050803() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendPattern((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}",""
"public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
    checkParser(parser);
    DateTimeParser[] parsers = new DateTimeParser[] { parser, null };
    return append0(null, new MatchingParser(parsers));
}","public void test051805() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendOptional((DateTimeParser) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No parser supplied
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends just a parser element which is optional. With no matching
 * printer, a printer cannot be built from this DateTimeFormatterBuilder.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if parser is null or of an invalid type
 */"
"public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
    return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);
}","public void test052807() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendMonthOfYear((-2155));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric monthOfYear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
    return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);
}","public void test053809() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendMinuteOfHour((-204));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric minuteOfHour field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);
}","public void test054811() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendMinuteOfDay((-2801));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric minuteOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
    return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);
}","public void test055813() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendMillisOfSecond((-504));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric millisOfSecond field.
 * <p>
 * This method will append a field that prints a three digit value.
 * During parsing the value that is parsed is assumed to be three digits.
 * If less than three digits are present then they will be counted as the
 * smallest parts of the millisecond. This is probably not what you want
 * if you are using the field as a fraction. Instead, a fractional
 * millisecond should be produced using {@link #appendFractionOfSecond}.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
    return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);
}","public void test056815() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendHourOfHalfday((-674));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric hourOfHalfday field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);
}","public void test057817() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendHourOfDay((-215));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric hourOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);
}","public void test058819() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFractionOfSecond(0, (-1861));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends the print/parse of a fractional second.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 230 milliseconds.
 * Contrast this behaviour to {@link #appendMillisOfSecond}.
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);
}","public void test059821() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDayOfMonth((-632));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric dayOfMonth field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
    return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);
}","public void test060823() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendClockhourOfHalfday((-3258));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric clockhourOfHalfday field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a DateTimeFormatterBuilder.
 */
public DateTimeFormatterBuilder() {
    super();
    iElementPairs = new ArrayList<Object>();
}","public void test061832() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    assertNotNull(dateTimeFormatterBuilder0);
}",""
"public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
    if (printer != null) {
        checkPrinter(printer);
    }
    if (parsers == null) {
        throw new IllegalArgumentException(""No parsers supplied"");
    }
    int length = parsers.length;
    if (length == 1) {
        if (parsers[0] == null) {
            throw new IllegalArgumentException(""No parser supplied"");
        }
        return append0(printer, parsers[0]);
    }
    DateTimeParser[] copyOfParsers = new DateTimeParser[length];
    int i;
    for (i = 0; i < length - 1; i++) {
        if ((copyOfParsers[i] = parsers[i]) == null) {
            throw new IllegalArgumentException(""Incomplete parser array"");
        }
    }
    copyOfParsers[i] = parsers[i];
    return append0(printer, new MatchingParser(copyOfParsers));
}","public void test061833() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-754), true);
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[0];
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimePrinter) dateTimeFormatterBuilder_TwoDigitYear0, dateTimeParserArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends a printer and a set of matching parsers. When parsing, the first
 * parser in the list is selected for parsing. If it fails, the next is
 * chosen, and so on. If none of these parsers succeeds, then the failed
 * position of the parser that made the greatest progress is returned.
 * <p>
 * Only the printer is optional. In addition, it is illegal for any but the
 * last of the parser array elements to be null. If the last element is
 * null, this represents the empty parser. The presence of an empty parser
 * indicates that the entire array of parse formats is optional.
 *
 * @param printer  the printer to add
 * @param parsers  the parsers to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if any printer or parser is of an invalid type
 * @throws IllegalArgumentException if any parser element but the last is null
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer) {
    checkPrinter(printer);
    return append0(printer, null);
}","public void test062835() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimePrinter) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No printer supplied
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends just a printer. With no matching parser, a parser cannot be
 * built from this DateTimeFormatterBuilder.
 *
 * @param printer  the printer to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if printer is null or of an invalid type
 */"
"public static DateTimeFieldType dayOfMonth() {
    return DAY_OF_MONTH_TYPE;
}","public void test063837() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the day of month field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test063838() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertEquals(""dayOfMonth"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test063839() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertEquals(""dayOfMonth"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    return append0(new Fraction(fieldType, minDigits, maxDigits));
}","public void test063840() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFraction(dateTimeFieldType0, 0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a remainder of time as a decimal fraction,
 * without decimal point. For example, if the field is specified as
 * minuteOfHour and the time is 12:30:45, the value printed is 75. A
 * decimal point is implied, so the fraction is 0.75, or three-quarters of
 * a minute.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to print.
 * @param maxDigits  maximum number of digits to print or parse.
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public static DateTimeFieldType minuteOfHour() {
    return MINUTE_OF_HOUR_TYPE;
}","public void test064842() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the minute of hour field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test064843() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test064844() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    assertEquals(""minuteOfHour"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    return append0(new Fraction(fieldType, minDigits, maxDigits));
}","public void test064845() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfHour();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFraction(dateTimeFieldType0, (-594), (-594));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a remainder of time as a decimal fraction,
 * without decimal point. For example, if the field is specified as
 * minuteOfHour and the time is 12:30:45, the value printed is 75. A
 * decimal point is implied, so the fraction is 0.75, or three-quarters of
 * a minute.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to print.
 * @param maxDigits  maximum number of digits to print or parse.
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public static DateTimeFieldType secondOfMinute() {
    return SECOND_OF_MINUTE_TYPE;
}","public void test065847() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the second of minute field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test065848() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertEquals(""secondOfMinute"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test065849() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    return append0(new Fraction(fieldType, minDigits, maxDigits));
}","public void test065850() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFraction(dateTimeFieldType0, 1000, 100);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a remainder of time as a decimal fraction,
 * without decimal point. For example, if the field is specified as
 * minuteOfHour and the time is 12:30:45, the value printed is 75. A
 * decimal point is implied, so the fraction is 0.75, or three-quarters of
 * a minute.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to print.
 * @param maxDigits  maximum number of digits to print or parse.
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public String toString() {
    return getName();
}","public void test065853() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFraction(dateTimeFieldType0, 1000, 100);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test065854() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFraction(dateTimeFieldType0, 1000, 100);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType minuteOfDay() {
    return MINUTE_OF_DAY_TYPE;
}","public void test066856() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the minute of day field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test066857() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test066858() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    return append0(new TextField(fieldType, true));
}","public void test066859() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendShortText(dateTimeFieldType0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as short text, and the
 * parser to expect text.
 *
 * @param fieldType  type of field to append
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test066862() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendShortText(dateTimeFieldType0);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test066863() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendShortText(dateTimeFieldType0);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a DateTimeFormatterBuilder.
 */
public DateTimeFormatterBuilder() {
    super();
    iElementPairs = new ArrayList<Object>();
}","public void test067867() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    assertNotNull(dateTimeFormatterBuilder0);
}",""
"public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    return append0(new TextField(fieldType, false));
}","public void test067868() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendText(dateTimeFieldType0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as text, and the
 * parser to expect text.
 *
 * @param fieldType  type of field to append
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public String toString() {
    return getName();
}","public void test067871() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendText(dateTimeFieldType0);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test067872() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendText(dateTimeFieldType0);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, true));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
    }
}","public void test068877() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendSignedDecimal(dateTimeFieldType0, (-3430), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect a signed decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public static DateTimeFieldType clockhourOfHalfday() {
    return CLOCKHOUR_OF_HALFDAY_TYPE;
}","public void test069879() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of am/pm (offset to 1-12) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test069880() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    assertEquals(""clockhourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test069881() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    assertEquals(""clockhourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, true));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
    }
}","public void test069882() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendSignedDecimal(dateTimeFieldType0, 3600000, 1492);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect a signed decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public String toString() {
    return getName();
}","public void test069885() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendSignedDecimal(dateTimeFieldType0, 3600000, 1492);
    assertEquals(""clockhourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test069886() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendSignedDecimal(dateTimeFieldType0, 3600000, 1492);
    assertEquals(""clockhourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType hourOfDay() {
    return HOUR_OF_DAY_TYPE;
}","public void test070888() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of day (0-23) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test070889() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test070890() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, false));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
    }
}","public void test070891() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 0, 13);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect an unsigned decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public String toString() {
    return getName();
}","public void test070894() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 0, 13);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test070895() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 0, 13);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, false));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
    }
}","public void test071900() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, (-513), 65533);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect an unsigned decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, false));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
    }
}","public void test072905() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 1660, 0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect an unsigned decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test072908() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 1660, 0);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test072909() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 1660, 0);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static DateTimeFieldType monthOfYear() {
    return MONTH_OF_YEAR_TYPE;
}","public void test073911() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the month of year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test073912() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    assertEquals(""monthOfYear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test073913() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    assertEquals(""monthOfYear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, false));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
    }
}","public void test073914() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.monthOfYear();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDecimal(dateTimeFieldType0, 0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect an unsigned decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public DateTimeFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    switch(text.length()) {
        case 0:
            return this;
        case 1:
            return append0(new CharacterLiteral(text.charAt(0)));
        default:
            return append0(new StringLiteral(text));
    }
}","public void test074916() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendLiteral(""org.joda.time.DateTime"");
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit specific text, and the parser to expect
 * it. The parser is case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if text is null
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
    if (printer != null) {
        checkPrinter(printer);
    }
    if (parsers == null) {
        throw new IllegalArgumentException(""No parsers supplied"");
    }
    int length = parsers.length;
    if (length == 1) {
        if (parsers[0] == null) {
            throw new IllegalArgumentException(""No parser supplied"");
        }
        return append0(printer, parsers[0]);
    }
    DateTimeParser[] copyOfParsers = new DateTimeParser[length];
    int i;
    for (i = 0; i < length - 1; i++) {
        if ((copyOfParsers[i] = parsers[i]) == null) {
            throw new IllegalArgumentException(""Incomplete parser array"");
        }
    }
    copyOfParsers[i] = parsers[i];
    return append0(printer, new MatchingParser(copyOfParsers));
}","public void test075920() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[8];
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimePrinter) null, dateTimeParserArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Incomplete parser array
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends a printer and a set of matching parsers. When parsing, the first
 * parser in the list is selected for parsing. If it fails, the next is
 * chosen, and so on. If none of these parsers succeeds, then the failed
 * position of the parser that made the greatest progress is returned.
 * <p>
 * Only the printer is optional. In addition, it is illegal for any but the
 * last of the parser array elements to be null. If the last element is
 * null, this represents the empty parser. The presence of an empty parser
 * indicates that the entire array of parse formats is optional.
 *
 * @param printer  the printer to add
 * @param parsers  the parsers to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if any printer or parser is of an invalid type
 * @throws IllegalArgumentException if any parser element but the last is null
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs a LocalDateTime from a <code>java.util.Calendar</code>
 * using exactly the same field values.
 * <p>
 * Each field is queried from the Calendar and assigned to the LocalDateTime.
 * This is useful if you have been using the Calendar as a local date,
 * ignoring the zone.
 * <p>
 * One advantage of this method is that this method is unaffected if the
 * version of the time zone data differs between the JDK and Joda-Time.
 * That is because the local field values are transferred, calculated using
 * the JDK time zone data and without using the Joda-Time time zone data.
 * <p>
 * This factory method ignores the type of the calendar and always
 * creates a LocalDateTime with ISO chronology. It is expected that you
 * will only pass in instances of <code>GregorianCalendar</code> however
 * this is not validated.
 *
 * @param calendar  the Calendar to extract fields from
 * @return the created LocalDateTime
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 */
public static LocalDateTime fromCalendarFields(Calendar calendar) {
    if (calendar == null) {
        throw new IllegalArgumentException(""The calendar must not be null"");
    }
    return new LocalDateTime(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));
}","public void test076927() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    assertNotNull(localDateTime0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test076932() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    assertEquals(4, localDateTime0.size());
}",""
"public Partial(ReadablePartial partial) {
    super();
    if (partial == null) {
        throw new IllegalArgumentException(""The partial must not be null"");
    }
    iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();
    iTypes = new DateTimeFieldType[partial.size()];
    iValues = new int[partial.size()];
    for (int i = 0; i < partial.size(); i++) {
        iTypes[i] = partial.getFieldType(i);
        iValues[i] = partial.getValue(i);
    }
}","public void test076933() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    assertNotNull(partial0);
}","/**
 * Constructs a Partial by copying all the fields and types from
 * another partial.
 * <p>
 * This is most useful when copying from a YearMonthDay or TimeOfDay.
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test076938() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    assertEquals(4, localDateTime0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test076939() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    assertEquals(4, partial0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets a formatter suitable for the fields in this partial.
 * <p>
 * If there is no appropriate ISO format, null is returned.
 * This method may return a formatter that does not display all the
 * fields of the partial. This might occur when you have overlapping
 * fields, such as dayOfWeek and dayOfMonth.
 *
 * @return a formatter suitable for the fields in this partial, null
 *  if none is suitable
 */
public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] f = iFormatter;
    if (f == null) {
        if (size() == 0) {
            return null;
        }
        f = new DateTimeFormatter[2];
        try {
            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));
            f[0] = ISODateTimeFormat.forFields(list, true, false);
            if (list.size() == 0) {
                f[1] = f[0];
            }
        } catch (IllegalArgumentException ex) {
            // ignore
        }
        iFormatter = f;
    }
    return f[0];
}","public void test076940() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertNotNull(dateTimeFormatter0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test076945() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertEquals(4, localDateTime0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test076946() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertEquals(4, partial0.size());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test076947() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test076948() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test076949() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test076950() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertTrue(dateTimeFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test076951() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    assertNull(dateTimeFormatter0.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Appends another formatter.
 *
 * @param formatter  the formatter to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if formatter is null or of an invalid type
 */
public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
    if (formatter == null) {
        throw new IllegalArgumentException(""No formatter supplied"");
    }
    return append0(formatter.getPrinter(), formatter.getParser());
}","public void test076952() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertNotNull(dateTimeFormatterBuilder1);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test076959() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertEquals(4, localDateTime0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test076960() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertEquals(4, partial0.size());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test076961() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test076962() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test076963() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test076964() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertTrue(dateTimeFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test076965() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    Calendar calendar0 = MockCalendar.getInstance();
    LocalDateTime localDateTime0 = LocalDateTime.fromCalendarFields(calendar0);
    Partial partial0 = new Partial(localDateTime0);
    DateTimeFormatter dateTimeFormatter0 = partial0.getFormatter();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append(dateTimeFormatter0);
    assertNull(dateTimeFormatter0.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public DateTimeFormatterBuilder append(DateTimeParser parser) {
    checkParser(parser);
    return append0(null, parser);
}","public void test077970() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends just a parser. With no matching printer, a printer cannot be
 * built from this builder.
 *
 * @param parser  the parser to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if parser is null or of an invalid type
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs a DateTimeFormatter using all the appended elements.
 * <p>
 * This is the main method used by applications at the end of the build
 * process to create a usable formatter.
 * <p>
 * Subsequent changes to this builder do not affect the returned formatter.
 * <p>
 * The returned formatter may not support both printing and parsing.
 * The methods {@link DateTimeFormatter#isPrinter()} and
 * {@link DateTimeFormatter#isParser()} will help you determine the state
 * of the formatter.
 *
 * @throws UnsupportedOperationException if neither printing nor parsing is supported
 */
public DateTimeFormatter toFormatter() {
    Object f = getFormatter();
    DateTimePrinter printer = null;
    if (isPrinter(f)) {
        printer = (DateTimePrinter) f;
    }
    DateTimeParser parser = null;
    if (isParser(f)) {
        parser = (DateTimeParser) f;
    }
    if (printer != null || parser != null) {
        return new DateTimeFormatter(printer, parser);
    }
    throw new UnsupportedOperationException(""Both printing and parsing not supported"");
}","public void test077975() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertNotNull(dateTimeFormatter0);
}",""
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test077977() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test077978() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test077979() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertNull(dateTimeFormatter0.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test077980() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test077981() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormat.StyleFormatter dateTimeFormat_StyleFormatter0 = new DateTimeFormat.StyleFormatter(3600000, 1584, 3600000);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimeParser) dateTimeFormat_StyleFormatter0);
    DateTimeFormatter dateTimeFormatter0 = dateTimeFormatterBuilder0.toFormatter();
    assertTrue(dateTimeFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
    return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);
}","public void test078983() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendWeekOfWeekyear(122);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric weekOfWeekyear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);
}","public void test079987() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendHourOfDay(10209375);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric hourOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
    return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);
}","public void test080991() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendSecondOfMinute((-1310));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric secondOfMinute field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);
}","public void test081993() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfMonth(10209375);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric dayOfMonth field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
    return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);
}","public void test082997() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMonthOfYear(59);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric monthOfYear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfWeekShortText() {
    return appendShortText(DateTimeFieldType.dayOfWeek());
}","public void test0831001() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfWeekShortText();
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a short locale-specific dayOfWeek
 * text. The parser will accept a long or short dayOfWeek text,
 * case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);
}","public void test0841005() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDayOfWeek((-1000));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric dayOfWeek field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {
    return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));
}","public void test0851007() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTwoDigitWeekyear(11, true);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric weekyear field which always prints
 * two digits. A pivot year is used during parsing to determine the range
 * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If
 * parse is instructed to be lenient and the digit count is not two, it is
 * treated as an absolute weekyear. With lenient parsing, specifying a positive
 * or negative sign before the weekyear also makes it absolute.
 *
 * @param pivot  pivot weekyear to use when parsing
 * @param lenientParse  when true, if digit count is not two, it is treated
 * as an absolute weekyear
 * @return this DateTimeFormatterBuilder, for chaining
 * @since 1.1
 */"
"public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);
}","public void test0861011() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFractionOfHour((-1156), (-2589));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends the print/parse of a fractional hour.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
    return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);
}","public void test0871013() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMinuteOfHour(0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric minuteOfHour field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
    return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);
}","public void test0881017() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDayOfYear((-2001));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric dayOfYear field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Instructs the printer to emit a specific character, and the parser to
 * expect it. The parser is case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */
public DateTimeFormatterBuilder appendLiteral(char c) {
    return append0(new CharacterLiteral(c));
}","public void test0891019() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendLiteral(';');
    assertNotNull(dateTimeFormatterBuilder1);
}",""
"public DateTimeFormatterBuilder appendDayOfWeekText() {
    return appendText(DateTimeFieldType.dayOfWeek());
}","public void test0901023() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfWeekText();
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a locale-specific dayOfWeek text. The
 * parser will accept a long or short dayOfWeek text, case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer) {
    checkPrinter(printer);
    return append0(printer, null);
}","public void test0901032() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfWeekText();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.append((DateTimePrinter) dateTimeFormatterBuilder_Composite0);
    assertNotNull(dateTimeFormatterBuilder2);
}","/**
 * Appends just a printer. With no matching parser, a parser cannot be
 * built from this DateTimeFormatterBuilder.
 *
 * @param printer  the printer to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if printer is null or of an invalid type
 */"
"public boolean canBuildParser() {
    return isParser(getFormatter());
}","public void test0901042() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendDayOfWeekText();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.append((DateTimePrinter) dateTimeFormatterBuilder_Composite0);
    boolean boolean0 = dateTimeFormatterBuilder1.canBuildParser();
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder2);
}","/**
 * Returns true if toParser can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a parser can be built
 */"
"public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);
}","public void test0911048() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1847, 10);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends the print/parse of a fractional second.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 230 milliseconds.
 * Contrast this behaviour to {@link #appendMillisOfSecond}.
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneShortName() {
    return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);
}","public void test0911051() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1847, 10);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.appendTimeZoneShortName();
    assertNotNull(dateTimeFormatterBuilder2);
}","/**
 * Instructs the printer to emit a short locale-specific time zone name.
 * Using this method prevents parsing, because time zone names are not unique.
 * See {@link #appendTimeZoneShortName(Map)}.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if toFormatter can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a formatter can be built
 */
public boolean canBuildFormatter() {
    return isFormatter(getFormatter());
}","public void test0911058() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFractionOfSecond(1847, 10);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.appendTimeZoneShortName();
    boolean boolean0 = dateTimeFormatterBuilder1.canBuildFormatter();
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder2);
}",""
"public static CopticChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), 4);
}","public void test0921069() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    assertNotNull(copticChronology0);
}","/**
 * Gets an instance of the CopticChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test0921078() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    Locale locale0 = Locale.PRC;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1393L, copticChronology0, locale0, (Integer) 1, (-4498));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test0921086() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    Locale locale0 = Locale.PRC;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1393L, copticChronology0, locale0, (Integer) 1, (-4498));
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test0921087() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    Locale locale0 = Locale.PRC;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1393L, copticChronology0, locale0, (Integer) 1, (-4498));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test0921088() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    Locale locale0 = Locale.PRC;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1393L, copticChronology0, locale0, (Integer) 1, (-4498));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is three.
 * The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @return the field count, three
 */
public int size() {
    return 3;
}","public void test0931100() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter"", false);
    MockDate mockDate0 = new MockDate(26, 2, (-131), 1440, 26, (-131));
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    assertEquals(3, localDate0.size());
}",""
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test0951123() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-511));
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test0951124() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-511));
    assertEquals(""-00:00:00.511"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test0951125() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-511));
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test0951126() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-511));
    assertEquals(""-00:00:00.511"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static CopticChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), 4);
}","public void test0961135() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    assertNotNull(copticChronology0);
}","/**
 * Gets an instance of the CopticChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public static GJChronology getInstanceUTC() {
    return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);
}","public void test0961146() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the default GJ cutover
 * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
 * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
 * October 15, 1582 (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * <p>The time zone of the returned instance is UTC.
 */"
"public DateTimeZone getZone() {
    Chronology base;
    if ((base = getBase()) != null) {
        return base.getZone();
    }
    return DateTimeZone.UTC;
}","public void test0961147() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    assertNotNull(dateTimeZone0);
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test0961148() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test0961149() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test0961150() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    assertTrue(dateTimeZone0.isFixed());
}",""
"public static ISOChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test0971159() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    assertNotNull(iSOChronology0);
}","/**
 * Gets an instance of the ISOChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test0971164() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test0971171() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    assertEquals(9, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test0971172() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test0971173() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test0971183() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    int int0 = dateTimeFormatterBuilder_TimeZoneId0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 0);
    assertEquals(9, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test0971184() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    int int0 = dateTimeFormatterBuilder_TimeZoneId0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 0);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test0971185() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    Integer integer0 = new Integer(9);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 9);
    int int0 = dateTimeFormatterBuilder_TimeZoneId0.parseInto(dateTimeParserBucket0, ""vRA@$:X}66xJ"", 0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public static ISOChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test0981194() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    assertNotNull(iSOChronology0);
}","/**
 * Gets an instance of the ISOChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the default time zone.
 * <p>
 * The default time zone is derived from the system property {@code user.timezone}.
 * If that is {@code null} or is not a valid identifier, then the value of the
 * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.
 * <p>
 * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this
 * method, then the change will not be picked up here.
 *
 * @return the default datetime zone object
 */
public static DateTimeZone getDefault() {
    DateTimeZone zone = cDefault;
    if (zone == null) {
        synchronized (DateTimeZone.class) {
            zone = cDefault;
            if (zone == null) {
                DateTimeZone temp = null;
                try {
                    try {
                        String id = System.getProperty(""user.timezone"");
                        if (id != null) {
                            // null check avoids stack overflow
                            temp = forID(id);
                        }
                    } catch (RuntimeException ex) {
                        // ignored
                    }
                    if (temp == null) {
                        temp = forTimeZone(TimeZone.getDefault());
                    }
                } catch (IllegalArgumentException ex) {
                    // ignored
                }
                if (temp == null) {
                    temp = UTC;
                }
                cDefault = zone = temp;
            }
        }
    }
    return zone;
}","public void test0981195() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertNotNull(dateTimeZone0);
}",""
"public String toString() {
    return getID();
}","public void test0981196() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test0981197() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test0981210() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.ENGLISH;
    dateTimeFormatterBuilder_TimeZoneId0.printTo(stringBuffer0, (-1539L), (Chronology) iSOChronology0, (-2245), dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test0981211() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    Locale locale0 = Locale.ENGLISH;
    dateTimeFormatterBuilder_TimeZoneId0.printTo(stringBuffer0, (-1539L), (Chronology) iSOChronology0, (-2245), dateTimeZone0, locale0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {
    TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);
    return append0(pp, pp);
}","public void test1001233() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTimeZoneShortName((Map<String, DateTimeZone>) null);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a short locale-specific time zone
 * name, providing a lookup for parsing.
 * Time zone names are not unique, thus the API forces you to supply the lookup.
 * The names are searched in the order of the map, thus it is strongly recommended
 * to use a {@code LinkedHashMap} or similar.
 *
 * @param parseLookup  the table of names, not null
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {
    TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);
    return append0(pp, pp);
}","public void test1001236() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTimeZoneShortName((Map<String, DateTimeZone>) null);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.appendTimeZoneName((Map<String, DateTimeZone>) null);
    assertNotNull(dateTimeFormatterBuilder2);
}","/**
 * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.
 * Time zone names are not unique, thus the API forces you to supply the lookup.
 * The names are searched in the order of the map, thus it is strongly recommended
 * to use a {@code LinkedHashMap} or similar.
 *
 * @param parseLookup  the table of names, not null
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeParser toParser() {
    Object f = getFormatter();
    if (isParser(f)) {
        return (DateTimeParser) f;
    }
    throw new UnsupportedOperationException(""Parsing is not supported"");
}","public void test1001243() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTimeZoneShortName((Map<String, DateTimeZone>) null);
    DateTimeFormatterBuilder dateTimeFormatterBuilder2 = dateTimeFormatterBuilder1.appendTimeZoneName((Map<String, DateTimeZone>) null);
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = (DateTimeFormatterBuilder.Composite) dateTimeFormatterBuilder2.toParser();
    assertNotNull(dateTimeFormatterBuilder_Composite0);
}","/**
 * Internal method to create a DateTimeParser instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a parser in an application, call {@link #toFormatter()}
 * and just use the parsing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned parser.
 *
 * @throws UnsupportedOperationException if parsing is not supported
 */"
"public static JulianChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1021268() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    assertNotNull(julianChronology0);
}","/**
 * Gets an instance of the JulianChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1021278() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1021285() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1021286() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1021287() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    assertEquals((-463), (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1021297() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    int int0 = dateTimeFormatterBuilder_TimeZoneOffset0.parseInto(dateTimeParserBucket0, ""UTC(-`)=,c{y"", 60000);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1021298() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    int int0 = dateTimeFormatterBuilder_TimeZoneOffset0.parseInto(dateTimeParserBucket0, ""UTC(-`)=,c{y"", 60000);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1021299() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    JulianChronology julianChronology0 = JulianChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREA;
    Integer integer0 = new Integer((-463));
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-874L), julianChronology0, locale0, integer0, 256);
    int int0 = dateTimeFormatterBuilder_TimeZoneOffset0.parseInto(dateTimeParserBucket0, ""UTC(-`)=,c{y"", 60000);
    assertEquals((-463), (int) dateTimeParserBucket0.getPivotYear());
}",""
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test1031306() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1031307() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1031308() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1031309() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static GJChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, DEFAULT_CUTOVER, 4);
}","public void test1031310() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the GJ cutover chronology. This uses
 * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
 * value, October 4, 1582 (Julian) is followed by October 15, 1582
 * (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * @param zone  the time zone to use, null is default
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1031311() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1031312() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1031313() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1031318() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 4110, dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1031319() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 4110, dateTimeZone0, (Locale) null);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1031320() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", false, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 4110, dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test1041327() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"public String toString() {
    return getID();
}","public void test1041328() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1041329() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1041330() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public static GJChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, DEFAULT_CUTOVER, 4);
}","public void test1041331() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the GJ cutover chronology. This uses
 * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
 * value, October 4, 1582 (Julian) is followed by October 15, 1582
 * (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * @param zone  the time zone to use, null is default
 */"
"public String toString() {
    return getID();
}","public void test1041332() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1041333() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1041334() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1041339() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, (-463), dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1041340() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, (-463), dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1041341() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, (-463), dateTimeZone0, (Locale) null);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public static GJChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, DEFAULT_CUTOVER, 4);
}","public void test1051348() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    GJChronology gJChronology0 = GJChronology.getInstance((DateTimeZone) null);
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the GJ cutover chronology. This uses
 * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
 * value, October 4, 1582 (Julian) is followed by October 15, 1582
 * (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * @param zone  the time zone to use, null is default
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1061371() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 12825000, dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test1061372() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 12825000, dateTimeZone0, (Locale) null);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1061373() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo((Writer) charArrayWriter0, (-1291L), (Chronology) gJChronology0, 12825000, dateTimeZone0, (Locale) null);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public static ISOChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1071384() throws Throwable {
    StringBuffer stringBuffer0 = new StringBuffer();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    assertNotNull(iSOChronology0);
}","/**
 * Gets an instance of the ISOChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */"
"public static DateTimeZone forOffsetMillis(int millisOffset) {
    String id = printOffset(millisOffset);
    return fixedOffsetZone(id, millisOffset);
}","public void test1081404() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in milliseconds.
 *
 * @param millisOffset  the offset in millis from UTC
 * @return the DateTimeZone object for the offset
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1081405() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1081406() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test1081407() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static GJChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, DEFAULT_CUTOVER, 4);
}","public void test1081408() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the GJ cutover chronology. This uses
 * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
 * value, October 4, 1582 (Julian) is followed by October 15, 1582
 * (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * @param zone  the time zone to use, null is default
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1081409() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1081410() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test1081411() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1081423() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    Locale locale0 = Locale.ENGLISH;
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo(stringBuffer0, (-1051L), (Chronology) gJChronology0, 7678125, dateTimeZone0, locale0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1081424() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    Locale locale0 = Locale.ENGLISH;
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo(stringBuffer0, (-1051L), (Chronology) gJChronology0, 7678125, dateTimeZone0, locale0);
    assertEquals(""+00:01"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getID();
}","public void test1081425() throws Throwable {
    DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset0 = new DateTimeFormatterBuilder.TimeZoneOffset(""UTC(-`)=,c{y"", ""--ct(=6mk5'v"", true, 60000, 60000);
    StringBuffer stringBuffer0 = new StringBuffer();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(60000);
    GJChronology gJChronology0 = GJChronology.getInstance(dateTimeZone0);
    Locale locale0 = Locale.ENGLISH;
    dateTimeFormatterBuilder_TimeZoneOffset0.printTo(stringBuffer0, (-1051L), (Chronology) gJChronology0, 7678125, dateTimeZone0, locale0);
    assertEquals(""+00:01"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Get the day of week field type.
 *
 * @return the DateTimeFieldType constant
 */
public static DateTimeFieldType dayOfWeek() {
    return DAY_OF_WEEK_TYPE;
}","public void test1101433() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    assertNotNull(dateTimeFieldType0);
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1101434() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    assertEquals(""dayOfWeek"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1101435() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    assertEquals(""dayOfWeek"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1101437() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    assertEquals(""dayOfWeek"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1101438() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    assertEquals(""dayOfWeek"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {
    return forOffsetHoursMinutes(hoursOffset, 0);
}","public void test1101441() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for the specified offset to UTC in hours.
 * This method assumes standard length hours.
 * <p>
 * This factory is a convenient way of constructing zones with a fixed offset.
 *
 * @param hoursOffset  the offset in hours from UTC
 * @return the DateTimeZone object for the offset
 * @throws IllegalArgumentException if the offset is too large or too small
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1101442() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    assertEquals(""+20:00"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1101443() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1101444() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    assertEquals(""+20:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
    if (zone == null) {
        zone = DateTimeZone.getDefault();
    }
    BuddhistChronology chrono = cCache.get(zone);
    if (chrono == null) {
        // First create without a lower limit.
        chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
        // Impose lower limit and make another BuddhistChronology.
        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
        chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), """");
        cCache.put(zone, chrono);
    }
    return chrono;
}","public void test1101445() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 *
 * @param zone  the time zone to use, null is default
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1101447() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertEquals(""+20:00"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1101448() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1101449() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertEquals(""+20:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1101450() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1101452() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertEquals(""+20:00"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1101453() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public String toString() {
    return getID();
}","public void test1101454() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertEquals(""+20:00"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1101455() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1101456() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1101457() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfWeek();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 20);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(20);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(20, buddhistChronology0, (Locale) null, (Integer) buddhistChronology0.BE, 0);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Gets an instance of the CopticChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */
public static CopticChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1111467() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    assertNotNull(copticChronology0);
}",""
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1111476() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1111484() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1111485() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1111486() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1111489() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    int int0 = dateTimeFormatterBuilder_Fraction0.parseInto(dateTimeParserBucket0, ""];"", 99);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1111490() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    int int0 = dateTimeFormatterBuilder_Fraction0.parseInto(dateTimeParserBucket0, ""];"", 99);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1111499() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    int int0 = dateTimeFormatterBuilder_Fraction0.parseInto(dateTimeParserBucket0, ""];"", 99);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1111500() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    int int0 = dateTimeFormatterBuilder_Fraction0.parseInto(dateTimeParserBucket0, ""];"", 99);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1111501() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-480), copticChronology0, locale0, (Integer) 1, (-1250));
    int int0 = dateTimeFormatterBuilder_Fraction0.parseInto(dateTimeParserBucket0, ""];"", 99);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public static DateTimeFieldType weekyear() {
    return WEEKYEAR_TYPE;
}","public void test1121502() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year of a week based year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test1121503() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    assertEquals(""weekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1121504() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    assertEquals(""weekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1121506() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    assertEquals(""weekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1121507() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    assertEquals(""weekyear"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the default time zone.
 * <p>
 * The default time zone is derived from the system property {@code user.timezone}.
 * If that is {@code null} or is not a valid identifier, then the value of the
 * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.
 * <p>
 * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this
 * method, then the change will not be picked up here.
 *
 * @return the default datetime zone object
 */
public static DateTimeZone getDefault() {
    DateTimeZone zone = cDefault;
    if (zone == null) {
        synchronized (DateTimeZone.class) {
            zone = cDefault;
            if (zone == null) {
                DateTimeZone temp = null;
                try {
                    try {
                        String id = System.getProperty(""user.timezone"");
                        if (id != null) {
                            // null check avoids stack overflow
                            temp = forID(id);
                        }
                    } catch (RuntimeException ex) {
                        // ignored
                    }
                    if (temp == null) {
                        temp = forTimeZone(TimeZone.getDefault());
                    }
                } catch (IllegalArgumentException ex) {
                    // ignored
                }
                if (temp == null) {
                    temp = UTC;
                }
                cDefault = zone = temp;
            }
        }
    }
    return zone;
}","public void test1121514() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertNotNull(dateTimeZone0);
}",""
"public String toString() {
    return getID();
}","public void test1121515() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1121516() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
    if (zone == null) {
        zone = DateTimeZone.getDefault();
    }
    BuddhistChronology chrono = cCache.get(zone);
    if (chrono == null) {
        // First create without a lower limit.
        chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
        // Impose lower limit and make another BuddhistChronology.
        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
        chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), """");
        cCache.put(zone, chrono);
    }
    return chrono;
}","public void test1121517() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 *
 * @param zone  the time zone to use, null is default
 */"
"public String toString() {
    return getID();
}","public void test1121519() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1121520() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getName();
}","public void test1121522() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_Fraction0.printTo(stringBuffer0, (Writer) pipedWriter0, (long) 0, (Chronology) buddhistChronology0);
    assertEquals(""weekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1121523() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_Fraction0.printTo(stringBuffer0, (Writer) pipedWriter0, (long) 0, (Chronology) buddhistChronology0);
    assertEquals(""weekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getID();
}","public void test1121528() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_Fraction0.printTo(stringBuffer0, (Writer) pipedWriter0, (long) 0, (Chronology) buddhistChronology0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1121529() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyear();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, 0, 50);
    StringBuffer stringBuffer0 = new StringBuffer();
    PipedWriter pipedWriter0 = new PipedWriter();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance(dateTimeZone0);
    dateTimeFormatterBuilder_Fraction0.printTo(stringBuffer0, (Writer) pipedWriter0, (long) 0, (Chronology) buddhistChronology0);
    assertEquals(""America/Los_Angeles"", dateTimeZone0.getID());
}",""
"public String toString() {
    return getName();
}","public void test1131534() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1131535() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatter(DateTimePrinter printer, DateTimeParser parser) {
    super();
    iPrinter = printer;
    iParser = parser;
    iLocale = null;
    iOffsetParsed = false;
    iChrono = null;
    iZone = null;
    iPivotYear = null;
    iDefaultYear = 2000;
}","public void test1131538() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertNotNull(dateTimeFormatter0);
}","/**
 * Creates a new formatter, however you will normally use the factory
 * or the builder.
 *
 * @param printer  the internal printer, null if cannot print
 * @param parser  the internal parser, null if cannot parse
 */"
"public String toString() {
    return getName();
}","public void test1131539() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1131540() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public int getDefaultYear() {
    return iDefaultYear;
}","public void test1131543() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertEquals(2000, dateTimeFormatter0.getDefaultYear());
}","/**
 * Gets the default year for parsing months and days.
 *
 * @return the default year for parsing months and days
 * @since 2.0
 */"
"public boolean isParser() {
    return (iParser != null);
}","public void test1131544() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertTrue(dateTimeFormatter0.isParser());
}","/**
 * Is this formatter capable of parsing.
 *
 * @return true if this is a parser
 */"
"public boolean isOffsetParsed() {
    return iOffsetParsed;
}","public void test1131545() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertFalse(dateTimeFormatter0.isOffsetParsed());
}","/**
 * Checks whether the offset from the string is used as the zone of
 * the parsed datetime.
 *
 * @return true if the offset from the string is used as the zone
 */"
"public Integer getPivotYear() {
    return iPivotYear;
}","public void test1131546() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertNull(dateTimeFormatter0.getPivotYear());
}","/**
 * Gets the pivot year to use as an override.
 *
 * @return the pivot year to use as an override
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Is this formatter capable of printing.
 *
 * @return true if this is a printer
 */
public boolean isPrinter() {
    return (iPrinter != null);
}","public void test1131547() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    assertTrue(dateTimeFormatter0.isPrinter());
}",""
"public static LocalDate parse(String str, DateTimeFormatter formatter) {
    return formatter.parseLocalDate(str);
}","public void test1131548() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimeFormatterBuilder_TextField0, dateTimeFormatterBuilder_TextField0);
    // Undeclared exception!
    try {
        LocalDate.parse(""EET"", dateTimeFormatter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""EET\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a {@code LocalDate} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static DateTimeFieldType weekOfWeekyear() {
    return WEEK_OF_WEEKYEAR_TYPE;
}","public void test1141550() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the week of a week based year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1141551() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1141552() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1141554() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1141555() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
    checkParser(parser);
    DateTimeParser[] parsers = new DateTimeParser[] { parser, null };
    return append0(null, new MatchingParser(parsers));
}","public void test1141558() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendOptional(dateTimeFormatterBuilder_TextField0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends just a parser element which is optional. With no matching
 * printer, a printer cannot be built from this DateTimeFormatterBuilder.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if parser is null or of an invalid type
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1141561() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendOptional(dateTimeFormatterBuilder_TextField0);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1141562() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField0 = new DateTimeFormatterBuilder.TextField(dateTimeFieldType0, true);
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendOptional(dateTimeFormatterBuilder_TextField0);
    assertEquals(""weekOfWeekyear"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public LocalDateTime(Object instant, Chronology chronology) {
    PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);
    chronology = converter.getChronology(instant, chronology);
    chronology = DateTimeUtils.getChronology(chronology);
    iChronology = chronology.withUTC();
    int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());
    iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);
}","public void test1151566() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    assertNotNull(localDateTime0);
}","/**
 * Constructs an instance from an Object that represents a datetime,
 * using the specified chronology.
 * <p>
 * If the chronology is null, ISO in the default time zone is used.
 * Once the constructor is completed, the zone is no longer used.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePartial, ReadableInstant, String, Calendar and Date.
 * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.
 * The default String converter ignores the zone and only parses the field values.
 *
 * @param instant  the datetime object
 * @param chronology  the chronology
 * @throws IllegalArgumentException if the instant is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test1151567() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    assertEquals(4, localDateTime0.size());
}",""
"public static DateTimeFieldType secondOfMinute() {
    return SECOND_OF_MINUTE_TYPE;
}","public void test1151575() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the second of minute field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test1151576() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertEquals(""secondOfMinute"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1151577() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1151579() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65533, false);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1151580() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65533, false);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test1151584() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65533, false);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""|54j#IjT\u0006c;:M"", false);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo((Writer) mockFileWriter0, (ReadablePartial) localDateTime0, locale0);
    assertEquals(4, localDateTime0.size());
}",""
"public String toString() {
    return getName();
}","public void test1151591() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65533, false);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""|54j#IjT\u0006c;:M"", false);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo((Writer) mockFileWriter0, (ReadablePartial) localDateTime0, locale0);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1151592() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDateTime localDateTime0 = new LocalDateTime((Object) null, gJChronology0);
    Locale locale0 = Locale.CHINA;
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfMinute();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 65533, false);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""|54j#IjT\u0006c;:M"", false);
    dateTimeFormatterBuilder_TwoDigitYear0.printTo((Writer) mockFileWriter0, (ReadablePartial) localDateTime0, locale0);
    assertEquals(""secondOfMinute"", dateTimeFieldType0.getName());
}",""
"public static DateTimeFieldType secondOfDay() {
    return SECOND_OF_DAY_TYPE;
}","public void test1161595() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the second of day field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1161596() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertEquals(""secondOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1161597() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertEquals(""secondOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1161599() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    assertEquals(""secondOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1161600() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    assertEquals(""secondOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static IslamicChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED);
}","public void test1161606() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    assertNotNull(islamicChronology0);
}","/**
 * Gets an instance of the IslamicChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public Partial(DateTimeFieldType type, int value, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    iChronology = chronology;
    if (type == null) {
        throw new IllegalArgumentException(""The field type must not be null"");
    }
    iTypes = new DateTimeFieldType[] { type };
    iValues = new int[] { value };
    chronology.validate(this, iValues);
}","public void test1161608() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    assertNotNull(partial0);
}","/**
 * Constructs a Partial with the specified field and value.
 * <p>
 * The constructor uses the specified chronology.
 *
 * @param type  the single type to create the partial from, not null
 * @param value  the value to store
 * @param chronology  the chronology, null means ISO
 * @throws IllegalArgumentException if the type or value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1161610() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    assertEquals(""secondOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1161611() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    assertEquals(""secondOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test1161612() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    assertEquals(1, partial0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1161621() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    Locale locale0 = Locale.FRANCE;
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (ReadablePartial) partial0, locale0);
    assertEquals(""secondOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1161622() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    Locale locale0 = Locale.FRANCE;
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (ReadablePartial) partial0, locale0);
    assertEquals(""secondOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial.
 *
 * @return the field count
 */
public int size() {
    return iTypes.length;
}","public void test1161627() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 2552, true);
    StringBuffer stringBuffer0 = new StringBuffer();
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    Partial partial0 = new Partial(dateTimeFieldType0, 2552, islamicChronology0);
    Locale locale0 = Locale.FRANCE;
    dateTimeFormatterBuilder_TwoDigitYear0.printTo(stringBuffer0, (ReadablePartial) partial0, locale0);
    assertEquals(1, partial0.size());
}",""
"public static DateTimeFieldType minuteOfDay() {
    return MINUTE_OF_DAY_TYPE;
}","public void test1171634() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the minute of day field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1171635() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1171636() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets an instance of the EthiopicChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */
public static EthiopicChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1171637() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    assertNotNull(ethiopicChronology0);
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1171647() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1171648() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1171651() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1171659() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1171660() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1171661() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1171664() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1171665() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1171674() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1171675() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1171676() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), true);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"public static DateTimeFieldType dayOfMonth() {
    return DAY_OF_MONTH_TYPE;
}","public void test1181677() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the day of month field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1181678() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertEquals(""dayOfMonth"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1181679() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    assertEquals(""dayOfMonth"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static ISOChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1181687() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    assertNotNull(iSOChronology0);
}","/**
 * Gets an instance of the ISOChronology.
 * The time zone of the returned instance is UTC.
 *
 * @return a singleton UTC instance of the chronology
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1181689() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    assertEquals(""dayOfMonth"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1181690() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    assertEquals(""dayOfMonth"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1181695() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1181702() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertEquals(275, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1181703() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1181704() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, false);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"public String toString() {
    return getName();
}","public void test1191719() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1191720() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1191723() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1191731() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1191732() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1191733() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public String toString() {
    return getName();
}","public void test1191736() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1191737() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(""minuteOfDay"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1191746() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1191747() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1191748() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Locale locale0 = Locale.ITALIAN;
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, (-745), false);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2889L), ethiopicChronology0, locale0, (Integer) 1, (-745));
    int int0 = dateTimeFormatterBuilder_TwoDigitYear0.parseInto(dateTimeParserBucket0, ""US/Central"", 214);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1201761() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    assertEquals(""dayOfMonth"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1201762() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    assertEquals(""dayOfMonth"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1201767() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1201774() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1201775() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1201776() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.dayOfMonth();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear0 = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType0, 275, true);
    Integer integer0 = new Integer(275);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(10, iSOChronology0, locale0, integer0, 1847);
    assertEquals(275, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1211782() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1211783() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static ISOChronology getInstance() {
    return getInstance(DateTimeZone.getDefault());
}","public void test1211786() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    assertNotNull(iSOChronology0);
}","/**
 * Gets an instance of the ISOChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1211794() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1211801() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1211802() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1211803() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1211805() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    int int0 = dateTimeFormatterBuilder_FixedNumber0.parseInto(dateTimeParserBucket0, ""kFdI~^pqIY}sv"", 1);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1211806() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    int int0 = dateTimeFormatterBuilder_FixedNumber0.parseInto(dateTimeParserBucket0, ""kFdI~^pqIY}sv"", 1);
    assertEquals(""weekyearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1211815() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    int int0 = dateTimeFormatterBuilder_FixedNumber0.parseInto(dateTimeParserBucket0, ""kFdI~^pqIY}sv"", 1);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1211816() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    int int0 = dateTimeFormatterBuilder_FixedNumber0.parseInto(dateTimeParserBucket0, ""kFdI~^pqIY}sv"", 1);
    assertEquals(1, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1211817() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekyearOfCentury();
    DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber0 = new DateTimeFormatterBuilder.FixedNumber(dateTimeFieldType0, 2300, false);
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(1, iSOChronology0, locale0, (Integer) 1, 1);
    int int0 = dateTimeFormatterBuilder_FixedNumber0.parseInto(dateTimeParserBucket0, ""kFdI~^pqIY}sv"", 1);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public static DateTimeFieldType yearOfEra() {
    return YEAR_OF_ERA_TYPE;
}","public void test1221818() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year of era field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test1221819() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    assertEquals(""yearOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1221820() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    assertEquals(""yearOfEra"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1221822() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    assertEquals(""yearOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1221823() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    assertEquals(""yearOfEra"", dateTimeFieldType0.getName());
}",""
"public static IslamicChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED);
}","public void test1221828() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    assertNotNull(islamicChronology0);
}","/**
 * Gets an instance of the IslamicChronology in the default time zone.
 *
 * @return a chronology in the default time zone
 */"
"public static LenientChronology getInstance(Chronology base) {
    if (base == null) {
        throw new IllegalArgumentException(""Must supply a chronology"");
    }
    return new LenientChronology(base);
}","public void test1221830() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    assertNotNull(lenientChronology0);
}","/**
 * Create a LenientChronology for any chronology.
 *
 * @param base the chronology to wrap
 * @throws IllegalArgumentException if chronology is null
 */"
"public YearMonth(long instant, Chronology chronology) {
    super(instant, chronology);
}","public void test1221832() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    assertNotNull(yearMonth0);
}","/**
 * Constructs a YearMonth extracting the partial fields from the specified
 * milliseconds using the chronology provided.
 * <p>
 * The constructor uses the time zone of the chronology specified.
 * Once the constructor is complete, all further calculations are performed
 * without reference to a time-zone (by switching to UTC).
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z
 * @param chronology  the chronology, null means ISOChronology in the default zone
 */"
"//-----------------------------------------------------------------------
/**
 * Get the year field value.
 *
 * @return the year
 */
public int getYear() {
    return getValue(YEAR);
}","public void test1221836() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    assertEquals(1389, yearMonth0.getYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are Year and MonthOfYear.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test1221837() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    assertEquals(2, yearMonth0.size());
}",""
"public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test1221838() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    assertEquals(10, yearMonth0.getMonthOfYear());
}","/**
 * Get the month of year field value.
 *
 * @return the month of year
 */"
"public String toString() {
    return getName();
}","public void test1221849() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) mockPrintWriter0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""yearOfEra"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1221850() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) mockPrintWriter0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(""yearOfEra"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the year field value.
 *
 * @return the year
 */
public int getYear() {
    return getValue(YEAR);
}","public void test1221869() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) mockPrintWriter0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(1389, yearMonth0.getYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are Year and MonthOfYear.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test1221870() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) mockPrintWriter0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(2, yearMonth0.size());
}",""
"public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test1221871() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    MockFile mockFile0 = new MockFile(""US/MountainvRA@$:X}66xJ"", ""B@\""*wvnr^%9/"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    LenientChronology lenientChronology0 = LenientChronology.getInstance(islamicChronology0);
    YearMonth yearMonth0 = new YearMonth((long) 0, (Chronology) lenientChronology0);
    Locale locale0 = Locale.KOREA;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo((Writer) mockPrintWriter0, (ReadablePartial) yearMonth0, locale0);
    assertEquals(10, yearMonth0.getMonthOfYear());
}","/**
 * Get the month of year field value.
 *
 * @return the month of year
 */"
"public static DateTimeZone forTimeZone(TimeZone zone) {
    if (zone == null) {
        return getDefault();
    }
    final String id = zone.getID();
    if (id.equals(""UTC"")) {
        return DateTimeZone.UTC;
    }
    // Convert from old alias before consulting provider since they may differ.
    DateTimeZone dtz = null;
    String convId = getConvertedId(id);
    if (convId != null) {
        dtz = cProvider.getZone(convId);
    }
    if (dtz == null) {
        dtz = cProvider.getZone(id);
    }
    if (dtz != null) {
        return dtz;
    }
    // Support GMT+/-hh:mm formats
    if (convId == null) {
        convId = zone.getDisplayName();
        if (convId.startsWith(""GMT+"") || convId.startsWith(""GMT-"")) {
            convId = convId.substring(3);
            int offset = parseOffset(convId);
            if (offset == 0L) {
                return DateTimeZone.UTC;
            } else {
                convId = printOffset(offset);
                return fixedOffsetZone(convId, offset);
            }
        }
    }
    throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}","public void test1231892() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    assertNotNull(dateTimeZone0);
}","/**
 * Gets a time zone instance for a JDK TimeZone.
 * <p>
 * DateTimeZone only accepts a subset of the IDs from TimeZone. The
 * excluded IDs are the short three letter form (except UTC). This
 * method will attempt to convert between time zones created using the
 * short IDs and the full version.
 * <p>
 * This method is not designed to parse time zones with rules created by
 * applications using <code>SimpleTimeZone</code> directly.
 *
 * @param zone  the zone to convert, null means default
 * @return the DateTimeZone object for the zone
 * @throws IllegalArgumentException if the zone is not recognised
 */"
"public String toString() {
    return getID();
}","public void test1231898() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1231899() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1231900() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public static CopticChronology getInstance(DateTimeZone zone) {
    return getInstance(zone, 4);
}","public void test1231901() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    assertNotNull(copticChronology0);
}","/**
 * Gets an instance of the CopticChronology in the given time zone.
 *
 * @param zone  the time zone to get the chronology in, null is default
 * @return a chronology in the specified time zone
 */"
"public String toString() {
    return getID();
}","public void test1231908() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1231909() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1231910() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"public LocalDate(Chronology chronology) {
    this(DateTimeUtils.currentTimeMillis(), chronology);
}","public void test1231911() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    assertNotNull(localDate0);
}","/**
 * Constructs an instance set to the current local time evaluated using
 * specified chronology.
 * <p>
 * If the chronology is null, ISO chronology in the default time zone is used.
 * Once the constructor is completed, the zone is no longer used.
 *
 * @param chronology  the chronology, null means ISOChronology in default zone
 * @see #now(Chronology)
 */"
"public String toString() {
    return getID();
}","public void test1231918() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    assertEquals(""UTC"", dateTimeZone0.toString());
}","/**
 * Gets the datetime zone as a string, which is simply its ID.
 * @return the id of the zone
 */"
"// Principal methods
//--------------------------------------------------------------------
/**
 * Gets the ID of this datetime zone.
 *
 * @return the ID of this datetime zone
 */
@ToString
public final String getID() {
    return iID;
}","public void test1231919() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    assertEquals(""UTC"", dateTimeZone0.getID());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns true if this time zone has no transitions.
 *
 * @return true if no transitions
 */
public abstract boolean isFixed();","public void test1231920() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    assertTrue(dateTimeZone0.isFixed());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is three.
 * The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @return the field count, three
 */
public int size() {
    return 3;
}","public void test1231921() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfEra();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, true);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""=(+MHG_'zofC_^5@|"", 10, 10, 0, 85, 10, 0, 10, 85);
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(simpleTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    assertEquals(3, localDate0.size());
}",""
"public static DateTimeFieldType year() {
    return YEAR_TYPE;
}","public void test1241930() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the year field type.
 *
 * @return the DateTimeFieldType constant
 */"
"public String toString() {
    return getName();
}","public void test1241931() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    assertEquals(""year"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1241932() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    assertEquals(""year"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1241934() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    assertEquals(""year"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1241935() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    assertEquals(""year"", dateTimeFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Constructs a MonthDay with the current monthOfYear, using ISOChronology in
 * the default zone to extract the fields.
 * <p>
 * The constructor uses the default time zone, resulting in the local time
 * being initialised. Once the constructor is complete, all further calculations
 * are performed without reference to a time-zone (by switching to UTC).
 *
 * @see #now()
 */
public MonthDay() {
    super();
}","public void test1241964() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    assertNotNull(monthDay0);
}",""
"public int getDayOfMonth() {
    return getValue(DAY_OF_MONTH);
}","public void test1241967() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    assertEquals(14, monthDay0.getDayOfMonth());
}","/**
 * Get the day of month field value.
 *
 * @return the day of month
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are MonthOfYear and DayOfMonth.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test1241968() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    assertEquals(2, monthDay0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the month of year field value.
 *
 * @return the month of year
 */
public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test1241969() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    assertEquals(2, monthDay0.getMonthOfYear());
}",""
"public String toString() {
    return getName();
}","public void test1241979() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) monthDay0, locale0);
    assertEquals(""year"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1241980() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) monthDay0, locale0);
    assertEquals(""year"", dateTimeFieldType0.getName());
}",""
"public int getDayOfMonth() {
    return getValue(DAY_OF_MONTH);
}","public void test1241996() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) monthDay0, locale0);
    assertEquals(14, monthDay0.getDayOfMonth());
}","/**
 * Get the day of month field value.
 *
 * @return the day of month
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is two.
 * The supported fields are MonthOfYear and DayOfMonth.
 * Note that only these fields may be queried.
 *
 * @return the field count, two
 */
public int size() {
    return 2;
}","public void test1241997() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) monthDay0, locale0);
    assertEquals(2, monthDay0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the month of year field value.
 *
 * @return the month of year
 */
public int getMonthOfYear() {
    return getValue(MONTH_OF_YEAR);
}","public void test1241998() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.year();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 0, false);
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    MonthDay monthDay0 = new MonthDay();
    Locale locale0 = Locale.GERMANY;
    dateTimeFormatterBuilder_UnpaddedNumber0.printTo(stringBuffer0, (ReadablePartial) monthDay0, locale0);
    assertEquals(2, monthDay0.getMonthOfYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1252009() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1252010() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public static GJChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
}","public void test1252013() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the default GJ cutover
 * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
 * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
 * October 15, 1582 (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * <p>The returned chronology is in the default time zone.
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1252023() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1252030() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1252031() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    assertEquals(11, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1252032() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1252034() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.parseInto(dateTimeParserBucket0, ""--ct(=6mk5'v"", 1103);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1252035() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.parseInto(dateTimeParserBucket0, ""--ct(=6mk5'v"", 1103);
    assertEquals(""halfdayOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1252044() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.parseInto(dateTimeParserBucket0, ""--ct(=6mk5'v"", 1103);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1252045() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.parseInto(dateTimeParserBucket0, ""--ct(=6mk5'v"", 1103);
    assertEquals(11, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1252046() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.halfdayOfDay();
    DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber0 = new DateTimeFormatterBuilder.UnpaddedNumber(dateTimeFieldType0, 11, true);
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.ENGLISH;
    Integer integer0 = new Integer(11);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket(11, gJChronology0, locale0, integer0, 1103);
    int int0 = dateTimeFormatterBuilder_UnpaddedNumber0.parseInto(dateTimeParserBucket0, ""--ct(=6mk5'v"", 1103);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code MonthDay} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#localDateParser()} or the format {@code --MM-dd}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static MonthDay parse(String str) {
    return parse(str, PARSER);
}","public void test1262047() throws Throwable {
    // Undeclared exception!
    try {
        MonthDay.parse(""fVct(=6MK5'V"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""fVct(=6MK5'V\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public static GJChronology getInstance() {
    return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
}","public void test1272051() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    assertNotNull(gJChronology0);
}","/**
 * Factory method returns instances of the default GJ cutover
 * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
 * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
 * October 15, 1582 (Gregorian).
 *
 * <p>The first day of the week is designated to be
 * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
 * and the minimum days in the first week of the year is 4.
 *
 * <p>The returned chronology is in the default time zone.
 */"
"public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) {
    super();
    chrono = DateTimeUtils.getChronology(chrono);
    iMillis = instantLocal;
    iZone = chrono.getZone();
    iChrono = chrono.withUTC();
    iLocale = (locale == null ? Locale.getDefault() : locale);
    iPivotYear = pivotYear;
    iDefaultYear = defaultYear;
}","public void test1272061() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    assertNotNull(dateTimeParserBucket0);
}","/**
 * Constructs a bucket, with the option of specifying the pivot year for
 * two-digit year parsing.
 *
 * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time
 * @param chrono  the chronology to use
 * @param locale  the locale to use
 * @param pivotYear  the pivot year to use when parsing two-digit years
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1272068() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1272069() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1272070() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    assertEquals(2049, (int) dateTimeParserBucket0.getPivotYear());
}",""
"//-----------------------------------------------------------------------
/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 * @deprecated use Integer version
 */
@Deprecated
public int getOffset() {
    return (iOffset != null ? iOffset : 0);
}","public void test1272080() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    int int0 = dateTimeFormatterBuilder_CharacterLiteral0.parseInto(dateTimeParserBucket0, "" 3.(:"", 116);
    assertEquals(0, dateTimeParserBucket0.getOffset());
}",""
"public Integer getOffsetInteger() {
    return iOffset;
}","public void test1272081() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    int int0 = dateTimeFormatterBuilder_CharacterLiteral0.parseInto(dateTimeParserBucket0, "" 3.(:"", 116);
    assertNull(dateTimeParserBucket0.getOffsetInteger());
}","/**
 * Returns the time zone offset in milliseconds used by computeMillis.
 */"
"//-----------------------------------------------------------------------
/**
 * Returns the default year used when information is incomplete.
 * <p>
 * This is used for two-digit years and when the largest parsed field is
 * months or days.
 * <p>
 * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.
 * A null value for month/day only parsing will cause the default of 2000 to be used.
 *
 * @return Integer value of the pivot year, null if not set
 * @since 1.1
 */
public Integer getPivotYear() {
    return iPivotYear;
}","public void test1272082() throws Throwable {
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('');
    GJChronology gJChronology0 = GJChronology.getInstance();
    Locale locale0 = Locale.UK;
    Integer integer0 = new Integer(2049);
    DateTimeParserBucket dateTimeParserBucket0 = new DateTimeParserBucket((-2337L), gJChronology0, locale0, integer0, (-4));
    int int0 = dateTimeFormatterBuilder_CharacterLiteral0.parseInto(dateTimeParserBucket0, "" 3.(:"", 116);
    assertEquals(2049, (int) dateTimeParserBucket0.getPivotYear());
}",""
"public String toString() {
    return getName();
}","public void test1282087() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 0, false, 7593750);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1282088() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 0, false, 7593750);
    assertEquals(""hourOfHalfday"", dateTimeFieldType0.getName());
}",""
"public static BuddhistChronology getInstanceUTC() {
    return INSTANCE_UTC;
}","public void test1282092() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 0, false, 7593750);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""TkXj<+"", false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    assertNotNull(buddhistChronology0);
}","/**
 * Standard instance of a Buddhist Chronology, that matches
 * Sun's BuddhistCalendar class. This means that it follows the
 * GregorianJulian calendar rules with a cutover date.
 * <p>
 * The time zone of the returned instance is UTC.
 */"
"public LocalDateTime(long instant, Chronology chronology) {
    chronology = DateTimeUtils.getChronology(chronology);
    long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);
    iLocalMillis = localMillis;
    iChronology = chronology.withUTC();
}","public void test1282094() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 0, false, 7593750);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""TkXj<+"", false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime(168L, (Chronology) buddhistChronology0);
    assertNotNull(localDateTime0);
}","/**
 * Constructs an instance set to the local time defined by the specified
 * instant evaluated using the specified chronology.
 * <p>
 * If the chronology is null, ISO chronology in the default zone is used.
 * Once the constructor is completed, the zone is no longer used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z
 * @param chronology  the chronology, null means ISOChronology in default zone
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test1282096() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfHalfday();
    DateTimeFormatterBuilder.PaddedNumber dateTimeFormatterBuilder_PaddedNumber0 = new DateTimeFormatterBuilder.PaddedNumber(dateTimeFieldType0, 0, false, 7593750);
    MockFileWriter mockFileWriter0 = new MockFileWriter(""TkXj<+"", false);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime(168L, (Chronology) buddhistChronology0);
    assertEquals(4, localDateTime0.size());
}",""
"public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);
}","public void test1302110() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFractionOfMinute(0, (-76));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends the print/parse of a fractional minute.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    return append0(new TextField(fieldType, true));
}","public void test1312112() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendShortText((DateTimeFieldType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field type must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as short text, and the
 * parser to expect text.
 *
 * @param fieldType  type of field to append
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public static DateTimeFieldType secondOfDay() {
    return SECOND_OF_DAY_TYPE;
}","public void test1322114() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the second of day field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1322115() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertEquals(""secondOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1322116() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    assertEquals(""secondOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, true));
}","public void test1322117() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFixedSignedDecimal(dateTimeFieldType0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal number of digits: 0
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an signed decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, true));
}","public void test1332119() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFixedSignedDecimal((DateTimeFieldType) null, 259);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field type must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an signed decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, true));
}","public void test1342124() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedSignedDecimal(dateTimeFieldType0, 60000);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an signed decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public String toString() {
    return getName();
}","public void test1342127() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedSignedDecimal(dateTimeFieldType0, 60000);
    assertEquals(""yearOfCentury"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1342128() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedSignedDecimal(dateTimeFieldType0, 60000);
    assertEquals(""yearOfCentury"", dateTimeFieldType0.getName());
}",""
"public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);
}","public void test1352130() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendWeekyear(1, 1);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric weekyear field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Get the millis of second field type.
 *
 * @return the DateTimeFieldType constant
 */
public static DateTimeFieldType millisOfSecond() {
    return MILLIS_OF_SECOND_TYPE;
}","public void test1362134() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertNotNull(dateTimeFieldType0);
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1362135() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertEquals(""millisOfSecond"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1362136() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    assertEquals(""millisOfSecond"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, true));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
    }
}","public void test1362137() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.millisOfSecond();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendSignedDecimal(dateTimeFieldType0, 0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect a signed decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);
}","public void test1372139() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendYear(5, 0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric year field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, true));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
    }
}","public void test1382143() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendSignedDecimal((DateTimeFieldType) null, 210, 210);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field type must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect a signed decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, false));
}","public void test1392148() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFixedDecimal(dateTimeFieldType0, (-2123));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal number of digits: -2123
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an unsigned decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"public static DateTimeFieldType clockhourOfDay() {
    return CLOCKHOUR_OF_DAY_TYPE;
}","public void test1402150() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    assertNotNull(dateTimeFieldType0);
}","/**
 * Get the hour of day (offset to 1-24) field type.
 *
 * @return the DateTimeFieldType constant
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1402151() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    assertEquals(""clockhourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1402152() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    assertEquals(""clockhourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (numDigits <= 0) {
        throw new IllegalArgumentException(""Illegal number of digits: "" + numDigits);
    }
    return append0(new FixedNumber(fieldType, numDigits, false));
}","public void test1402153() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedDecimal(dateTimeFieldType0, 2946);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a field value as a fixed-width decimal
 * number (smaller numbers will be left-padded with zeros), and the parser
 * to expect an unsigned decimal number with the same fixed width.
 *
 * @param fieldType  type of field to append
 * @param numDigits  the exact number of digits to parse or print, except if
 * printed value requires more digits
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1402156() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedDecimal(dateTimeFieldType0, 2946);
    assertEquals(""clockhourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1402157() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendFixedDecimal(dateTimeFieldType0, 2946);
    assertEquals(""clockhourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
    return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);
}","public void test1412159() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendYearOfEra(0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric yearOfEra field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field type must not be null"");
    }
    if (maxDigits < minDigits) {
        maxDigits = minDigits;
    }
    if (minDigits < 0 || maxDigits <= 0) {
        throw new IllegalArgumentException();
    }
    if (minDigits <= 1) {
        return append0(new UnpaddedNumber(fieldType, maxDigits, false));
    } else {
        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
    }
}","public void test1422161() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendDecimal((DateTimeFieldType) null, 1, (-2317));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field type must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a field value as a decimal number, and the
 * parser to expect an unsigned decimal number.
 *
 * @param fieldType  type of field to append
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if field type is null
 */"
"public DateTimeFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    switch(text.length()) {
        case 0:
            return this;
        case 1:
            return append0(new CharacterLiteral(text.charAt(0)));
        default:
            return append0(new StringLiteral(text));
    }
}","public void test1432163() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendLiteral(""S"");
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit specific text, and the parser to expect
 * it. The parser is case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if text is null
 */"
"public DateTimeFormatterBuilder appendLiteral(String text) {
    if (text == null) {
        throw new IllegalArgumentException(""Literal must not be null"");
    }
    switch(text.length()) {
        case 0:
            return this;
        case 1:
            return append0(new CharacterLiteral(text.charAt(0)));
        default:
            return append0(new StringLiteral(text));
    }
}","public void test1442167() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendLiteral((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Literal must not be null
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit specific text, and the parser to expect
 * it. The parser is case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if text is null
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {
    checkPrinter(printer);
    checkParser(parser);
    return append0(printer, parser);
}","public void test1452172() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral0 = new DateTimeFormatterBuilder.CharacterLiteral('4');
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimePrinter) null, (DateTimeParser) dateTimeFormatterBuilder_CharacterLiteral0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No printer supplied
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends a printer/parser pair.
 *
 * @param printer  the printer to add
 * @param parser  the parser to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if printer or parser is null or of an invalid type
 */"
"public DateTimeFormatterBuilder append(DateTimeParser parser) {
    checkParser(parser);
    return append0(null, parser);
}","public void test1462174() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimeParser) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No parser supplied
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends just a parser. With no matching printer, a printer cannot be
 * built from this builder.
 *
 * @param parser  the parser to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if parser is null or of an invalid type
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
    if (printer != null) {
        checkPrinter(printer);
    }
    if (parsers == null) {
        throw new IllegalArgumentException(""No parsers supplied"");
    }
    int length = parsers.length;
    if (length == 1) {
        if (parsers[0] == null) {
            throw new IllegalArgumentException(""No parser supplied"");
        }
        return append0(printer, parsers[0]);
    }
    DateTimeParser[] copyOfParsers = new DateTimeParser[length];
    int i;
    for (i = 0; i < length - 1; i++) {
        if ((copyOfParsers[i] = parsers[i]) == null) {
            throw new IllegalArgumentException(""Incomplete parser array"");
        }
    }
    copyOfParsers[i] = parsers[i];
    return append0(printer, new MatchingParser(copyOfParsers));
}","public void test1472182() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    dateTimeParserArray0[0] = (DateTimeParser) dateTimeFormatterBuilder_Composite0;
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.append((DateTimePrinter) dateTimeFormatterBuilder_Composite0, dateTimeParserArray0);
    assertNotNull(dateTimeFormatterBuilder1);
}","/**
 * Appends a printer and a set of matching parsers. When parsing, the first
 * parser in the list is selected for parsing. If it fails, the next is
 * chosen, and so on. If none of these parsers succeeds, then the failed
 * position of the parser that made the greatest progress is returned.
 * <p>
 * Only the printer is optional. In addition, it is illegal for any but the
 * last of the parser array elements to be null. If the last element is
 * null, this represents the empty parser. The presence of an empty parser
 * indicates that the entire array of parse formats is optional.
 *
 * @param printer  the printer to add
 * @param parsers  the parsers to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if any printer or parser is of an invalid type
 * @throws IllegalArgumentException if any parser element but the last is null
 */"
"public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
    if (printer != null) {
        checkPrinter(printer);
    }
    if (parsers == null) {
        throw new IllegalArgumentException(""No parsers supplied"");
    }
    int length = parsers.length;
    if (length == 1) {
        if (parsers[0] == null) {
            throw new IllegalArgumentException(""No parser supplied"");
        }
        return append0(printer, parsers[0]);
    }
    DateTimeParser[] copyOfParsers = new DateTimeParser[length];
    int i;
    for (i = 0; i < length - 1; i++) {
        if ((copyOfParsers[i] = parsers[i]) == null) {
            throw new IllegalArgumentException(""Incomplete parser array"");
        }
    }
    copyOfParsers[i] = parsers[i];
    return append0(printer, new MatchingParser(copyOfParsers));
}","public void test1482196() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite0 = new DateTimeFormatterBuilder.Composite(linkedList0);
    DateTimeParser[] dateTimeParserArray0 = new DateTimeParser[1];
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.append((DateTimePrinter) dateTimeFormatterBuilder_Composite0, dateTimeParserArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No parser supplied
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends a printer and a set of matching parsers. When parsing, the first
 * parser in the list is selected for parsing. If it fails, the next is
 * chosen, and so on. If none of these parsers succeeds, then the failed
 * position of the parser that made the greatest progress is returned.
 * <p>
 * Only the printer is optional. In addition, it is illegal for any but the
 * last of the parser array elements to be null. If the last element is
 * null, this represents the empty parser. The presence of an empty parser
 * indicates that the entire array of parse formats is optional.
 *
 * @param printer  the printer to add
 * @param parsers  the parsers to add
 * @return this DateTimeFormatterBuilder, for chaining
 * @throws IllegalArgumentException if any printer or parser is of an invalid type
 * @throws IllegalArgumentException if any parser element but the last is null
 */"
"public DateTimeParser toParser() {
    Object f = getFormatter();
    if (isParser(f)) {
        return (DateTimeParser) f;
    }
    throw new UnsupportedOperationException(""Parsing is not supported"");
}","public void test1492198() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.toParser();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Parsing is not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Internal method to create a DateTimeParser instance using all the
 * appended elements.
 * <p>
 * Most applications will not use this method.
 * If you want a parser in an application, call {@link #toFormatter()}
 * and just use the parsing API.
 * <p>
 * Subsequent changes to this builder do not affect the returned parser.
 *
 * @throws UnsupportedOperationException if parsing is not supported
 */"
"public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) {
    chrono = DateTimeUtils.getChronology(chrono).withUTC();
    return new LocalTime(millisOfDay, chrono);
}","public void test1502219() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    MockFileWriter mockFileWriter0 = new MockFileWriter(""V*5{`cp )y~EvNag"", false);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(bufferedWriter0, false);
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-4644L), (Chronology) copticChronology0);
    assertNotNull(localTime0);
}","/**
 * Constructs a LocalTime from the specified millis of day using the
 * specified chronology.
 * <p>
 * The millisOfDay value may exceed the number of millis in one day,
 * but additional days will be ignored.
 * This method uses the UTC time zone internally.
 *
 * @param millisOfDay  the number of milliseconds into a day to convert
 * @param chrono  the chronology, null means ISO chronology
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute
 * and MillisOfSecond.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test1502221() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    MockFileWriter mockFileWriter0 = new MockFileWriter(""V*5{`cp )y~EvNag"", false);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(bufferedWriter0, false);
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-4644L), (Chronology) copticChronology0);
    assertEquals(4, localTime0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * <p>
 * By convention, names follow a pattern of ""dddOfRrr"", where ""ddd"" represents
 * the (singular) duration unit field name and ""Rrr"" represents the (singular)
 * duration range field name. If the range field is not applicable, then
 * the name of the field is simply the (singular) duration field name.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1502223() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    MockFileWriter mockFileWriter0 = new MockFileWriter(""V*5{`cp )y~EvNag"", false);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(bufferedWriter0, false);
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-4644L), (Chronology) copticChronology0);
    dateTimeFormatterBuilder_Fraction0.printTo((Writer) mockPrintWriter0, (ReadablePartial) localTime0, locale0);
    assertEquals(""hourOfDay"", dateTimeFieldType0.getName());
}",""
"public String toString() {
    return getName();
}","public void test1502224() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    MockFileWriter mockFileWriter0 = new MockFileWriter(""V*5{`cp )y~EvNag"", false);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(bufferedWriter0, false);
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-4644L), (Chronology) copticChronology0);
    dateTimeFormatterBuilder_Fraction0.printTo((Writer) mockPrintWriter0, (ReadablePartial) localTime0, locale0);
    assertEquals(""hourOfDay"", dateTimeFieldType0.toString());
}","/**
 * Get a suitable debug string.
 *
 * @return debug string
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is four.
 * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute
 * and MillisOfSecond.
 *
 * @return the field count, four
 */
public int size() {
    return 4;
}","public void test1502233() throws Throwable {
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.hourOfDay();
    DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction0 = new DateTimeFormatterBuilder.Fraction(dateTimeFieldType0, (-480), (-1054));
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    Locale locale0 = Locale.KOREAN;
    MockFileWriter mockFileWriter0 = new MockFileWriter(""V*5{`cp )y~EvNag"", false);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockFileWriter0);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(bufferedWriter0, false);
    LocalTime localTime0 = LocalTime.fromMillisOfDay((-4644L), (Chronology) copticChronology0);
    dateTimeFormatterBuilder_Fraction0.printTo((Writer) mockPrintWriter0, (ReadablePartial) localTime0, locale0);
    assertEquals(4, localTime0.size());
}",""
"public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);
}","public void test1682255() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendClockhourOfDay((-1988));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric clockhourOfDay field.
 *
 * @param minDigits minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendHalfdayOfDayText() {
    return appendText(DateTimeFieldType.halfdayOfDay());
}","public void test1692256() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendHalfdayOfDayText();
    assertSame(dateTimeFormatterBuilder1, dateTimeFormatterBuilder0);
}","/**
 * Instructs the printer to emit a locale-specific AM/PM text, and the
 * parser to expect it. The parser is case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {
    return appendTwoDigitWeekyear(pivot, false);
}","public void test1702257() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTwoDigitWeekyear(2946);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric weekyear field which always prints
 * and parses two digits. A pivot year is used during parsing to determine
 * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivot  pivot weekyear to use when parsing
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);
}","public void test1712258() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMinuteOfDay(16);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric minuteOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {
    return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);
}","public void test1722259() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendYearOfCentury(5, 431);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric year of century field.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) {
    return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));
}","public void test1742262() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendTimeZoneOffset(""f"", ""pVYM$2rx"", false, 719482, (-945));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset"", e);
    }
}","/**
 * Instructs the printer to emit text and numbers to display time zone
 * offset from UTC. A parser will use the parsed time zone offset to adjust
 * the datetime.
 * <p>
 * If zero offset print text is supplied, then it will be printed when the zone is zero.
 * If zero offset parse text is supplied, then either it or the offset will be parsed.
 *
 * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If
 * null, offset is always shown.
 * @param zeroOffsetParseText  the text to optionally parse to indicate that the time
 * zone offset is zero. If null, then always use the offset.
 * @param showSeparators  if true, prints ':' separator before minute and
 * second field and prints '.' separator before fraction field.
 * @param minFields  minimum number of fields to print, stopping when no
 * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
 * @param maxFields  maximum number of fields to print
 * @return this DateTimeFormatterBuilder, for chaining
 * @since 2.0
 */"
"public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);
}","public void test1752263() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendMillisOfDay((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric millisOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMonthOfYearShortText() {
    return appendShortText(DateTimeFieldType.monthOfYear());
}","public void test1762264() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMonthOfYearShortText();
    assertSame(dateTimeFormatterBuilder1, dateTimeFormatterBuilder0);
}","/**
 * Instructs the printer to emit a locale-specific monthOfYear text. The
 * parser will accept a long or short monthOfYear text, case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public boolean canBuildPrinter() {
    return isPrinter(getFormatter());
}","public void test1772265() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    boolean boolean0 = dateTimeFormatterBuilder0.canBuildPrinter();
    assertFalse(boolean0);
}","/**
 * Returns true if toPrinter can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a printer can be built
 */"
"public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
    return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);
}","public void test1782266() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMillisOfSecond(574);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric millisOfSecond field.
 * <p>
 * This method will append a field that prints a three digit value.
 * During parsing the value that is parsed is assumed to be three digits.
 * If less than three digits are present then they will be counted as the
 * smallest parts of the millisecond. This is probably not what you want
 * if you are using the field as a fraction. Instead, a fractional
 * millisecond should be produced using {@link #appendFractionOfSecond}.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public boolean canBuildParser() {
    return isParser(getFormatter());
}","public void test1792267() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    boolean boolean0 = dateTimeFormatterBuilder0.canBuildParser();
    assertFalse(boolean0);
}","/**
 * Returns true if toParser can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a parser can be built
 */"
"public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
    return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);
}","public void test1802268() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendSecondOfDay((-286));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric secondOfDay field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTimeZoneName() {
    return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);
}","public void test1812269() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTimeZoneName();
    assertSame(dateTimeFormatterBuilder1, dateTimeFormatterBuilder0);
}","/**
 * Instructs the printer to emit a locale-specific time zone name.
 * Using this method prevents parsing, because time zone names are not unique.
 * See {@link #appendTimeZoneName(Map)}.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Clears out all the appended elements, allowing this builder to be
 * reused.
 */
public void clear() {
    iFormatter = null;
    iElementPairs.clear();
}","public void test1832276() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    dateTimeFormatterBuilder0.clear();
}",""
"//-----------------------------------------------------------------------
/**
 * Calls upon {@link DateTimeFormat} to parse the pattern and append the
 * results into this builder.
 *
 * @param pattern  pattern specification
 * @throws IllegalArgumentException if the pattern is invalid
 * @see DateTimeFormat
 */
public DateTimeFormatterBuilder appendPattern(String pattern) {
    DateTimeFormat.appendPatternTo(this, pattern);
    return this;
}","public void test1842277() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendPattern(""EU["");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}",""
"public boolean canBuildParser() {
    return isParser(getFormatter());
}","public void test1852278() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    dateTimeFormatterBuilder0.appendDayOfWeekText();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTwoDigitYear(260, true);
    boolean boolean0 = dateTimeFormatterBuilder1.canBuildParser();
    assertTrue(boolean0);
}","/**
 * Returns true if toParser can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a parser can be built
 */"
"public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {
    return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);
}","public void test1862279() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendFractionOfDay((-241), (-241));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Appends the print/parse of a fractional day.
 * <p>
 * This reliably handles the case where fractional digits are being handled
 * beyond a visible decimal point. The digits parsed will always be treated
 * as the most significant (numerically largest) digits.
 * Thus '23' will be parsed as 0.23 days (converted to milliseconds).
 * This method does not print or parse the decimal point itself.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to print or parse
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendMonthOfYearText() {
    return appendText(DateTimeFieldType.monthOfYear());
}","public void test1872280() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendMonthOfYearText();
    assertSame(dateTimeFormatterBuilder1, dateTimeFormatterBuilder0);
}","/**
 * Instructs the printer to emit a short locale-specific monthOfYear
 * text. The parser will accept a long or short monthOfYear text,
 * case-insensitive.
 *
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Returns true if toFormatter can be called without throwing an
 * UnsupportedOperationException.
 *
 * @return true if a formatter can be built
 */
public boolean canBuildFormatter() {
    return isFormatter(getFormatter());
}","public void test1882281() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    boolean boolean0 = dateTimeFormatterBuilder0.canBuildFormatter();
    assertFalse(boolean0);
}",""
"public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
    return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);
}","public void test1892282() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendHourOfHalfday(12825000);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric hourOfHalfday field.
 *
 * @param minDigits  minimum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {
    return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);
}","public void test1912285() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    // Undeclared exception!
    try {
        dateTimeFormatterBuilder0.appendCenturyOfEra((-457), (-457));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder"", e);
    }
}","/**
 * Instructs the printer to emit a numeric century of era field.
 *
 * @param minDigits  minimum number of digits to print
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
    return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);
}","public void test1922286() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendYearOfEra(5, 574);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric yearOfEra field.
 *
 * @param minDigits  minimum number of digits to <i>print</i>
 * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated
 * maximum number of digits to print
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {
    return appendTwoDigitYear(pivot, false);
}","public void test1932287() throws Throwable {
    DateTimeFormatterBuilder dateTimeFormatterBuilder0 = new DateTimeFormatterBuilder();
    DateTimeFormatterBuilder dateTimeFormatterBuilder1 = dateTimeFormatterBuilder0.appendTwoDigitYear(0);
    assertSame(dateTimeFormatterBuilder0, dateTimeFormatterBuilder1);
}","/**
 * Instructs the printer to emit a numeric year field which always prints
 * and parses two digits. A pivot year is used during parsing to determine
 * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.
 *
 * <pre>
 * pivot   supported range   00 is   20 is   40 is   60 is   80 is
 * ---------------------------------------------------------------
 * 1950      1900..1999      1900    1920    1940    1960    1980
 * 1975      1925..2024      2000    2020    1940    1960    1980
 * 2000      1950..2049      2000    2020    2040    1960    1980
 * 2025      1975..2074      2000    2020    2040    2060    1980
 * 2050      2000..2099      2000    2020    2040    2060    2080
 * </pre>
 *
 * @param pivot  pivot year to use when parsing
 * @return this DateTimeFormatterBuilder, for chaining
 */"
"public Instant(Object instant) {
    super();
    InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
    iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());
}","public void test1972292() throws Throwable {
    Instant instant0 = null;
    try {
        instant0 = new Instant(""kFdI~^pqIY}sv"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""kFdI~^pqIY}sv\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Constructs an instance from an Object that represents a datetime.
 * <p>
 * The recognised object types are defined in {@link ConverterManager} and
 * include String, Calendar and Date.
 *
 * @param instant  the datetime object, null means now
 * @throws IllegalArgumentException if the instant is invalid
 */"
