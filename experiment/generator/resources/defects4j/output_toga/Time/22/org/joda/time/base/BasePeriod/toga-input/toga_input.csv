focal_method,test_prefix,docstring
"public void setValue(int index, int value) {
    super.setValue(index, value);
}","public void test000() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod((-2880L));
    // Undeclared exception!
    try {
        mutablePeriod0.setValue(1204, 18);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1204
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Sets the value of one of the fields by index.
 *
 * @param index  the field index
 * @param value  the new value for the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public void add(ReadablePeriod period) {
    super.addPeriod(period);
}","public void test011() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    Period period0 = new Period((-1458L), (Chronology) gJChronology0);
    PeriodType periodType0 = PeriodType.weeks();
    MutablePeriod mutablePeriod0 = new MutablePeriod(100000000L, periodType0);
    // Undeclared exception!
    try {
        mutablePeriod0.add((ReadablePeriod) period0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'seconds'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Adds a period to this one by adding each field in turn.
 *
 * @param period  the period to add, null means add nothing
 * @throws IllegalArgumentException if the period being added contains a field
 * not supported by this period
 * @throws ArithmeticException if the addition exceeds the capacity of the period
 */"
"public void addYears(int years) {
    super.addField(DurationFieldType.years(), years);
}","public void test022() throws Throwable {
    Weeks weeks0 = Weeks.MIN_VALUE;
    PeriodType periodType0 = weeks0.getPeriodType();
    MutablePeriod mutablePeriod0 = new MutablePeriod(10000000000000000L, periodType0);
    // Undeclared exception!
    try {
        mutablePeriod0.addYears((-1375));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'years'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Adds the specified years to the number of years in the period.
 *
 * @param years  the number of years
 * @throws IllegalArgumentException if field is not supported and the value is non-zero
 * @throws ArithmeticException if the addition exceeds the capacity of the period
 */"
"//-----------------------------------------------------------------------
/**
 * Sets the number of millis of the period.
 *
 * @param millis  the number of millis
 * @throws IllegalArgumentException if field is not supported and the value is non-zero
 */
public void setMillis(int millis) {
    super.setField(DurationFieldType.millis(), millis);
}","public void test033() throws Throwable {
    Period period0 = new Period(0L);
    Days days0 = period0.toStandardDays();
    PeriodType periodType0 = days0.getPeriodType();
    MutablePeriod mutablePeriod0 = new MutablePeriod(0L, 0L, periodType0);
    // Undeclared exception!
    try {
        mutablePeriod0.setMillis((-1808));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'millis'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test044() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    MutablePeriod mutablePeriod0 = new MutablePeriod((Object) null, islamicChronology0);
    mutablePeriod0.setPeriod(885, 1, (-795), 1, 355, 1, 0, 514);
    assertEquals(8, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test055() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    MutablePeriod mutablePeriod0 = new MutablePeriod((Object) null, islamicChronology0);
    Months months0 = Months.ZERO;
    PeriodType periodType0 = months0.getPeriodType();
    Period period0 = new Period(mutablePeriod0, periodType0, islamicChronology0);
    assertEquals(1, period0.size());
}",""
"public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) {
    super(years, months, weeks, days, hours, minutes, seconds, millis, type);
}","public void test066() throws Throwable {
    Months months0 = Months.MIN_VALUE;
    PeriodType periodType0 = months0.getPeriodType();
    Period period0 = null;
    try {
        period0 = new Period(0, 0, 0, 0, 725, 3216, 0, 0, periodType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'hours'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Create a period from a set of field values.
 * <p>
 * There is usually little need to use this constructor.
 * The period type is used primarily to define how to split an interval into a period.
 * As this constructor already is split, the period type does no real work.
 *
 * @param years  amount of years in this period, which must be zero if unsupported
 * @param months  amount of months in this period, which must be zero if unsupported
 * @param weeks  amount of weeks in this period, which must be zero if unsupported
 * @param days  amount of days in this period, which must be zero if unsupported
 * @param hours  amount of hours in this period, which must be zero if unsupported
 * @param minutes  amount of minutes in this period, which must be zero if unsupported
 * @param seconds  amount of seconds in this period, which must be zero if unsupported
 * @param millis  amount of milliseconds in this period, which must be zero if unsupported
 * @param type  which set of fields this period supports, null means AllType
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test077() throws Throwable {
    PeriodType periodType0 = PeriodType.standard();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    MutablePeriod mutablePeriod0 = new MutablePeriod(10000000000000L, periodType0, (Chronology) ethiopicChronology0);
    mutablePeriod0.setPeriod(0L, (Chronology) ethiopicChronology0);
    mutablePeriod0.addMonths((-499));
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    DateMidnight dateMidnight0 = localDate0.toDateMidnight(dateTimeZone0);
    Duration duration0 = mutablePeriod0.toDurationTo(dateMidnight0);
    assertEquals((-1312156800000L), duration0.getMillis());
}",""
"public long getStandardSeconds() {
    return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
}","public void test088() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    DateTime dateTime0 = new DateTime((Chronology) gJChronology0);
    Interval interval0 = new Interval((ReadablePeriod) null, dateTime0);
    Period period0 = interval0.toPeriod();
    Period period1 = period0.plusYears(1024);
    Duration duration0 = period1.toDurationTo(dateTime0);
    assertEquals(32313859622L, duration0.getStandardSeconds());
}","/**
 * Gets the length of this duration in seconds assuming that there are the
 * standard number of milliseconds in a second.
 * <p>
 * This method assumes that there are 1000 milliseconds in a second.
 * All currently supplied chronologies use this definition.
 * <p>
 * This returns <code>getMillis() / 1000</code>.
 * The result is an integer division, so 2999 millis returns 2 seconds.
 *
 * @return the length of the duration in standard seconds
 * @since 1.6
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test099() throws Throwable {
    Period period0 = Period.millis((-978));
    GJChronology gJChronology0 = GJChronology.getInstance();
    Instant instant0 = gJChronology0.getGregorianCutover();
    Duration duration0 = period0.toDurationTo(instant0);
    assertEquals((-978L), duration0.getMillis());
}",""
"public long getStandardHours() {
    return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;
}","public void test1010() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    DateMidnight dateMidnight0 = new DateMidnight((Chronology) gregorianChronology0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(dateMidnight0, (ReadableInstant) null);
    mutablePeriod0.setDays(1576);
    Duration duration0 = mutablePeriod0.toDurationFrom((ReadableInstant) null);
    assertEquals(37843L, duration0.getStandardHours());
}","/**
 * Gets the length of this duration in hours assuming that there are the
 * standard number of milliseconds in an hour.
 * <p>
 * This method assumes that there are 60 minutes in an hour,
 * 60 seconds in a minute and 1000 milliseconds in a second.
 * All currently supplied chronologies use this definition.
 * <p>
 * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.
 * The result is an integer division, thus excess milliseconds are truncated.
 *
 * @return the length of the duration in standard seconds
 * @since 2.0
 */"
"public long getStandardSeconds() {
    return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;
}","public void test1111() throws Throwable {
    Period period0 = Period.millis((-115));
    Period period1 = period0.withDays((-115));
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(0, 0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    YearMonthDay yearMonthDay0 = new YearMonthDay((Chronology) iSOChronology0);
    DateMidnight dateMidnight0 = yearMonthDay0.toDateMidnight(dateTimeZone0);
    Duration duration0 = period1.toDurationFrom(dateMidnight0);
    assertEquals((-9936000L), duration0.getStandardSeconds());
}","/**
 * Gets the length of this duration in seconds assuming that there are the
 * standard number of milliseconds in a second.
 * <p>
 * This method assumes that there are 1000 milliseconds in a second.
 * All currently supplied chronologies use this definition.
 * <p>
 * This returns <code>getMillis() / 1000</code>.
 * The result is an integer division, so 2999 millis returns 2 seconds.
 *
 * @return the length of the duration in standard seconds
 * @since 1.6
 */"
"public long getStandardHours() {
    return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;
}","public void test1212() throws Throwable {
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    DateMidnight dateMidnight0 = new DateMidnight((Chronology) gregorianChronology0);
    MutablePeriod mutablePeriod0 = new MutablePeriod(dateMidnight0, (ReadableInstant) null);
    Duration duration0 = mutablePeriod0.toDurationFrom((ReadableInstant) null);
    assertEquals(20L, duration0.getStandardHours());
}","/**
 * Gets the length of this duration in hours assuming that there are the
 * standard number of milliseconds in an hour.
 * <p>
 * This method assumes that there are 60 minutes in an hour,
 * 60 seconds in a minute and 1000 milliseconds in a second.
 * All currently supplied chronologies use this definition.
 * <p>
 * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.
 * The result is an integer division, thus excess milliseconds are truncated.
 *
 * @return the length of the duration in standard seconds
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test1313() throws Throwable {
    Period period0 = Period.millis((-115));
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes(0, 0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    YearMonthDay yearMonthDay0 = new YearMonthDay((Chronology) iSOChronology0);
    DateMidnight dateMidnight0 = yearMonthDay0.toDateMidnight(dateTimeZone0);
    Duration duration0 = period0.toDurationFrom(dateMidnight0);
    assertEquals((-115L), duration0.getMillis());
}",""
"public int getValue(int index) {
    return iValues[index];
}","public void test1414() throws Throwable {
    Days days0 = Days.THREE;
    Period period0 = days0.toPeriod();
    int int0 = period0.getValue(0);
    assertEquals(0, int0);
}","/**
 * Gets the value at the specified index.
 *
 * @param index  the index to retrieve
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int getValue(int index) {
    return iValues[index];
}","public void test1515() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod((-1), (-1), (-1), 142);
    mutablePeriod0.setPeriod(142, 142, (-1), 1544, 0, 0, 60, (-1));
    int int0 = mutablePeriod0.getValue(1);
    assertEquals(142, int0);
}","/**
 * Gets the value at the specified index.
 *
 * @param index  the index to retrieve
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the name of the period type.
 *
 * @return the name
 */
public String getName() {
    return iName;
}","public void test1616() throws Throwable {
    Period period0 = Period.hours(0);
    PeriodType periodType0 = period0.getPeriodType();
    assertEquals(""Standard"", periodType0.getName());
}",""
"public int getValue(int index) {
    return iValues[index];
}","public void test1717() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(528);
    Duration duration0 = Duration.standardSeconds(0L);
    MutableDateTime mutableDateTime0 = new MutableDateTime((-2456L), dateTimeZone0);
    PeriodType periodType0 = PeriodType.yearMonthDayTime();
    Period period0 = new Period(duration0, mutableDateTime0, periodType0);
    // Undeclared exception!
    try {
        period0.getValue(900);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the value at the specified index.
 *
 * @param index  the index to retrieve
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * By convention, names are plural.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1818() throws Throwable {
    Period period0 = new Period(0L, (Chronology) null);
    DurationFieldType durationFieldType0 = period0.getFieldType(0);
    assertEquals(""years"", durationFieldType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test1919() throws Throwable {
    PeriodType periodType0 = PeriodType.yearDayTime();
    Period period0 = new Period(0L, (-941L), periodType0);
    int int0 = period0.size();
    assertEquals(6, int0);
}",""
"public void add(ReadablePeriod period) {
    super.addPeriod(period);
}","public void test2020() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDay();
    MutablePeriod mutablePeriod0 = new MutablePeriod(0L, periodType0, (Chronology) null);
    Days days0 = Days.THREE;
    Period period0 = days0.toPeriod();
    Period period1 = period0.plusMinutes(903);
    // Undeclared exception!
    try {
        mutablePeriod0.add((ReadablePeriod) period1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'minutes'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Adds a period to this one by adding each field in turn.
 *
 * @param period  the period to add, null means add nothing
 * @throws IllegalArgumentException if the period being added contains a field
 * not supported by this period
 * @throws ArithmeticException if the addition exceeds the capacity of the period
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test2121() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod(0, (-679), 2, (-1017));
    DateMidnight dateMidnight0 = new DateMidnight((long) (-679));
    Interval interval0 = dateMidnight0.toInterval();
    mutablePeriod0.add((ReadableInterval) interval0);
    assertEquals(8, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test2222() throws Throwable {
    Instant instant0 = new Instant();
    MutableDateTime mutableDateTime0 = instant0.toMutableDateTime();
    MutablePeriod mutablePeriod0 = new MutablePeriod(mutableDateTime0, instant0);
    mutablePeriod0.add((ReadablePeriod) null);
    assertEquals(8, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test2323() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(528);
    CopticChronology copticChronology0 = CopticChronology.getInstance(dateTimeZone0);
    MutablePeriod mutablePeriod0 = new MutablePeriod((-3893L), (Chronology) copticChronology0);
    mutablePeriod0.mergePeriod((ReadablePeriod) null);
    assertEquals(8, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test2424() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDay();
    MutablePeriod mutablePeriod0 = new MutablePeriod(1L, periodType0, (Chronology) null);
    mutablePeriod0.setWeeks(0);
    assertEquals(3, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Merges all the fields from the specified period into this one.
 * <p>
 * Fields that are not present in the specified period are left unaltered.
 *
 * @param period  the period to set, null ignored
 * @throws IllegalArgumentException if an unsupported field's value is non-zero
 */
public void mergePeriod(ReadablePeriod period) {
    super.mergePeriod(period);
}","public void test2525() throws Throwable {
    Period period0 = Period.millis((-579));
    PeriodType periodType0 = PeriodType.months();
    Instant instant0 = new Instant((-2788L));
    Chronology chronology0 = instant0.getChronology();
    MutablePeriod mutablePeriod0 = new MutablePeriod((long) (-579), periodType0, chronology0);
    // Undeclared exception!
    try {
        mutablePeriod0.mergePeriod(period0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'millis'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}",""
"public DurationFieldType getFieldType(int index) {
    return iType.getFieldType(index);
}","public void test2626() throws Throwable {
    Period period0 = new Period((Object) null);
    // Undeclared exception!
    try {
        period0.getFieldType(291);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the field type at the specified index.
 *
 * @param index  the index to retrieve
 * @return the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Sets the number of weeks of the period.
 *
 * @param weeks  the number of weeks
 * @throws IllegalArgumentException if field is not supported and the value is non-zero
 */
public void setWeeks(int weeks) {
    super.setField(DurationFieldType.weeks(), weeks);
}","public void test2727() throws Throwable {
    TimeOfDay timeOfDay0 = new TimeOfDay();
    PeriodType periodType0 = PeriodType.hours();
    Period period0 = new Period(timeOfDay0, timeOfDay0, periodType0);
    ISOChronology iSOChronology0 = ISOChronology.getInstanceUTC();
    MutablePeriod mutablePeriod0 = new MutablePeriod(period0, iSOChronology0);
    // Undeclared exception!
    try {
        mutablePeriod0.setWeeks(2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'weeks'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test2828() throws Throwable {
    LocalTime localTime0 = new LocalTime();
    Period period0 = new Period(localTime0, localTime0);
    assertEquals(8, period0.size());
}",""
"public Period(ReadablePartial start, ReadablePartial end) {
    super(start, end, null);
}","public void test2929() throws Throwable {
    LocalTime localTime0 = new LocalTime();
    Period period0 = null;
    try {
        period0 = new Period(localTime0, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Creates a period from two partially specified times.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each.
 * As these are Partial objects, time zones have no effect on the result.
 * <p>
 * The two partials must also both be contiguous - see
 * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.
 * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.
 * <p>
 * An alternative way of constructing a Period from two Partials
 * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.
 * That method handles all kinds of partials.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */"
"public Period(ReadablePartial start, ReadablePartial end) {
    super(start, end, null);
}","public void test3030() throws Throwable {
    Period period0 = null;
    try {
        period0 = new Period((ReadablePartial) null, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Creates a period from two partially specified times.
 * <p>
 * The two partials must contain the same fields, thus you can specify
 * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,
 * but not one of each.
 * As these are Partial objects, time zones have no effect on the result.
 * <p>
 * The two partials must also both be contiguous - see
 * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.
 * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.
 * <p>
 * An alternative way of constructing a Period from two Partials
 * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.
 * That method handles all kinds of partials.
 *
 * @param start  the start of the period, must not be null
 * @param end  the end of the period, must not be null
 * @throws IllegalArgumentException if the partials are null or invalid
 * @since 1.1
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test3131() throws Throwable {
    Period period0 = new Period((ReadableInstant) null, (ReadableInstant) null);
    assertEquals(8, period0.size());
}",""
"public void addDays(int days) {
    super.addField(DurationFieldType.days(), days);
}","public void test3232() throws Throwable {
    PeriodType periodType0 = PeriodType.minutes();
    MutablePeriod mutablePeriod0 = new MutablePeriod((Object) null, periodType0);
    // Undeclared exception!
    try {
        mutablePeriod0.addDays(2000);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Period does not support field 'days'
        //
        verifyException(""org.joda.time.base.BasePeriod"", e);
    }
}","/**
 * Adds the specified days to the number of days in the period.
 *
 * @param days  the number of days
 * @throws IllegalArgumentException if field is not supported and the value is non-zero
 * @throws ArithmeticException if the addition exceeds the capacity of the period
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test3333() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDay();
    MutablePeriod mutablePeriod0 = new MutablePeriod(1L, periodType0, (Chronology) null);
    mutablePeriod0.addMinutes(0);
    assertEquals(3, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test3434() throws Throwable {
    MutablePeriod mutablePeriod0 = new MutablePeriod();
    Instant instant0 = new Instant((-2887L));
    Duration duration0 = mutablePeriod0.toDurationTo(instant0);
    assertEquals(0L, duration0.getMillis());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports.
 *
 * @return the number of fields supported
 */
public int size() {
    return iType.size();
}","public void test3535() throws Throwable {
    PeriodType periodType0 = PeriodType.yearMonthDay();
    MutablePeriod mutablePeriod0 = new MutablePeriod(1L, periodType0, (Chronology) null);
    mutablePeriod0.setValue(0, 0);
    assertEquals(3, mutablePeriod0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the length of this duration in milliseconds.
 *
 * @return the length of the duration in milliseconds.
 */
public long getMillis() {
    return iMillis;
}","public void test3636() throws Throwable {
    Instant instant0 = new Instant();
    Duration duration0 = Duration.millis(0L);
    Period period0 = new Period(instant0, duration0);
    Duration duration1 = period0.toDurationFrom(instant0);
    assertEquals(0L, duration1.getMillis());
}",""
