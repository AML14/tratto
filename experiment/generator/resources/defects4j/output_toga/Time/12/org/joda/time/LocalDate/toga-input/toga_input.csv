focal_method,test_prefix,docstring
"public LocalDate minusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().subtract(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test0000() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-2973));
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) ethiopicChronology0);
    localDate0.minusDays((-2973));
}","/**
 * Returns a copy of this date minus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusDays(6);
 * LocalDate subtracted = dt.minus(Period.days(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);
 * </pre>
 *
 * @param days  the amount of days to subtract, may be negative
 * @return the new LocalDate minus the increased days
 */"
"public LocalDate minusMonths(int months) {
    if (months == 0) {
        return this;
    }
    long instant = getChronology().months().subtract(getLocalMillis(), months);
    return withLocalMillis(instant);
}","public void test0011() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    localDate0.minusMonths((-1946));
}","/**
 * Returns a copy of this date minus the specified number of months.
 * <p>
 * This subtracts the specified number of months from the date.
 * The subtraction may change the year, but the day-of-month is normally unchanged.
 * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusMonths(6);
 * LocalDate subtracted = dt.minus(Period.months(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);
 * </pre>
 *
 * @param months  the amount of months to subtract, may be negative
 * @return the new LocalDate minus the increased months
 */"
"public LocalDate plusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().add(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test0022() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.plusDays((-2082));
}","/**
 * Returns a copy of this date plus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusDays(6);
 * LocalDate added = dt.plus(Period.days(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);
 * </pre>
 *
 * @param days  the amount of days to add, may be negative
 * @return the new LocalDate plus the increased days
 */"
"public LocalDate plusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    long instant = getChronology().weeks().add(getLocalMillis(), weeks);
    return withLocalMillis(instant);
}","public void test0033() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.plusWeeks((-368));
}","/**
 * Returns a copy of this date plus the specified number of weeks.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusWeeks(6);
 * LocalDate added = dt.plus(Period.weeks(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);
 * </pre>
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new LocalDate plus the increased weeks
 */"
"public LocalDate plusMonths(int months) {
    if (months == 0) {
        return this;
    }
    long instant = getChronology().months().add(getLocalMillis(), months);
    return withLocalMillis(instant);
}","public void test0044() throws Throwable {
    MockDate mockDate0 = new MockDate((-27), (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    localDate0.plusMonths((-21));
}","/**
 * Returns a copy of this date plus the specified number of months.
 * <p>
 * This adds the specified number of months to the date.
 * The addition may change the year, but the day-of-month is normally unchanged.
 * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusMonths(6);
 * LocalDate added = dt.plus(Period.months(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);
 * </pre>
 *
 * @param months  the amount of months to add, may be negative
 * @return the new LocalDate plus the increased months
 */"
"public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    if (amount == 0) {
        return this;
    }
    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);
    return withLocalMillis(instant);
}","public void test0055() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime(21600000L, (Chronology) buddhistChronology0);
    LocalDate localDate0 = new LocalDate(localDateTime0, (DateTimeZone) null);
    DurationFieldType durationFieldType0 = DurationFieldType.months();
    localDate0.withFieldAdded(durationFieldType0, 1);
}","/**
 * Returns a copy of this date with the value of the specified field increased.
 * <p>
 * If the addition is zero or the field is null, then <code>this</code> is returned.
 * <p>
 * These three lines are equivalent:
 * <pre>
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * </pre>
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this date with the field updated
 * @throws IllegalArgumentException if the field is null or unsupported
 * @throws ArithmeticException if the result exceeds the internal capacity
 */"
"public LocalDate withField(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);
    return withLocalMillis(instant);
}","public void test0099() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.weekOfWeekyear();
    localDate0.withField(dateTimeFieldType0, 2);
}","/**
 * Returns a copy of this date with the specified field set to a new value.
 * <p>
 * For example, if the field type is <code>monthOfYear</code> then the
 * month of year field will be changed in the returned instance.
 * If the field type is null, then <code>this</code> is returned.
 * <p>
 * These two lines are equivalent:
 * <pre>
 * LocalDate updated = dt.withDayOfMonth(6);
 * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);
 * </pre>
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this date with the field set
 * @throws IllegalArgumentException if the field is null or unsupported
 */"
"public LocalDate withDayOfWeek(int dayOfWeek) {
    return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));
}","public void test01010() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.withDayOfWeek(1);
}","/**
 * Returns a copy of this date with the day of week field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * day of week changed.
 *
 * @param dayOfWeek  the day of week to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public Interval toInterval(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    DateTime start = toDateTimeAtStartOfDay(zone);
    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);
    return new Interval(start, end);
}","public void test01111() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes((-87), 1);
    MonthDay monthDay0 = MonthDay.now(dateTimeZone0);
    LocalDate localDate0 = monthDay0.toLocalDate(1);
    LocalDate localDate1 = localDate0.minusYears((-2331));
    localDate1.toInterval(dateTimeZone0);
}","/**
 * Converts this object to an Interval representing the whole day.
 * <p>
 * The interval may have more or less than 24 hours if this is a daylight
 * savings cutover date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the Interval in, null means default
 * @return a interval over the day
 */"
"public Interval toInterval(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    DateTime start = toDateTimeAtStartOfDay(zone);
    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);
    return new Interval(start, end);
}","public void test01212() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    localDate0.toInterval((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this object to an Interval representing the whole day.
 * <p>
 * The interval may have more or less than 24 hours if this is a daylight
 * savings cutover date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the Interval in, null means default
 * @return a interval over the day
 */"
"public Interval toInterval(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    DateTime start = toDateTimeAtStartOfDay(zone);
    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);
    return new Interval(start, end);
}","public void test01313() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Days days0 = Days.MAX_VALUE;
    LocalDate localDate1 = localDate0.minus(days0);
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    localDate1.toInterval((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this object to an Interval representing the whole day.
 * <p>
 * The interval may have more or less than 24 hours if this is a daylight
 * savings cutover date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the Interval in, null means default
 * @return a interval over the day
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this object to an Interval representing the whole day
 * in the default time zone.
 * <p>
 * The interval may have more or less than 24 hours if this is a daylight
 * savings cutover date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @return a interval over the day
 */
public Interval toInterval() {
    return toInterval(null);
}","public void test01414() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    LocalDate localDate1 = localDate0.withYear((-28800000));
    localDate1.toInterval();
}",""
"public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;
    long instant = zone.convertLocalToUTC(localMillis, false);
    instant = chrono.dayOfMonth().roundFloor(instant);
    return new DateTime(instant, chrono);
}","public void test01515() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = new LocalDate();
    LocalDate localDate1 = localDate0.withLocalMillis(21600000L);
    localDate1.toDateTimeAtStartOfDay((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime at the earliest valid time
 * for the date using the specified time zone.
 * <p>
 * The time will normally be midnight, as that is the earliest time on
 * any given day. However, in some time zones when Daylight Savings Time
 * starts, there is no midnight because time jumps from 11:59 to 01:00.
 * This method handles that situation by returning 01:00 on that date.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at the start of the day
 * @since 1.5
 */"
"public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;
    long instant = zone.convertLocalToUTC(localMillis, false);
    instant = chrono.dayOfMonth().roundFloor(instant);
    return new DateTime(instant, chrono);
}","public void test01616() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.toDateTimeAtStartOfDay(dateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime at the earliest valid time
 * for the date using the specified time zone.
 * <p>
 * The time will normally be midnight, as that is the earliest time on
 * any given day. However, in some time zones when Daylight Savings Time
 * starts, there is no midnight because time jumps from 11:59 to 01:00.
 * This method handles that situation by returning 01:00 on that date.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at the start of the day
 * @since 1.5
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this LocalDate to a full datetime at the earliest valid time
 * for the date using the default time zone.
 * <p>
 * The time will normally be midnight, as that is the earliest time on
 * any given day. However, in some time zones when Daylight Savings Time
 * starts, there is no midnight because time jumps from 11:59 to 01:00.
 * This method handles that situation by returning 01:00 on that date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @return this date as a datetime at the start of the day
 * @since 1.5
 */
public DateTime toDateTimeAtStartOfDay() {
    return toDateTimeAtStartOfDay(null);
}","public void test01717() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime(21600000L, (Chronology) buddhistChronology0);
    LocalDate localDate0 = new LocalDate(localDateTime0, (DateTimeZone) null);
    LocalDate localDate1 = localDate0.minusMonths(1840);
    localDate1.toDateTimeAtStartOfDay();
}",""
"@Deprecated
public DateTime toDateTimeAtMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);
}","public void test01818() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    Chronology chronology0 = ethiopicChronology0.withZone(fixedDateTimeZone0);
    LocalDate localDate0 = new LocalDate(0L, chronology0);
    localDate0.toDateTimeAtMidnight((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime at midnight using the
 * specified time zone.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at midnight
 * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception
 */"
"@Deprecated
public DateTime toDateTimeAtMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);
}","public void test01919() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = LocalDate.now((DateTimeZone) fixedDateTimeZone0);
    localDate0.toDateTimeAtMidnight((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime at midnight using the
 * specified time zone.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at midnight
 * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this LocalDate to a full datetime at midnight using the default
 * time zone.
 * <p>
 * This method will throw an exception if the default time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @return this date as a datetime at midnight
 * @deprecated Use {@link #toDateTimeAtStartOfDay()} which won't throw an exception
 */
@Deprecated
public DateTime toDateTimeAtMidnight() {
    return toDateTimeAtMidnight(null);
}","public void test02020() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    Chronology chronology0 = ethiopicChronology0.withZone(fixedDateTimeZone0);
    LocalDate localDate0 = new LocalDate(0L, chronology0);
    localDate0.toDateTimeAtMidnight();
}",""
"public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long instantMillis = DateTimeUtils.currentTimeMillis();
    long resolved = chrono.set(this, instantMillis);
    return new DateTime(resolved, chrono);
}","public void test02121() throws Throwable {
    MockDate mockDate0 = new MockDate(0, (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    localDate0.toDateTimeAtCurrentTime(dateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime using the specified time zone
 * setting the date fields from this instance and the time fields from
 * the current time.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime with the time as the current time
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this LocalDate to a full datetime using the default time zone
 * setting the date fields from this instance and the time fields from
 * the current time.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @return this date as a datetime with the time as the current time
 */
public DateTime toDateTimeAtCurrentTime() {
    return toDateTimeAtCurrentTime(null);
}","public void test02222() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate localDate1 = localDate0.withYear(40);
    localDate1.toDateTimeAtCurrentTime();
}",""
"public DateTime toDateTime(LocalTime time, DateTimeZone zone) {
    if (time != null && getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    Chronology chrono = getChronology().withZone(zone);
    long instant = DateTimeUtils.currentTimeMillis();
    instant = chrono.set(this, instant);
    if (time != null) {
        instant = chrono.set(time, instant);
    }
    return new DateTime(instant, chrono);
}","public void test02323() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    LocalTime localTime0 = new LocalTime(2, 41);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis(2);
    localDate0.toDateTime(localTime0, dateTimeZone0);
}","/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate plus the time zone. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @param zone  the zone to get the DateTime in, null means default
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields and using the default time zone.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */
public DateTime toDateTime(LocalTime time) {
    return toDateTime(time, null);
}","public void test02424() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    LocalDate localDate1 = localDate0.withLocalMillis(0L);
    LocalDate localDate2 = localDate1.withDayOfMonth(1);
    LocalTime localTime0 = new LocalTime(3600000L, (Chronology) copticChronology0);
    localDate2.toDateTime(localTime0);
}",""
"public DateMidnight toDateMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);
}","public void test02525() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    Chronology chronology0 = iSOChronology0.withUTC();
    LocalDate localDate0 = new LocalDate(0L, chronology0);
    localDate0.toDateMidnight(dateTimeZone0);
}","/**
 * Converts this LocalDate to a DateMidnight.
 * <p>
 * As from v1.5, you are recommended to avoid DateMidnight and use
 * {@link #toDateTimeAtStartOfDay()} instead because of the exception
 * detailed below.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the DateMidnight in, null means default zone
 * @return the DateMidnight instance
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this LocalDate to a DateMidnight in the default time zone.
 * <p>
 * As from v1.5, you are recommended to avoid DateMidnight and use
 * {@link #toDateTimeAtStartOfDay()} instead because of the exception
 * detailed below.
 * <p>
 * This method will throw an exception if the default time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @return the DateMidnight instance in the default zone
 */
public DateMidnight toDateMidnight() {
    return toDateMidnight(null);
}","public void test02626() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    localDate0.toDateMidnight();
}",""
"//-----------------------------------------------------------------------
/**
 * Parses a {@code LocalDate} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#localDateParser()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static LocalDate parse(String str) {
    return parse(str, ISODateTimeFormat.localDateParser());
}","public void test02727() throws Throwable {
    LocalDate.parse(""2014-02-14"");
}",""
"public int getYear() {
    return getChronology().year().get(getLocalMillis());
}","public void test02828() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    LocalDate localDate0 = LocalDate.fromCalendarFields(calendar0);
    LocalDate localDate1 = localDate0.plusYears((-3969));
    localDate1.getYear();
}","/**
 * Get the year field value.
 *
 * @return the year
 */"
"public int getWeekyear() {
    return getChronology().weekyear().get(getLocalMillis());
}","public void test02929() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    LocalDate localDate1 = localDate0.withYear((-28800000));
    localDate1.getWeekyear();
}","/**
 * Get the weekyear field value.
 * <p>
 * The weekyear is the year that matches with the weekOfWeekyear field.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 * The weekyear allows you to query the effective year for that day.
 *
 * @return the weekyear
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the local milliseconds from the Java epoch
 * of 1970-01-01T00:00:00 (not fixed to any specific time zone).
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00
 * @since 1.5 (previously private)
 */
protected long getLocalMillis() {
    return iLocalMillis;
}","public void test03030() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    Chronology chronology0 = ethiopicChronology0.withZone(fixedDateTimeZone0);
    LocalDate localDate0 = new LocalDate(0L, chronology0);
    localDate0.getLocalMillis();
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the local milliseconds from the Java epoch
 * of 1970-01-01T00:00:00 (not fixed to any specific time zone).
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00
 * @since 1.5 (previously private)
 */
protected long getLocalMillis() {
    return iLocalMillis;
}","public void test03131() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.getLocalMillis();
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the local milliseconds from the Java epoch
 * of 1970-01-01T00:00:00 (not fixed to any specific time zone).
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00
 * @since 1.5 (previously private)
 */
protected long getLocalMillis() {
    return iLocalMillis;
}","public void test03232() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate((-24L), (Chronology) ethiopicChronology0);
    localDate0.getLocalMillis();
}",""
"protected DateTimeField getField(int index, Chronology chrono) {
    switch(index) {
        case YEAR:
            return chrono.year();
        case MONTH_OF_YEAR:
            return chrono.monthOfYear();
        case DAY_OF_MONTH:
            return chrono.dayOfMonth();
        default:
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
    }
}","public void test03333() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    localDate0.getField(1, (Chronology) copticChronology0);
}","/**
 * Gets the field for a specific index in the chronology specified.
 * <p>
 * This method must not use any instance variables.
 *
 * @param index  the index to retrieve
 * @param chrono  the chronology to use
 * @return the field
 */"
"//-----------------------------------------------------------------------
/**
 * Get the era field value.
 *
 * @return the era
 */
public int getEra() {
    return getChronology().era().get(getLocalMillis());
}","public void test03434() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Days days0 = Days.MAX_VALUE;
    LocalDate localDate1 = localDate0.minus(days0);
    localDate1.getEra();
}",""
"public int getCenturyOfEra() {
    return getChronology().centuryOfEra().get(getLocalMillis());
}","public void test03535() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes((-87), 1);
    MonthDay monthDay0 = MonthDay.now(dateTimeZone0);
    LocalDate localDate0 = monthDay0.toLocalDate(1);
    localDate0.getCenturyOfEra();
}","/**
 * Get the year of era field value.
 *
 * @return the year of era
 */"
"//-----------------------------------------------------------------------
/**
 * Get the value of one of the fields of a datetime.
 * <p>
 * This method gets the value of the specified field.
 * For example:
 * <pre>
 * LocalDate dt = LocalDate.nowDefaultZone();
 * int year = dt.get(DateTimeFieldType.year());
 * </pre>
 *
 * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null
 * @return the value of that field
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public int get(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return fieldType.getField(getChronology()).get(getLocalMillis());
}","public void test03636() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    LocalDate localDate1 = localDate0.withYearOfCentury(0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.yearOfCentury();
    localDate1.get(dateTimeFieldType0);
}",""
"public LocalDate withYearOfEra(int yearOfEra) {
    return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));
}","public void test03737() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-4001), 44, 44, 40, (-4001), 2);
    LocalDate localDate0 = LocalDate.fromCalendarFields(mockGregorianCalendar0);
    // Undeclared exception!
    try {
        localDate0.withYearOfEra((-4001));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -4001 for yearOfEra must be in the range [1,292278993]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the year of era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * year of era changed.
 *
 * @param yearOfEra  the year of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withYearOfCentury(int yearOfCentury) {
    return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));
}","public void test03838() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    // Undeclared exception!
    try {
        localDate0.withYearOfCentury(1687);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 1687 for yearOfCentury must be in the range [0,99]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the year of century field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * year of century changed.
 *
 * @param yearOfCentury  the year of century to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withYear(int year) {
    return withLocalMillis(getChronology().year().set(getLocalMillis(), year));
}","public void test03939() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) gJChronology0);
    // Undeclared exception!
    try {
        localDate0.withYear(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for year is not supported
        //
        verifyException(""org.joda.time.chrono.JulianChronology"", e);
    }
}","/**
 * Returns a copy of this date with the year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * year changed.
 *
 * @param year  the year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withWeekyear(int weekyear) {
    return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));
}","public void test04040() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(87).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    IslamicChronology islamicChronology0 = IslamicChronology.getInstance();
    DateTimeFormatter dateTimeFormatter1 = dateTimeFormatter0.withChronology(islamicChronology0);
    LocalDate localDate0 = LocalDate.parse(""org.joda.time.field.PreciseDurationField"", dateTimeFormatter1);
    // Undeclared exception!
    try {
        localDate0.withWeekyear((-1320));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The resulting instant is below the supported minimum of 0001-01-01T00:00:00.000Z (IslamicChronology[UTC])
        //
        verifyException(""org.joda.time.chrono.LimitChronology"", e);
    }
}","/**
 * Returns a copy of this date with the weekyear field updated.
 * <p>
 * The weekyear is the year that matches with the weekOfWeekyear field.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 * The weekyear allows you to query the effective year for that day.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * weekyear changed.
 *
 * @param weekyear  the weekyear to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {
    return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));
}","public void test04141() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(3);
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    // Undeclared exception!
    try {
        localDate0.withWeekOfWeekyear(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for weekOfWeekyear must be in the range [1,52]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the week of weekyear field updated.
 * <p>
 * This field is associated with the ""weekyear"" via {@link #withWeekyear(int)}.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * week of weekyear changed.
 *
 * @param weekOfWeekyear  the week of weekyear to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using methods
 * like {@link #withFieldAdded(DurationFieldType, int)}
 * or {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    long instant = getLocalMillis();
    Chronology chrono = getChronology();
    for (int i = 0; i < period.size(); i++) {
        long value = FieldUtils.safeMultiply(period.getValue(i), scalar);
        DurationFieldType type = period.getFieldType(i);
        if (isSupported(type)) {
            instant = type.getField(chrono).add(instant, value);
        }
    }
    return withLocalMillis(instant);
}","public void test04242() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    Period period0 = new Period(0L, (Chronology) julianChronology0);
    Period period1 = period0.withMillis((-782));
    // Undeclared exception!
    try {
        localDate0.withPeriodAdded(period1, 10209375);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows an int: -782 * 10209375
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public LocalDate withMonthOfYear(int monthOfYear) {
    return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));
}","public void test04343() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    // Undeclared exception!
    try {
        localDate0.withMonthOfYear(20);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 20 for monthOfYear must be in the range [1,12]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the month of year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * month of year changed.
 *
 * @param monthOfYear  the month of year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * era changed.
 *
 * @param era  the era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDate withEra(int era) {
    return withLocalMillis(getChronology().era().set(getLocalMillis(), era));
}","public void test04444() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(1761).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDate localDate0 = LocalDate.parse(""WB]X}Vjj"", dateTimeFormatter0);
    // Undeclared exception!
    try {
        localDate0.withEra(2090);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 2090 for era must be in the range [0,1]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public LocalDate withDayOfYear(int dayOfYear) {
    return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));
}","public void test04545() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    // Undeclared exception!
    try {
        localDate0.withDayOfYear(951);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 951 for dayOfYear must be in the range [1,365]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the day of year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * day of year changed.
 *
 * @param dayOfYear  the day of year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withDayOfMonth(int dayOfMonth) {
    return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));
}","public void test04646() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(37);
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    // Undeclared exception!
    try {
        localDate0.withDayOfMonth((-108));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -108 for dayOfMonth must be in the range [1,28]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the day of month field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * day of month changed.
 *
 * @param dayOfMonth  the day of month to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withCenturyOfEra(int centuryOfEra) {
    return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));
}","public void test04747() throws Throwable {
    MockDate mockDate0 = new MockDate(0, (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    // Undeclared exception!
    try {
        localDate0.withCenturyOfEra((-2));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -2 for centuryOfEra must be in the range [0,2922789]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the century of era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * century of era changed.
 *
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date plus the specified number of years.
 * <p>
 * This adds the specified number of years to the date.
 * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * </pre>
 *
 * @param years  the amount of years to add, may be negative
 * @return the new LocalDate plus the increased years
 */
public LocalDate plusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().add(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test04848() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetMillis((-2973));
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance(dateTimeZone0);
    LocalDate localDate0 = new LocalDate((Chronology) ethiopicChronology0);
    // Undeclared exception!
    try {
        localDate0.plusYears((-2973));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The resulting instant is below the supported minimum of 0001-01-01T00:00:00.000Z (EthiopicChronology[UTC])
        //
        verifyException(""org.joda.time.chrono.LimitChronology"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add complex period instances.
 * Adding one field is best achieved using methods
 * like {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate plus(ReadablePeriod period) {
    return withPeriodAdded(period, 1);
}","public void test04949() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Years years0 = Years.MAX_VALUE;
    // Undeclared exception!
    try {
        localDate0.plus(years0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: 2014 + 2147483647
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public static LocalDate parse(String str, DateTimeFormatter formatter) {
    return formatter.parseLocalDate(str);
}","public void test05050() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn((-2147483646)).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    // Undeclared exception!
    try {
        LocalDate.parse(""org.joda.time.field.PreciseDurationField"", dateTimeFormatter0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parses a {@code LocalDate} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static LocalDate parse(String str, DateTimeFormatter formatter) {
    return formatter.parseLocalDate(str);
}","public void test05151() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.parse("">PN:7W}S(^"", (DateTimeFormatter) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Parses a {@code LocalDate} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"public static LocalDate parse(String str, DateTimeFormatter formatter) {
    return formatter.parseLocalDate(str);
}","public void test05252() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    // Undeclared exception!
    try {
        LocalDate.parse(""WB]X}Vjj"", dateTimeFormatter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""WB]X}Vjj\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a {@code LocalDate} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code LocalDate} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#localDateParser()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static LocalDate parse(String str) {
    return parse(str, ISODateTimeFormat.localDateParser());
}","public void test05353() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.parse((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date minus the specified number of years.
 * <p>
 * This subtracts the specified number of years from the date.
 * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusYears(6);
 * LocalDate subtracted = dt.minus(Period.years(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);
 * </pre>
 *
 * @param years  the amount of years to subtract, may be negative
 * @return the new LocalDate minus the increased years
 */
public LocalDate minusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().subtract(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test05454() throws Throwable {
    MockDate mockDate0 = new MockDate((-3620), 2587, 623191204, (-1688), 2477, 2587);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    // Undeclared exception!
    try {
        localDate0.minusYears(2147483639);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -2145778905 for year must be in the range [-292275054,292278993]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date minus the specified number of years.
 * <p>
 * This subtracts the specified number of years from the date.
 * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusYears(6);
 * LocalDate subtracted = dt.minus(Period.years(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);
 * </pre>
 *
 * @param years  the amount of years to subtract, may be negative
 * @return the new LocalDate minus the increased years
 */
public LocalDate minusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().subtract(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test05555() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    // Undeclared exception!
    try {
        localDate0.minusYears((-2147483646));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The calculation caused an overflow: 2014 + 2147483646
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public LocalDate minusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);
    return withLocalMillis(instant);
}","public void test05656() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) ethiopicChronology0);
    LocalDate localDate1 = localDate0.withWeekyear(1);
    // Undeclared exception!
    try {
        localDate1.minusWeeks(1900);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The resulting instant is below the supported minimum of 0001-01-01T00:00:00.000Z (EthiopicChronology[UTC])
        //
        verifyException(""org.joda.time.chrono.LimitChronology"", e);
    }
}","/**
 * Returns a copy of this date minus the specified number of weeks.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusWeeks(6);
 * LocalDate subtracted = dt.minus(Period.weeks(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);
 * </pre>
 *
 * @param weeks  the amount of weeks to subtract, may be negative
 * @return the new LocalDate minus the increased weeks
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period taken away.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 * <p>
 * This method is typically used to subtract complex period instances.
 * Subtracting one field is best achieved using methods
 * like {@link #minusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus subtracting a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to reduce this instant by
 * @return a copy of this LocalDate with the period taken away
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate minus(ReadablePeriod period) {
    return withPeriodAdded(period, -1);
}","public void test05757() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Days days0 = Days.MIN_VALUE;
    // Undeclared exception!
    try {
        localDate0.minus(days0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Multiplication overflows an int: -2147483648 * -1
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public LocalDate(Object instant, DateTimeZone zone) {
    PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);
    Chronology chronology = converter.getChronology(instant, zone);
    chronology = DateTimeUtils.getChronology(chronology);
    iChronology = chronology.withUTC();
    int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());
    iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);
}","public void test05858() throws Throwable {
    Partial partial0 = new Partial();
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(partial0, (DateTimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'year' is not supported
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}","/**
 * Constructs an instance from an Object that represents a datetime,
 * forcing the time zone to that specified.
 * <p>
 * If the object contains no chronology, <code>ISOChronology</code> is used.
 * If the specified time zone is null, the default zone is used.
 * Once the constructor is completed, the zone is no longer used.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePartial, ReadableInstant, String, Calendar and Date.
 * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
 * The default String converter ignores the zone and only parses the field values.
 *
 * @param instant  the datetime object
 * @param zone  the time zone
 * @throws IllegalArgumentException if the instant is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs an instance from an Object that represents a datetime.
 * The time zone will be retrieved from the object if possible,
 * otherwise the default time zone will be used.
 * <p>
 * If the object contains no chronology, <code>ISOChronology</code> is used.
 * Once the constructor is completed, the zone is no longer used.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePartial, ReadableInstant, String, Calendar and Date.
 * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
 * The default String converter ignores the zone and only parses the field values.
 *
 * @param instant  the datetime object
 * @throws IllegalArgumentException if the instant is invalid
 */
public LocalDate(Object instant) {
    this(instant, (Chronology) null);
}","public void test05959() throws Throwable {
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(""eg1/`gL<X|%"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""eg1/`gL<X|%\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public LocalDate(long instant, Chronology chronology) {
    chronology = DateTimeUtils.getChronology(chronology);
    long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);
    chronology = chronology.withUTC();
    iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);
    iChronology = chronology;
}","public void test06060() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate((-9223372036854775808L), (Chronology) buddhistChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The instant is below the supported minimum of 0001-01-01T00:00:00.000Z (BuddhistChronology[UTC])
        //
        verifyException(""org.joda.time.chrono.LimitChronology"", e);
    }
}","/**
 * Constructs an instance set to the local time defined by the specified
 * instant evaluated using the specified chronology.
 * <p>
 * If the chronology is null, ISO chronology in the default zone is used.
 * Once the constructor is completed, the zone is no longer used.
 *
 * @param instant  the milliseconds from 1970-01-01T00:00:00Z
 * @param chronology  the chronology, null means ISOChronology in default zone
 */"
"public LocalDate(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
    iChronology = chronology;
    iLocalMillis = instant;
}","public void test06161() throws Throwable {
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(943, (-3028), (-1566), (Chronology) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -3028 for monthOfYear must be in the range [1,12]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Constructs an instance set to the specified date and time
 * using the specified chronology, whose zone is ignored.
 * <p>
 * If the chronology is null, <code>ISOChronology</code> is used.
 *
 * @param year  the year, valid values defined by the chronology
 * @param monthOfYear  the month of the year, valid values defined by the chronology
 * @param dayOfMonth  the day of the month, valid values defined by the chronology
 * @param chronology  the chronology, null means ISOChronology in default zone
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs an instance set to the specified date and time
 * using <code>ISOChronology</code>.
 *
 * @param year  the year
 * @param monthOfYear  the month of the year, from 1 to 12
 * @param dayOfMonth  the day of the month, from 1 to 31
 */
public LocalDate(int year, int monthOfYear, int dayOfMonth) {
    this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());
}","public void test06262() throws Throwable {
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(0, 0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 0 for monthOfYear must be in the range [1,12]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}",""
"public LocalDate plusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().add(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test06363() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime((long) (-2174), (Chronology) buddhistChronology0);
    LocalDate localDate0 = new LocalDate(localDateTime0, buddhistChronology0);
    localDate0.plusDays(3304);
}","/**
 * Returns a copy of this date plus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusDays(6);
 * LocalDate added = dt.plus(Period.days(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);
 * </pre>
 *
 * @param days  the amount of days to add, may be negative
 * @return the new LocalDate plus the increased days
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using methods
 * like {@link #withFieldAdded(DurationFieldType, int)}
 * or {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    long instant = getLocalMillis();
    Chronology chrono = getChronology();
    for (int i = 0; i < period.size(); i++) {
        long value = FieldUtils.safeMultiply(period.getValue(i), scalar);
        DurationFieldType type = period.getFieldType(i);
        if (isSupported(type)) {
            instant = type.getField(chrono).add(instant, value);
        }
    }
    return withLocalMillis(instant);
}","public void test06464() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    JulianChronology julianChronology0 = JulianChronology.getInstance();
    Period period0 = new Period(0L, (Chronology) julianChronology0);
    localDate0.withPeriodAdded(period0, 10209375);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using methods
 * like {@link #withFieldAdded(DurationFieldType, int)}
 * or {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    long instant = getLocalMillis();
    Chronology chrono = getChronology();
    for (int i = 0; i < period.size(); i++) {
        long value = FieldUtils.safeMultiply(period.getValue(i), scalar);
        DurationFieldType type = period.getFieldType(i);
        if (isSupported(type)) {
            instant = type.getField(chrono).add(instant, value);
        }
    }
    return withLocalMillis(instant);
}","public void test06565() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHoursMinutes((-87), 1);
    MonthDay monthDay0 = MonthDay.now(dateTimeZone0);
    LocalDate localDate0 = monthDay0.toLocalDate(1);
    localDate0.withPeriodAdded((ReadablePeriod) null, 247);
}",""
"public DateTime toDateTime(LocalTime time, DateTimeZone zone) {
    if (time != null && getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    Chronology chrono = getChronology().withZone(zone);
    long instant = DateTimeUtils.currentTimeMillis();
    instant = chrono.set(this, instant);
    if (time != null) {
        instant = chrono.set(time, instant);
    }
    return new DateTime(instant, chrono);
}","public void test06666() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) copticChronology0);
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours((-288));
    LocalTime localTime0 = new LocalTime((long) 1, dateTimeZone0);
    // Undeclared exception!
    try {
        localDate0.toDateTime(localTime0, dateTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The chronology of the time does not match
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate plus the time zone. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @param zone  the zone to get the DateTime in, null means default
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */"
"public DateTime toDateTime(LocalTime time, DateTimeZone zone) {
    if (time != null && getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    Chronology chrono = getChronology().withZone(zone);
    long instant = DateTimeUtils.currentTimeMillis();
    instant = chrono.set(this, instant);
    if (time != null) {
        instant = chrono.set(time, instant);
    }
    return new DateTime(instant, chrono);
}","public void test06767() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = new LocalDate();
    LocalDateTime localDateTime0 = LocalDateTime.now((Chronology) ethiopicChronology0);
    Date date0 = localDateTime0.toDate();
    LocalTime localTime0 = LocalTime.fromDateFields(date0);
    localDate0.toDateTime(localTime0, (DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate plus the time zone. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @param zone  the zone to get the DateTime in, null means default
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */"
"public int compareTo(ReadablePartial partial) {
    // override to perform faster
    if (this == partial) {
        return 0;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));
        }
    }
    return super.compareTo(partial);
}","public void test06868() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    LocalDate localDate1 = localDate0.minusWeeks((-3165));
    localDate1.compareTo((ReadablePartial) localDate0);
}","/**
 * Compares this partial with another returning an integer
 * indicating the order.
 * <p>
 * The fields are compared in order, from largest to smallest.
 * The first field that is non-equal is used to determine the result.
 * <p>
 * The specified object must be a partial instance whose field types
 * match those of this partial.
 *
 * @param partial  an object to check against
 * @return negative if this is less, zero if equal, positive if greater
 * @throws ClassCastException if the partial is the wrong class
 *  or if it has field types that don't match
 * @throws NullPointerException if the partial is null
 */"
"public int compareTo(ReadablePartial partial) {
    // override to perform faster
    if (this == partial) {
        return 0;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));
        }
    }
    return super.compareTo(partial);
}","public void test06969() throws Throwable {
    MockDate mockDate0 = new MockDate((-27), (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    LocalDate localDate1 = localDate0.plusMonths(3);
    LocalDate localDate2 = localDate0.plusMonths(3);
    localDate2.compareTo((ReadablePartial) localDate1);
}","/**
 * Compares this partial with another returning an integer
 * indicating the order.
 * <p>
 * The fields are compared in order, from largest to smallest.
 * The first field that is non-equal is used to determine the result.
 * <p>
 * The specified object must be a partial instance whose field types
 * match those of this partial.
 *
 * @param partial  an object to check against
 * @return negative if this is less, zero if equal, positive if greater
 * @throws ClassCastException if the partial is the wrong class
 *  or if it has field types that don't match
 * @throws NullPointerException if the partial is null
 */"
"public int compareTo(ReadablePartial partial) {
    // override to perform faster
    if (this == partial) {
        return 0;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));
        }
    }
    return super.compareTo(partial);
}","public void test07070() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalTime localTime0 = new LocalTime((-2271L));
    // Undeclared exception!
    try {
        localDate0.compareTo((ReadablePartial) localTime0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // ReadablePartial objects must have matching field types
        //
        verifyException(""org.joda.time.base.AbstractPartial"", e);
    }
}","/**
 * Compares this partial with another returning an integer
 * indicating the order.
 * <p>
 * The fields are compared in order, from largest to smallest.
 * The first field that is non-equal is used to determine the result.
 * <p>
 * The specified object must be a partial instance whose field types
 * match those of this partial.
 *
 * @param partial  an object to check against
 * @return negative if this is less, zero if equal, positive if greater
 * @throws ClassCastException if the partial is the wrong class
 *  or if it has field types that don't match
 * @throws NullPointerException if the partial is null
 */"
"public int compareTo(ReadablePartial partial) {
    // override to perform faster
    if (this == partial) {
        return 0;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));
        }
    }
    return super.compareTo(partial);
}","public void test07171() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    LocalDate localDate1 = localDate0.minusWeeks((-3165));
    localDate0.compareTo((ReadablePartial) localDate1);
}","/**
 * Compares this partial with another returning an integer
 * indicating the order.
 * <p>
 * The fields are compared in order, from largest to smallest.
 * The first field that is non-equal is used to determine the result.
 * <p>
 * The specified object must be a partial instance whose field types
 * match those of this partial.
 *
 * @param partial  an object to check against
 * @return negative if this is less, zero if equal, positive if greater
 * @throws ClassCastException if the partial is the wrong class
 *  or if it has field types that don't match
 * @throws NullPointerException if the partial is null
 */"
"public int compareTo(ReadablePartial partial) {
    // override to perform faster
    if (this == partial) {
        return 0;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));
        }
    }
    return super.compareTo(partial);
}","public void test07272() throws Throwable {
    MockDate mockDate0 = new MockDate((-27), (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    localDate0.compareTo((ReadablePartial) localDate0);
}","/**
 * Compares this partial with another returning an integer
 * indicating the order.
 * <p>
 * The fields are compared in order, from largest to smallest.
 * The first field that is non-equal is used to determine the result.
 * <p>
 * The specified object must be a partial instance whose field types
 * match those of this partial.
 *
 * @param partial  an object to check against
 * @return negative if this is less, zero if equal, positive if greater
 * @throws ClassCastException if the partial is the wrong class
 *  or if it has field types that don't match
 * @throws NullPointerException if the partial is null
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    // override to perform faster
    if (this == partial) {
        return true;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return iLocalMillis == other.iLocalMillis;
        }
    }
    return super.equals(partial);
}","public void test07373() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    LocalDate.Property localDate_Property0 = localDate0.monthOfYear();
    LocalDate localDate1 = localDate_Property0.roundFloorCopy();
    localDate1.equals(localDate0);
}",""
"public boolean isSupported(DurationFieldType type) {
    if (type == null) {
        return false;
    }
    DurationField field = type.getField(getChronology());
    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return field.isSupported();
    }
    return false;
}","public void test07474() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    DurationFieldType durationFieldType0 = DurationFieldType.SECONDS_TYPE;
    localDate0.isSupported(durationFieldType0);
}","/**
 * Checks if the duration type specified is supported by this
 * local date and chronology.
 *
 * @param type  a duration type, usually obtained from DurationFieldType
 * @return true if the field type is supported
 */"
"public boolean isSupported(DateTimeFieldType type) {
    if (type == null) {
        return false;
    }
    DurationFieldType durType = type.getDurationType();
    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return type.getField(getChronology()).isSupported();
    }
    return false;
}","public void test07575() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    localDate0.isSupported(dateTimeFieldType0);
}","/**
 * Checks if the field type specified is supported by this
 * local date and chronology.
 * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.
 *
 * @param type  a field type, usually obtained from DateTimeFieldType
 * @return true if the field type is supported
 */"
"public boolean isSupported(DateTimeFieldType type) {
    if (type == null) {
        return false;
    }
    DurationFieldType durType = type.getDurationType();
    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return type.getField(getChronology()).isSupported();
    }
    return false;
}","public void test07676() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime((long) (-2174), (Chronology) buddhistChronology0);
    LocalDate localDate0 = new LocalDate(localDateTime0, buddhistChronology0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    localDate0.isSupported(dateTimeFieldType0);
}","/**
 * Checks if the field type specified is supported by this
 * local date and chronology.
 * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.
 *
 * @param type  a field type, usually obtained from DateTimeFieldType
 * @return true if the field type is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Get the value of one of the fields of a datetime.
 * <p>
 * This method gets the value of the specified field.
 * For example:
 * <pre>
 * LocalDate dt = LocalDate.nowDefaultZone();
 * int year = dt.get(DateTimeFieldType.year());
 * </pre>
 *
 * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null
 * @return the value of that field
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public int get(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return fieldType.getField(getChronology()).get(getLocalMillis());
}","public void test07777() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    localDate0.get(dateTimeFieldType0);
}",""
"public int getValue(int index) {
    switch(index) {
        case YEAR:
            return getChronology().year().get(getLocalMillis());
        case MONTH_OF_YEAR:
            return getChronology().monthOfYear().get(getLocalMillis());
        case DAY_OF_MONTH:
            return getChronology().dayOfMonth().get(getLocalMillis());
        default:
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
    }
}","public void test07878() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(1761).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    LocalDate localDate0 = LocalDate.parse(""WB]X}Vjj"", dateTimeFormatter0);
    localDate0.getValue(2);
}","/**
 * Gets the value of the field at the specifed index.
 * <p>
 * This method is required to support the <code>ReadablePartial</code>
 * interface. The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int getValue(int index) {
    switch(index) {
        case YEAR:
            return getChronology().year().get(getLocalMillis());
        case MONTH_OF_YEAR:
            return getChronology().monthOfYear().get(getLocalMillis());
        case DAY_OF_MONTH:
            return getChronology().dayOfMonth().get(getLocalMillis());
        default:
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
    }
}","public void test07979() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.getValue(1);
}","/**
 * Gets the value of the field at the specifed index.
 * <p>
 * This method is required to support the <code>ReadablePartial</code>
 * interface. The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int getDayOfMonth() {
    return getChronology().dayOfMonth().get(getLocalMillis());
}","public void test08080() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    DateTimeZone dateTimeZone0 = buddhistChronology0.getZone();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.getDayOfMonth();
}","/**
 * Get the day of month field value.
 * <p>
 * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.
 *
 * @return the day of month
 */"
"public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;
    long instant = zone.convertLocalToUTC(localMillis, false);
    instant = chrono.dayOfMonth().roundFloor(instant);
    return new DateTime(instant, chrono);
}","public void test08181() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    StrictChronology strictChronology0 = StrictChronology.getInstance(ethiopicChronology0);
    LocalDate localDate0 = new LocalDate((long) (-1701), (Chronology) strictChronology0);
    localDate0.toDateTimeAtStartOfDay((DateTimeZone) null);
}","/**
 * Converts this LocalDate to a full datetime at the earliest valid time
 * for the date using the specified time zone.
 * <p>
 * The time will normally be midnight, as that is the earliest time on
 * any given day. However, in some time zones when Daylight Savings Time
 * starts, there is no midnight because time jumps from 11:59 to 01:00.
 * This method handles that situation by returning 01:00 on that date.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at the start of the day
 * @since 1.5
 */"
"public Interval toInterval(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    DateTime start = toDateTimeAtStartOfDay(zone);
    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);
    return new Interval(start, end);
}","public void test08282() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = new LocalDate((-24L), (Chronology) ethiopicChronology0);
    localDate0.toInterval((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this object to an Interval representing the whole day.
 * <p>
 * The interval may have more or less than 24 hours if this is a daylight
 * savings cutover date.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the Interval in, null means default
 * @return a interval over the day
 */"
"public DateMidnight toDateMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);
}","public void test08383() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDateTime localDateTime0 = LocalDateTime.now((DateTimeZone) fixedDateTimeZone0);
    Date date0 = localDateTime0.toDate();
    LocalDate localDate0 = LocalDate.fromDateFields(date0);
    localDate0.toDateMidnight((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this LocalDate to a DateMidnight.
 * <p>
 * As from v1.5, you are recommended to avoid DateMidnight and use
 * {@link #toDateTimeAtStartOfDay()} instead because of the exception
 * detailed below.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the DateMidnight in, null means default zone
 * @return the DateMidnight instance
 */"
"public LocalDate(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {
    super();
    chronology = DateTimeUtils.getChronology(chronology).withUTC();
    long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
    iChronology = chronology;
    iLocalMillis = instant;
}","public void test08484() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    ISOChronology iSOChronology0 = ISOChronology.getInstance((DateTimeZone) fixedDateTimeZone0);
    StrictChronology strictChronology0 = StrictChronology.getInstance(iSOChronology0);
    LocalDate localDate0 = new LocalDate(2, 2, 2, strictChronology0);
}","/**
 * Constructs an instance set to the specified date and time
 * using the specified chronology, whose zone is ignored.
 * <p>
 * If the chronology is null, <code>ISOChronology</code> is used.
 *
 * @param year  the year, valid values defined by the chronology
 * @param monthOfYear  the month of the year, valid values defined by the chronology
 * @param dayOfMonth  the day of the month, valid values defined by the chronology
 * @param chronology  the chronology, null means ISOChronology in default zone
 */"
"public Chronology getChronology() {
    return iChronology;
}","public void test08585() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.getChronology();
}","/**
 * Gets the chronology of the date.
 *
 * @return the Chronology that the date is using
 */"
"public int getMonthOfYear() {
    return getChronology().monthOfYear().get(getLocalMillis());
}","public void test08686() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    LocalDate localDate0 = new LocalDate((Chronology) islamicChronology0);
    localDate0.getMonthOfYear();
}","/**
 * Get the month of year field value.
 *
 * @return the month of year
 */"
"public static LocalDate parse(String str, DateTimeFormatter formatter) {
    return formatter.parseLocalDate(str);
}","public void test08787() throws Throwable {
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, (DateTimeParser) null);
    // Undeclared exception!
    try {
        LocalDate.parse(""d4?"", dateTimeFormatter0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Parsing not supported
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}","/**
 * Parses a {@code LocalDate} from the specified string using a formatter.
 *
 * @param str  the string to parse, not null
 * @param formatter  the formatter to use, not null
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is three.
 * The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @return the field count, three
 */
public int size() {
    return 3;
}","public void test08888() throws Throwable {
    LocalDate localDate0 = new LocalDate((DateTimeZone) null);
    localDate0.size();
}",""
"public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    long instantMillis = DateTimeUtils.currentTimeMillis();
    long resolved = chrono.set(this, instantMillis);
    return new DateTime(resolved, chrono);
}","public void test08989() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    localDate0.toDateTimeAtCurrentTime(dateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime using the specified time zone
 * setting the date fields from this instance and the time fields from
 * the current time.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime with the time as the current time
 */"
"@Deprecated
public DateTime toDateTimeAtMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);
}","public void test09090() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    localDate0.toDateTimeAtMidnight((DateTimeZone) fixedDateTimeZone0);
}","/**
 * Converts this LocalDate to a full datetime at midnight using the
 * specified time zone.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This method uses the chronology from this instance plus the time zone
 * specified.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to use, null means default zone
 * @return this date as a datetime at midnight
 * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs an instance set to the specified date and time
 * using <code>ISOChronology</code>.
 *
 * @param year  the year
 * @param monthOfYear  the month of the year, from 1 to 12
 * @param dayOfMonth  the day of the month, from 1 to 31
 */
public LocalDate(int year, int monthOfYear, int dayOfMonth) {
    this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());
}","public void test09191() throws Throwable {
    LocalDate localDate0 = new LocalDate(21, 8, 21);
}",""
"public LocalDate(Object instant, Chronology chronology) {
    PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);
    chronology = converter.getChronology(instant, chronology);
    chronology = DateTimeUtils.getChronology(chronology);
    iChronology = chronology.withUTC();
    int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());
    iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);
}","public void test09292() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstance();
    LocalDate localDate0 = null;
    try {
        localDate0 = new LocalDate(gJChronology0, gJChronology0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No partial converter found for type: org.joda.time.chrono.GJChronology
        //
        verifyException(""org.joda.time.convert.ConverterManager"", e);
    }
}","/**
 * Constructs an instance from an Object that represents a datetime,
 * using the specified chronology.
 * <p>
 * If the chronology is null, ISO in the default time zone is used.
 * Once the constructor is completed, the zone is no longer used.
 * <p>
 * The recognised object types are defined in
 * {@link org.joda.time.convert.ConverterManager ConverterManager} and
 * include ReadablePartial, ReadableInstant, String, Calendar and Date.
 * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
 * The default String converter ignores the zone and only parses the field values.
 *
 * @param instant  the datetime object
 * @param chronology  the chronology
 * @throws IllegalArgumentException if the instant is invalid
 */"
"public String toString(String pattern, Locale locale) throws IllegalArgumentException {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test09393() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    Locale locale0 = Locale.ROOT;
    localDate0.toString((String) null, locale0);
}","/**
 * Output the date using the specified format pattern.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern, Locale locale) throws IllegalArgumentException {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test09494() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    Locale locale0 = Locale.FRENCH;
    localDate0.toString(""4"", locale0);
}","/**
 * Output the date using the specified format pattern.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test09595() throws Throwable {
    GJChronology gJChronology0 = GJChronology.getInstanceUTC();
    DateTimeZone dateTimeZone0 = gJChronology0.getZone();
    LocalDate localDate0 = new LocalDate((-1269L), dateTimeZone0);
    localDate0.toString((String) null);
}","/**
 * Output the date using the specified format pattern.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"public String toString(String pattern) {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).print(this);
}","public void test09696() throws Throwable {
    MockDate mockDate0 = new MockDate((-27), (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    // Undeclared exception!
    try {
        localDate0.toString(""org.joda.time.field.PreciseDurationField"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains many
 * useful methods.
 *
 * @param fieldType  the field type to get the chronology for
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return new Property(this, fieldType.getField(getChronology()));
}","public void test09797() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    // Undeclared exception!
    try {
        localDate0.property(dateTimeFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'secondOfDay' is not supported
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains many
 * useful methods.
 *
 * @param fieldType  the field type to get the chronology for
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return new Property(this, fieldType.getField(getChronology()));
}","public void test09898() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(58, 58, (-2699));
    LocalDate localDate0 = LocalDate.fromCalendarFields(mockGregorianCalendar0);
    // Undeclared exception!
    try {
        localDate0.property((DateTimeFieldType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The DateTimeFieldType must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the property object for the specified type, which contains many
 * useful methods.
 *
 * @param fieldType  the field type to get the chronology for
 * @return the property object
 * @throws IllegalArgumentException if the field is null or unsupported
 */
public Property property(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return new Property(this, fieldType.getField(getChronology()));
}","public void test09999() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTime dateTime0 = new DateTime((Chronology) iSOChronology0);
    LocalDate localDate0 = dateTime0.toLocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    localDate0.property(dateTimeFieldType0);
}",""
"public LocalDate minusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().subtract(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test100100() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) buddhistChronology0);
    localDate0.minusDays(0);
}","/**
 * Returns a copy of this date minus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusDays(6);
 * LocalDate subtracted = dt.minus(Period.days(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);
 * </pre>
 *
 * @param days  the amount of days to subtract, may be negative
 * @return the new LocalDate minus the increased days
 */"
"public LocalDate minusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().subtract(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test101101() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.minusDays(14);
}","/**
 * Returns a copy of this date minus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusDays(6);
 * LocalDate subtracted = dt.minus(Period.days(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);
 * </pre>
 *
 * @param days  the amount of days to subtract, may be negative
 * @return the new LocalDate minus the increased days
 */"
"public LocalDate minusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);
    return withLocalMillis(instant);
}","public void test102102() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.minusWeeks(0);
}","/**
 * Returns a copy of this date minus the specified number of weeks.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusWeeks(6);
 * LocalDate subtracted = dt.minus(Period.weeks(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);
 * </pre>
 *
 * @param weeks  the amount of weeks to subtract, may be negative
 * @return the new LocalDate minus the increased weeks
 */"
"public LocalDate minusMonths(int months) {
    if (months == 0) {
        return this;
    }
    long instant = getChronology().months().subtract(getLocalMillis(), months);
    return withLocalMillis(instant);
}","public void test103103() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.minusMonths(0);
}","/**
 * Returns a copy of this date minus the specified number of months.
 * <p>
 * This subtracts the specified number of months from the date.
 * The subtraction may change the year, but the day-of-month is normally unchanged.
 * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusMonths(6);
 * LocalDate subtracted = dt.minus(Period.months(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);
 * </pre>
 *
 * @param months  the amount of months to subtract, may be negative
 * @return the new LocalDate minus the increased months
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date minus the specified number of years.
 * <p>
 * This subtracts the specified number of years from the date.
 * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate subtracted = dt.minusYears(6);
 * LocalDate subtracted = dt.minus(Period.years(6));
 * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);
 * </pre>
 *
 * @param years  the amount of years to subtract, may be negative
 * @return the new LocalDate minus the increased years
 */
public LocalDate minusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().subtract(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test104104() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    localDate0.minusYears(0);
}",""
"public LocalDate plusDays(int days) {
    if (days == 0) {
        return this;
    }
    long instant = getChronology().days().add(getLocalMillis(), days);
    return withLocalMillis(instant);
}","public void test105105() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    LocalDate localDate0 = new LocalDate((Chronology) iSOChronology0);
    localDate0.plusDays(0);
}","/**
 * Returns a copy of this date plus the specified number of days.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusDays(6);
 * LocalDate added = dt.plus(Period.days(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);
 * </pre>
 *
 * @param days  the amount of days to add, may be negative
 * @return the new LocalDate plus the increased days
 */"
"public LocalDate plusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    long instant = getChronology().weeks().add(getLocalMillis(), weeks);
    return withLocalMillis(instant);
}","public void test106106() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    localDate0.plusWeeks(0);
}","/**
 * Returns a copy of this date plus the specified number of weeks.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusWeeks(6);
 * LocalDate added = dt.plus(Period.weeks(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);
 * </pre>
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new LocalDate plus the increased weeks
 */"
"public LocalDate plusWeeks(int weeks) {
    if (weeks == 0) {
        return this;
    }
    long instant = getChronology().weeks().add(getLocalMillis(), weeks);
    return withLocalMillis(instant);
}","public void test107107() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    localDate0.plusWeeks(51);
}","/**
 * Returns a copy of this date plus the specified number of weeks.
 * <p>
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusWeeks(6);
 * LocalDate added = dt.plus(Period.weeks(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);
 * </pre>
 *
 * @param weeks  the amount of weeks to add, may be negative
 * @return the new LocalDate plus the increased weeks
 */"
"public LocalDate plusMonths(int months) {
    if (months == 0) {
        return this;
    }
    long instant = getChronology().months().add(getLocalMillis(), months);
    return withLocalMillis(instant);
}","public void test108108() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    localDate0.plusMonths(0);
}","/**
 * Returns a copy of this date plus the specified number of months.
 * <p>
 * This adds the specified number of months to the date.
 * The addition may change the year, but the day-of-month is normally unchanged.
 * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusMonths(6);
 * LocalDate added = dt.plus(Period.months(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);
 * </pre>
 *
 * @param months  the amount of months to add, may be negative
 * @return the new LocalDate plus the increased months
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date plus the specified number of years.
 * <p>
 * This adds the specified number of years to the date.
 * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * </pre>
 *
 * @param years  the amount of years to add, may be negative
 * @return the new LocalDate plus the increased years
 */
public LocalDate plusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().add(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test109109() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    localDate0.plusYears(0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date plus the specified number of years.
 * <p>
 * This adds the specified number of years to the date.
 * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.
 * This LocalDate instance is immutable and unaffected by this method call.
 * <p>
 * The following three lines are identical in effect:
 * <pre>
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * </pre>
 *
 * @param years  the amount of years to add, may be negative
 * @return the new LocalDate plus the increased years
 */
public LocalDate plusYears(int years) {
    if (years == 0) {
        return this;
    }
    long instant = getChronology().years().add(getLocalMillis(), years);
    return withLocalMillis(instant);
}","public void test110110() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    localDate0.plusYears(2);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the addition is zero, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add multiple copies of complex
 * period instances. Adding one field is best achieved using methods
 * like {@link #withFieldAdded(DurationFieldType, int)}
 * or {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @param scalar  the amount of times to add, such as -1 to subtract once
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {
    if (period == null || scalar == 0) {
        return this;
    }
    long instant = getLocalMillis();
    Chronology chrono = getChronology();
    for (int i = 0; i < period.size(); i++) {
        long value = FieldUtils.safeMultiply(period.getValue(i), scalar);
        DurationFieldType type = period.getFieldType(i);
        if (isSupported(type)) {
            instant = type.getField(chrono).add(instant, value);
        }
    }
    return withLocalMillis(instant);
}","public void test111111() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    DateTime dateTime0 = DateTime.now((Chronology) copticChronology0);
    Hours hours0 = Hours.hoursBetween((ReadableInstant) dateTime0, (ReadableInstant) dateTime0);
    localDate0.withPeriodAdded(hours0, 0);
}",""
"public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    if (amount == 0) {
        return this;
    }
    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);
    return withLocalMillis(instant);
}","public void test112112() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.minuteOfDay();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    localDate0.withFieldAdded(durationFieldType0, 0);
}","/**
 * Returns a copy of this date with the value of the specified field increased.
 * <p>
 * If the addition is zero or the field is null, then <code>this</code> is returned.
 * <p>
 * These three lines are equivalent:
 * <pre>
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * </pre>
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this date with the field updated
 * @throws IllegalArgumentException if the field is null or unsupported
 * @throws ArithmeticException if the result exceeds the internal capacity
 */"
"public DateMidnight toDateMidnight(DateTimeZone zone) {
    zone = DateTimeUtils.getZone(zone);
    Chronology chrono = getChronology().withZone(zone);
    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);
}","public void test113113() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    DurationFieldType durationFieldType0 = DurationFieldType.WEEKYEARS_TYPE;
    LocalDate localDate1 = localDate0.withFieldAdded(durationFieldType0, (-2803));
    localDate1.toDateMidnight((DateTimeZone) null);
}","/**
 * Converts this LocalDate to a DateMidnight.
 * <p>
 * As from v1.5, you are recommended to avoid DateMidnight and use
 * {@link #toDateTimeAtStartOfDay()} instead because of the exception
 * detailed below.
 * <p>
 * This method will throw an exception if the time zone switches
 * to Daylight Savings Time at midnight and this LocalDate represents
 * that switchover date. The problem is that there is no such time as
 * midnight on the required date, and as such an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param zone  the zone to get the DateMidnight in, null means default zone
 * @return the DateMidnight instance
 */"
"public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    if (amount == 0) {
        return this;
    }
    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);
    return withLocalMillis(instant);
}","public void test114114() throws Throwable {
    LocalDate localDate0 = new LocalDate(0L);
    // Undeclared exception!
    try {
        localDate0.withFieldAdded((DurationFieldType) null, 2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Returns a copy of this date with the value of the specified field increased.
 * <p>
 * If the addition is zero or the field is null, then <code>this</code> is returned.
 * <p>
 * These three lines are equivalent:
 * <pre>
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * </pre>
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this date with the field updated
 * @throws IllegalArgumentException if the field is null or unsupported
 * @throws ArithmeticException if the result exceeds the internal capacity
 */"
"public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    if (amount == 0) {
        return this;
    }
    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);
    return withLocalMillis(instant);
}","public void test115115() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DurationFieldType durationFieldType0 = DurationFieldType.MILLIS_TYPE;
    // Undeclared exception!
    try {
        localDate0.withFieldAdded(durationFieldType0, 1900);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'millis' is not supported
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Returns a copy of this date with the value of the specified field increased.
 * <p>
 * If the addition is zero or the field is null, then <code>this</code> is returned.
 * <p>
 * These three lines are equivalent:
 * <pre>
 * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);
 * LocalDate added = dt.plusYears(6);
 * LocalDate added = dt.plus(Period.years(6));
 * </pre>
 *
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this date with the field updated
 * @throws IllegalArgumentException if the field is null or unsupported
 * @throws ArithmeticException if the result exceeds the internal capacity
 */"
"public LocalDate withField(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);
    return withLocalMillis(instant);
}","public void test116116() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTime dateTime0 = new DateTime((Chronology) iSOChronology0);
    LocalDate localDate0 = dateTime0.toLocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfDay();
    // Undeclared exception!
    try {
        localDate0.withField(dateTimeFieldType0, (-1978));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'clockhourOfDay' is not supported
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Returns a copy of this date with the specified field set to a new value.
 * <p>
 * For example, if the field type is <code>monthOfYear</code> then the
 * month of year field will be changed in the returned instance.
 * If the field type is null, then <code>this</code> is returned.
 * <p>
 * These two lines are equivalent:
 * <pre>
 * LocalDate updated = dt.withDayOfMonth(6);
 * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);
 * </pre>
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this date with the field set
 * @throws IllegalArgumentException if the field is null or unsupported
 */"
"public LocalDate withField(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);
    return withLocalMillis(instant);
}","public void test117117() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    // Undeclared exception!
    try {
        localDate0.withField((DateTimeFieldType) null, (-2857));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Returns a copy of this date with the specified field set to a new value.
 * <p>
 * For example, if the field type is <code>monthOfYear</code> then the
 * month of year field will be changed in the returned instance.
 * If the field type is null, then <code>this</code> is returned.
 * <p>
 * These two lines are equivalent:
 * <pre>
 * LocalDate updated = dt.withDayOfMonth(6);
 * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);
 * </pre>
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this date with the field set
 * @throws IllegalArgumentException if the field is null or unsupported
 */"
"public LocalDate withField(DateTimeFieldType fieldType, int value) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""Field must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);
    return withLocalMillis(instant);
}","public void test118118() throws Throwable {
    ISOChronology iSOChronology0 = ISOChronology.getInstance();
    DateTime dateTime0 = new DateTime((Chronology) iSOChronology0);
    LocalDate localDate0 = dateTime0.toLocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.centuryOfEra();
    // Undeclared exception!
    try {
        localDate0.withField(dateTimeFieldType0, (-1978));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -1978 for centuryOfEra must be in the range [0,2922789]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the specified field set to a new value.
 * <p>
 * For example, if the field type is <code>monthOfYear</code> then the
 * month of year field will be changed in the returned instance.
 * If the field type is null, then <code>this</code> is returned.
 * <p>
 * These two lines are equivalent:
 * <pre>
 * LocalDate updated = dt.withDayOfMonth(6);
 * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);
 * </pre>
 *
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this date with the field set
 * @throws IllegalArgumentException if the field is null or unsupported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the partial set of fields replacing
 * those from this instance.
 * <p>
 * For example, if the partial contains a year and a month then those two
 * fields will be changed in the returned instance.
 * Unsupported fields are ignored.
 * If the partial is null, then <code>this</code> is returned.
 *
 * @param partial  the partial set of fields to apply to this date, null ignored
 * @return a copy of this date with a different set of fields
 * @throws IllegalArgumentException if any value is invalid
 */
public LocalDate withFields(ReadablePartial partial) {
    if (partial == null) {
        return this;
    }
    return withLocalMillis(getChronology().set(partial, getLocalMillis()));
}","public void test119119() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    localDate0.withFields(localDate0);
}",""
"//-----------------------------------------------------------------------
/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields and using the default time zone.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */
public DateTime toDateTime(LocalTime time) {
    return toDateTime(time, null);
}","public void test120120() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(1);
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    GregorianChronology gregorianChronology0 = GregorianChronology.getInstanceUTC();
    LocalTime localTime0 = new LocalTime(3600L, (Chronology) gregorianChronology0);
    // Undeclared exception!
    try {
        localDate0.toDateTime(localTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The chronology of the time does not match
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"public DateTime toDateTime(LocalTime time, DateTimeZone zone) {
    if (time != null && getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    Chronology chrono = getChronology().withZone(zone);
    long instant = DateTimeUtils.currentTimeMillis();
    instant = chrono.set(this, instant);
    if (time != null) {
        instant = chrono.set(time, instant);
    }
    return new DateTime(instant, chrono);
}","public void test121121() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(37);
    LocalDate localDate0 = LocalDate.now(dateTimeZone0);
    localDate0.toDateTime((LocalTime) null, dateTimeZone0);
}","/**
 * Converts this object to a DateTime using a LocalTime to fill in the
 * missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate plus the time zone. The chronology of the time must match.
 * If the time is null, the current time in the date's chronology is used.
 * <p>
 * This method will throw an exception if the datetime that would be
 * created does not exist when the time zone is taken into account.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, null means current time
 * @param zone  the zone to get the DateTime in, null means default
 * @return the DateTime instance
 * @throws IllegalArgumentException if the chronology of the time does not match
 */"
"//-----------------------------------------------------------------------
/**
 * Converts this object to a LocalDateTime using a LocalTime to fill in
 * the missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate. The chronology of the time must also match.
 * If the time is null an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, must not be null
 * @return the LocalDateTime instance
 * @throws IllegalArgumentException if the time is null
 * @throws IllegalArgumentException if the chronology of the time does not match
 * @since 1.5
 */
public LocalDateTime toLocalDateTime(LocalTime time) {
    if (time == null) {
        throw new IllegalArgumentException(""The time must not be null"");
    }
    if (getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    long localMillis = getLocalMillis() + time.getLocalMillis();
    return new LocalDateTime(localMillis, getChronology());
}","public void test122122() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = LocalDate.now((DateTimeZone) fixedDateTimeZone0);
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) copticChronology0);
    LocalTime localTime0 = new LocalTime(localDateTime0);
    // Undeclared exception!
    try {
        localDate0.toLocalDateTime(localTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The chronology of the time does not match
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Converts this object to a LocalDateTime using a LocalTime to fill in
 * the missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate. The chronology of the time must also match.
 * If the time is null an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, must not be null
 * @return the LocalDateTime instance
 * @throws IllegalArgumentException if the time is null
 * @throws IllegalArgumentException if the chronology of the time does not match
 * @since 1.5
 */
public LocalDateTime toLocalDateTime(LocalTime time) {
    if (time == null) {
        throw new IllegalArgumentException(""The time must not be null"");
    }
    if (getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    long localMillis = getLocalMillis() + time.getLocalMillis();
    return new LocalDateTime(localMillis, getChronology());
}","public void test123123() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    LocalDate localDate0 = new LocalDate(100000000000000000L, (Chronology) islamicChronology0);
    // Undeclared exception!
    try {
        localDate0.toLocalDateTime((LocalTime) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The time must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Converts this object to a LocalDateTime using a LocalTime to fill in
 * the missing fields.
 * <p>
 * The resulting chronology is determined by the chronology of this
 * LocalDate. The chronology of the time must also match.
 * If the time is null an exception is thrown.
 * <p>
 * This instance is immutable and unaffected by this method call.
 *
 * @param time  the time of day to use, must not be null
 * @return the LocalDateTime instance
 * @throws IllegalArgumentException if the time is null
 * @throws IllegalArgumentException if the chronology of the time does not match
 * @since 1.5
 */
public LocalDateTime toLocalDateTime(LocalTime time) {
    if (time == null) {
        throw new IllegalArgumentException(""The time must not be null"");
    }
    if (getChronology() != time.getChronology()) {
        throw new IllegalArgumentException(""The chronology of the time does not match"");
    }
    long localMillis = getLocalMillis() + time.getLocalMillis();
    return new LocalDateTime(localMillis, getChronology());
}","public void test124124() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    LocalTime localTime0 = new LocalTime(3600000L, (Chronology) copticChronology0);
    localDate0.toLocalDateTime(localTime0);
}",""
"public int hashCode() {
    // override for performance
    int hash = iHash;
    if (hash == 0) {
        hash = iHash = super.hashCode();
    }
    return hash;
}","public void test125125() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.hashCode();
}","/**
 * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.
 *
 * @return a suitable hash code
 */"
"//-----------------------------------------------------------------------
/**
 * Get the date time as a <code>java.util.Date</code>.
 * <p>
 * The <code>Date</code> object created has exactly the same year, month and day
 * as this date. The time will be set to the earliest valid time for that date.
 * <p>
 * Converting to a JDK Date is full of complications as the JDK Date constructor
 * doesn't behave as you might expect around DST transitions. This method works
 * by taking a first guess and then adjusting the JDK date until it has the
 * earliest valid instant. This also handles the situation where the JDK time
 * zone data differs from the Joda-Time time zone data.
 *
 * @return a Date initialised with this date, never null
 * @since 2.0
 */
@SuppressWarnings(""deprecation"")
public Date toDate() {
    int dom = getDayOfMonth();
    Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);
    LocalDate check = LocalDate.fromDateFields(date);
    if (check.isBefore(this)) {
        // DST gap (no midnight)
        // move forward in units of one hour until date correct
        while (check.equals(this) == false) {
            date.setTime(date.getTime() + 3600000);
            check = LocalDate.fromDateFields(date);
        }
        // move back in units of one second until date wrong
        while (date.getDate() == dom) {
            date.setTime(date.getTime() - 1000);
        }
        // fix result
        date.setTime(date.getTime() + 1000);
    } else if (check.equals(this)) {
        // check for DST overlap (two midnights)
        Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());
        if (earlier.getDate() == dom) {
            date = earlier;
        }
    }
    return date;
}","public void test126126() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Days days0 = Days.MAX_VALUE;
    LocalDate localDate1 = localDate0.minus(days0);
    localDate1.toDate();
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this ReadablePartial with another returning true if the chronology,
 * field types and values are equal.
 *
 * @param partial  an object to check against
 * @return true if fields and values are equal
 */
public boolean equals(Object partial) {
    // override to perform faster
    if (this == partial) {
        return true;
    }
    if (partial instanceof LocalDate) {
        LocalDate other = (LocalDate) partial;
        if (iChronology.equals(other.iChronology)) {
            return iLocalMillis == other.iLocalMillis;
        }
    }
    return super.equals(partial);
}","public void test127127() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    Integer integer0 = new Integer(5);
    localDate0.equals(integer0);
}",""
"//-----------------------------------------------------------------------
/**
 * Get the date time as a <code>java.util.Date</code>.
 * <p>
 * The <code>Date</code> object created has exactly the same year, month and day
 * as this date. The time will be set to the earliest valid time for that date.
 * <p>
 * Converting to a JDK Date is full of complications as the JDK Date constructor
 * doesn't behave as you might expect around DST transitions. This method works
 * by taking a first guess and then adjusting the JDK date until it has the
 * earliest valid instant. This also handles the situation where the JDK time
 * zone data differs from the Joda-Time time zone data.
 *
 * @return a Date initialised with this date, never null
 * @since 2.0
 */
@SuppressWarnings(""deprecation"")
public Date toDate() {
    int dom = getDayOfMonth();
    Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);
    LocalDate check = LocalDate.fromDateFields(date);
    if (check.isBefore(this)) {
        // DST gap (no midnight)
        // move forward in units of one hour until date correct
        while (check.equals(this) == false) {
            date.setTime(date.getTime() + 3600000);
            check = LocalDate.fromDateFields(date);
        }
        // move back in units of one second until date wrong
        while (date.getDate() == dom) {
            date.setTime(date.getTime() - 1000);
        }
        // fix result
        date.setTime(date.getTime() + 1000);
    } else if (check.equals(this)) {
        // check for DST overlap (two midnights)
        Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());
        if (earlier.getDate() == dom) {
            date = earlier;
        }
    }
    return date;
}","public void test128128() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    localDate0.toDate();
}",""
"public boolean isSupported(DurationFieldType type) {
    if (type == null) {
        return false;
    }
    DurationField field = type.getField(getChronology());
    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return field.isSupported();
    }
    return false;
}","public void test130130() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = LocalDate.now((DateTimeZone) fixedDateTimeZone0);
    DurationFieldType durationFieldType0 = DurationFieldType.MONTHS_TYPE;
    boolean boolean0 = localDate0.isSupported(durationFieldType0);
    assertTrue(boolean0);
}","/**
 * Checks if the duration type specified is supported by this
 * local date and chronology.
 *
 * @param type  a duration type, usually obtained from DurationFieldType
 * @return true if the field type is supported
 */"
"public boolean isSupported(DurationFieldType type) {
    if (type == null) {
        return false;
    }
    DurationField field = type.getField(getChronology());
    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return field.isSupported();
    }
    return false;
}","public void test131131() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    boolean boolean0 = localDate0.isSupported((DurationFieldType) null);
    assertFalse(boolean0);
}","/**
 * Checks if the duration type specified is supported by this
 * local date and chronology.
 *
 * @param type  a duration type, usually obtained from DurationFieldType
 * @return true if the field type is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the specified period added.
 * <p>
 * If the amount is zero or null, then <code>this</code> is returned.
 * <p>
 * This method is typically used to add complex period instances.
 * Adding one field is best achieved using methods
 * like {@link #plusYears(int)}.
 * <p>
 * Unsupported time fields are ignored, thus adding a period of 24 hours
 * will not have any effect.
 *
 * @param period  the period to add to this one, null means zero
 * @return a copy of this date with the period added
 * @throws ArithmeticException if the result exceeds the internal capacity
 */
public LocalDate plus(ReadablePeriod period) {
    return withPeriodAdded(period, 1);
}","public void test132132() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    DateTime dateTime0 = DateTime.now((Chronology) copticChronology0);
    Hours hours0 = Hours.hoursBetween((ReadableInstant) dateTime0, (ReadableInstant) dateTime0);
    LocalDate localDate1 = localDate0.plus(hours0);
    assertSame(localDate1, localDate0);
}",""
"public boolean isSupported(DateTimeFieldType type) {
    if (type == null) {
        return false;
    }
    DurationFieldType durType = type.getDurationType();
    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) {
        return type.getField(getChronology()).isSupported();
    }
    return false;
}","public void test133133() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    LocalDate localDate0 = new LocalDate((Chronology) islamicChronology0);
    boolean boolean0 = localDate0.isSupported((DateTimeFieldType) null);
    assertFalse(boolean0);
}","/**
 * Checks if the field type specified is supported by this
 * local date and chronology.
 * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.
 *
 * @param type  a field type, usually obtained from DateTimeFieldType
 * @return true if the field type is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Get the value of one of the fields of a datetime.
 * <p>
 * This method gets the value of the specified field.
 * For example:
 * <pre>
 * LocalDate dt = LocalDate.nowDefaultZone();
 * int year = dt.get(DateTimeFieldType.year());
 * </pre>
 *
 * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null
 * @return the value of that field
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public int get(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return fieldType.getField(getChronology()).get(getLocalMillis());
}","public void test134134() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.secondOfDay();
    // Undeclared exception!
    try {
        localDate0.get(dateTimeFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Field 'secondOfDay' is not supported
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Get the value of one of the fields of a datetime.
 * <p>
 * This method gets the value of the specified field.
 * For example:
 * <pre>
 * LocalDate dt = LocalDate.nowDefaultZone();
 * int year = dt.get(DateTimeFieldType.year());
 * </pre>
 *
 * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null
 * @return the value of that field
 * @throws IllegalArgumentException if the field type is null or unsupported
 */
public int get(DateTimeFieldType fieldType) {
    if (fieldType == null) {
        throw new IllegalArgumentException(""The DateTimeFieldType must not be null"");
    }
    if (isSupported(fieldType) == false) {
        throw new IllegalArgumentException(""Field '"" + fieldType + ""' is not supported"");
    }
    return fieldType.getField(getChronology()).get(getLocalMillis());
}","public void test135135() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    // Undeclared exception!
    try {
        localDate0.get((DateTimeFieldType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The DateTimeFieldType must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"public int getValue(int index) {
    switch(index) {
        case YEAR:
            return getChronology().year().get(getLocalMillis());
        case MONTH_OF_YEAR:
            return getChronology().monthOfYear().get(getLocalMillis());
        case DAY_OF_MONTH:
            return getChronology().dayOfMonth().get(getLocalMillis());
        default:
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
    }
}","public void test136136() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    // Undeclared exception!
    try {
        localDate0.getValue(3);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Invalid index: 3
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Gets the value of the field at the specifed index.
 * <p>
 * This method is required to support the <code>ReadablePartial</code>
 * interface. The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"protected DateTimeField getField(int index, Chronology chrono) {
    switch(index) {
        case YEAR:
            return chrono.year();
        case MONTH_OF_YEAR:
            return chrono.monthOfYear();
        case DAY_OF_MONTH:
            return chrono.dayOfMonth();
        default:
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
    }
}","public void test137137() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    // Undeclared exception!
    try {
        localDate0.getField(62, (Chronology) ethiopicChronology0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Invalid index: 62
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Gets the field for a specific index in the chronology specified.
 * <p>
 * This method must not use any instance variables.
 *
 * @param index  the index to retrieve
 * @param chrono  the chronology to use
 * @return the field
 */"
"@SuppressWarnings(""deprecation"")
public static LocalDate fromDateFields(Date date) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    // handle years in era BC
    return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate());
}","public void test138138() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.fromDateFields((Date) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Constructs a LocalDate from a <code>java.util.Date</code>
 * using exactly the same field values.
 * <p>
 * Each field is queried from the Date and assigned to the LocalDate.
 * This is useful if you have been using the Date as a local date,
 * ignoring the zone.
 * <p>
 * One advantage of this method is that this method is unaffected if the
 * version of the time zone data differs between the JDK and Joda-Time.
 * That is because the local field values are transferred, calculated using
 * the JDK time zone data and without using the Joda-Time time zone data.
 * <p>
 * This factory method always creates a LocalDate with ISO chronology.
 *
 * @param date  the Date to extract fields from, not null
 * @return the created local date, not null
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 */"
"//-----------------------------------------------------------------------
/**
 * Constructs a LocalDate from a <code>java.util.Calendar</code>
 * using exactly the same field values.
 * <p>
 * Each field is queried from the Calendar and assigned to the LocalDate.
 * This is useful if you have been using the Calendar as a local date,
 * ignoring the zone.
 * <p>
 * One advantage of this method is that this method is unaffected if the
 * version of the time zone data differs between the JDK and Joda-Time.
 * That is because the local field values are transferred, calculated using
 * the JDK time zone data and without using the Joda-Time time zone data.
 * <p>
 * This factory method ignores the type of the calendar and always
 * creates a LocalDate with ISO chronology. It is expected that you
 * will only pass in instances of <code>GregorianCalendar</code> however
 * this is not validated.
 *
 * @param calendar  the Calendar to extract fields from, not null
 * @return the created local date, not null
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 */
public static LocalDate fromCalendarFields(Calendar calendar) {
    if (calendar == null) {
        throw new IllegalArgumentException(""The calendar must not be null"");
    }
    int yearOfEra = calendar.get(Calendar.YEAR);
    return new LocalDate(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));
}","public void test139139() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.fromCalendarFields((Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The calendar must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}",""
"public static LocalDate now(Chronology chronology) {
    if (chronology == null) {
        throw new NullPointerException(""Chronology must not be null"");
    }
    return new LocalDate(chronology);
}","public void test140140() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.now((Chronology) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Chronology must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Obtains a {@code LocalDate} set to the current system millisecond time
 * using the specified chronology.
 *
 * @param chronology  the chronology, not null
 * @return the current date-time, not null
 * @since 2.0
 */"
"public static LocalDate now(DateTimeZone zone) {
    if (zone == null) {
        throw new NullPointerException(""Zone must not be null"");
    }
    return new LocalDate(zone);
}","public void test141141() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.now((DateTimeZone) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Zone must not be null
        //
        verifyException(""org.joda.time.LocalDate"", e);
    }
}","/**
 * Obtains a {@code LocalDate} set to the current system millisecond time
 * using <code>ISOChronology</code> in the specified time zone.
 *
 * @param zone  the time zone, not null
 * @return the current date-time, not null
 * @since 2.0
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is three.
 * The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @return the field count, three
 */
public int size() {
    return 3;
}","public void test145145() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate.Property localDate_Property0 = localDate0.year();
    LocalDate localDate1 = localDate_Property0.getLocalDate();
    assertEquals(3, localDate1.size());
}",""
"public String toString(String pattern, Locale locale) throws IllegalArgumentException {
    if (pattern == null) {
        return toString();
    }
    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
}","public void test150150() throws Throwable {
    BuddhistChronology buddhistChronology0 = BuddhistChronology.getInstanceUTC();
    LocalDateTime localDateTime0 = new LocalDateTime(21600000L, (Chronology) buddhistChronology0);
    LocalDate localDate0 = new LocalDate(localDateTime0, (DateTimeZone) null);
    Locale locale0 = Locale.CANADA_FRENCH;
    try {
        localDate0.toString(""14G/mB\""Y^M9;~k2RFk"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.joda.time.format.DateTimeFormat"", e);
    }
}","/**
 * Output the date using the specified format pattern.
 *
 * @param pattern  the pattern specification, null means use <code>toString</code>
 * @param locale  Locale to use, null means default
 * @see org.joda.time.format.DateTimeFormat
 */"
"//-----------------------------------------------------------------------
/**
 * Get the era field value.
 *
 * @return the era
 */
public int getEra() {
    return getChronology().era().get(getLocalMillis());
}","public void test151151() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    int int0 = localDate0.getEra();
    assertEquals(1, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test152152() throws Throwable {
    LocalDate localDate0 = new LocalDate((Object) null);
    DateTime dateTime0 = localDate0.toDateTimeAtStartOfDay();
    assertEquals(1392364800000L, dateTime0.getMillis());
}",""
"public int getWeekOfWeekyear() {
    return getChronology().weekOfWeekyear().get(getLocalMillis());
}","public void test153153() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    int int0 = localDate0.getWeekOfWeekyear();
    assertEquals(7, int0);
}","/**
 * Get the week of weekyear field value.
 * <p>
 * This field is associated with the ""weekyear"" via {@link #getWeekyear()}.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 *
 * @return the week of a week based year
 */"
"public LocalDate withDayOfWeek(int dayOfWeek) {
    return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));
}","public void test154154() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    // Undeclared exception!
    try {
        localDate0.withDayOfWeek((-28800000));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -28800000 for dayOfWeek must be in the range [1,7]
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Returns a copy of this date with the day of week field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * day of week changed.
 *
 * @param dayOfWeek  the day of week to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test155155() throws Throwable {
    CopticChronology copticChronology0 = CopticChronology.getInstanceUTC();
    LocalDate localDate0 = LocalDate.now((Chronology) copticChronology0);
    LocalTime localTime0 = new LocalTime(3600000L, (Chronology) copticChronology0);
    DateTime dateTime0 = localDate0.toDateTime(localTime0);
    assertEquals(1392368400000L, dateTime0.getMillis());
}",""
"public int getYearOfEra() {
    return getChronology().yearOfEra().get(getLocalMillis());
}","public void test156156() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    int int0 = localDate0.getYearOfEra();
    assertEquals(2014, int0);
}","/**
 * Get the year of era field value.
 *
 * @return the year of era
 */"
"//-----------------------------------------------------------------------
/**
 * Get the era property which provides access to advanced functionality.
 *
 * @return the era property
 */
public Property era() {
    return new Property(this, getChronology().era());
}","public void test157157() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    LocalDate.Property localDate_Property0 = localDate0.era();
    assertNotNull(localDate_Property0);
}",""
"public int getWeekyear() {
    return getChronology().weekyear().get(getLocalMillis());
}","public void test158158() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    int int0 = localDate0.getWeekyear();
    assertEquals(2014, int0);
}","/**
 * Get the weekyear field value.
 * <p>
 * The weekyear is the year that matches with the weekOfWeekyear field.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 * The weekyear allows you to query the effective year for that day.
 *
 * @return the weekyear
 */"
"public Property dayOfWeek() {
    return new Property(this, getChronology().dayOfWeek());
}","public void test159159() throws Throwable {
    LocalDate localDate0 = new LocalDate((Object) null);
    LocalDate.Property localDate_Property0 = localDate0.dayOfWeek();
    assertNotNull(localDate_Property0);
}","/**
 * Get the day of week property which provides access to advanced functionality.
 *
 * @return the day of week property
 */"
"public int getDayOfYear() {
    return getChronology().dayOfYear().get(getLocalMillis());
}","public void test160160() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    int int0 = localDate0.getDayOfYear();
    assertEquals(112, int0);
}","/**
 * Get the day of year field value.
 *
 * @return the day of year
 */"
"public Property weekyear() {
    return new Property(this, getChronology().weekyear());
}","public void test163163() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate.Property localDate_Property0 = localDate0.weekyear();
    assertNotNull(localDate_Property0);
}","/**
 * Get the weekyear property which provides access to advanced functionality.
 *
 * @return the weekyear property
 */"
"public Property dayOfMonth() {
    return new Property(this, getChronology().dayOfMonth());
}","public void test164164() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate.Property localDate_Property0 = localDate0.dayOfMonth();
    assertNotNull(localDate_Property0);
}","/**
 * Get the day of month property which provides access to advanced functionality.
 *
 * @return the day of month property
 */"
"public int getYearOfCentury() {
    return getChronology().yearOfCentury().get(getLocalMillis());
}","public void test165165() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    int int0 = localDate0.getYearOfCentury();
    assertEquals(62, int0);
}","/**
 * Get the year of century field value.
 *
 * @return the year of century
 */"
"//-----------------------------------------------------------------------
/**
 * Parses a {@code LocalDate} from the specified string.
 * <p>
 * This uses {@link ISODateTimeFormat#localDateParser()}.
 *
 * @param str  the string to parse, not null
 * @since 2.0
 */
@FromString
public static LocalDate parse(String str) {
    return parse(str, ISODateTimeFormat.localDateParser());
}","public void test166166() throws Throwable {
    // Undeclared exception!
    try {
        LocalDate.parse(""k+4%tE`lkM32"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format: \""k+4%tE`lkM32\""
        //
        verifyException(""org.joda.time.format.DateTimeFormatter"", e);
    }
}",""
"public int getCenturyOfEra() {
    return getChronology().centuryOfEra().get(getLocalMillis());
}","public void test167167() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    int int0 = localDate0.getCenturyOfEra();
    assertEquals(20, int0);
}","/**
 * Get the year of era field value.
 *
 * @return the year of era
 */"
"public Property weekOfWeekyear() {
    return new Property(this, getChronology().weekOfWeekyear());
}","public void test168168() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate.Property localDate_Property0 = localDate0.weekOfWeekyear();
    assertNotNull(localDate_Property0);
}","/**
 * Get the week of a week based year property which provides access to advanced functionality.
 *
 * @return the week of a week based year property
 */"
"public int getDayOfWeek() {
    return getChronology().dayOfWeek().get(getLocalMillis());
}","public void test169169() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    int int0 = localDate0.getDayOfWeek();
    assertEquals(5, int0);
}","/**
 * Get the day of week field value.
 * <p>
 * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.
 *
 * @return the day of week
 */"
"public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {
    return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));
}","public void test170170() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate localDate1 = localDate0.withWeekOfWeekyear(1);
    assertNotSame(localDate1, localDate0);
}","/**
 * Returns a copy of this date with the week of weekyear field updated.
 * <p>
 * This field is associated with the ""weekyear"" via {@link #withWeekyear(int)}.
 * In the standard ISO8601 week algorithm, the first week of the year
 * is that in which at least 4 days are in the year. As a result of this
 * definition, day 1 of the first week may be in the previous year.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * week of weekyear changed.
 *
 * @param weekOfWeekyear  the week of weekyear to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test171171() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    DateTime dateTime0 = localDate0.toDateTimeAtMidnight();
    assertEquals((-57600000L), dateTime0.getMillis());
}",""
"public LocalDate withCenturyOfEra(int centuryOfEra) {
    return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));
}","public void test172172() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    LocalDate localDate1 = localDate0.withCenturyOfEra(14);
    assertNotSame(localDate1, localDate0);
}","/**
 * Returns a copy of this date with the century of era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * century of era changed.
 *
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withYearOfEra(int yearOfEra) {
    return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));
}","public void test173173() throws Throwable {
    MockDate mockDate0 = new MockDate((-27), (-1320), 1900);
    LocalDate localDate0 = LocalDate.fromDateFields(mockDate0);
    LocalDate localDate1 = localDate0.withYearOfEra(5);
    assertNotSame(localDate1, localDate0);
}","/**
 * Returns a copy of this date with the year of era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * year of era changed.
 *
 * @param yearOfEra  the year of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test174174() throws Throwable {
    LocalDate localDate0 = new LocalDate();
    DateMidnight dateMidnight0 = localDate0.toDateMidnight();
    assertEquals(1392364800000L, dateMidnight0.getMillis());
}",""
"public int getYear() {
    return getChronology().year().get(getLocalMillis());
}","public void test175175() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    int int0 = localDate0.getYear();
    assertEquals(2014, int0);
}","/**
 * Get the year field value.
 *
 * @return the year
 */"
"public LocalDate withMonthOfYear(int monthOfYear) {
    return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));
}","public void test176176() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstance();
    LocalDate localDate0 = new LocalDate(0L, (Chronology) ethiopicChronology0);
    LocalDate localDate1 = localDate0.withMonthOfYear(1);
    assertNotSame(localDate1, localDate0);
}","/**
 * Returns a copy of this date with the month of year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * month of year changed.
 *
 * @param monthOfYear  the month of year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"public LocalDate withDayOfYear(int dayOfYear) {
    return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));
}","public void test177177() throws Throwable {
    LocalDate localDate0 = new LocalDate(1L);
    LocalDate localDate1 = localDate0.withDayOfYear(2);
    assertNotSame(localDate1, localDate0);
}","/**
 * Returns a copy of this date with the day of year field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * day of year changed.
 *
 * @param dayOfYear  the day of year to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields in this partial, which is three.
 * The supported fields are Year, MonthOfYear and DayOfMonth.
 * Note that all fields from day and above may in fact be queried via
 * other methods.
 *
 * @return the field count, three
 */
public int size() {
    return 3;
}","public void test178178() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = LocalDate.now((DateTimeZone) fixedDateTimeZone0);
    DateTime dateTime0 = localDate0.toDateTimeAtCurrentTime();
    assertEquals(3, localDate0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the milliseconds of the datetime instant from the Java epoch
 * of 1970-01-01T00:00:00Z.
 *
 * @return the number of milliseconds since 1970-01-01T00:00:00Z
 */
public long getMillis() {
    return iMillis;
}","public void test178179() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalDate localDate0 = LocalDate.now((DateTimeZone) fixedDateTimeZone0);
    DateTime dateTime0 = localDate0.toDateTimeAtCurrentTime();
    assertEquals(1392409281320L, dateTime0.getMillis());
}",""
"public long getEndMillis() {
    return iEndMillis;
}","public void test179180() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    Interval interval0 = localDate0.toInterval();
    assertEquals(1392451200000L, interval0.getEndMillis());
}","/**
 * Gets the end of this time interval which is exclusive.
 *
 * @return the end of the time interval,
 *  millisecond instant from 1970-01-01T00:00:00Z
 */"
"public long getStartMillis() {
    return iStartMillis;
}","public void test179181() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    Interval interval0 = localDate0.toInterval();
    assertEquals(1392364800000L, interval0.getStartMillis());
}","/**
 * Gets the start of this time interval which is inclusive.
 *
 * @return the start of the time interval,
 *  millisecond instant from 1970-01-01T00:00:00Z
 */"
"//-----------------------------------------------------------------------
/**
 * Output the date time in ISO8601 format (yyyy-MM-dd).
 *
 * @return ISO8601 time formatted string.
 */
@ToString
public String toString() {
    return ISODateTimeFormat.date().print(this);
}","public void test181183() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    String string0 = localDate0.toString();
    assertEquals(""2014-02-14"", string0);
}",""
"//-----------------------------------------------------------------------
/**
 * Returns a copy of this date with the era field updated.
 * <p>
 * LocalDate is immutable, so there are no set methods.
 * Instead, this method returns a new instance with the value of
 * era changed.
 *
 * @param era  the era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDate withEra(int era) {
    return withLocalMillis(getChronology().era().set(getLocalMillis(), era));
}","public void test182184() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.getDefault();
    LocalDate localDate0 = new LocalDate(dateTimeZone0);
    LocalDate localDate1 = localDate0.withEra(0);
    assertNotSame(localDate1, localDate0);
}",""
