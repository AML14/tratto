focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test000() throws Throwable {
    Years years0 = Years.MIN_VALUE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test001() throws Throwable {
    Years years0 = Years.MIN_VALUE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertFalse(years1.equals((Object) years0));
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of years that this period represents.
 *
 * @return the number of years in the period
 */
public int getYears() {
    return getValue();
}","public void test002() throws Throwable {
    Years years0 = Years.MIN_VALUE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertEquals(2, years1.getYears());
}",""
"public int getValue(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getValue();
}","public void test013() throws Throwable {
    Minutes minutes0 = Minutes.ONE;
    // Undeclared exception!
    try {
        minutes0.getValue((-2693));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // -2693
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Gets the value at the specified index.
 * <p>
 * The only index supported by this period is zero.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public DurationFieldType getFieldType(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getFieldType();
}","public void test024() throws Throwable {
    Days days0 = Days.standardDaysIn((ReadablePeriod) null);
    // Undeclared exception!
    try {
        days0.getFieldType((-225));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // -225
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Gets the field type at the specified index.
 * <p>
 * The only index supported by this period is zero which returns the
 * field type of this class.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test035() throws Throwable {
    IslamicChronology islamicChronology0 = IslamicChronology.getInstanceUTC();
    LocalTime localTime0 = new LocalTime(240L, (Chronology) islamicChronology0);
    DateTimeFieldType dateTimeFieldType0 = DateTimeFieldType.clockhourOfHalfday();
    DurationFieldType durationFieldType0 = dateTimeFieldType0.getRangeDurationType();
    LocalTime localTime1 = localTime0.withFieldAdded(durationFieldType0, 1);
    Days days0 = Days.daysBetween((ReadablePartial) localTime1, (ReadablePartial) localTime0);
    assertEquals(0, days0.getDays());
}",""
"public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) {
    if (start instanceof LocalTime && end instanceof LocalTime) {
        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());
        int hours = chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());
        return Hours.hours(hours);
    }
    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);
    return Hours.hours(amount);
}","public void test046() throws Throwable {
    YearMonth yearMonth0 = YearMonth.now();
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    StrictChronology strictChronology0 = StrictChronology.getInstance(ethiopicChronology0);
    LocalDateTime localDateTime0 = new LocalDateTime((Chronology) strictChronology0);
    // Undeclared exception!
    try {
        Hours.hoursBetween((ReadablePartial) yearMonth0, (ReadablePartial) localDateTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must have the same set of fields
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a <code>Hours</code> representing the number of whole hours
 * between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalTime</code> objects.
 *
 * @param start  the start partial date, must not be null
 * @param end  the end partial date, must not be null
 * @return the period in hours
 * @throws IllegalArgumentException if the partials are null or invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test057() throws Throwable {
    Years years0 = Years.MAX_VALUE;
    boolean boolean0 = years0.equals(years0);
    assertTrue(boolean0);
}",""
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test068() throws Throwable {
    EthiopicChronology ethiopicChronology0 = EthiopicChronology.getInstanceUTC();
    Interval interval0 = new Interval(2224L, 2224L, ethiopicChronology0);
    Duration duration0 = interval0.toDuration();
    Hours hours0 = duration0.toStandardHours();
    Minutes minutes0 = hours0.toStandardMinutes();
    int int0 = BaseSingleFieldPeriod.standardPeriodIn(minutes0, 1);
    assertEquals(0, int0);
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test079() throws Throwable {
    Minutes minutes0 = Minutes.TWO;
    int int0 = BaseSingleFieldPeriod.standardPeriodIn(minutes0, 10L);
    assertEquals(12000, int0);
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"public int getValue(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getValue();
}","public void test0810() throws Throwable {
    Period period0 = new Period();
    Weeks weeks0 = period0.toStandardWeeks();
    int int0 = weeks0.getValue(0);
    assertEquals(0, int0);
}","/**
 * Gets the value at the specified index.
 * <p>
 * The only index supported by this period is zero.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int getValue(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getValue();
}","public void test0911() throws Throwable {
    Years years0 = Years.THREE;
    int int0 = years0.getValue(0);
    assertEquals(3, int0);
}","/**
 * Gets the value at the specified index.
 * <p>
 * The only index supported by this period is zero.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the name of the period type.
 *
 * @return the name
 */
public String getName() {
    return iName;
}","public void test1012() throws Throwable {
    FixedDateTimeZone fixedDateTimeZone0 = (FixedDateTimeZone) DateTimeZone.UTC;
    LocalTime localTime0 = LocalTime.now((DateTimeZone) fixedDateTimeZone0);
    Years years0 = Years.yearsBetween((ReadablePartial) localTime0, (ReadablePartial) localTime0);
    PeriodType periodType0 = years0.getPeriodType();
    assertEquals(""Years"", periodType0.getName());
}",""
"//-----------------------------------------------------------------------
/**
 * Get the name of the field.
 * By convention, names are plural.
 *
 * @return field name
 */
public String getName() {
    return iName;
}","public void test1113() throws Throwable {
    Minutes minutes0 = Minutes.THREE;
    DurationFieldType durationFieldType0 = minutes0.getFieldType();
    assertEquals(""minutes"", durationFieldType0.getName());
}",""
"public int get(DurationFieldType type) {
    if (type == getFieldType()) {
        return getValue();
    }
    return 0;
}","public void test1214() throws Throwable {
    Months months0 = Months.MIN_VALUE;
    DurationFieldType durationFieldType0 = DurationFieldType.months();
    int int0 = months0.get(durationFieldType0);
    assertEquals(Integer.MIN_VALUE, int0);
}","/**
 * Gets the value of a duration field represented by this period.
 * <p>
 * If the field type specified does not match the type used by this class
 * then zero is returned.
 *
 * @param type  the field type to query, null returns zero
 * @return the value of that field, zero if field not supported
 */"
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified datetimes.
 *
 * @param start  the start instant, validated to not be null
 * @param end  the end instant, validated to not be null
 * @param field  the field type to use, must not be null
 * @return the period
 * @throws IllegalArgumentException if the instants are null or invalid
 */
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadableInstant objects must not be null"");
    }
    Chronology chrono = DateTimeUtils.getInstantChronology(start);
    int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());
    return amount;
}","public void test1315() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    DateMidnight dateMidnight0 = localDate0.toDateMidnight((DateTimeZone) null);
    Instant instant0 = dateMidnight0.toInstant();
    Weeks weeks0 = Weeks.weeksBetween((ReadableInstant) instant0, (ReadableInstant) dateMidnight0);
    DurationFieldType durationFieldType0 = weeks0.getFieldType();
    int int0 = BaseSingleFieldPeriod.between(dateMidnight0, instant0, durationFieldType0);
    assertEquals(0, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified datetimes.
 *
 * @param start  the start instant, validated to not be null
 * @param end  the end instant, validated to not be null
 * @param field  the field type to use, must not be null
 * @return the period
 * @throws IllegalArgumentException if the instants are null or invalid
 */
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadableInstant objects must not be null"");
    }
    Chronology chrono = DateTimeUtils.getInstantChronology(start);
    int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());
    return amount;
}","public void test1416() throws Throwable {
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    DateTime dateTime0 = DateTime.now(dateTimeZone0);
    DateTime dateTime1 = dateTime0.withYear(1);
    DurationFieldType durationFieldType0 = DurationFieldType.halfdays();
    int int0 = BaseSingleFieldPeriod.between(dateTime1, dateTime0, durationFieldType0);
    assertEquals(1470466, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified datetimes.
 *
 * @param start  the start instant, validated to not be null
 * @param end  the end instant, validated to not be null
 * @param field  the field type to use, must not be null
 * @return the period
 * @throws IllegalArgumentException if the instants are null or invalid
 */
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadableInstant objects must not be null"");
    }
    Chronology chrono = DateTimeUtils.getInstantChronology(start);
    int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());
    return amount;
}","public void test1517() throws Throwable {
    LocalDate localDate0 = LocalDate.now();
    DateMidnight dateMidnight0 = localDate0.toDateMidnight((DateTimeZone) null);
    Instant instant0 = dateMidnight0.toInstant();
    DateMidnight dateMidnight1 = dateMidnight0.withYearOfEra(27);
    DurationFieldType durationFieldType0 = DurationFieldType.days();
    int int0 = BaseSingleFieldPeriod.between(instant0, dateMidnight1, durationFieldType0);
    assertEquals((-725737), int0);
}",""
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test1618() throws Throwable {
    Hours hours0 = Hours.FIVE;
    // Undeclared exception!
    try {
        BaseSingleFieldPeriod.standardPeriodIn(hours0, 0L);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // / by zero
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test1719() throws Throwable {
    Hours hours0 = Hours.MIN_VALUE;
    // Undeclared exception!
    try {
        BaseSingleFieldPeriod.standardPeriodIn(hours0, (-1));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Value cannot fit in an int: 7730941132800000
        //
        verifyException(""org.joda.time.field.FieldUtils"", e);
    }
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"public int compareTo(BaseSingleFieldPeriod other) {
    if (other.getClass() != getClass()) {
        throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass());
    }
    int otherValue = other.getValue();
    int thisValue = getValue();
    if (thisValue > otherValue) {
        return 1;
    }
    if (thisValue < otherValue) {
        return -1;
    }
    return 0;
}","public void test1820() throws Throwable {
    Weeks weeks0 = Weeks.weeks(0);
    // Undeclared exception!
    try {
        weeks0.compareTo((BaseSingleFieldPeriod) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Compares this period to another object of the same class.
 *
 * @param other  the other period, must not be null
 * @return zero if equal, positive if greater, negative if less
 * @throws NullPointerException if the other period is null
 * @throws ClassCastException if the other period is of a different type
 */"
"public int getValue(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getValue();
}","public void test1921() throws Throwable {
    Months months0 = Months.MIN_VALUE;
    int int0 = months0.getValue(0);
    assertEquals(Integer.MIN_VALUE, int0);
}","/**
 * Gets the value at the specified index.
 * <p>
 * The only index supported by this period is zero.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports, which is one.
 *
 * @return the number of fields supported, which is one
 */
public int size() {
    return 1;
}","public void test2022() throws Throwable {
    Months months0 = Months.TWELVE;
    int int0 = months0.size();
    assertEquals(1, int0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of hours that this period represents.
 *
 * @return the number of hours in the period
 */
public int getHours() {
    return getValue();
}","public void test2123() throws Throwable {
    Hours hours0 = Hours.FIVE;
    Hours hours1 = Hours.MIN_VALUE;
    int int0 = hours1.compareTo((BaseSingleFieldPeriod) hours0);
    assertEquals(5, hours0.getHours());
}",""
"public int compareTo(BaseSingleFieldPeriod other) {
    if (other.getClass() != getClass()) {
        throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass());
    }
    int otherValue = other.getValue();
    int thisValue = getValue();
    if (thisValue > otherValue) {
        return 1;
    }
    if (thisValue < otherValue) {
        return -1;
    }
    return 0;
}","public void test2124() throws Throwable {
    Hours hours0 = Hours.FIVE;
    Hours hours1 = Hours.MIN_VALUE;
    int int0 = hours1.compareTo((BaseSingleFieldPeriod) hours0);
    assertEquals((-1), int0);
}","/**
 * Compares this period to another object of the same class.
 *
 * @param other  the other period, must not be null
 * @return zero if equal, positive if greater, negative if less
 * @throws NullPointerException if the other period is null
 * @throws ClassCastException if the other period is of a different type
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of months that this period represents.
 *
 * @return the number of months in the period
 */
public int getMonths() {
    return getValue();
}","public void test2225() throws Throwable {
    Months months0 = Months.TWELVE;
    Months months1 = months0.dividedBy(667);
    int int0 = months0.compareTo((BaseSingleFieldPeriod) months1);
    assertEquals(0, months1.getMonths());
}",""
"public int compareTo(BaseSingleFieldPeriod other) {
    if (other.getClass() != getClass()) {
        throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass());
    }
    int otherValue = other.getValue();
    int thisValue = getValue();
    if (thisValue > otherValue) {
        return 1;
    }
    if (thisValue < otherValue) {
        return -1;
    }
    return 0;
}","public void test2226() throws Throwable {
    Months months0 = Months.TWELVE;
    Months months1 = months0.dividedBy(667);
    int int0 = months0.compareTo((BaseSingleFieldPeriod) months1);
    assertEquals(1, int0);
}","/**
 * Compares this period to another object of the same class.
 *
 * @param other  the other period, must not be null
 * @return zero if equal, positive if greater, negative if less
 * @throws NullPointerException if the other period is null
 * @throws ClassCastException if the other period is of a different type
 */"
"public int compareTo(BaseSingleFieldPeriod other) {
    if (other.getClass() != getClass()) {
        throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass());
    }
    int otherValue = other.getValue();
    int thisValue = getValue();
    if (thisValue > otherValue) {
        return 1;
    }
    if (thisValue < otherValue) {
        return -1;
    }
    return 0;
}","public void test2327() throws Throwable {
    Weeks weeks0 = Weeks.weeks(0);
    Hours hours0 = Hours.SIX;
    // Undeclared exception!
    try {
        weeks0.compareTo((BaseSingleFieldPeriod) hours0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // class org.joda.time.Weeks cannot be compared to class org.joda.time.Hours
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Compares this period to another object of the same class.
 *
 * @param other  the other period, must not be null
 * @return zero if equal, positive if greater, negative if less
 * @throws NullPointerException if the other period is null
 * @throws ClassCastException if the other period is of a different type
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test2428() throws Throwable {
    LocalTime localTime0 = LocalTime.MIDNIGHT;
    Days days0 = Days.daysBetween((ReadablePartial) localTime0, (ReadablePartial) localTime0);
    int int0 = days0.compareTo((BaseSingleFieldPeriod) days0);
    assertEquals(0, days0.getDays());
}",""
"public int compareTo(BaseSingleFieldPeriod other) {
    if (other.getClass() != getClass()) {
        throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass());
    }
    int otherValue = other.getValue();
    int thisValue = getValue();
    if (thisValue > otherValue) {
        return 1;
    }
    if (thisValue < otherValue) {
        return -1;
    }
    return 0;
}","public void test2429() throws Throwable {
    LocalTime localTime0 = LocalTime.MIDNIGHT;
    Days days0 = Days.daysBetween((ReadablePartial) localTime0, (ReadablePartial) localTime0);
    int int0 = days0.compareTo((BaseSingleFieldPeriod) days0);
    assertEquals(0, int0);
}","/**
 * Compares this period to another object of the same class.
 *
 * @param other  the other period, must not be null
 * @return zero if equal, positive if greater, negative if less
 * @throws NullPointerException if the other period is null
 * @throws ClassCastException if the other period is of a different type
 */"
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test2530() throws Throwable {
    LocalTime localTime0 = LocalTime.MIDNIGHT;
    Days days0 = Days.daysBetween((ReadablePartial) localTime0, (ReadablePartial) localTime0);
    Seconds seconds0 = Seconds.MAX_VALUE;
    boolean boolean0 = days0.equals(seconds0);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test2631() throws Throwable {
    Years years0 = Years.ONE;
    boolean boolean0 = years0.equals((Object) null);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of weeks that this period represents.
 *
 * @return the number of weeks in the period
 */
public int getWeeks() {
    return getValue();
}","public void test2732() throws Throwable {
    Period period0 = Period.hours(0);
    Weeks weeks0 = period0.toStandardWeeks();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, dateTimeZone0);
    Period period1 = new Period(weeks0, zonedChronology0);
    boolean boolean0 = weeks0.equals(period1);
    assertEquals(0, weeks0.getWeeks());
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test2733() throws Throwable {
    Period period0 = Period.hours(0);
    Weeks weeks0 = period0.toStandardWeeks();
    DateTimeZone dateTimeZone0 = DateTimeZone.forOffsetHours(0);
    ISOChronology iSOChronology0 = ISOChronology.getInstance(dateTimeZone0);
    ZonedChronology zonedChronology0 = ZonedChronology.getInstance(iSOChronology0, dateTimeZone0);
    Period period1 = new Period(weeks0, zonedChronology0);
    boolean boolean0 = weeks0.equals(period1);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test2834() throws Throwable {
    Years years0 = Years.THREE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertFalse(years1.equals((Object) years0));
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of years that this period represents.
 *
 * @return the number of years in the period
 */
public int getYears() {
    return getValue();
}","public void test2835() throws Throwable {
    Years years0 = Years.THREE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertEquals(2, years1.getYears());
}",""
"//-----------------------------------------------------------------------
/**
 * Compares this object with the specified object for equality based on the
 * value of each field. All ReadablePeriod instances are accepted, but only
 * those with a matching <code>PeriodType</code> can return true.
 *
 * @param period  a readable period to check against
 * @return true if all the field values are equal, false if
 *  not or the period is null or of an incorrect type
 */
public boolean equals(Object period) {
    if (this == period) {
        return true;
    }
    if (period instanceof ReadablePeriod == false) {
        return false;
    }
    ReadablePeriod other = (ReadablePeriod) period;
    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());
}","public void test2836() throws Throwable {
    Years years0 = Years.THREE;
    Years years1 = Years.TWO;
    boolean boolean0 = years0.equals(years1);
    assertFalse(boolean0);
}",""
"public boolean isSupported(DurationFieldType type) {
    return (type == getFieldType());
}","public void test2937() throws Throwable {
    Months months0 = Months.TWELVE;
    DurationFieldType durationFieldType0 = DurationFieldType.months();
    boolean boolean0 = months0.isSupported(durationFieldType0);
    assertTrue(boolean0);
}","/**
 * Checks whether the duration field specified is supported by this period.
 *
 * @param type  the type to check, may be null which returns false
 * @return true if the field is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of seconds that this period represents.
 *
 * @return the number of seconds in the period
 */
public int getSeconds() {
    return getValue();
}","public void test3038() throws Throwable {
    Days days0 = Days.FOUR;
    Seconds seconds0 = days0.toStandardSeconds();
    DurationFieldType durationFieldType0 = DurationFieldType.centuries();
    boolean boolean0 = seconds0.isSupported(durationFieldType0);
    assertEquals(345600, seconds0.getSeconds());
}",""
"public boolean isSupported(DurationFieldType type) {
    return (type == getFieldType());
}","public void test3039() throws Throwable {
    Days days0 = Days.FOUR;
    Seconds seconds0 = days0.toStandardSeconds();
    DurationFieldType durationFieldType0 = DurationFieldType.centuries();
    boolean boolean0 = seconds0.isSupported(durationFieldType0);
    assertFalse(boolean0);
}","/**
 * Checks whether the duration field specified is supported by this period.
 *
 * @param type  the type to check, may be null which returns false
 * @return true if the field is supported
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of days that this period represents.
 *
 * @return the number of days in the period
 */
public int getDays() {
    return getValue();
}","public void test3040() throws Throwable {
    Days days0 = Days.FOUR;
    Seconds seconds0 = days0.toStandardSeconds();
    DurationFieldType durationFieldType0 = DurationFieldType.centuries();
    boolean boolean0 = seconds0.isSupported(durationFieldType0);
    assertEquals(4, days0.getDays());
}",""
"public int get(DurationFieldType type) {
    if (type == getFieldType()) {
        return getValue();
    }
    return 0;
}","public void test3141() throws Throwable {
    Months months0 = Months.TWO;
    DurationFieldType durationFieldType0 = DurationFieldType.months();
    int int0 = months0.get(durationFieldType0);
    assertEquals(2, int0);
}","/**
 * Gets the value of a duration field represented by this period.
 * <p>
 * If the field type specified does not match the type used by this class
 * then zero is returned.
 *
 * @param type  the field type to query, null returns zero
 * @return the value of that field, zero if field not supported
 */"
"public int get(DurationFieldType type) {
    if (type == getFieldType()) {
        return getValue();
    }
    return 0;
}","public void test3242() throws Throwable {
    Minutes minutes0 = Minutes.parseMinutes(""PT0S"");
    Hours hours0 = Hours.SIX;
    DurationFieldType durationFieldType0 = hours0.getFieldType(0);
    int int0 = minutes0.get(durationFieldType0);
    assertEquals(0, int0);
}","/**
 * Gets the value of a duration field represented by this period.
 * <p>
 * If the field type specified does not match the type used by this class
 * then zero is returned.
 *
 * @param type  the field type to query, null returns zero
 * @return the value of that field, zero if field not supported
 */"
"public int getValue(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getValue();
}","public void test3343() throws Throwable {
    Months months0 = Months.ONE;
    // Undeclared exception!
    try {
        months0.getValue(599);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // 599
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Gets the value at the specified index.
 * <p>
 * The only index supported by this period is zero.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the value of the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test3444() throws Throwable {
    Years years0 = Years.years(4);
    // Undeclared exception!
    try {
        BaseSingleFieldPeriod.standardPeriodIn(years0, 4);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot convert period to duration as years is not precise in the period P4Y
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) {
    if (start instanceof LocalDate && end instanceof LocalDate) {
        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());
        int weeks = chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());
        return Weeks.weeks(weeks);
    }
    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);
    return Weeks.weeks(amount);
}","public void test3545() throws Throwable {
    LocalTime localTime0 = new LocalTime(0, 0, 0);
    LocalDateTime localDateTime0 = new LocalDateTime((long) 0, (Chronology) null);
    // Undeclared exception!
    try {
        Weeks.weeksBetween((ReadablePartial) localTime0, (ReadablePartial) localDateTime0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must have the same set of fields
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a <code>Weeks</code> representing the number of whole weeks
 * between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalDate</code> objects.
 *
 * @param start  the start partial date, must not be null
 * @param end  the end partial date, must not be null
 * @return the period in weeks
 * @throws IllegalArgumentException if the partials are null or invalid
 */"
"public static Days daysBetween(ReadablePartial start, ReadablePartial end) {
    if (start instanceof LocalDate && end instanceof LocalDate) {
        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());
        int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());
        return Days.days(days);
    }
    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);
    return Days.days(amount);
}","public void test3646() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    DateTimeZone dateTimeZone0 = DateTimeZone.forTimeZone(timeZone0);
    LocalTime localTime0 = new LocalTime((-880L), dateTimeZone0);
    MonthDay monthDay0 = MonthDay.now();
    // Undeclared exception!
    try {
        Days.daysBetween((ReadablePartial) localTime0, (ReadablePartial) monthDay0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must have the same set of fields
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a <code>Days</code> representing the number of whole days
 * between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalDate</code> objects.
 *
 * @param start  the start partial date, must not be null
 * @param end  the end partial date, must not be null
 * @return the period in days
 * @throws IllegalArgumentException if the partials are null or invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalDate</code> objects.
 *
 * @param start  the start partial date, validated to not be null
 * @param end  the end partial date, validated to not be null
 * @param zeroInstance  the zero instance constant, must not be null
 * @return the period
 * @throws IllegalArgumentException if the partials are null or invalid
 */
protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
    }
    if (DateTimeUtils.isContiguous(start) == false) {
        throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
    }
    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
    int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
    return values[0];
}","public void test3747() throws Throwable {
    Seconds seconds0 = Seconds.ZERO;
    LocalTime localTime0 = new LocalTime(0, 0, 0);
    // Undeclared exception!
    try {
        BaseSingleFieldPeriod.between(localTime0, (ReadablePartial) null, seconds0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalDate</code> objects.
 *
 * @param start  the start partial date, validated to not be null
 * @param end  the end partial date, validated to not be null
 * @param zeroInstance  the zero instance constant, must not be null
 * @return the period
 * @throws IllegalArgumentException if the partials are null or invalid
 */
protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
    }
    if (start.size() != end.size()) {
        throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
    }
    for (int i = 0, isize = start.size(); i < isize; i++) {
        if (start.getFieldType(i) != end.getFieldType(i)) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
    }
    if (DateTimeUtils.isContiguous(start) == false) {
        throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
    }
    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
    int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
    return values[0];
}","public void test3848() throws Throwable {
    Seconds seconds0 = Seconds.ZERO;
    LocalTime localTime0 = new LocalTime(0, 0, 0);
    int int0 = BaseSingleFieldPeriod.between(localTime0, localTime0, seconds0);
    assertEquals(0, int0);
}",""
"public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) {
    if (start instanceof LocalTime && end instanceof LocalTime) {
        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());
        int seconds = chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());
        return Seconds.seconds(seconds);
    }
    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);
    return Seconds.seconds(amount);
}","public void test3949() throws Throwable {
    // Undeclared exception!
    try {
        Seconds.secondsBetween((ReadablePartial) null, (ReadablePartial) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadablePartial objects must not be null
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Creates a <code>Seconds</code> representing the number of whole seconds
 * between the two specified partial datetimes.
 * <p>
 * The two partials must contain the same fields, for example you can specify
 * two <code>LocalTime</code> objects.
 *
 * @param start  the start partial date, must not be null
 * @param end  the end partial date, must not be null
 * @return the period in seconds
 * @throws IllegalArgumentException if the partials are null or invalid
 */"
"public DurationFieldType getFieldType(int index) {
    if (index != 0) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    return getFieldType();
}","public void test4050() throws Throwable {
    Duration duration0 = Duration.ZERO;
    DateTimePrinter dateTimePrinter0 = mock(DateTimePrinter.class, new ViolatedAssumptionAnswer());
    DateTimeParser dateTimeParser0 = mock(DateTimeParser.class, new ViolatedAssumptionAnswer());
    doReturn(10080).when(dateTimeParser0).parseInto(any(org.joda.time.format.DateTimeParserBucket.class), anyString(), anyInt());
    DateTimeFormatter dateTimeFormatter0 = new DateTimeFormatter(dateTimePrinter0, dateTimeParser0);
    DateTime dateTime0 = dateTimeFormatter0.parseDateTime(""ReadablePartial objects must be contiguous"");
    Interval interval0 = duration0.toIntervalTo(dateTime0);
    Weeks weeks0 = Weeks.weeksIn(interval0);
    // Undeclared exception!
    try {
        weeks0.getFieldType(10080);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // 10080
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}","/**
 * Gets the field type at the specified index.
 * <p>
 * The only index supported by this period is zero which returns the
 * field type of this class.
 *
 * @param index  the index to retrieve, which must be zero
 * @return the field at the specified index
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Creates a <code>Seconds</code> representing the number of whole seconds
 * between the two specified datetimes.
 *
 * @param start  the start instant, must not be null
 * @param end  the end instant, must not be null
 * @return the period in seconds
 * @throws IllegalArgumentException if the instants are null or invalid
 */
public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) {
    int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds());
    return Seconds.seconds(amount);
}","public void test4151() throws Throwable {
    DateMidnight dateMidnight0 = new DateMidnight((DateTimeZone) null);
    Instant instant0 = dateMidnight0.toInstant();
    // Undeclared exception!
    try {
        Seconds.secondsBetween((ReadableInstant) instant0, (ReadableInstant) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadableInstant objects must not be null
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Calculates the number of whole units between the two specified datetimes.
 *
 * @param start  the start instant, validated to not be null
 * @param end  the end instant, validated to not be null
 * @param field  the field type to use, must not be null
 * @return the period
 * @throws IllegalArgumentException if the instants are null or invalid
 */
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {
    if (start == null || end == null) {
        throw new IllegalArgumentException(""ReadableInstant objects must not be null"");
    }
    Chronology chrono = DateTimeUtils.getInstantChronology(start);
    int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());
    return amount;
}","public void test4252() throws Throwable {
    DurationFieldType durationFieldType0 = DurationFieldType.centuries();
    // Undeclared exception!
    try {
        BaseSingleFieldPeriod.between((ReadableInstant) null, (ReadableInstant) null, durationFieldType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ReadableInstant objects must not be null
        //
        verifyException(""org.joda.time.base.BaseSingleFieldPeriod"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of years that this period represents.
 *
 * @return the number of years in the period
 */
public int getYears() {
    return getValue();
}","public void test4353() throws Throwable {
    Years years0 = Years.ONE;
    years0.toMutablePeriod();
    assertEquals(1, years0.getYears());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports, which is one.
 *
 * @return the number of fields supported, which is one
 */
public int size() {
    return 1;
}","public void test4354() throws Throwable {
    Years years0 = Years.ONE;
    years0.toMutablePeriod();
    assertEquals(1, years0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of fields that this period supports, which is one.
 *
 * @return the number of fields supported, which is one
 */
public int size() {
    return 1;
}","public void test4455() throws Throwable {
    Years years0 = Years.ONE;
    years0.toPeriod();
    assertEquals(1, years0.size());
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the number of years that this period represents.
 *
 * @return the number of years in the period
 */
public int getYears() {
    return getValue();
}","public void test4456() throws Throwable {
    Years years0 = Years.ONE;
    years0.toPeriod();
    assertEquals(1, years0.getYears());
}",""
"protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {
    if (period == null) {
        return 0;
    }
    Chronology iso = ISOChronology.getInstanceUTC();
    long duration = 0L;
    for (int i = 0; i < period.size(); i++) {
        int value = period.getValue(i);
        if (value != 0) {
            DurationField field = period.getFieldType(i).getField(iso);
            if (field.isPrecise() == false) {
                throw new IllegalArgumentException(""Cannot convert period to duration as "" + field.getName() + "" is not precise in the period "" + period);
            }
            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));
        }
    }
    return FieldUtils.safeToInt(duration / millisPerUnit);
}","public void test4557() throws Throwable {
    Hours hours0 = Hours.FIVE;
    int int0 = BaseSingleFieldPeriod.standardPeriodIn(hours0, (-1));
    assertEquals((-18000000), int0);
}","/**
 * Creates a new instance representing the number of complete standard length units
 * in the specified period.
 * <p>
 * This factory method converts all fields from the period to hours using standardised
 * durations for each field. Only those fields which have a precise duration in
 * the ISO UTC chronology can be converted.
 * <ul>
 * <li>One week consists of 7 days.
 * <li>One day consists of 24 hours.
 * <li>One hour consists of 60 minutes.
 * <li>One minute consists of 60 seconds.
 * <li>One second consists of 1000 milliseconds.
 * </ul>
 * Months and Years are imprecise and periods containing these values cannot be converted.
 *
 * @param period  the period to get the number of hours from, must not be null
 * @param millisPerUnit  the number of milliseconds in one standard unit of this period
 * @throws IllegalArgumentException if the period contains imprecise duration values
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the number of months that this period represents.
 *
 * @return the number of months in the period
 */
public int getMonths() {
    return getValue();
}","public void test4658() throws Throwable {
    Months months0 = Months.TWO;
    months0.hashCode();
    assertEquals(2, months0.getMonths());
}",""
