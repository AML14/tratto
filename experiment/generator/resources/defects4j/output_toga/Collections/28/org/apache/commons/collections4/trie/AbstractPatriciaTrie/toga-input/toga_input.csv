focal_method,test_prefix,docstring
"@Override
public K lastKey() {
    final TrieEntry<K, V> entry = lastEntry();
    if (entry != null) {
        return entry.getKey();
    }
    throw new NoSuchElementException();
}","public void test0000() throws Throwable {
    Integer integer0 = new Integer(1);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""A{CEcN}(;:+"", integer0, 1);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""A{CEcN}(;:+"", integer0, 1);
    abstractPatriciaTrie_TrieEntry0.left = abstractPatriciaTrie_TrieEntry1;
    Integer integer1 = new Integer(1);
    abstractPatriciaTrie_TrieEntry0.setKeyValue(""A{CEcN}(;:+"", integer1);
    abstractPatriciaTrie_TrieEntry0.isExternalNode();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""A{CEcN}(;:+"", ""A{CEcN}(;:+"");
    patriciaTrie0.floorEntry(""A{CEcN}(;:+"");
    abstractPatriciaTrie_TrieEntry1.setValue((Integer) null);
    Collection<String> collection0 = patriciaTrie0.values();
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Object, Object>(""A{CEcN}(;:+"", abstractPatriciaTrie_TrieEntry1, (-2426));
    abstractPatriciaTrie_TrieEntry2.isExternalNode();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>();
    patriciaTrie1.lowerEntry(""A{CEcN}(;:+"");
    AbstractMap.SimpleImmutableEntry<Object, Object> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<Object, Object>(collection0, integer0);
    patriciaTrie0.get((Object) null);
    AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>> abstractPatriciaTrie_TrieEntry3 = new AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>>(abstractPatriciaTrie_TrieEntry0, abstractMap_SimpleImmutableEntry0, (-1006));
    abstractPatriciaTrie_TrieEntry3.isInternalNode();
    // Undeclared exception!
    try {
        patriciaTrie1.lastKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {
    TrieEntry<K, V> current = start;
    // Only look at the left if this was a recursive or
    // the first check, otherwise we know we've already looked
    // at the left.
    if (previous == null || start != previous.predecessor) {
        while (!current.left.isEmpty()) {
            // stop traversing if we've already
            // returned the left of this node.
            if (previous == current.left) {
                break;
            }
            if (isValidUplink(current.left, current)) {
                return current.left;
            }
            current = current.left;
        }
    }
    // If there's no data at all, exit.
    if (current.isEmpty()) {
        return null;
    }
    // If we've already returned the left,
    // and the immediate right is null,
    // there's only one entry in the Trie
    // which is stored at the root.
    //
    //  / ("""")   <-- root
    //  \_/  \
    //       null <-- 'current'
    //
    if (current.right == null) {
        return null;
    }
    // If nothing valid on the left, try the right.
    if (previous != current.right) {
        // See if it immediately is valid.
        if (isValidUplink(current.right, current)) {
            return current.right;
        }
        // Must search on the right's side if it wasn't initially valid.
        return nextEntryImpl(current.right, previous, tree);
    }
    // Neither left nor right are valid, find the first parent
    // whose child did not come from the right & traverse it.
    while (current == current.parent.right) {
        // If we're going to traverse to above the subtree, stop.
        if (current == tree) {
            return null;
        }
        current = current.parent;
    }
    // If we're on the top of the subtree, we can't go any higher.
    if (current == tree) {
        return null;
    }
    // If there's no right, the parent must be root, so we're done.
    if (current.parent.right == null) {
        return null;
    }
    // If the parent's right points to itself, we've found one.
    if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent)) {
        return current.parent.right;
    }
    // If the parent's right is itself, there can't be any more nodes.
    if (current.parent.right == current.parent) {
        return null;
    }
    // We need to traverse down the parent's right's path.
    return nextEntryImpl(current.parent.right, previous, tree);
}","public void test0011() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.previousKey(""="");
    patriciaTrie0.ceilingEntry(""Mwm'[Qp!|Y"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    patriciaTrie1.higherEntry("""");
    PatriciaTrie<String> patriciaTrie2 = new PatriciaTrie<String>(patriciaTrie1);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""!UZbyVBqi3D>\""G"", """", 0);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie1.addEntry(abstractPatriciaTrie_TrieEntry1, 2);
    patriciaTrie1.selectKey(""="");
    PatriciaTrie<Integer> patriciaTrie3 = new PatriciaTrie<Integer>();
    Integer integer0 = new Integer((-1));
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""!UZbyVBqi3D>\""G"", integer0, 2);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry3 = abstractPatriciaTrie_TrieEntry2.right;
    // Undeclared exception!
    try {
        patriciaTrie3.nextEntryImpl((AbstractPatriciaTrie.TrieEntry<String, Integer>) null, (AbstractPatriciaTrie.TrieEntry<String, Integer>) null, (AbstractPatriciaTrie.TrieEntry<String, Integer>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Scans for the next node, starting at the specified point, and using 'previous'
 * as a hint that the last node we returned was 'previous' (so we know not to return
 * it again).  If 'tree' is non-null, this will limit the search to the given tree.
 *
 * The basic premise is that each iteration can follow the following steps:
 *
 * 1) Scan all the way to the left.
 *   a) If we already started from this node last time, proceed to Step 2.
 *   b) If a valid uplink is found, use it.
 *   c) If the result is an empty node (root not set), break the scan.
 *   d) If we already returned the left node, break the scan.
 *
 * 2) Check the right.
 *   a) If we already returned the right node, proceed to Step 3.
 *   b) If it is a valid uplink, use it.
 *   c) Do Step 1 from the right node.
 *
 * 3) Back up through the parents until we encounter find a parent
 *    that we're not the right child of.
 *
 * 4) If there's no right child of that parent, the iteration is finished.
 *    Otherwise continue to Step 5.
 *
 * 5) Check to see if the right child is a valid uplink.
 *    a) If we already returned that child, proceed to Step 6.
 *       Otherwise, use it.
 *
 * 6) If the right child of the parent is the parent itself, we've
 *    already found & returned the end of the Trie, so exit.
 *
 * 7) Do Step 1 on the parent's right child.
 */"
"TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {
            break;
        }
        path = current;
        if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    // Make sure the entry is valid for a subtree.
    final TrieEntry<K, V> entry = current.isEmpty() ? path : current;
    // If entry is root, it can't be empty.
    if (entry.isEmpty()) {
        return null;
    }
    final int endIndexInBits = offsetInBits + lengthInBits;
    // if root && length of root is less than length of lookup,
    // there's nothing.
    // (this prevents returning the whole subtree if root has an empty
    //  string and we want to lookup things with ""\0"")
    if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {
        return null;
    }
    // Found key's length-th bit differs from our key
    // which means it cannot be the prefix...
    if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits) != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {
        return null;
    }
    // ... or there are less than 'length' equal bits
    final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));
    if (bitIndex >= 0 && bitIndex < lengthInBits) {
        return null;
    }
    return entry;
}","public void test0022() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>(hashMap0);
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    String string0 = ""2p`5Ku8/LMa}l</nZpE"";
    String string1 = ""j5(~AGXZ"";
    patriciaTrie1.put(""2p`5Ku8/LMa}l</nZpE"", ""j5(~AGXZ"");
    hashMap0.put("""", ""j5(~AGXZ"");
    patriciaTrie0.clear();
    patriciaTrie1.put(""x^5*FXq[NZn6N@K,O"", ""x^5*FXq[NZn6N@K,O"");
    patriciaTrie0.floorEntry(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeMap"");
    PatriciaTrie<String> patriciaTrie2 = new PatriciaTrie<String>(patriciaTrie1);
    // Undeclared exception!
    try {
        patriciaTrie1.subtree((String) null, (-463), (-463));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Finds the subtree that contains the prefix.
 *
 * This is very similar to getR but with the difference that
 * we stop the lookup if h.bitIndex > lengthInBits.
 */"
"TrieEntry<K, V> getEntry(final Object k) {
    final K key = castKey(k);
    if (key == null) {
        return null;
    }
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;
}","public void test0044() throws Throwable {
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    hashMap0.clone();
    Integer integer0 = new Integer(0);
    hashMap0.put(""%*Y1R'r"", integer0);
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>(hashMap0);
    hashMap0.put(""m"", integer0);
    Integer integer1 = new Integer(1136);
    patriciaTrie0.prefixMap("""");
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""f\""5\""p:y._D#`7>Z~0P"", integer1, 1136);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""f\""5\""p:y._D#`7>Z~0P"", integer1, 1136);
    abstractPatriciaTrie_TrieEntry0.value = null;
    abstractPatriciaTrie_TrieEntry0.left = abstractPatriciaTrie_TrieEntry1;
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry2 = abstractPatriciaTrie_TrieEntry0.parent;
    patriciaTrie0.nextEntry((AbstractPatriciaTrie.TrieEntry<String, Integer>) null);
    patriciaTrie0.getNearestEntryForKey((String) null, 1136);
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry3 = new AbstractPatriciaTrie.TrieEntry<String, String>("""", ""%*Y1R'r"", 0);
    abstractPatriciaTrie_TrieEntry3.setValue(""a1k["");
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByKey((Comparator<? super Integer>) comparator0);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry4 = new AbstractPatriciaTrie.TrieEntry<String, String>(""%*Y1R'r"", ""%*Y1R'r"", 0);
    patriciaTrie1.previousEntry(abstractPatriciaTrie_TrieEntry4);
    patriciaTrie1.headMap(""m"");
    PatriciaTrie<Object> patriciaTrie2 = new PatriciaTrie<Object>();
    Integer integer2 = new Integer(0);
    // Undeclared exception!
    try {
        patriciaTrie2.getEntry(integer2);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * Returns the entry associated with the specified key in the
 * PatriciaTrieBase.  Returns null if the map contains no mapping
 * for this key.
 * <p>
 * This may throw ClassCastException if the object is not of type K.
 */"
"@Override
public K previousKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> prevEntry = previousEntry(entry);
        return prevEntry != null ? prevEntry.getKey() : null;
    }
    return null;
}","public void test0055() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put("""", ""?Z"");
    patriciaTrie0.put("" + "", "",ee)#(<d};,Q57g"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie0.nextKey("""");
    patriciaTrie0.getEntry((Object) null);
    patriciaTrie1.ceilingEntry(""left="");
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie1.get((Object) null);
    Integer integer0 = new Integer(116);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>((String) null, integer0, 116);
    patriciaTrie0.incrementSize();
    Integer integer1 = new Integer((-711));
    patriciaTrie2.put(""?Z"", integer1);
    abstractPatriciaTrie_TrieEntry0.setValue(integer0);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie1.isBitSet(""left="", 0, 0);
    patriciaTrie2.addEntry(abstractPatriciaTrie_TrieEntry1, 116);
    // Undeclared exception!
    try {
        patriciaTrie1.previousKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> floorEntry(final K key) {
    // TODO: Cleanup so that we don't actually have to add/remove from the
    //       tree.  (We do it here because there are other well-defined
    //       functions to perform the search.)
    final int lengthInBits = lengthInBits(key);
    if (lengthInBits == 0) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        return found;
    }
    final int bitIndex = bitIndex(key, found.key);
    if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
        final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);
        addEntry(added, lengthInBits);
        // must increment because remove will decrement
        incrementSize();
        final TrieEntry<K, V> floor = previousEntry(added);
        removeEntry(added);
        // we didn't really modify it.
        modCount -= 2;
        return floor;
    } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
        return found;
    }
    // we should have exited above.
    throw new IllegalStateException(""invalid lookup: "" + key);
}","public void test0066() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    BiFunction<Object, Object, String> biFunction0 = (BiFunction<Object, Object, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    patriciaTrie0.put(""@/$<UTx@O"", ""@/$<UTx@O"");
    patriciaTrie0.computeIfPresent(""ToKey is out of range: "", biFunction0);
    patriciaTrie0.floorEntry(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
}","/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or null if there is no such key.
 */"
"public K selectKey(final K key) {
    final Map.Entry<K, V> entry = select(key);
    if (entry == null) {
        return null;
    }
    return entry.getKey();
}","public void test0099() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>(hashMap0);
    patriciaTrie0.entrySet();
    Set<Map.Entry<String, String>> set0 = (Set<Map.Entry<String, String>>) patriciaTrie0.entrySet();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Object, String>(set0, ""Ur>+bf"", 0);
    patriciaTrie0.values();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, String>((Object) null, ""'tcP#JyA{:\"",n+F#HSq"", (-1));
    abstractPatriciaTrie_TrieEntry0.right = abstractPatriciaTrie_TrieEntry1;
    Integer integer0 = new Integer(0);
    patriciaTrie0.subtree(""u@;uw1LS`{,s8u`5"", 0, (-1));
    Integer integer1 = new Integer(0);
    AbstractPatriciaTrie.TrieEntry<Integer, Object> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Integer, Object>(integer0, integer1, (-55));
    hashMap0.put(""K4#n2I+47C?"", ""K4#n2I+47C?"");
    Integer integer2 = (Integer) abstractPatriciaTrie_TrieEntry2.value;
    abstractPatriciaTrie_TrieEntry0.bitIndex = 0;
    abstractPatriciaTrie_TrieEntry0.key = (Object) integer2;
    AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry0, abstractPatriciaTrie_TrieEntry0);
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>();
    patriciaTrie1.entrySet();
    patriciaTrie1.ceilingEntry(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
    patriciaTrie1.put(""K4#n2I+47C?"", integer1);
    patriciaTrie1.floorEntry(""Cannot determine prefix outside of Character boundaries"");
    PatriciaTrie<Object> patriciaTrie2 = new PatriciaTrie<Object>();
    BiFunction<Object, Object, String> biFunction0 = (BiFunction<Object, Object, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    patriciaTrie2.computeIfPresent(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", biFunction0);
    patriciaTrie2.selectKey(""Cannot determine prefix outside of Character boundaries"");
}","/**
 * Returns the key that is closest in a bitwise XOR metric to the
 * provided key. This is NOT lexicographic closeness!
 *
 * For example, given the keys:
 *
 * <ol>
 * <li>D = 1000100
 * <li>H = 1001000
 * <li>L = 1001100
 * </ol>
 *
 * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would
 * return 'L', because the XOR distance between D &amp; L is smaller
 * than the XOR distance between D &amp; H.
 *
 * @param key  the key to use in the search
 * @return the key that is closest in a bitwise XOR metric to the provided key
 */"
"@Override
public SortedMap<K, V> headMap(final K toKey) {
    return new RangeEntryMap(null, toKey);
}","public void test01010() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.ceilingEntry("""");
    patriciaTrie0.put("""", """");
    patriciaTrie0.prefixMap(""j($ldQy56"");
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<Comparable<String>> patriciaTrie1 = new PatriciaTrie<Comparable<String>>(hashMap0);
    hashMap0.put("""", """");
    patriciaTrie1.headMap("""");
}",""
"@Override
public V put(final K key, final V value) {
    if (key == null) {
        throw new NullPointerException(""Key cannot be null"");
    }
    final int lengthInBits = lengthInBits(key);
    // The only place to store a key with a length
    // of zero bits is the root node
    if (lengthInBits == 0) {
        if (root.isEmpty()) {
            incrementSize();
        } else {
            incrementModCount();
        }
        return root.setKeyValue(key, value);
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        if (found.isEmpty()) {
            // <- must be the root
            incrementSize();
        } else {
            incrementModCount();
        }
        return found.setKeyValue(key, value);
    }
    final int bitIndex = bitIndex(key, found.key);
    if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {
        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
            // in 99.999...9% the case
            /* NEW KEY+VALUE TUPLE */
            final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);
            addEntry(t, lengthInBits);
            incrementSize();
            return null;
        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
            // A bits of the Key are zero. The only place to
            // store such a Key is the root Node!
            /* NULL BIT KEY */
            if (root.isEmpty()) {
                incrementSize();
            } else {
                incrementModCount();
            }
            return root.setKeyValue(key, value);
        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
            // This is a very special and rare case.
            /* REPLACE OLD KEY+VALUE */
            if (found != root) {
                incrementModCount();
                return found.setKeyValue(key, value);
            }
        }
    }
    throw new IllegalArgumentException(""Failed to put: "" + key + "" -> "" + value + "", "" + bitIndex);
}","public void test01212() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleEntry<Integer, Object>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleEntry<Integer, Object>>();
    Integer integer0 = new Integer((-3));
    AbstractMap.SimpleEntry<Integer, Object> abstractMap_SimpleEntry0 = new AbstractMap.SimpleEntry<Integer, Object>(integer0, (Object) null);
    // Undeclared exception!
    try {
        patriciaTrie0.put((String) null, abstractMap_SimpleEntry0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Key cannot be null
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"//-----------------------------------------------------------------------
@Override
public Comparator<? super K> comparator() {
    return getKeyAnalyzer();
}","public void test01313() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    patriciaTrie1.comparator();
}",""
"@Override
public Set<K> keySet() {
    if (keySet == null) {
        keySet = new KeySet();
    }
    return keySet;
}","public void test01414() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""Cannot determine prefix outside of Character boundaries"", ""Cannot determine prefix outside of Character boundaries"");
    patriciaTrie0.modCount = (-495);
    patriciaTrie0.values();
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, String>> patriciaTrie1 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, String>>();
    patriciaTrie1.keySet();
}",""
"@Override
public SortedMap<K, V> subMap(final K fromKey, final K toKey) {
    return new RangeEntryMap(fromKey, toKey);
}","public void test01515() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    HashMap<String, String> hashMap0 = new HashMap<String, String>(patriciaTrie0);
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(hashMap0);
    patriciaTrie1.subMap(""(G\u0002Ohkk{/%8tCT"", ""<B"");
}",""
"@Override
public SortedMap<K, V> subMap(final K fromKey, final K toKey) {
    return new RangeEntryMap(fromKey, toKey);
}","public void test01616() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    // Undeclared exception!
    try {
        patriciaTrie0.subMap(""kyYa;[.9|j|WbufZ"", "" is not an internal Entry!"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // fromKey > toKey
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$RangeEntryMap"", e);
    }
}",""
"@Override
public boolean containsKey(final Object k) {
    if (k == null) {
        return false;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key);
}","public void test01717() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    Object object0 = new Object();
    // Undeclared exception!
    try {
        patriciaTrie0.containsKey(object0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Object cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}",""
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test01818() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.put("""", (Object) null);
    patriciaTrie0.getOrDefault((Object) null, (Object) null);
    String string0 = ""]={\n"";
    patriciaTrie0.higherEntry(""]={\n"");
    patriciaTrie0.comparator();
    Object object0 = new Object();
    // Undeclared exception!
    try {
        patriciaTrie0.remove(object0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Object cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {
            break;
        }
        path = current;
        if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    // Make sure the entry is valid for a subtree.
    final TrieEntry<K, V> entry = current.isEmpty() ? path : current;
    // If entry is root, it can't be empty.
    if (entry.isEmpty()) {
        return null;
    }
    final int endIndexInBits = offsetInBits + lengthInBits;
    // if root && length of root is less than length of lookup,
    // there's nothing.
    // (this prevents returning the whole subtree if root has an empty
    //  string and we want to lookup things with ""\0"")
    if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {
        return null;
    }
    // Found key's length-th bit differs from our key
    // which means it cannot be the prefix...
    if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits) != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {
        return null;
    }
    // ... or there are less than 'length' equal bits
    final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));
    if (bitIndex >= 0 && bitIndex < lengthInBits) {
        return null;
    }
    return entry;
}","public void test01919() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie1.put(""org.apache.commons.collections4.trie.PatriciaTrie"", ""org.apache.commons.collections4.trie.PatriciaTrie"");
    int int0 = 2032;
    patriciaTrie0.put(""org.apache.commons.collections4.trie.PatriciaTrie"", ""keyAnalyzer"");
    // Undeclared exception!
    try {
        patriciaTrie1.subtree(""org.apache.commons.collections4.trie.PatriciaTrie"", 0, 2032);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Finds the subtree that contains the prefix.
 *
 * This is very similar to getR but with the difference that
 * we stop the lookup if h.bitIndex > lengthInBits.
 */"
"@Override
public V put(final K key, final V value) {
    if (key == null) {
        throw new NullPointerException(""Key cannot be null"");
    }
    final int lengthInBits = lengthInBits(key);
    // The only place to store a key with a length
    // of zero bits is the root node
    if (lengthInBits == 0) {
        if (root.isEmpty()) {
            incrementSize();
        } else {
            incrementModCount();
        }
        return root.setKeyValue(key, value);
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        if (found.isEmpty()) {
            // <- must be the root
            incrementSize();
        } else {
            incrementModCount();
        }
        return found.setKeyValue(key, value);
    }
    final int bitIndex = bitIndex(key, found.key);
    if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {
        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
            // in 99.999...9% the case
            /* NEW KEY+VALUE TUPLE */
            final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);
            addEntry(t, lengthInBits);
            incrementSize();
            return null;
        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
            // A bits of the Key are zero. The only place to
            // store such a Key is the root Node!
            /* NULL BIT KEY */
            if (root.isEmpty()) {
                incrementSize();
            } else {
                incrementModCount();
            }
            return root.setKeyValue(key, value);
        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
            // This is a very special and rare case.
            /* REPLACE OLD KEY+VALUE */
            if (found != root) {
                incrementModCount();
                return found.setKeyValue(key, value);
            }
        }
    }
    throw new IllegalArgumentException(""Failed to put: "" + key + "" -> "" + value + "", "" + bitIndex);
}","public void test02020() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, Integer>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, Integer>>();
    patriciaTrie0.decrementSize();
    patriciaTrie0.decrementSize();
    String string0 = null;
    Integer integer0 = new Integer(893);
    AbstractMap.SimpleImmutableEntry<String, Integer> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<String, Integer>((String) null, integer0);
    AbstractMap.SimpleImmutableEntry<String, Integer> abstractMap_SimpleImmutableEntry1 = new AbstractMap.SimpleImmutableEntry<String, Integer>(abstractMap_SimpleImmutableEntry0);
    // Undeclared exception!
    try {
        patriciaTrie0.put((String) null, abstractMap_SimpleImmutableEntry1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // Key cannot be null
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"@Override
public SortedMap<K, V> subMap(final K fromKey, final K toKey) {
    return new RangeEntryMap(fromKey, toKey);
}","public void test02121() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleEntry<Object, Object>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleEntry<Object, Object>>();
    Object object0 = new Object();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Object, String>(object0, ""w"", 0);
    abstractPatriciaTrie_TrieEntry0.setValue(""w"");
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, String>(object0, ""w"", 543);
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByKey((Comparator<? super Integer>) comparator0);
    abstractPatriciaTrie_TrieEntry0.left = abstractPatriciaTrie_TrieEntry1;
    Comparator<Object> comparator1 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByValue();
    abstractPatriciaTrie_TrieEntry1.bitIndex = (-2342);
    Comparator<Object> comparator2 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByValue((Comparator<? super Object>) comparator2);
    abstractPatriciaTrie_TrieEntry1.parent = abstractPatriciaTrie_TrieEntry0;
    Map.Entry.comparingByValue((Comparator<? super Object>) comparator1);
    abstractPatriciaTrie_TrieEntry0.toString();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>();
    patriciaTrie1.keySet();
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>(hashMap0);
    PatriciaTrie<Integer> patriciaTrie3 = new PatriciaTrie<Integer>(patriciaTrie2);
    PatriciaTrie<Integer> patriciaTrie4 = new PatriciaTrie<Integer>(patriciaTrie3);
    PatriciaTrie<Integer> patriciaTrie5 = new PatriciaTrie<Integer>(patriciaTrie4);
    // Undeclared exception!
    try {
        patriciaTrie5.subMap(""w"", ""Cannot determine prefix outside of Character boundaries"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // fromKey > toKey
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$RangeEntryMap"", e);
    }
}",""
"TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {
            break;
        }
        path = current;
        if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    // Make sure the entry is valid for a subtree.
    final TrieEntry<K, V> entry = current.isEmpty() ? path : current;
    // If entry is root, it can't be empty.
    if (entry.isEmpty()) {
        return null;
    }
    final int endIndexInBits = offsetInBits + lengthInBits;
    // if root && length of root is less than length of lookup,
    // there's nothing.
    // (this prevents returning the whole subtree if root has an empty
    //  string and we want to lookup things with ""\0"")
    if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {
        return null;
    }
    // Found key's length-th bit differs from our key
    // which means it cannot be the prefix...
    if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits) != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {
        return null;
    }
    // ... or there are less than 'length' equal bits
    final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));
    if (bitIndex >= 0 && bitIndex < lengthInBits) {
        return null;
    }
    return entry;
}","public void test02222() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    String string0 = ""p1v\\kXa(&=a='<@]7\"""";
    Integer integer0 = new Integer(404);
    patriciaTrie0.put(""p1vkXa(&=a='<@]7\"""", integer0);
    int int0 = 0;
    Integer integer1 = new Integer(0);
    patriciaTrie0.put(""]={\n"", integer1);
    Integer integer2 = new Integer(0);
    patriciaTrie0.replace((String) null, integer2);
    int int1 = 1479;
    // Undeclared exception!
    try {
        patriciaTrie0.subtree("""", 1479, 1479);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Finds the subtree that contains the prefix.
 *
 * This is very similar to getR but with the difference that
 * we stop the lookup if h.bitIndex > lengthInBits.
 */"
"TrieEntry<K, V> getEntry(final Object k) {
    final K key = castKey(k);
    if (key == null) {
        return null;
    }
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;
}","public void test02323() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    PatriciaTrie<Object> patriciaTrie2 = new PatriciaTrie<Object>(patriciaTrie1);
    // Undeclared exception!
    try {
        patriciaTrie2.getEntry(patriciaTrie0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.collections4.trie.PatriciaTrie cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * Returns the entry associated with the specified key in the
 * PatriciaTrieBase.  Returns null if the map contains no mapping
 * for this key.
 * <p>
 * This may throw ClassCastException if the object is not of type K.
 */"
"@Override
public SortedMap<K, V> headMap(final K toKey) {
    return new RangeEntryMap(null, toKey);
}","public void test02525() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>(hashMap0);
    patriciaTrie0.headMap("""");
}",""
"@Override
public K nextKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> nextEntry = nextEntry(entry);
        return nextEntry != null ? nextEntry.getKey() : null;
    }
    return null;
}","public void test02727() throws Throwable {
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    Integer integer0 = new Integer(0);
    hashMap0.put(""Tf"", integer0);
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>(hashMap0);
    hashMap0.put(""Tf"", (Integer) null);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = patriciaTrie0.subtree(""Tf"", 0, 0);
    patriciaTrie0.selectValue("""");
    patriciaTrie0.selectKey("""");
    patriciaTrie0.clear();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, String>(""Tf"", (String) null, 1);
    Integer integer1 = new Integer(1);
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Object, String>(integer1, ""Tf"", (-3825));
    abstractPatriciaTrie_TrieEntry1.parent = abstractPatriciaTrie_TrieEntry2;
    abstractPatriciaTrie_TrieEntry1.isExternalNode();
    abstractPatriciaTrie_TrieEntry0.toString();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    // Undeclared exception!
    try {
        patriciaTrie1.nextKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"@Override
public OrderedMapIterator<K, V> mapIterator() {
    return new TrieMapIterator();
}","public void test02828() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    AbstractMap.SimpleEntry<String, Object> abstractMap_SimpleEntry0 = new AbstractMap.SimpleEntry<String, Object>(""-!d/_w$.nUCsF9i[S0"", patriciaTrie0);
    AbstractPatriciaTrie.TrieEntry<AbstractMap.SimpleEntry<String, Object>, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<AbstractMap.SimpleEntry<String, Object>, String>(abstractMap_SimpleEntry0, """", (-1404));
    String string0 = abstractPatriciaTrie_TrieEntry0.value;
    patriciaTrie0.remove((Object) """");
    patriciaTrie0.mapIterator();
}",""
"TrieEntry<K, V> followRight(TrieEntry<K, V> node) {
    // if Trie is empty, no last entry.
    if (node.right == null) {
        return null;
    }
    // Go as far right as possible, until we encounter an uplink.
    while (node.right.bitIndex > node.bitIndex) {
        node = node.right;
    }
    return node.right;
}","public void test03030() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    int int0 = 32768;
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""eN7j"", ""eN7j"", 32768);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.right;
    // Undeclared exception!
    try {
        patriciaTrie1.followRight((AbstractPatriciaTrie.TrieEntry<String, String>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Traverses down the right path until it finds an uplink.
 */"
"TrieEntry<K, V> lastEntry() {
    return followRight(root.left);
}","public void test03131() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.lastEntry();
}","/**
 * Returns the last entry the {@link Trie} is storing.
 *
 * <p>This is implemented by going always to the right until
 * we encounter a valid uplink. That uplink is the last key.
 */"
"@Override
public V get(final Object k) {
    final TrieEntry<K, V> entry = getEntry(k);
    return entry != null ? entry.getValue() : null;
}","public void test03232() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.get(""org.apache.commons.collections4.trie.PatriciaTrie"");
}",""
"TrieEntry<K, V> higherEntry(final K key) {
    // TODO: Cleanup so that we don't actually have to add/remove from the
    //       tree.  (We do it here because there are other well-defined
    //       functions to perform the search.)
    final int lengthInBits = lengthInBits(key);
    if (lengthInBits == 0) {
        if (!root.isEmpty()) {
            // If data in root, and more after -- return it.
            if (size() > 1) {
                return nextEntry(root);
            }
            // If no more after, no higher entry.
            return null;
        }
        // Root is empty & we want something after empty, return first.
        return firstEntry();
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        return nextEntry(found);
    }
    final int bitIndex = bitIndex(key, found.key);
    if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
        final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);
        addEntry(added, lengthInBits);
        // must increment because remove will decrement
        incrementSize();
        final TrieEntry<K, V> ceil = nextEntry(added);
        removeEntry(added);
        // we didn't really modify it.
        modCount -= 2;
        return ceil;
    } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
        if (!root.isEmpty()) {
            return firstEntry();
        } else if (size() > 1) {
            return nextEntry(firstEntry());
        } else {
            return null;
        }
    } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
        return nextEntry(found);
    }
    // we should have exited above.
    throw new IllegalStateException(""invalid lookup: "" + key);
}","public void test03333() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleEntry<String, String>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleEntry<String, String>>();
    patriciaTrie0.higherEntry("""");
}","/**
 * Returns an entry strictly higher than the given key,
 * or null if no such entry exists.
 */"
"TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {
    TrieEntry<K, V> current = start;
    // Only look at the left if this was a recursive or
    // the first check, otherwise we know we've already looked
    // at the left.
    if (previous == null || start != previous.predecessor) {
        while (!current.left.isEmpty()) {
            // stop traversing if we've already
            // returned the left of this node.
            if (previous == current.left) {
                break;
            }
            if (isValidUplink(current.left, current)) {
                return current.left;
            }
            current = current.left;
        }
    }
    // If there's no data at all, exit.
    if (current.isEmpty()) {
        return null;
    }
    // If we've already returned the left,
    // and the immediate right is null,
    // there's only one entry in the Trie
    // which is stored at the root.
    //
    //  / ("""")   <-- root
    //  \_/  \
    //       null <-- 'current'
    //
    if (current.right == null) {
        return null;
    }
    // If nothing valid on the left, try the right.
    if (previous != current.right) {
        // See if it immediately is valid.
        if (isValidUplink(current.right, current)) {
            return current.right;
        }
        // Must search on the right's side if it wasn't initially valid.
        return nextEntryImpl(current.right, previous, tree);
    }
    // Neither left nor right are valid, find the first parent
    // whose child did not come from the right & traverse it.
    while (current == current.parent.right) {
        // If we're going to traverse to above the subtree, stop.
        if (current == tree) {
            return null;
        }
        current = current.parent;
    }
    // If we're on the top of the subtree, we can't go any higher.
    if (current == tree) {
        return null;
    }
    // If there's no right, the parent must be root, so we're done.
    if (current.parent.right == null) {
        return null;
    }
    // If the parent's right points to itself, we've found one.
    if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent)) {
        return current.parent.right;
    }
    // If the parent's right is itself, there can't be any more nodes.
    if (current.parent.right == current.parent) {
        return null;
    }
    // We need to traverse down the parent's right's path.
    return nextEntryImpl(current.parent.right, previous, tree);
}","public void test03434() throws Throwable {
    Integer integer0 = new Integer((-1204));
    AbstractPatriciaTrie.TrieEntry<Integer, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Integer, String>(integer0, ""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", (-1204));
    abstractPatriciaTrie_TrieEntry0.equals((Object) null);
    abstractPatriciaTrie_TrieEntry0.isEmpty();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, String>(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", ""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", 5128);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry2 = abstractPatriciaTrie_TrieEntry1.parent;
    // Undeclared exception!
    try {
        patriciaTrie0.nextEntryImpl((AbstractPatriciaTrie.TrieEntry<String, String>) null, (AbstractPatriciaTrie.TrieEntry<String, String>) null, abstractPatriciaTrie_TrieEntry1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Scans for the next node, starting at the specified point, and using 'previous'
 * as a hint that the last node we returned was 'previous' (so we know not to return
 * it again).  If 'tree' is non-null, this will limit the search to the given tree.
 *
 * The basic premise is that each iteration can follow the following steps:
 *
 * 1) Scan all the way to the left.
 *   a) If we already started from this node last time, proceed to Step 2.
 *   b) If a valid uplink is found, use it.
 *   c) If the result is an empty node (root not set), break the scan.
 *   d) If we already returned the left node, break the scan.
 *
 * 2) Check the right.
 *   a) If we already returned the right node, proceed to Step 3.
 *   b) If it is a valid uplink, use it.
 *   c) Do Step 1 from the right node.
 *
 * 3) Back up through the parents until we encounter find a parent
 *    that we're not the right child of.
 *
 * 4) If there's no right child of that parent, the iteration is finished.
 *    Otherwise continue to Step 5.
 *
 * 5) Check to see if the right child is a valid uplink.
 *    a) If we already returned that child, proceed to Step 6.
 *       Otherwise, use it.
 *
 * 6) If the right child of the parent is the parent itself, we've
 *    already found & returned the end of the Trie, so exit.
 *
 * 7) Do Step 1 on the parent's right child.
 */"
"//-----------------------------------------------------------------------
@Override
public void clear() {
    root.key = null;
    root.bitIndex = -1;
    root.value = null;
    root.parent = null;
    root.left = root;
    root.right = null;
    root.predecessor = root;
    size = 0;
    incrementModCount();
}","public void test03535() throws Throwable {
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>("""", """", (-52));
    AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry0, abstractPatriciaTrie_TrieEntry0);
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.ceilingEntry("""");
    patriciaTrie0.size();
    Integer integer0 = new Integer(0);
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, Object>((Object) null, integer0, (-52));
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Object, Object>(integer0, """", (-1));
    abstractPatriciaTrie_TrieEntry2.value = (Object) abstractPatriciaTrie_TrieEntry1;
    AbstractPatriciaTrie.TrieEntry abstractPatriciaTrie_TrieEntry3 = (AbstractPatriciaTrie.TrieEntry) abstractPatriciaTrie_TrieEntry2.value;
    abstractPatriciaTrie_TrieEntry1.key = (Object) abstractPatriciaTrie_TrieEntry3;
    abstractPatriciaTrie_TrieEntry1.isInternalNode();
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>(hashMap0);
    patriciaTrie1.clear();
}",""
"@Override
public SortedMap<K, V> subMap(final K fromKey, final K toKey) {
    return new RangeEntryMap(fromKey, toKey);
}","public void test03636() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.lowerEntry("""");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie2.selectKey(""H)dRl ]}I.+mb'"");
    patriciaTrie2.toString();
    patriciaTrie2.floorEntry("""");
    Integer integer0 = new Integer(0);
    AbstractPatriciaTrie.TrieEntry<Integer, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Integer, String>(integer0, ""Trie[0]={\n}\n"", 0);
    abstractPatriciaTrie_TrieEntry0.isEmpty();
    patriciaTrie1.subMap("""", """");
}",""
"V removeEntry(final TrieEntry<K, V> h) {
    if (h != root) {
        if (h.isInternalNode()) {
            removeInternalEntry(h);
        } else {
            removeExternalEntry(h);
        }
    }
    decrementSize();
    return h.setKeyValue(null, null);
}","public void test03838() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Object>((String) null, (Object) null, 0);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.right;
    // Undeclared exception!
    try {
        patriciaTrie0.removeEntry((AbstractPatriciaTrie.TrieEntry<String, Object>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Removes a single entry from the {@link Trie}.
 *
 * If we found a Key (Entry h) then figure out if it's
 * an internal (hard to remove) or external Entry (easy
 * to remove)
 */"
"TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {
    if (start.predecessor == null) {
        throw new IllegalArgumentException(""must have come from somewhere!"");
    }
    if (start.predecessor.right == start) {
        if (isValidUplink(start.predecessor.left, start.predecessor)) {
            return start.predecessor.left;
        }
        return followRight(start.predecessor.left);
    }
    TrieEntry<K, V> node = start.predecessor;
    while (node.parent != null && node == node.parent.left) {
        node = node.parent;
    }
    if (node.parent == null) {
        // can be null if we're looking up root.
        return null;
    }
    if (isValidUplink(node.parent.left, node.parent)) {
        if (node.parent.left == root) {
            if (root.isEmpty()) {
                return null;
            }
            return root;
        }
        return node.parent.left;
    }
    return followRight(node.parent.left);
}","public void test03939() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>(hashMap0);
    String string0 = ""M&Us"";
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""org.apache.commons.collections4.trie.KeyAnalyzer"", ""m2g"", 16);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.parent;
    // Undeclared exception!
    try {
        patriciaTrie0.previousEntry((AbstractPatriciaTrie.TrieEntry<String, String>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Returns the node lexicographically before the given node (or null if none).
 *
 * This follows four simple branches:
 *  - If the uplink that returned us was a right uplink:
 *      - If predecessor's left is a valid uplink from predecessor, return it.
 *      - Else, follow the right path from the predecessor's left.
 *  - If the uplink that returned us was a left uplink:
 *      - Loop back through parents until we encounter a node where
 *        node != node.parent.left.
 *          - If node.parent.left is uplink from node.parent:
 *              - If node.parent.left is not root, return it.
 *              - If it is root & root isEmpty, return null.
 *              - If it is root & root !isEmpty, return root.
 *          - If node.parent.left is not uplink from node.parent:
 *              - Follow right path for first right child from node.parent.left
 *
 * @param start  the start entry
 */"
"@Override
public Set<Map.Entry<K, V>> entrySet() {
    if (entrySet == null) {
        entrySet = new EntrySet();
    }
    return entrySet;
}","public void test04040() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    PatriciaTrie<String> patriciaTrie2 = new PatriciaTrie<String>(patriciaTrie1);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""fqh^ xd/<EG"", ""Buy(g/,[+"", 1052);
    patriciaTrie1.nextEntry(abstractPatriciaTrie_TrieEntry0);
    patriciaTrie2.put("""", (String) null);
    patriciaTrie2.entrySet();
}",""
"public K selectKey(final K key) {
    final Map.Entry<K, V> entry = select(key);
    if (entry == null) {
        return null;
    }
    return entry.getKey();
}","public void test04141() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.previousKey(""="");
    patriciaTrie0.ceilingEntry(""Mwm'[Qp!|Y"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie2 = new PatriciaTrie<String>(patriciaTrie1);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""!UZbyVBqi3D>\""G"", """", 0);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie1.addEntry(abstractPatriciaTrie_TrieEntry1, 2);
    PatriciaTrie<String> patriciaTrie3 = new PatriciaTrie<String>(patriciaTrie2);
    patriciaTrie3.selectKey(""="");
}","/**
 * Returns the key that is closest in a bitwise XOR metric to the
 * provided key. This is NOT lexicographic closeness!
 *
 * For example, given the keys:
 *
 * <ol>
 * <li>D = 1000100
 * <li>H = 1001000
 * <li>L = 1001100
 * </ol>
 *
 * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would
 * return 'L', because the XOR distance between D &amp; L is smaller
 * than the XOR distance between D &amp; H.
 *
 * @param key  the key to use in the search
 * @return the key that is closest in a bitwise XOR metric to the provided key
 */"
"TrieEntry<K, V> firstEntry() {
    // if Trie is empty, no first node.
    if (isEmpty()) {
        return null;
    }
    return followLeft(root);
}","public void test04242() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie1.firstEntry();
}","/**
 * Returns the first entry the {@link Trie} is storing.
 * <p>
 * This is implemented by going always to the left until
 * we encounter a valid uplink. That uplink is the first key.
 */"
"@Override
public SortedMap<K, V> prefixMap(final K key) {
    return getPrefixMapByBits(key, 0, lengthInBits(key));
}","public void test04444() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    patriciaTrie0.prefixMap("""");
}",""
"@Override
public boolean containsKey(final Object k) {
    if (k == null) {
        return false;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key);
}","public void test04545() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, Integer>> patriciaTrie1 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<String, Integer>>();
    patriciaTrie1.containsKey(""lXsl]^JP'A_"");
}",""
"@Override
public SortedMap<K, V> tailMap(final K fromKey) {
    return new RangeEntryMap(fromKey, null);
}","public void test04646() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    PatriciaTrie<Object> patriciaTrie2 = new PatriciaTrie<Object>(patriciaTrie1);
    patriciaTrie2.tailMap("""");
}",""
"@Override
public V get(final Object k) {
    final TrieEntry<K, V> entry = getEntry(k);
    return entry != null ? entry.getValue() : null;
}","public void test04747() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    int int0 = (-3847);
    Integer integer0 = new Integer((-3847));
    // Undeclared exception!
    try {
        patriciaTrie0.get(integer0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}",""
"@Override
public boolean containsKey(final Object k) {
    if (k == null) {
        return false;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key);
}","public void test04848() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    patriciaTrie0.lowerEntry(""d"");
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    PatriciaTrie<AbstractMap.SimpleEntry<Integer, Object>> patriciaTrie2 = new PatriciaTrie<AbstractMap.SimpleEntry<Integer, Object>>();
    patriciaTrie2.compareKeys((String) null, "";?^atJ)"");
    patriciaTrie2.floorEntry(""d"");
    PatriciaTrie<String> patriciaTrie3 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie4 = new PatriciaTrie<String>(patriciaTrie3);
    Integer integer0 = new Integer(1405);
    // Undeclared exception!
    try {
        patriciaTrie4.containsKey(integer0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}",""
"public K selectKey(final K key) {
    final Map.Entry<K, V> entry = select(key);
    if (entry == null) {
        return null;
    }
    return entry.getKey();
}","public void test04949() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>(hashMap0);
    patriciaTrie0.entrySet();
    Set<Map.Entry<String, String>> set0 = (Set<Map.Entry<String, String>>) patriciaTrie0.entrySet();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Object, String>(set0, ""Ur>+bf"", 0);
    patriciaTrie0.values();
    AbstractPatriciaTrie.TrieEntry<Object, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, String>((Object) null, ""'tc#JyA{:\"",n+F#HSq"", (-1));
    abstractPatriciaTrie_TrieEntry0.right = abstractPatriciaTrie_TrieEntry1;
    Integer integer0 = new Integer(0);
    patriciaTrie0.subtree(""u@;uw1LS`{,s8u`5"", 0, (-1));
    Integer integer1 = new Integer(0);
    AbstractPatriciaTrie.TrieEntry<Integer, Object> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Integer, Object>(integer0, integer1, (-55));
    hashMap0.put(""K4#n2I+47C?"", ""K4#n2I+47C?"");
    Integer integer2 = (Integer) abstractPatriciaTrie_TrieEntry2.value;
    abstractPatriciaTrie_TrieEntry0.bitIndex = 0;
    abstractPatriciaTrie_TrieEntry0.key = (Object) integer2;
    AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry0, abstractPatriciaTrie_TrieEntry0);
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>();
    patriciaTrie1.ceilingEntry(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
    patriciaTrie1.put(""K4#n2I+47C?"", integer1);
    patriciaTrie1.floorEntry(""Cannot determine prefix outside of Character boundaries"");
    PatriciaTrie<Object> patriciaTrie2 = new PatriciaTrie<Object>();
    BiFunction<Object, Object, String> biFunction0 = (BiFunction<Object, Object, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    patriciaTrie2.computeIfPresent(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", biFunction0);
    patriciaTrie2.selectKey(""Cannot determine prefix outside of Character boundaries"");
}","/**
 * Returns the key that is closest in a bitwise XOR metric to the
 * provided key. This is NOT lexicographic closeness!
 *
 * For example, given the keys:
 *
 * <ol>
 * <li>D = 1000100
 * <li>H = 1001000
 * <li>L = 1001100
 * </ol>
 *
 * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would
 * return 'L', because the XOR distance between D &amp; L is smaller
 * than the XOR distance between D &amp; H.
 *
 * @param key  the key to use in the search
 * @return the key that is closest in a bitwise XOR metric to the provided key
 */"
"TrieEntry<K, V> followRight(TrieEntry<K, V> node) {
    // if Trie is empty, no last entry.
    if (node.right == null) {
        return null;
    }
    // Go as far right as possible, until we encounter an uplink.
    while (node.right.bitIndex > node.bitIndex) {
        node = node.right;
    }
    return node.right;
}","public void test05050() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put("":_;y3k{)Y64]NjJ"", ""[Mi*>9DTb%0H?K:}|"");
    patriciaTrie0.remove((Object) null);
    patriciaTrie0.modCount = 0;
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>((String) null, (String) null, 0);
    patriciaTrie1.put(""0{nL*"", "" is not an internal Entry!"");
    String string0 = abstractPatriciaTrie_TrieEntry0.value;
    patriciaTrie0.containsKey((Object) null);
    patriciaTrie0.firstEntry();
    patriciaTrie1.clear();
    patriciaTrie0.decrementSize();
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie2.selectKey("""");
    PatriciaTrie<Object> patriciaTrie3 = new PatriciaTrie<Object>(patriciaTrie2);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Object>(""bq h}>0_"", """", 1);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry2 = abstractPatriciaTrie_TrieEntry1.parent;
    // Undeclared exception!
    try {
        patriciaTrie3.followRight((AbstractPatriciaTrie.TrieEntry<String, Object>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Traverses down the right path until it finds an uplink.
 */"
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test05151() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<Integer, Object>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<Integer, Object>>();
    // Undeclared exception!
    try {
        patriciaTrie0.firstKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test05252() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    hashMap0.put(""\n"", "" is not an internal Entry!"");
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>(hashMap0);
    patriciaTrie0.replace(""parent="", (Object) ""parent="", (Object) ""parent="");
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    patriciaTrie1.firstKey();
}",""
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test05353() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<Object, Object>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<Object, Object>>();
    int int0 = (-2446);
    patriciaTrie0.getNearestEntryForKey(""+W8%!;6Y.}"", (-2446));
    // Undeclared exception!
    try {
        patriciaTrie0.firstKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> firstEntry() {
    // if Trie is empty, no first node.
    if (isEmpty()) {
        return null;
    }
    return followLeft(root);
}","public void test05454() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    Integer integer0 = new Integer(541);
    patriciaTrie0.nextKey(""9S3V1f&zERN`,("");
    patriciaTrie0.put("""", integer0);
    patriciaTrie0.put(""9S3V1f&zERN`,("", integer0);
    patriciaTrie0.bitIndex((String) null, ""9S3V1f&zERN`,("");
    Integer integer1 = new Integer(541);
    patriciaTrie0.replace(""delegate"", (Integer) null, integer1);
    patriciaTrie0.getNearestEntryForKey((String) null, 1);
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    patriciaTrie1.firstEntry();
}","/**
 * Returns the first entry the {@link Trie} is storing.
 * <p>
 * This is implemented by going always to the left until
 * we encounter a valid uplink. That uplink is the first key.
 */"
"TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {
    while (true) {
        TrieEntry<K, V> child = node.left;
        // if we hit root and it didn't have a node, go right instead.
        if (child.isEmpty()) {
            child = node.right;
        }
        if (child.bitIndex <= node.bitIndex) {
            return child;
        }
        node = child;
    }
}","public void test05555() throws Throwable {
    AbstractPatriciaTrie.TrieEntry<AbstractMap.SimpleEntry<Object, Object>, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<AbstractMap.SimpleEntry<Object, Object>, String>((AbstractMap.SimpleEntry<Object, Object>) null, """", (-1));
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Object>("""", (Object) null, 1);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry2 = abstractPatriciaTrie_TrieEntry1.left;
    patriciaTrie0.followLeft(abstractPatriciaTrie_TrieEntry2);
}","/**
 * Goes left through the tree until it finds a valid node.
 */"
"@Override
public K lastKey() {
    final TrieEntry<K, V> entry = lastEntry();
    if (entry != null) {
        return entry.getKey();
    }
    throw new NoSuchElementException();
}","public void test05656() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>(patriciaTrie0);
    Integer integer0 = new Integer(1699);
    patriciaTrie1.put(""RR?y[B]/$?hq"", integer0);
    patriciaTrie1.lastKey();
}",""
"@Override
public SortedMap<K, V> tailMap(final K fromKey) {
    return new RangeEntryMap(fromKey, null);
}","public void test05757() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    PatriciaTrie<AbstractMap.SimpleEntry<Object, String>> patriciaTrie1 = new PatriciaTrie<AbstractMap.SimpleEntry<Object, String>>();
    Integer integer0 = new Integer(1162);
    AbstractMap.SimpleEntry<Object, String> abstractMap_SimpleEntry0 = new AbstractMap.SimpleEntry<Object, String>(integer0, """");
    patriciaTrie1.put("")4EtKa*"", abstractMap_SimpleEntry0);
    // Undeclared exception!
    try {
        patriciaTrie1.tailMap((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have a from or to!
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$RangeEntryMap"", e);
    }
}",""
"@Override
public K lastKey() {
    final TrieEntry<K, V> entry = lastEntry();
    if (entry != null) {
        return entry.getKey();
    }
    throw new NoSuchElementException();
}","public void test05858() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    patriciaTrie0.firstEntry();
    Integer integer0 = new Integer(186);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeEntrySet$SingletonIterator"", integer0, 186);
    // Undeclared exception!
    try {
        patriciaTrie0.lastKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test06060() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    Integer integer0 = new Integer((-1));
    Integer integer1 = new Integer((-7334));
    patriciaTrie0.put(""RX1q!2W}t}>3o"", integer1);
    patriciaTrie0.put(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", integer0);
    patriciaTrie0.put(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"", integer0);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = null;
    patriciaTrie0.nextEntry((AbstractPatriciaTrie.TrieEntry<String, Integer>) null);
    Integer integer2 = new Integer((-1));
    patriciaTrie0.put(""uSpBVc{Z,V"", integer2);
    patriciaTrie0.ceilingEntry(""uSpBVc{Z,V"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    patriciaTrie1.select(""uSpBVc{Z,V"");
    // Undeclared exception!
    try {
        patriciaTrie1.firstKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> getEntry(final Object k) {
    final K key = castKey(k);
    if (key == null) {
        return null;
    }
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;
}","public void test06161() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    Integer integer0 = new Integer(0);
    patriciaTrie0.put("""", integer0);
    patriciaTrie0.previousKey("""");
    patriciaTrie0.nextKey(""3PeJLNRnnQK/,](_"");
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>(patriciaTrie0);
    Integer integer1 = new Integer(0);
    patriciaTrie1.putIfAbsent("""", integer1);
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>(patriciaTrie1);
    AbstractPatriciaTrie.TrieEntry<Integer, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Integer, Object>(integer1, (Object) null, 0);
    abstractPatriciaTrie_TrieEntry0.getValue();
    patriciaTrie2.getEntry((Object) null);
}","/**
 * Returns the entry associated with the specified key in the
 * PatriciaTrieBase.  Returns null if the map contains no mapping
 * for this key.
 * <p>
 * This may throw ClassCastException if the object is not of type K.
 */"
"TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {
    while (true) {
        TrieEntry<K, V> child = node.left;
        // if we hit root and it didn't have a node, go right instead.
        if (child.isEmpty()) {
            child = node.right;
        }
        if (child.bitIndex <= node.bitIndex) {
            return child;
        }
        node = child;
    }
}","public void test06262() throws Throwable {
    Integer integer0 = new Integer((-122));
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<Object, Object>(integer0, integer0, (-122));
    abstractPatriciaTrie_TrieEntry0.isExternalNode();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.comparator();
    AbstractMap.SimpleImmutableEntry<Object, Object> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<Object, Object>(abstractPatriciaTrie_TrieEntry0);
    abstractPatriciaTrie_TrieEntry0.bitIndex = 447;
    AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>>(abstractPatriciaTrie_TrieEntry0, abstractMap_SimpleImmutableEntry0, (-122));
    abstractPatriciaTrie_TrieEntry1.isInternalNode();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    patriciaTrie1.selectKey(""{ffRQe%y7G."");
    String string0 = ""FromKey is out of range: "";
    patriciaTrie1.prefixMap(""FromKey is out of range: "");
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<String, String>(""`^F$;>C=8bxm)6w_FU"", ""{ffRQe%y7G."", 0);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry3 = abstractPatriciaTrie_TrieEntry2.parent;
    // Undeclared exception!
    try {
        patriciaTrie0.followLeft((AbstractPatriciaTrie.TrieEntry<String, String>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Goes left through the tree until it finds a valid node.
 */"
"static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {
    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();
}","public void test06363() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""s{MX;X0n/.7C"", """");
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>(""}d5[47a"", ""}d5[47a"", 65);
    patriciaTrie0.nextEntryInSubtree(abstractPatriciaTrie_TrieEntry0, abstractPatriciaTrie_TrieEntry0);
    // Undeclared exception!
    try {
        AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry0, (AbstractPatriciaTrie.TrieEntry<?, ?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Returns true if 'next' is a valid uplink coming from 'from'.
 */"
"@Override
public SortedMap<K, V> headMap(final K toKey) {
    return new RangeEntryMap(null, toKey);
}","public void test06464() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.firstEntry();
    patriciaTrie0.putIfAbsent(""ToKey is out of range: "", ""ToKey is out of range: "");
    patriciaTrie0.put(""@/$<UTx@O"", ""@/$<UTx@O"");
    patriciaTrie0.floorEntry(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>();
    patriciaTrie1.headMap(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
}",""
"//-----------------------------------------------------------------------
@Override
public void clear() {
    root.key = null;
    root.bitIndex = -1;
    root.value = null;
    root.parent = null;
    root.left = root;
    root.right = null;
    root.predecessor = root;
    size = 0;
    incrementModCount();
}","public void test06565() throws Throwable {
    Integer integer0 = new Integer(1);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Object>("")D>pE/KPb:ub(d"", integer0, (-647));
    abstractPatriciaTrie_TrieEntry0.toString();
    Object object0 = abstractPatriciaTrie_TrieEntry0.setValue("")D>pE/KPb:ub(d"");
    abstractPatriciaTrie_TrieEntry0.toString();
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>(patriciaTrie0);
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>(patriciaTrie1);
    patriciaTrie0.nextKey(""Entry(key=)D>pE/KPb:ub(d [-647], value=)D>pE/KPb:ub(d, parent=null, left=)D>pE/KPb:ub(d [-647], right=null, predecessor=)D>pE/KPb:ub(d [-647])"");
    PatriciaTrie<Integer> patriciaTrie3 = new PatriciaTrie<Integer>(patriciaTrie2);
    patriciaTrie3.decrementSize();
    abstractPatriciaTrie_TrieEntry0.value = object0;
    BiFunction<Object, Integer, Integer> biFunction0 = (BiFunction<Object, Integer, Integer>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    patriciaTrie3.computeIfPresent(""IcqWo"", biFunction0);
    patriciaTrie3.size();
    patriciaTrie1.put(""6}%5!O?u@"", integer0);
    patriciaTrie1.prefixMap(""*DfI3?H~"");
    Integer integer1 = new Integer(1);
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<Object, Object>(integer1, patriciaTrie2, 1);
    abstractPatriciaTrie_TrieEntry1.isExternalNode();
    AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry1, abstractPatriciaTrie_TrieEntry0);
    patriciaTrie3.clear();
}",""
"TrieEntry<K, V> followRight(TrieEntry<K, V> node) {
    // if Trie is empty, no last entry.
    if (node.right == null) {
        return null;
    }
    // Go as far right as possible, until we encounter an uplink.
    while (node.right.bitIndex > node.bitIndex) {
        node = node.right;
    }
    return node.right;
}","public void test06666() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleEntry<Integer, Integer>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleEntry<Integer, Integer>>();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>();
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Object>("" > "", patriciaTrie0, 1092);
    Map.Entry.comparingByValue();
    patriciaTrie1.followRight(abstractPatriciaTrie_TrieEntry0);
}","/**
 * Traverses down the right path until it finds an uplink.
 */"
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test06767() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.decrementSize();
    // Undeclared exception!
    try {
        patriciaTrie0.firstKey();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex >= entry.bitIndex || current.bitIndex <= path.bitIndex) {
            entry.predecessor = entry;
            if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {
                entry.left = entry;
                entry.right = current;
            } else {
                entry.left = current;
                entry.right = entry;
            }
            entry.parent = path;
            if (current.bitIndex >= entry.bitIndex) {
                current.parent = entry;
            }
            // if we inserted an uplink, set the predecessor on it
            if (current.bitIndex <= path.bitIndex) {
                current.predecessor = entry;
            }
            if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {
                path.left = entry;
            } else {
                path.right = entry;
            }
            return entry;
        }
        path = current;
        if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test06868() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleEntry<String, String>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleEntry<String, String>>();
    String string0 = """";
    String string1 = ""  "";
    AbstractMap.SimpleEntry<String, String> abstractMap_SimpleEntry0 = new AbstractMap.SimpleEntry<String, String>("";\""EH e$C)$JC"", ""  "");
    int int0 = 0;
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByKey((Comparator<? super AbstractMap.SimpleEntry<String, String>>) comparator0);
    AbstractPatriciaTrie.TrieEntry<String, AbstractMap.SimpleEntry<String, String>> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, AbstractMap.SimpleEntry<String, String>>("""", abstractMap_SimpleEntry0, 0);
    String string2 = ""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"";
    abstractPatriciaTrie_TrieEntry0.key = ""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"";
    Comparator<Object> comparator1 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByKey((Comparator<? super AbstractMap.SimpleEntry<String, String>>) comparator1);
    patriciaTrie0.values();
    AbstractPatriciaTrie.TrieEntry<String, AbstractMap.SimpleEntry<String, String>> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.parent;
    // Undeclared exception!
    try {
        patriciaTrie0.addEntry((AbstractPatriciaTrie.TrieEntry<String, AbstractMap.SimpleEntry<String, String>>) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Adds the given {@link TrieEntry} to the {@link Trie}.
 */"
"public Map.Entry<K, V> select(final K key) {
    final int lengthInBits = lengthInBits(key);
    final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K, V>>();
    if (!selectR(root.left, -1, key, lengthInBits, reference)) {
        return reference.get();
    }
    return null;
}","public void test06969() throws Throwable {
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>(hashMap0);
    patriciaTrie0.nextKey("""");
    patriciaTrie0.select(""io,acXLpb#,Gs8"");
}","/**
 * Returns the {@link Entry} whose key is closest in a bitwise XOR
 * metric to the given key. This is NOT lexicographic closeness.
 * For example, given the keys:
 *
 * <ol>
 * <li>D = 1000100
 * <li>H = 1001000
 * <li>L = 1001100
 * </ol>
 *
 * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would
 * return 'L', because the XOR distance between D &amp; L is smaller
 * than the XOR distance between D &amp; H.
 *
 * @param key  the key to use in the search
 * @return the {@link Entry} whose key is closest in a bitwise XOR metric
 *   to the provided key
 */"
"@Override
public K firstKey() {
    if (size() == 0) {
        throw new NoSuchElementException();
    }
    return firstEntry().getKey();
}","public void test07070() throws Throwable {
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    HashMap<String, String> hashMap1 = new HashMap<String, String>(hashMap0);
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>(hashMap1);
    hashMap1.put(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeMap"", ""org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeMap"");
    hashMap1.put(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$KeySet"", ""8;H3Ii|6^3Dqir{F1("");
    patriciaTrie0.put(""O=`KmYH5bQr"", (Object) null);
    patriciaTrie0.put(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$KeySet"", (Object) null);
    patriciaTrie0.lastEntry();
    PatriciaTrie<AbstractMap.SimpleEntry<String, String>> patriciaTrie1 = new PatriciaTrie<AbstractMap.SimpleEntry<String, String>>();
    // Undeclared exception!
    try {
        patriciaTrie1.firstKey();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {
    while (true) {
        TrieEntry<K, V> child = node.left;
        // if we hit root and it didn't have a node, go right instead.
        if (child.isEmpty()) {
            child = node.right;
        }
        if (child.bitIndex <= node.bitIndex) {
            return child;
        }
        node = child;
    }
}","public void test07272() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.put("", "", "", "");
    patriciaTrie0.higherEntry(""<Qe1H.+)QZ<ZjO *{X("");
    HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();
    PatriciaTrie<Integer> patriciaTrie1 = new PatriciaTrie<Integer>(hashMap0);
    // Undeclared exception!
    try {
        patriciaTrie1.followLeft((AbstractPatriciaTrie.TrieEntry<String, Integer>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Goes left through the tree until it finds a valid node.
 */"
"TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {
    if (node == null) {
        return firstEntry();
    }
    return nextEntryImpl(node.predecessor, node, null);
}","public void test07373() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.put(""C]6DQ/ahxA"", ""C]6DQ/ahxA"");
    patriciaTrie0.nextEntry((AbstractPatriciaTrie.TrieEntry<String, Object>) null);
}","/**
 * Returns the entry lexicographically after the given entry.
 * If the given entry is null, returns the first node.
 */"
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test07474() throws Throwable {
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>(patriciaTrie0);
    patriciaTrie1.subMap("""", """");
    Integer integer0 = new Integer((-1));
    patriciaTrie0.put("""", integer0);
    patriciaTrie1.put("""", """");
    patriciaTrie1.headMap("""");
    patriciaTrie1.size();
    PatriciaTrie<String> patriciaTrie2 = new PatriciaTrie<String>();
    PatriciaTrie<String> patriciaTrie3 = new PatriciaTrie<String>(patriciaTrie2);
    patriciaTrie3.put("""", ""EivOMO-#cT"");
    patriciaTrie3.keySet();
    Integer integer1 = new Integer(1258);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>("""", integer1, 1);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.parent;
    patriciaTrie0.nextEntry((AbstractPatriciaTrie.TrieEntry<String, Integer>) null);
    patriciaTrie1.remove((Object) ""VZU4)YcLr_nAw"");
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"@Override
public SortedMap<K, V> headMap(final K toKey) {
    return new RangeEntryMap(null, toKey);
}","public void test07676() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put("""", """");
    patriciaTrie0.put("""", (String) null);
    String string0 = null;
    // Undeclared exception!
    try {
        patriciaTrie0.headMap((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // must have a from or to!
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$RangeEntryMap"", e);
    }
}",""
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test08181() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.lengthInBits("""");
    patriciaTrie0.put(""Entry("", """");
    patriciaTrie0.ceilingEntry("""");
    Integer integer0 = new Integer((-2693));
    // Undeclared exception!
    try {
        patriciaTrie0.remove((Object) integer0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test08383() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    String string0 = """";
    patriciaTrie0.select("""");
    patriciaTrie0.put(""WW X"", ""WW X"");
    String string1 = ""9}F"";
    patriciaTrie0.prefixMap(""9}F"");
    patriciaTrie0.remove((Object) """");
    Integer integer0 = new Integer(62);
    // Undeclared exception!
    try {
        patriciaTrie0.remove((Object) integer0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test08484() throws Throwable {
    Integer integer0 = new Integer((-1422));
    int int0 = (-486);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""owWc<MDV>n.!*Xq%Zg^"", integer0, (-486));
    Integer integer1 = new Integer((-1422));
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""org.apache.commons.collections4.trie.AbstractPatriciaTrie$EntrySet$EntryIterator"", integer1, (-1422));
    abstractPatriciaTrie_TrieEntry0.setKeyValue(""owWc<MDV>n.!*Xq%Zg^"", integer0);
    Map.Entry.comparingByValue();
    abstractPatriciaTrie_TrieEntry0.parent = abstractPatriciaTrie_TrieEntry1;
    abstractPatriciaTrie_TrieEntry0.toString();
    PatriciaTrie<Integer> patriciaTrie0 = new PatriciaTrie<Integer>();
    patriciaTrie0.put(""owWc<MDV>n.!*Xq%Zg^"", integer0);
    Object object0 = new Object();
    // Undeclared exception!
    try {
        patriciaTrie0.remove(object0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Object cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"@Override
public boolean containsKey(final Object k) {
    if (k == null) {
        return false;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key);
}","public void test08686() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.put("""", ""org.apache.commons.collections4.trie.AbstractBitwiseTrie"");
    patriciaTrie0.values();
    patriciaTrie0.containsKey("""");
}",""
"@Override
public K previousKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> prevEntry = previousEntry(entry);
        return prevEntry != null ? prevEntry.getKey() : null;
    }
    return null;
}","public void test08787() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put("""", ""?Z"");
    patriciaTrie0.put("" + "", "",ee)#(<d};,Q57g"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie0.put(""7.*Cz$U"", (String) null);
    patriciaTrie0.nextKey("""");
    patriciaTrie0.getEntry((Object) null);
    patriciaTrie1.ceilingEntry(""left="");
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie1.get((Object) null);
    Integer integer0 = new Integer(116);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>((String) null, integer0, 116);
    patriciaTrie0.incrementSize();
    Integer integer1 = new Integer((-711));
    patriciaTrie2.put(""?Z"", integer1);
    abstractPatriciaTrie_TrieEntry0.setValue(integer0);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie1.isBitSet(""left="", 0, 0);
    patriciaTrie2.addEntry(abstractPatriciaTrie_TrieEntry1, 116);
    // Undeclared exception!
    try {
        patriciaTrie1.previousKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {
    TrieEntry<K, V> current = start;
    // Only look at the left if this was a recursive or
    // the first check, otherwise we know we've already looked
    // at the left.
    if (previous == null || start != previous.predecessor) {
        while (!current.left.isEmpty()) {
            // stop traversing if we've already
            // returned the left of this node.
            if (previous == current.left) {
                break;
            }
            if (isValidUplink(current.left, current)) {
                return current.left;
            }
            current = current.left;
        }
    }
    // If there's no data at all, exit.
    if (current.isEmpty()) {
        return null;
    }
    // If we've already returned the left,
    // and the immediate right is null,
    // there's only one entry in the Trie
    // which is stored at the root.
    //
    //  / ("""")   <-- root
    //  \_/  \
    //       null <-- 'current'
    //
    if (current.right == null) {
        return null;
    }
    // If nothing valid on the left, try the right.
    if (previous != current.right) {
        // See if it immediately is valid.
        if (isValidUplink(current.right, current)) {
            return current.right;
        }
        // Must search on the right's side if it wasn't initially valid.
        return nextEntryImpl(current.right, previous, tree);
    }
    // Neither left nor right are valid, find the first parent
    // whose child did not come from the right & traverse it.
    while (current == current.parent.right) {
        // If we're going to traverse to above the subtree, stop.
        if (current == tree) {
            return null;
        }
        current = current.parent;
    }
    // If we're on the top of the subtree, we can't go any higher.
    if (current == tree) {
        return null;
    }
    // If there's no right, the parent must be root, so we're done.
    if (current.parent.right == null) {
        return null;
    }
    // If the parent's right points to itself, we've found one.
    if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent)) {
        return current.parent.right;
    }
    // If the parent's right is itself, there can't be any more nodes.
    if (current.parent.right == current.parent) {
        return null;
    }
    // We need to traverse down the parent's right's path.
    return nextEntryImpl(current.parent.right, previous, tree);
}","public void test08888() throws Throwable {
    Function<String, String> function0 = Function.identity();
    Function<Object, String> function1 = (Function<Object, String>) mock(Function.class, new ViolatedAssumptionAnswer());
    Function<String, String> function2 = function0.andThen((Function<? super String, ? extends String>) function1);
    function0.compose((Function<? super String, ? extends String>) function2);
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Object>((String) null, (Object) null, 0);
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    // Undeclared exception!
    try {
        patriciaTrie0.nextEntryImpl((AbstractPatriciaTrie.TrieEntry<String, Object>) null, abstractPatriciaTrie_TrieEntry1, abstractPatriciaTrie_TrieEntry1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Scans for the next node, starting at the specified point, and using 'previous'
 * as a hint that the last node we returned was 'previous' (so we know not to return
 * it again).  If 'tree' is non-null, this will limit the search to the given tree.
 *
 * The basic premise is that each iteration can follow the following steps:
 *
 * 1) Scan all the way to the left.
 *   a) If we already started from this node last time, proceed to Step 2.
 *   b) If a valid uplink is found, use it.
 *   c) If the result is an empty node (root not set), break the scan.
 *   d) If we already returned the left node, break the scan.
 *
 * 2) Check the right.
 *   a) If we already returned the right node, proceed to Step 3.
 *   b) If it is a valid uplink, use it.
 *   c) Do Step 1 from the right node.
 *
 * 3) Back up through the parents until we encounter find a parent
 *    that we're not the right child of.
 *
 * 4) If there's no right child of that parent, the iteration is finished.
 *    Otherwise continue to Step 5.
 *
 * 5) Check to see if the right child is a valid uplink.
 *    a) If we already returned that child, proceed to Step 6.
 *       Otherwise, use it.
 *
 * 6) If the right child of the parent is the parent itself, we've
 *    already found & returned the end of the Trie, so exit.
 *
 * 7) Do Step 1 on the parent's right child.
 */"
"TrieEntry<K, V> floorEntry(final K key) {
    // TODO: Cleanup so that we don't actually have to add/remove from the
    //       tree.  (We do it here because there are other well-defined
    //       functions to perform the search.)
    final int lengthInBits = lengthInBits(key);
    if (lengthInBits == 0) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        return found;
    }
    final int bitIndex = bitIndex(key, found.key);
    if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
        final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);
        addEntry(added, lengthInBits);
        // must increment because remove will decrement
        incrementSize();
        final TrieEntry<K, V> floor = previousEntry(added);
        removeEntry(added);
        // we didn't really modify it.
        modCount -= 2;
        return floor;
    } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
        return found;
    }
    // we should have exited above.
    throw new IllegalStateException(""invalid lookup: "" + key);
}","public void test08989() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    BiFunction<Object, Object, String> biFunction0 = (BiFunction<Object, Object, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(biFunction0).apply(any(), any());
    patriciaTrie0.put(""ToKey is out of range: "", ""ToKey is out of range: "");
    patriciaTrie0.computeIfPresent(""ToKey is out of range: "", biFunction0);
    patriciaTrie0.floorEntry(""org.apache.commons.collections4.trie.AbstractBitwiseTrie$BasicEntry"");
}","/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or null if there is no such key.
 */"
"@Override
public K previousKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> prevEntry = previousEntry(entry);
        return prevEntry != null ? prevEntry.getKey() : null;
    }
    return null;
}","public void test09090() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""x"", ""?Z"");
    patriciaTrie0.selectKey(""@yV1Q[6*[jT"");
    patriciaTrie0.put("" + "", "",ee)#(<d};,Q57g"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie0.nextKey(""x"");
    patriciaTrie0.getEntry((Object) null);
    patriciaTrie1.ceilingEntry(""left="");
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie1.get((Object) null);
    Integer integer0 = new Integer(116);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>((String) null, integer0, 116);
    patriciaTrie0.incrementSize();
    Integer integer1 = new Integer((-711));
    patriciaTrie2.put(""?Z"", integer1);
    abstractPatriciaTrie_TrieEntry0.setValue(integer0);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie1.isBitSet(""left="", 0, 0);
    patriciaTrie2.addEntry(abstractPatriciaTrie_TrieEntry1, 116);
    // Undeclared exception!
    try {
        patriciaTrie1.previousKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"@Override
public K previousKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> prevEntry = previousEntry(entry);
        return prevEntry != null ? prevEntry.getKey() : null;
    }
    return null;
}","public void test09191() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""tX"", ""?Z"");
    patriciaTrie0.put("" + "", "",ee)(<d};,Q57g"");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(patriciaTrie0);
    patriciaTrie0.nextKey(""tX"");
    patriciaTrie0.getEntry((Object) null);
    patriciaTrie1.ceilingEntry(""left="");
    PatriciaTrie<Integer> patriciaTrie2 = new PatriciaTrie<Integer>();
    patriciaTrie1.get((Object) null);
    Integer integer0 = new Integer(116);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>((String) null, integer0, 116);
    patriciaTrie0.incrementSize();
    Integer integer1 = new Integer((-710));
    patriciaTrie2.put(""?Z"", integer1);
    abstractPatriciaTrie_TrieEntry0.setValue(integer0);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Integer>((String) null, integer1, (-710));
    patriciaTrie1.isBitSet(""left="", 0, 0);
    patriciaTrie2.addEntry(abstractPatriciaTrie_TrieEntry1, 116);
    // Undeclared exception!
    try {
        patriciaTrie1.previousKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {
            break;
        }
        path = current;
        if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    // Make sure the entry is valid for a subtree.
    final TrieEntry<K, V> entry = current.isEmpty() ? path : current;
    // If entry is root, it can't be empty.
    if (entry.isEmpty()) {
        return null;
    }
    final int endIndexInBits = offsetInBits + lengthInBits;
    // if root && length of root is less than length of lookup,
    // there's nothing.
    // (this prevents returning the whole subtree if root has an empty
    //  string and we want to lookup things with ""\0"")
    if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {
        return null;
    }
    // Found key's length-th bit differs from our key
    // which means it cannot be the prefix...
    if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits) != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {
        return null;
    }
    // ... or there are less than 'length' equal bits
    final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));
    if (bitIndex >= 0 && bitIndex < lengthInBits) {
        return null;
    }
    return entry;
}","public void test09292() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.put(""g}+*-#*QOtO7"", ""g}+*-#*QOtO7"");
    patriciaTrie0.put(""MBy%"", ""MBy%"");
    // Undeclared exception!
    try {
        patriciaTrie0.subtree((String) null, 3, 381);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The offsets and lengths must be at Character boundaries
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * Finds the subtree that contains the prefix.
 *
 * This is very similar to getR but with the difference that
 * we stop the lookup if h.bitIndex > lengthInBits.
 */"
"@Override
public K previousKey(final K key) {
    if (key == null) {
        throw new NullPointerException();
    }
    final TrieEntry<K, V> entry = getEntry(key);
    if (entry != null) {
        final TrieEntry<K, V> prevEntry = previousEntry(entry);
        return prevEntry != null ? prevEntry.getKey() : null;
    }
    return null;
}","public void test09393() throws Throwable {
    PatriciaTrie<AbstractMap.SimpleImmutableEntry<Integer, Object>> patriciaTrie0 = new PatriciaTrie<AbstractMap.SimpleImmutableEntry<Integer, Object>>();
    patriciaTrie0.values();
    patriciaTrie0.mapIterator();
    patriciaTrie0.get(""Trie["");
    patriciaTrie0.subtree(""n&dofo?X}-jz"", (-1754), 77);
    HashMap<String, String> hashMap0 = new HashMap<String, String>();
    hashMap0.put(""n&dofo?X}-jz"", """");
    hashMap0.put(""CZz"", ""n&dofo?X}-jz"");
    hashMap0.put(""n&dofo?X}-jz"", ""Trie["");
    hashMap0.put("""", ""Trie["");
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>(hashMap0);
    BiConsumer<String, Object> biConsumer0 = (BiConsumer<String, Object>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
    patriciaTrie1.forEach(biConsumer0);
    hashMap0.put(""n&dofo?X}-jz"", ""n&dofo?X}-jz"");
    hashMap0.put("""", """");
    // Undeclared exception!
    try {
        patriciaTrie1.previousKey((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}",""
"V removeEntry(final TrieEntry<K, V> h) {
    if (h != root) {
        if (h.isInternalNode()) {
            removeInternalEntry(h);
        } else {
            removeExternalEntry(h);
        }
    }
    decrementSize();
    return h.setKeyValue(null, null);
}","public void test09494() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    String string0 = null;
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, String>((String) null, (String) null, 3508);
    abstractPatriciaTrie_TrieEntry0.bitIndex = 3508;
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, String>(""#v1w([p3'!"", (String) null, 2);
    patriciaTrie0.put(""@.&<"", ""#v1w([p3'!"");
    abstractPatriciaTrie_TrieEntry1.bitIndex = 3508;
    abstractPatriciaTrie_TrieEntry0.left = abstractPatriciaTrie_TrieEntry1;
    // Undeclared exception!
    try {
        patriciaTrie0.removeEntry(abstractPatriciaTrie_TrieEntry0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.collections4.trie.AbstractPatriciaTrie"", e);
    }
}","/**
 * Removes a single entry from the {@link Trie}.
 *
 * If we found a Key (Entry h) then figure out if it's
 * an internal (hard to remove) or external Entry (easy
 * to remove)
 */"
"@Override
public boolean containsKey(final Object k) {
    if (k == null) {
        return false;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);
    return !entry.isEmpty() && compareKeys(key, entry.key);
}","public void test09595() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    Collection<String> collection0 = patriciaTrie0.values();
    String string0 = ""org.apache.commons.collections4.trie.KeyAnalyzer"";
    int int0 = (-1298);
    AbstractPatriciaTrie.TrieEntry<String, String> abstractPatriciaTrie_TrieEntry0 = patriciaTrie0.getNearestEntryForKey(""org.apache.commons.collections4.trie.KeyAnalyzer"", (-1298));
    String string1 = ""qZ.OKGoE49.}Rbj}F"";
    patriciaTrie0.put(""org.apache.commons.collections4.trie.KeyAnalyzer"", ""qZ.OKGoE49.}Rbj}F"");
    patriciaTrie0.put("""", """");
    patriciaTrie0.removeEntry(abstractPatriciaTrie_TrieEntry0);
    // Undeclared exception!
    try {
        patriciaTrie0.containsKey(collection0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.collections4.trie.AbstractPatriciaTrie$Values cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}",""
"TrieEntry<K, V> floorEntry(final K key) {
    // TODO: Cleanup so that we don't actually have to add/remove from the
    //       tree.  (We do it here because there are other well-defined
    //       functions to perform the search.)
    final int lengthInBits = lengthInBits(key);
    if (lengthInBits == 0) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    }
    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);
    if (compareKeys(key, found.key)) {
        return found;
    }
    final int bitIndex = bitIndex(key, found.key);
    if (KeyAnalyzer.isValidBitIndex(bitIndex)) {
        final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);
        addEntry(added, lengthInBits);
        // must increment because remove will decrement
        incrementSize();
        final TrieEntry<K, V> floor = previousEntry(added);
        removeEntry(added);
        // we didn't really modify it.
        modCount -= 2;
        return floor;
    } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {
        if (!root.isEmpty()) {
            return root;
        }
        return null;
    } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {
        return found;
    }
    // we should have exited above.
    throw new IllegalStateException(""invalid lookup: "" + key);
}","public void test09696() throws Throwable {
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""@/$<UTx@O"", ""@/$<UTx@O"");
    patriciaTrie0.floorEntry("" is not an internal Entry!"");
}","/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or null if there is no such key.
 */"
"TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {
    if (start.predecessor == null) {
        throw new IllegalArgumentException(""must have come from somewhere!"");
    }
    if (start.predecessor.right == start) {
        if (isValidUplink(start.predecessor.left, start.predecessor)) {
            return start.predecessor.left;
        }
        return followRight(start.predecessor.left);
    }
    TrieEntry<K, V> node = start.predecessor;
    while (node.parent != null && node == node.parent.left) {
        node = node.parent;
    }
    if (node.parent == null) {
        // can be null if we're looking up root.
        return null;
    }
    if (isValidUplink(node.parent.left, node.parent)) {
        if (node.parent.left == root) {
            if (root.isEmpty()) {
                return null;
            }
            return root;
        }
        return node.parent.left;
    }
    return followRight(node.parent.left);
}","public void test09797() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    patriciaTrie0.select("""");
    patriciaTrie0.put(""WW X"", ""WW X"");
    patriciaTrie0.prefixMap("""");
    patriciaTrie0.remove((Object) """");
    Integer integer0 = new Integer(62);
    patriciaTrie0.remove((Object) ""9}F"");
    Object object0 = new Object();
    PatriciaTrie<String> patriciaTrie1 = new PatriciaTrie<String>();
    patriciaTrie1.higherEntry(""#6~pB3"");
    patriciaTrie1.clear();
    patriciaTrie1.entrySet();
    patriciaTrie1.headMap(""9}F"");
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Object>(""zW*SgLZ$UknaPxMw~"", (Object) null, (-797));
    abstractPatriciaTrie_TrieEntry0.bitIndex = 1;
    Integer integer1 = new Integer((-797));
    abstractPatriciaTrie_TrieEntry0.setValue(integer1);
    patriciaTrie0.headMap(""9}F"");
    Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    Map.Entry.comparingByValue((Comparator<? super AbstractMap.SimpleEntry<Object, AbstractMap.SimpleImmutableEntry<String, Object>>>) comparator0);
    Map.Entry.comparingByValue();
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Object>("""", patriciaTrie0, (-3));
    abstractPatriciaTrie_TrieEntry0.equals((Object) null);
    abstractPatriciaTrie_TrieEntry0.parent = abstractPatriciaTrie_TrieEntry1;
    AbstractPatriciaTrie.TrieEntry<String, Object> abstractPatriciaTrie_TrieEntry2 = abstractPatriciaTrie_TrieEntry0.predecessor;
    patriciaTrie0.previousEntry(abstractPatriciaTrie_TrieEntry2);
}","/**
 * Returns the node lexicographically before the given node (or null if none).
 *
 * This follows four simple branches:
 *  - If the uplink that returned us was a right uplink:
 *      - If predecessor's left is a valid uplink from predecessor, return it.
 *      - Else, follow the right path from the predecessor's left.
 *  - If the uplink that returned us was a left uplink:
 *      - Loop back through parents until we encounter a node where
 *        node != node.parent.left.
 *          - If node.parent.left is uplink from node.parent:
 *              - If node.parent.left is not root, return it.
 *              - If it is root & root isEmpty, return null.
 *              - If it is root & root !isEmpty, return root.
 *          - If node.parent.left is not uplink from node.parent:
 *              - Follow right path for first right child from node.parent.left
 *
 * @param start  the start entry
 */"
"@Override
public V remove(final Object k) {
    if (k == null) {
        return null;
    }
    final K key = castKey(k);
    final int lengthInBits = lengthInBits(key);
    TrieEntry<K, V> current = root.left;
    TrieEntry<K, V> path = root;
    while (true) {
        if (current.bitIndex <= path.bitIndex) {
            if (!current.isEmpty() && compareKeys(key, current.key)) {
                return removeEntry(current);
            }
            return null;
        }
        path = current;
        if (!isBitSet(key, current.bitIndex, lengthInBits)) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
}","public void test09898() throws Throwable {
    PatriciaTrie<Object> patriciaTrie0 = new PatriciaTrie<Object>();
    String string0 = """";
    patriciaTrie0.select("""");
    patriciaTrie0.put("""", """");
    String string1 = ""9}F"";
    patriciaTrie0.prefixMap(""9}F"");
    patriciaTrie0.remove((Object) """");
    Integer integer0 = new Integer(62);
    // Undeclared exception!
    try {
        patriciaTrie0.remove((Object) integer0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.Integer cannot be cast to java.lang.String
        //
        verifyException(""org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * @throws ClassCastException if provided key is of an incompatible type
 */"
"static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {
    return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();
}","public void test100100() throws Throwable {
    Integer integer0 = new Integer(1);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry0 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""A{CEcN}(;:+"", integer0, 1);
    AbstractPatriciaTrie.TrieEntry<String, Integer> abstractPatriciaTrie_TrieEntry1 = new AbstractPatriciaTrie.TrieEntry<String, Integer>(""A{CEcN}(;:+"", integer0, 1);
    abstractPatriciaTrie_TrieEntry0.left = abstractPatriciaTrie_TrieEntry1;
    Integer integer1 = new Integer(1);
    abstractPatriciaTrie_TrieEntry0.setKeyValue(""A{CEcN}(;:+"", integer1);
    abstractPatriciaTrie_TrieEntry0.isExternalNode();
    PatriciaTrie<String> patriciaTrie0 = new PatriciaTrie<String>();
    patriciaTrie0.put(""A{CEcN}(;:+"", ""A{CEcN}(;:+"");
    patriciaTrie0.floorEntry(""A{CEcN}(;:+"");
    abstractPatriciaTrie_TrieEntry1.setValue((Integer) null);
    Collection<String> collection0 = patriciaTrie0.values();
    AbstractPatriciaTrie.TrieEntry<Object, Object> abstractPatriciaTrie_TrieEntry2 = new AbstractPatriciaTrie.TrieEntry<Object, Object>(""A{CEcN}(;:+"", abstractPatriciaTrie_TrieEntry1, (-2426));
    abstractPatriciaTrie_TrieEntry2.isExternalNode();
    PatriciaTrie<Object> patriciaTrie1 = new PatriciaTrie<Object>();
    patriciaTrie1.put(""A{CEcN}(;:+"", integer0);
    patriciaTrie1.lowerEntry(""A{CEcN}(;:+"");
    AbstractMap.SimpleImmutableEntry<Object, Object> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<Object, Object>(collection0, integer0);
    patriciaTrie0.get((Object) null);
    AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>> abstractPatriciaTrie_TrieEntry3 = new AbstractPatriciaTrie.TrieEntry<Object, AbstractMap.SimpleImmutableEntry<Object, Object>>(abstractPatriciaTrie_TrieEntry0, abstractMap_SimpleImmutableEntry0, (-1006));
    abstractPatriciaTrie_TrieEntry3.isInternalNode();
    patriciaTrie1.lastKey();
    patriciaTrie1.higherEntry(""QQ~u"");
    AbstractPatriciaTrie.isValidUplink(abstractPatriciaTrie_TrieEntry0, abstractPatriciaTrie_TrieEntry3);
}","/**
 * Returns true if 'next' is a valid uplink coming from 'from'.
 */"
