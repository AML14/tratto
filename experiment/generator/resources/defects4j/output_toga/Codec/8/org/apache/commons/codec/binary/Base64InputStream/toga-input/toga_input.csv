focal_method,test_prefix,docstring
"public boolean markSupported() {
    // not an easy job to support marks
    return false;
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 2142, 2142);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0, true, 2142, byteArray0);
    assertFalse(base64InputStream0.markSupported());
}","/**
 * {@inheritDoc}
 *
 * @return false
 */"
"public int read() throws IOException {
    int r = read(singleByte, 0, 1);
    while (r == 0) {
        r = read(singleByte, 0, 1);
    }
    if (r > 0) {
        return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];
    }
    return -1;
}","public void test012() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    int int0 = base64InputStream0.read();
    assertEquals((-1), int0);
}","/**
 * Reads one <code>byte</code> from this input stream.
 *
 * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
 * @throws IOException
 *             if an I/O error occurs.
 */"
"public boolean markSupported() {
    // not an easy job to support marks
    return false;
}","public void test023() throws Throwable {
    Base64InputStream base64InputStream0 = new Base64InputStream((InputStream) null);
    boolean boolean0 = base64InputStream0.markSupported();
    assertFalse(boolean0);
}","/**
 * {@inheritDoc}
 *
 * @return false
 */"
"public int read() throws IOException {
    int r = read(singleByte, 0, 1);
    while (r == 0) {
        r = read(singleByte, 0, 1);
    }
    if (r > 0) {
        return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];
    }
    return -1;
}","public void test035() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[1] = (byte) (-68);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 1, (byte) 22);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0, true);
    Base64InputStream base64InputStream1 = new Base64InputStream(base64InputStream0);
    int int0 = base64InputStream1.read();
    assertEquals(188, int0);
}","/**
 * Reads one <code>byte</code> from this input stream.
 *
 * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
 * @throws IOException
 *             if an I/O error occurs.
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test046() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0, false);
    // Undeclared exception!
    try {
        base64InputStream0.read((byte[]) null, 256, 256);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64InputStream"", e);
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test057() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        base64InputStream0.read(byteArray0, (-39), (-39));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64InputStream"", e);
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test068() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        base64InputStream0.read(byteArray0, 4, (-1));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64InputStream"", e);
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test079() throws Throwable {
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        base64InputStream0.read(byteArray0, 115, 115);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64InputStream"", e);
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test0810() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        base64InputStream0.read(byteArray0, 5, 5);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64InputStream"", e);
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test0911() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0, true);
    int int0 = base64InputStream0.read(byteArray0, (int) (byte) 0, (int) (byte) 0);
    assertEquals(0, int0);
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
"public int read() throws IOException {
    int r = read(singleByte, 0, 1);
    while (r == 0) {
        r = read(singleByte, 0, 1);
    }
    if (r > 0) {
        return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];
    }
    return -1;
}","public void test1013() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0, true);
    base64InputStream0.read();
    int int0 = base64InputStream0.read();
    assertEquals(65, int0);
}","/**
 * Reads one <code>byte</code> from this input stream.
 *
 * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
 * @throws IOException
 *             if an I/O error occurs.
 */"
"public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","public void test1115() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Base64InputStream base64InputStream0 = new Base64InputStream(byteArrayInputStream0);
    int int0 = base64InputStream0.read(byteArray0, 1, 1);
    assertEquals((-1), int0);
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */"
