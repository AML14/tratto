focal_method,test_prefix,docstring
"int readResults(byte[] b, int bPos, int bAvail) {
    if (buffer != null) {
        int len = Math.min(avail(), bAvail);
        System.arraycopy(buffer, readPos, b, bPos, len);
        readPos += len;
        if (readPos >= pos) {
            buffer = null;
        }
        return len;
    }
    return eof ? -1 : 0;
}","public void test000() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    BigInteger bigInteger0 = new BigInteger(1135, 818, mockRandom0);
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    Base64 base64_0 = new Base64(835);
    base64_0.decode(byteArray0, 2, 773);
    int int0 = base64_0.readResults(byteArray0, 0, 94);
    assertEquals(192, byteArray0.length);
}","/**
 * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
 * bytes. Returns how many bytes were actually extracted.
 *
 * @param b
 *            byte[] array to extract the buffered data into.
 * @param bPos
 *            position in byte[] array to start extraction at.
 * @param bAvail
 *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
 * @return The number of bytes successfully extracted into the provided byte[] array.
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test012() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""]"");
    BigInteger bigInteger0 = Base64.decodeInteger(byteArray0);
    byte[] byteArray1 = Base64.toIntegerBytes(bigInteger0);
    assertEquals(0, byteArray1.length);
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.
 *
 * @param bigInt
 *            <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"public String encodeToString(byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test024() throws Throwable {
    Base64 base64_0 = new Base64(true);
    byte[] byteArray0 = new byte[0];
    String string0 = base64_0.encodeToString(byteArray0);
    assertEquals("""", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A String containing only Base64 character data
 * @since 1.4
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));
}","public void test035() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""org.apache.commons.codec.EncoderException"");
    String string0 = Base64.encodeBase64String(byteArray0);
    assertEquals(""orgapachecommonscodecEncoderExceptio"", string0);
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
"public static String encodeBase64URLSafeString(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));
}","public void test046() throws Throwable {
    byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
    String string0 = Base64.encodeBase64URLSafeString(byteArray0);
    assertEquals(""AAo"", string0);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters
 * @since 1.4
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test057() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64URLSafe((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test068() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""org.apache.commons.codec.EncoderException"");
    byte[] byteArray1 = Base64.encodeBase64(byteArray0);
    assertEquals(36, byteArray1.length);
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test079() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byte[] byteArray1 = Base64.encodeBase64Chunked(byteArray0);
    boolean boolean0 = Base64.isArrayByteBase64(byteArray1);
    assertArrayEquals(new byte[] { (byte) 65, (byte) 65, (byte) 65, (byte) 61, (byte) 0, (byte) 10 }, byteArray1);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test0811() throws Throwable {
    Base64 base64_0 = new Base64(1939, (byte[]) null, true);
    assertTrue(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test0912() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""@mitSsw0vd"");
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\uFFFD+R\uFFFD\r/]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1013() throws Throwable {
    Base64 base64_0 = new Base64(false);
    boolean boolean0 = base64_0.isUrlSafe();
    assertFalse(boolean0);
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1114() throws Throwable {
    Base64 base64_0 = new Base64(true);
    boolean boolean0 = base64_0.isUrlSafe();
    assertTrue(boolean0);
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1215() throws Throwable {
    Base64 base64_0 = new Base64();
    boolean boolean0 = base64_0.hasData();
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"boolean hasData() {
    return this.buffer != null;
}","public void test1216() throws Throwable {
    Base64 base64_0 = new Base64();
    boolean boolean0 = base64_0.hasData();
    assertFalse(boolean0);
}","/**
 * Returns true if this Base64 object has buffered data for reading.
 *
 * @return true if there is Base64 object still available for reading.
 */"
"void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buffer == null || buffer.length - pos < encodeSize) {
            resizeBuffer();
        }
        switch(modulus) {
            case 1:
                buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                    buffer[pos++] = PAD;
                }
                break;
            case 2:
                buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                }
                break;
        }
        // Don't want to append the CRLF two times in a row, so make sure previous
        // character is not from CRLF!
        byte b = lineSeparator[lineSeparator.length - 1];
        if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buffer[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}","public void test1317() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""]"");
    Base64 base64_0 = new Base64(0);
    base64_0.encode(byteArray0, 0, (-1892));
    assertEquals(0, byteArray0.length);
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 3).
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of binary data to base64 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"boolean hasData() {
    return this.buffer != null;
}","public void test1318() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""]"");
    Base64 base64_0 = new Base64(0);
    base64_0.encode(byteArray0, 0, (-1892));
    boolean boolean0 = base64_0.hasData();
    assertTrue(boolean0);
}","/**
 * Returns true if this Base64 object has buffered data for reading.
 *
 * @return true if there is Base64 object still available for reading.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1419() throws Throwable {
    Base64 base64_0 = new Base64();
    int int0 = base64_0.avail();
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"int avail() {
    return buffer != null ? pos - readPos : 0;
}","public void test1420() throws Throwable {
    Base64 base64_0 = new Base64();
    int int0 = base64_0.avail();
    assertEquals(0, int0);
}","/**
 * Returns the amount of buffered data available for reading.
 *
 * @return The amount of buffered data available for reading.
 */"
"int readResults(byte[] b, int bPos, int bAvail) {
    if (buffer != null) {
        int len = Math.min(avail(), bAvail);
        System.arraycopy(buffer, readPos, b, bPos, len);
        readPos += len;
        if (readPos >= pos) {
            buffer = null;
        }
        return len;
    }
    return eof ? -1 : 0;
}","public void test1521() throws Throwable {
    byte[] byteArray0 = new byte[6];
    Base64 base64_0 = new Base64((byte) 4);
    int int0 = base64_0.readResults(byteArray0, 13, (byte) 1);
    assertEquals(0, int0);
}","/**
 * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
 * bytes. Returns how many bytes were actually extracted.
 *
 * @param b
 *            byte[] array to extract the buffered data into.
 * @param bPos
 *            position in byte[] array to start extraction at.
 * @param bAvail
 *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
 * @return The number of bytes successfully extracted into the provided byte[] array.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1522() throws Throwable {
    byte[] byteArray0 = new byte[6];
    Base64 base64_0 = new Base64((byte) 4);
    int int0 = base64_0.readResults(byteArray0, 13, (byte) 1);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public byte[] encode(byte[] pArray) {
    reset();
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    encode(pArray, 0, pArray.length);
    // Notify encoder of EOF.
    encode(pArray, 0, -1);
    byte[] buf = new byte[pos - readPos];
    readResults(buf, 0, buf.length);
    return buf;
}","public void test1623() throws Throwable {
    byte[] byteArray0 = new byte[6];
    Base64 base64_0 = new Base64((byte) 4);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    assertEquals(12, byteArray1.length);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only Base64 character data
 */"
"int readResults(byte[] b, int bPos, int bAvail) {
    if (buffer != null) {
        int len = Math.min(avail(), bAvail);
        System.arraycopy(buffer, readPos, b, bPos, len);
        readPos += len;
        if (readPos >= pos) {
            buffer = null;
        }
        return len;
    }
    return eof ? -1 : 0;
}","public void test1624() throws Throwable {
    byte[] byteArray0 = new byte[6];
    Base64 base64_0 = new Base64((byte) 4);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    int int0 = base64_0.readResults(byteArray0, 13, (byte) 1);
    assertEquals((-1), int0);
}","/**
 * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
 * bytes. Returns how many bytes were actually extracted.
 *
 * @param b
 *            byte[] array to extract the buffered data into.
 * @param bPos
 *            position in byte[] array to start extraction at.
 * @param bAvail
 *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
 * @return The number of bytes successfully extracted into the provided byte[] array.
 */"
"void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buffer == null || buffer.length - pos < encodeSize) {
            resizeBuffer();
        }
        switch(modulus) {
            case 1:
                buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                    buffer[pos++] = PAD;
                }
                break;
            case 2:
                buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                }
                break;
        }
        // Don't want to append the CRLF two times in a row, so make sure previous
        // character is not from CRLF!
        byte b = lineSeparator[lineSeparator.length - 1];
        if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buffer[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}","public void test2025() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""org.apache.commons.codec.EncoderException"");
    Base64 base64_0 = new Base64();
    base64_0.decode(""org.apache.commons.codec.EncoderException"");
    base64_0.encode(byteArray0, (-2840), (-2840));
    assertEquals(27, byteArray0.length);
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 3).
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of binary data to base64 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test2026() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""org.apache.commons.codec.EncoderException"");
    Base64 base64_0 = new Base64();
    base64_0.decode(""org.apache.commons.codec.EncoderException"");
    base64_0.encode(byteArray0, (-2840), (-2840));
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","public void test2127() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byte[] byteArray1 = Base64.encodeBase64(byteArray0, true, true);
    assertArrayEquals(new byte[] { (byte) 65, (byte) 65, (byte) 0, (byte) 10 }, byteArray1);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 * @since 1.4
 */"
"void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buffer == null || buffer.length - pos < encodeSize) {
            resizeBuffer();
        }
        switch(modulus) {
            case 1:
                buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                    buffer[pos++] = PAD;
                }
                break;
            case 2:
                buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                }
                break;
        }
        // Don't want to append the CRLF two times in a row, so make sure previous
        // character is not from CRLF!
        byte b = lineSeparator[lineSeparator.length - 1];
        if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) {
            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buffer[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}","public void test2228() throws Throwable {
    byte[] byteArray0 = new byte[2];
    Base64 base64_0 = new Base64(true);
    base64_0.encode(byteArray0, (int) (byte) (-1), (int) (byte) (-1));
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 3).
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of binary data to base64 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // We're done.
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as base64 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        x = x << 6;
        switch(modulus) {
            case 2:
                x = x << 6;
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}","public void test2329() throws Throwable {
    byte[] byteArray0 = new byte[6];
    Base64 base64_0 = new Base64((byte) 4);
    base64_0.encode(byteArray0);
    base64_0.decode(byteArray0, (-1), 13);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to base64 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"public Object decode(Object pObject) throws DecoderException {
    if (pObject instanceof byte[]) {
        return decode((byte[]) pObject);
    } else if (pObject instanceof String) {
        return decode((String) pObject);
    } else {
        throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
    }
}","public void test2430() throws Throwable {
    Base64 base64_0 = new Base64();
    Object object0 = base64_0.decode((Object) ""org.apache.commons.codec.DecoderException"");
    base64_0.decode(object0);
}","/**
 * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
 *
 * @param pObject
 *            Object to decode
 * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.
 * @throws DecoderException
 *             if the parameter supplied is not of type byte[]
 */"
"// Implementation of the Encoder Interface
/**
 * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
 *
 * @param pObject
 *            Object to encode
 * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
 * @throws EncoderException
 *             if the parameter supplied is not of type byte[]
 */
public Object encode(Object pObject) throws EncoderException {
    if (!(pObject instanceof byte[])) {
        throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
    }
    return encode((byte[]) pObject);
}","public void test2531() throws Throwable {
    Base64 base64_0 = new Base64(true);
    Object object0 = base64_0.decode((Object) ""5~p*VAfA~xR"");
    base64_0.encode(object0);
}",""
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test2632() throws Throwable {
    Base64.decodeBase64(""Parameter supplied to Base64 decode is not a byte[] or a String"");
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test2733() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 126);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public Object decode(Object pObject) throws DecoderException {
    if (pObject instanceof byte[]) {
        return decode((byte[]) pObject);
    } else if (pObject instanceof String) {
        return decode((String) pObject);
    } else {
        throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
    }
}","public void test2834() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    Base64 base64_0 = new Base64(8168);
    try {
        base64_0.decode((Object) bigInteger0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Parameter supplied to Base64 decode is not a byte[] or a String
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
 *
 * @param pObject
 *            Object to decode
 * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.
 * @throws DecoderException
 *             if the parameter supplied is not of type byte[]
 */"
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test2935() throws Throwable {
    Base64.decodeBase64((String) null);
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test3036() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""]"");
    Base64.encodeBase64Chunked(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test3137() throws Throwable {
    byte[] byteArray0 = new byte[2];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true, (int) (byte) (-92));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Input array too big, the output array would be bigger (6) than the specified maxium size of -92
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test3238() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64(""Input array too big, the output array would be bigger ("");
    Base64.discardWhitespace(byteArray0);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test3339() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[1] = (byte) 9;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 9, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test3442() throws Throwable {
    byte[] byteArray0 = Base64.CHUNK_SEPARATOR;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertEquals(2, byteArray1.length);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test3544() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[5] = (byte) 32;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertEquals(5, byteArray1.length);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test3645() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 9;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"// Implementation of the Encoder Interface
/**
 * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
 *
 * @param pObject
 *            Object to encode
 * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
 * @throws EncoderException
 *             if the parameter supplied is not of type byte[]
 */
public Object encode(Object pObject) throws EncoderException {
    if (!(pObject instanceof byte[])) {
        throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
    }
    return encode((byte[]) pObject);
}","public void test3746() throws Throwable {
    Base64 base64_0 = new Base64();
    Object object0 = new Object();
    try {
        base64_0.encode(object0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Parameter supplied to Base64 encode is not a byte[]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test3847() throws Throwable {
    Base64 base64_0 = new Base64(2);
    byte[] byteArray0 = base64_0.encode((byte[]) null);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public byte[] encode(byte[] pArray) {
    reset();
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    encode(pArray, 0, pArray.length);
    // Notify encoder of EOF.
    encode(pArray, 0, -1);
    byte[] buf = new byte[pos - readPos];
    readResults(buf, 0, buf.length);
    return buf;
}","public void test3848() throws Throwable {
    Base64 base64_0 = new Base64(2);
    byte[] byteArray0 = base64_0.encode((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only Base64 character data
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test3949() throws Throwable {
    MockRandom mockRandom0 = new MockRandom();
    BigInteger bigInteger0 = BigInteger.probablePrime(334, mockRandom0);
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    byte[] byteArray1 = Base64.encodeBase64Chunked(byteArray0);
    assertEquals(78, byteArray1.length);
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test4050() throws Throwable {
    // Undeclared exception!
    try {
        Base64.encodeInteger((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // encodeInteger called with null parameter
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
