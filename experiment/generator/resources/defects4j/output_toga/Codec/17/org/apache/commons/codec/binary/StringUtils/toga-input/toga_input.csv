focal_method,test_prefix,docstring
"public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}","public void test000() throws Throwable {
    StringUtils.getBytesUtf16Be((String) null);
    StringUtils.newStringUtf16Le((byte[]) null);
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.newString((byte[]) null, (String) null);
    StringUtils.getBytesUnchecked((String) null, (String) null);
    StringUtils.getBytesUtf16((String) null);
    StringUtils.equals((CharSequence) ""UTF-16BE"", (CharSequence) ""%"");
    StringUtils.getBytesIso8859_1((String) null);
    StringUtils.newStringUtf16Be((byte[]) null);
    StringUtils.getBytesUsAscii((String) null);
    StringUtils.newStringUtf16((byte[]) null);
    StringUtils.equals((CharSequence) ""UTF-16BE"", (CharSequence) null);
    StringUtils.newStringIso8859_1((byte[]) null);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[16];
    StringUtils.newStringUsAscii(byteArray0);
    CharBuffer charBuffer0 = CharBuffer.allocate((byte) 16);
    StringUtils.equals((CharSequence) ""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", (CharSequence) charBuffer0);
    StringUtils.getByteBufferUtf8(""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"");
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static String newString(final byte[] bytes, final String charsetName) {
    if (bytes == null) {
        return null;
    }
    try {
        return new String(bytes, charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","public void test022() throws Throwable {
    byte[] byteArray0 = new byte[1];
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.equals((CharSequence) ""\u0000"", (CharSequence) ""\u0000"");
    byte[] byteArray1 = StringUtils.getBytesUtf8(""\u0000"");
    StringUtils.getBytesUtf16Le(""\u0000"");
    // Undeclared exception!
    try {
        StringUtils.newString(byteArray1, ""\u0000"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // \u0000: java.io.UnsupportedEncodingException: \u0000
        //
        verifyException(""org.apache.commons.codec.binary.StringUtils"", e);
    }
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.
 * <p>
 * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
 * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
 * </p>
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @param charsetName
 *            The name of a required {@link java.nio.charset.Charset}
 * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws IllegalStateException
 *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
 *             required charset name.
 * @see CharEncoding
 * @see String#String(byte[], String)
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test033() throws Throwable {
    StringUtils.equals((CharSequence) null, (CharSequence) ""&"");
    StringUtils.getByteBufferUtf8((String) null);
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}","public void test044() throws Throwable {
    CharBuffer charBuffer0 = CharBuffer.allocate(1308);
    CharBuffer charBuffer1 = CharBuffer.allocate(1308);
    StringUtils.equals((CharSequence) charBuffer0, (CharSequence) charBuffer1);
}","/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */"
"public static String newStringUtf8(final byte[] bytes) {
    return newString(bytes, Charsets.UTF_8);
}","public void test055() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesUnchecked(""+!:l/zq;tD2R"", ""+!:l/zq;tD2R"");
    // Undeclared exception!
    try {
        StringUtils.newStringUtf8(byteArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // +!:l/zq;tD2R: java.io.UnsupportedEncodingException: +!:l/zq;tD2R
        //
        verifyException(""org.apache.commons.codec.binary.StringUtils"", e);
    }
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test066() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.getBytesIso8859_1((String) null);
    StringUtils.getByteBufferUtf8(""TLK .xCO$m"");
    StringUtils.newStringUtf16Le((byte[]) null);
    StringUtils.getByteBufferUtf8("""");
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}","public void test077() throws Throwable {
    StringUtils.newStringUsAscii((byte[]) null);
    StringUtils.equals((CharSequence) null, (CharSequence) null);
}","/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */"
"public static byte[] getBytesUtf16Le(final String string) {
    return getBytes(string, Charsets.UTF_16LE);
}","public void test088() throws Throwable {
    StringUtils.getBytesUtf16Le(""Bvu"");
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
    if (string == null) {
        return null;
    }
    try {
        return string.getBytes(charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","public void test099() throws Throwable {
    StringUtils.getBytesUsAscii("""");
    StringUtils.getBytesUsAscii(""> FNW0uFPtx!%"");
    StringUtils.getBytesUnchecked(""w}?TDcHSVa_C\u0000]"", ""w}?TDcHSVa_C\u0000]"");
}","/**
 * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte
 * array.
 * <p>
 * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which
 * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
 * </p>
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @param charsetName
 *            The name of a required {@link java.nio.charset.Charset}
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws IllegalStateException
 *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
 *             required charset name.
 * @see CharEncoding
 * @see String#getBytes(String)
 */"
"public static byte[] getBytesUsAscii(final String string) {
    return getBytes(string, Charsets.US_ASCII);
}","public void test1010() throws Throwable {
    StringUtils.getBytesUtf8(""qQn<6$94fs6)"");
    StringUtils.getBytesUsAscii(""qQn<6$94fs6)"");
}","/**
 * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static String newStringUtf8(final byte[] bytes) {
    return newString(bytes, Charsets.UTF_8);
}","public void test1111() throws Throwable {
    StringUtils.newStringUtf8((byte[]) null);
    StringUtils.getBytesUsAscii((String) null);
    StringUtils.newStringUtf8((byte[]) null);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static String newStringUsAscii(final byte[] bytes) {
    return newString(bytes, Charsets.US_ASCII);
}","public void test1212() throws Throwable {
    StringUtils.getByteBufferUtf8((String) null);
    StringUtils.getByteBufferUtf8("""");
    StringUtils.equals((CharSequence) """", (CharSequence) null);
    byte[] byteArray0 = StringUtils.getBytesUtf16Be("""");
    StringUtils.equals((CharSequence) null, (CharSequence) null);
    StringUtils.getBytesUtf16Le((String) null);
    StringUtils.newStringUsAscii(byteArray0);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}","public void test1313() throws Throwable {
    byte[] byteArray0 = new byte[0];
    StringUtils.newStringUsAscii(byteArray0);
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.newStringUtf16Be(byteArray0);
    StringUtils.getBytesUtf8(""yI_I6oCIR&s"");
    StringUtils.getByteBufferUtf8(""zG"");
    StringUtils.newStringUtf16Le(byteArray0);
    byte[] byteArray1 = StringUtils.getBytesUtf16("": "");
    StringUtils.newStringUtf16(byteArray1);
    StringUtils.equals((CharSequence) "": "", (CharSequence) ""yI_I6oCIR&s"");
}","/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */"
"public static byte[] getBytesUtf8(final String string) {
    return getBytes(string, Charsets.UTF_8);
}","public void test1414() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesUtf16Be(""US-ASCII"");
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.newStringIso8859_1(byteArray0);
    StringUtils.getBytesUtf8(""3f;Tmok6+f"");
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static String newString(final byte[] bytes, final String charsetName) {
    if (bytes == null) {
        return null;
    }
    try {
        return new String(bytes, charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","public void test1515() throws Throwable {
    byte[] byteArray0 = new byte[0];
    StringUtils.newString(byteArray0, """");
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.
 * <p>
 * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
 * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
 * </p>
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @param charsetName
 *            The name of a required {@link java.nio.charset.Charset}
 * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws IllegalStateException
 *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
 *             required charset name.
 * @see CharEncoding
 * @see String#String(byte[], String)
 */"
"public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}","public void test1616() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-100);
    byteArray0[4] = (byte) 55;
    byteArray0[5] = (byte) (-1);
    byteArray0[6] = (byte) (-92);
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.getBytesUtf16Le(""29JMm8,&AoRu]*'L#oc"");
    StringUtils.getByteBufferUtf8("""");
    StringUtils.getBytesUtf8(""0%Jd}BE$.w"");
    StringUtils.getBytesUnchecked(""fmYW"", ""0%Jd}BE$.w"");
    byte[] byteArray1 = new byte[4];
    byte byte0 = (byte) 0;
    byteArray1[0] = byte0;
    byte byte1 = (byte) 0;
    byteArray1[1] = byte1;
    byte byte2 = (byte) 92;
    byteArray1[2] = byte2;
    byte byte3 = (byte) 0;
    byteArray1[3] = byte3;
    StringUtils.newStringIso8859_1(byteArray1);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}","public void test1919() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesUtf16Be("""");
    String string0 = ""y22Pi3($^nL:"";
    StringUtils.getBytesIso8859_1(""y22Pi3($^nL:"");
    StringUtils.getBytesUtf16Be("""");
    byte[] byteArray1 = StringUtils.getBytesUtf16Le("""");
    byte[] byteArray2 = StringUtils.getBytesUtf16Be("""");
    StringUtils.newStringUsAscii(byteArray2);
    StringUtils.newStringIso8859_1(byteArray0);
    StringUtils.newStringUtf16(byteArray1);
    StringUtils.getBytesUnchecked(""mvQ'c_y4`a}$l^J"", (String) null);
    String string1 = ""C)IX*%\\&sV4pZ1IE"";
    StringUtils.getBytesUtf8(string1);
    StringUtils.equals((CharSequence) string1, (CharSequence) string0);
}","/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */"
"public static String newString(final byte[] bytes, final String charsetName) {
    if (bytes == null) {
        return null;
    }
    try {
        return new String(bytes, charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","public void test2020() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesUtf16Le(""-?n}t3oZ#S'V4mL]"");
    StringUtils.newStringUtf16(byteArray0);
    StringUtils.newStringUtf8(byteArray0);
    StringUtils stringUtils0 = new StringUtils();
    byte[] byteArray1 = StringUtils.getBytesUsAscii("""");
    byte[] byteArray2 = StringUtils.getBytesUtf16Be(""\u0000-\u0000?\u0000n\u0000}\u0000t\u00003\u0000o\u0000Z\u0000#\u0000S\u0000'\u0000V\u00004\u0000m\u0000L\u0000]\u0000"");
    StringUtils.newStringUtf16Be(byteArray2);
    StringUtils.newStringUtf16Be(byteArray1);
    byte[] byteArray3 = new byte[2];
    byteArray3[0] = (byte) 73;
    byteArray3[1] = (byte) (-58);
    StringUtils.newString(byteArray3, ""\u0000-\u0000?\u0000n\u0000}\u0000t\u00003\u0000o\u0000Z\u0000#\u0000S\u0000'\u0000V\u00004\u0000m\u0000L\u0000]\u0000"");
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.
 * <p>
 * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
 * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
 * </p>
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @param charsetName
 *            The name of a required {@link java.nio.charset.Charset}
 * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws IllegalStateException
 *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
 *             required charset name.
 * @see CharEncoding
 * @see String#String(byte[], String)
 */"
"public static byte[] getBytesUnchecked(final String string, final String charsetName) {
    if (string == null) {
        return null;
    }
    try {
        return string.getBytes(charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","public void test2121() throws Throwable {
    StringUtils.getByteBufferUtf8(""L0<w9n' K%<a ||!-O"");
    StringUtils.newStringUtf16Le((byte[]) null);
    StringUtils.newStringUtf16((byte[]) null);
    StringUtils.getBytesUtf8((String) null);
    StringUtils.newStringUtf8((byte[]) null);
    StringUtils.newStringUtf16((byte[]) null);
    StringUtils.newStringUtf16Le((byte[]) null);
    StringUtils.newStringUtf16Be((byte[]) null);
    StringUtils.getBytesUnchecked(""\""mrWYsn"", ""\""mrWYsn"");
}","/**
 * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte
 * array.
 * <p>
 * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which
 * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
 * </p>
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @param charsetName
 *            The name of a required {@link java.nio.charset.Charset}
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws IllegalStateException
 *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
 *             required charset name.
 * @see CharEncoding
 * @see String#getBytes(String)
 */"
"public static byte[] getBytesUtf8(final String string) {
    return getBytes(string, Charsets.UTF_8);
}","public void test2222() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesIso8859_1("""");
    StringUtils.equals((CharSequence) """", (CharSequence) """");
    String string0 = ""8!,H/6RhUL8L}x"";
    StringUtils.newString(byteArray0, ""8!,H/6RhUL8L}x"");
    // Undeclared exception!
    try {
        StringUtils.getBytesUtf8(string0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8!,H/6RhUL8L}x: java.io.UnsupportedEncodingException: 8!,H/6RhUL8L}x
        //
        verifyException(""org.apache.commons.codec.binary.StringUtils"", e);
    }
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static String newStringUtf16Le(final byte[] bytes) {
    return newString(bytes, Charsets.UTF_16LE);
}","public void test2323() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-1);
    StringUtils.newStringUtf16Le(byteArray0);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static byte[] getBytesUtf8(final String string) {
    return getBytes(string, Charsets.UTF_8);
}","public void test2424() throws Throwable {
    StringUtils.getBytesUnchecked("": "", ""UTF-8"");
    StringUtils.getBytesUtf16("": "");
    StringUtils.getBytesUtf16("": "");
    StringUtils.getBytesUtf8("""");
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static byte[] getBytesUtf8(final String string) {
    return getBytes(string, Charsets.UTF_8);
}","public void test2525() throws Throwable {
    StringUtils.getByteBufferUtf8((String) null);
    byte[] byteArray0 = new byte[0];
    StringUtils.newStringUtf16Be(byteArray0);
    byte[] byteArray1 = StringUtils.getBytesUnchecked("""", ""US-ASCII"");
    StringUtils.newStringUtf8(byteArray1);
    StringUtils.newStringUtf16Le(byteArray1);
    StringUtils.getBytesIso8859_1("""");
    StringUtils.getBytesUtf8(""N"");
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static byte[] getBytesUtf16Le(final String string) {
    return getBytes(string, Charsets.UTF_16LE);
}","public void test2626() throws Throwable {
    StringUtils.getBytesUtf8("""");
    byte[] byteArray0 = StringUtils.getBytesUtf16("""");
    byte[] byteArray1 = StringUtils.getBytesUsAscii((String) null);
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.getBytesUtf16Be("""");
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.getBytesUnchecked("""", (String) null);
    String string0 = ""org.apache.commons.codec.binary.StringUtils"";
    StringUtils.newString(byteArray1, string0);
    String string1 = ""org.apache.commons.codec.Charsets"";
    // Undeclared exception!
    try {
        StringUtils.getBytesUtf16Le(string1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static String newStringUtf16Le(final byte[] bytes) {
    return newString(bytes, Charsets.UTF_16LE);
}","public void test2727() throws Throwable {
    StringUtils.getBytesUsAscii((String) null);
    StringUtils.getBytesUnchecked((String) null, "": "");
    StringUtils.getBytesUtf16("": "");
    StringUtils.getBytesUtf16Be("""");
    StringUtils.newStringUsAscii((byte[]) null);
    StringUtils.newStringUtf16Be((byte[]) null);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 1;
    StringUtils.newStringUtf16Le(byteArray0);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test2828() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 89;
    StringUtils.newStringUtf8(byteArray0);
    StringUtils.getBytesIso8859_1((String) null);
    byte[] byteArray1 = StringUtils.getBytesUtf8(""\u0000Y"");
    StringUtils.getBytesUtf8((String) null);
    StringUtils.getBytesUtf16((String) null);
    StringUtils.getBytesUtf16((String) null);
    StringUtils.newStringIso8859_1(byteArray0);
    StringUtils.newStringUtf16Be(byteArray1);
    StringUtils.getBytesUtf16Le(""Y"");
    StringUtils.newStringUtf16Be(byteArray0);
    StringUtils.equals((CharSequence) ""Y"", (CharSequence) ""Y"");
    StringUtils.getBytesUsAscii(""3hQ\""~ejLg;=`mCF'-$5"");
    StringUtils.getByteBufferUtf8((String) null);
    StringUtils.getBytesUtf8((String) null);
    StringUtils.getBytesUtf16(""l\u0002&}j>4?g+\""<,"");
    StringUtils.newStringUsAscii(byteArray0);
    StringUtils.equals((CharSequence) ""\u0000Y"", (CharSequence) null);
    StringUtils.getByteBufferUtf8(""\u0000Y"");
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test2929() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-93);
    StringUtils.newString(byteArray0, ""UTF-16"");
    StringUtils.getByteBufferUtf8("""");
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static byte[] getBytesUtf16Le(final String string) {
    return getBytes(string, Charsets.UTF_16LE);
}","public void test3030() throws Throwable {
    StringUtils.newString((byte[]) null, ""dzT1_@'Zx4^+oj7)*@n"");
    byte[] byteArray0 = StringUtils.getBytesUtf8(""dzT1_@'Zx4^+oj7)*@n"");
    StringUtils.getBytesUsAscii("""");
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.newString(byteArray0, (String) null);
    String string0 = ""US-ASCII"";
    StringUtils.getBytesUtf16Le(string0);
}","/**
 * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 */"
"public static String newStringUtf16Be(final byte[] bytes) {
    return newString(bytes, Charsets.UTF_16BE);
}","public void test3131() throws Throwable {
    byte[] byteArray0 = StringUtils.getBytesUtf16Be((String) null);
    StringUtils.newStringIso8859_1((byte[]) null);
    // Undeclared exception!
    try {
        StringUtils.newStringUtf16Be(byteArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters
 * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,
 *         or <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test3232() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 79;
    byteArray0[2] = (byte) 45;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 88;
    byteArray0[5] = (byte) 70;
    byteArray0[6] = (byte) 0;
    byteArray0[7] = (byte) 18;
    byteArray0[8] = (byte) (-1);
    StringUtils.newStringIso8859_1(byteArray0);
    StringUtils.newStringUsAscii(byteArray0);
    StringUtils.equals((CharSequence) ""\u0001O-\u0000XF\u0000\u0012\uFFFD"", (CharSequence) ""\u0001O-\u0000XF\u0000\u0012\u00FF"");
    CharBuffer charBuffer0 = CharBuffer.allocate(512);
    StringUtils.equals((CharSequence) ""\u0001O-\u0000XF\u0000\u0012\uFFFD"", (CharSequence) charBuffer0);
    StringUtils.getByteBufferUtf8(""\u0001O-\u0000XF\u0000\u0012\uFFFD"");
    StringUtils.getByteBufferUtf8(""\u0001O-\u0000XF\u0000\u0012\uFFFD"");
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}","public void test3434() throws Throwable {
    CharBuffer charBuffer0 = CharBuffer.allocate(1241);
    charBuffer0.limit(1241);
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0);
    charBuffer1.codePoints();
    charBuffer0.clear();
    StringUtils.equals((CharSequence) charBuffer1, (CharSequence) charBuffer0);
    StringUtils.equals((CharSequence) charBuffer0, (CharSequence) charBuffer1);
    StringUtils.equals((CharSequence) charBuffer1, (CharSequence) charBuffer0);
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-123);
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 1;
    StringUtils.newStringIso8859_1(byteArray0);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */"
"public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, Charsets.UTF_8);
}","public void test3535() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 79;
    byteArray0[2] = (byte) 45;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 88;
    byteArray0[5] = (byte) 70;
    byteArray0[6] = (byte) 0;
    byteArray0[7] = (byte) 18;
    byteArray0[8] = (byte) (-1);
    StringUtils.newStringIso8859_1(byteArray0);
    String string0 = StringUtils.newStringUsAscii(byteArray0);
    StringUtils.equals((CharSequence) ""\u0001O-\u0000XF\u0000\u0012\uFFFD"", (CharSequence) ""\u0001O-\u0000XF\u0000\u0012\u00FF"");
    CharBuffer charBuffer0 = CharBuffer.allocate(512);
    charBuffer0.compact();
    StringUtils.equals((CharSequence) ""\u0001O-\u0000XF\u0000\u0012\uFFFD"", (CharSequence) charBuffer0);
    StringUtils.getByteBufferUtf8(string0);
    StringUtils.getByteBufferUtf8(string0);
    String string1 = """";
    StringUtils.getByteBufferUtf8(string1);
}","/**
 * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
 * array.
 *
 * @param string
 *            the String to encode, may be <code>null</code>
 * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>
 * @throws NullPointerException
 *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @see <a href=""http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @see #getBytesUnchecked(String, String)
 * @since 1.11
 */"
"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
}","public void test3636() throws Throwable {
    byte[] byteArray0 = new byte[9];
    StringUtils.newStringUsAscii(byteArray0);
    CharBuffer charBuffer0 = CharBuffer.allocate((byte) 94);
    StringUtils.equals((CharSequence) ""\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"", (CharSequence) charBuffer0);
}","/**
 * <p>
 * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.
 * </p>
 *
 * <p>
 * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.
 * The comparison is case sensitive.
 * </p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * <p>
 * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see Object#equals(Object)
 * @param cs1
 *            the first CharSequence, may be <code>null</code>
 * @param cs2
 *            the second CharSequence, may be <code>null</code>
 * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>
 * @since 1.10
 */"
