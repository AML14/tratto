focal_method,test_prefix,docstring
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, false, false, 6);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test011() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-458), (byte[]) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test022() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-2005));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test033() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(577);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test044() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-1961));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param pArray
 *            a byte array containing base64 character data
 * @return A BigInteger
 * @since 1.4
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test055() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public Base64() {
    this(false);
}","public void test066() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64();
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 */"
"public static String encodeBase64URLSafeString(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));
}","public void test077() throws Throwable {
    String string0 = Base64.encodeBase64URLSafeString((byte[]) null);
    assertNull(string0);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters
 * @since 1.4
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test088() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
 * <p>
 * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param urlSafe
 *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to
 *            <code>false</code>.
 * @since 1.4
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test099() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64URLSafe((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 * @since 1.4
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test1010() throws Throwable {
    byte[] byteArray0 = new byte[6];
    // Undeclared exception!
    try {
        Base64.encodeBase64URLSafe(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 * @since 1.4
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64String(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test1212() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
 * <p>
 * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param urlSafe
 *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to
 *            <code>false</code>.
 * @since 1.4
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test1313() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64Chunked((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param pArray
 *            a byte array containing base64 character data
 * @return A BigInteger
 * @since 1.4
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test1414() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","public void test1515() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, false, false);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test1616() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, true);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test1717() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test1818() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0, false);
    byte[] byteArray1 = base64_0.decode(byteArray0);
    Base64.encodeBase64(byteArray1);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test1819() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0, false);
    byte[] byteArray1 = base64_0.decode(byteArray0);
    Base64.encodeBase64(byteArray1);
    assertSame(byteArray1, byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test1920() throws Throwable {
    byte[] byteArray0 = new byte[0];
    byte[] byteArray1 = Base64.encodeBase64URLSafe(byteArray0);
    byte[] byteArray2 = Base64.discardWhitespace(byteArray1);
    assertEquals(0, byteArray2.length);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test2022() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-92);
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","public void test2123() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-115);
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 * @since 1.4
 */"
"public static byte[] decodeBase64(byte[] base64Data) {
    return new Base64().decode(base64Data);
}","public void test2224() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeBase64((byte[]) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes Base64 data into octets
 *
 * @param base64Data
 *            Byte array containing Base64 data
 * @return Array containing decoded data.
 */"
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test2325() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeBase64((String) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test2426() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeBase64(""org.apache.commons.codec.binary.Base64"");
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public byte[] encode(byte[] pArray) {
    reset();
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    long len = getEncodeLength(pArray, lineLength, lineSeparator);
    byte[] buf = new byte[(int) len];
    setInitialBuffer(buf, 0, buf.length);
    encode(pArray, 0, pArray.length);
    // Notify encoder of EOF.
    encode(pArray, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (buffer != buf) {
        readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (isUrlSafe() && pos < buf.length) {
        byte[] smallerBuf = new byte[pos];
        System.arraycopy(buf, 0, smallerBuf, 0, pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test2527() throws Throwable {
    byte[] byteArray0 = new byte[4];
    Base64 base64_0 = new Base64(0, byteArray0);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    assertArrayEquals(new byte[] { (byte) 65, (byte) 65, (byte) 65, (byte) 65, (byte) 65, (byte) 65, (byte) 61, (byte) 61 }, byteArray1);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only Base64 character data
 */"
"int avail() {
    return buffer != null ? pos - readPos : 0;
}","public void test2529() throws Throwable {
    byte[] byteArray0 = new byte[4];
    Base64 base64_0 = new Base64(0, byteArray0);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    int int0 = base64_0.avail();
    assertEquals(8, int0);
}","/**
 * Returns the amount of buffered data available for reading.
 *
 * @return The amount of buffered data available for reading.
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test2630() throws Throwable {
    // Undeclared exception!
    try {
        Base64.toIntegerBytes((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.
 *
 * @param bigInt
 *            <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test2731() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
 * <p>
 * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param urlSafe
 *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to
 *            <code>false</code>.
 * @since 1.4
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test2832() throws Throwable {
    // Undeclared exception!
    try {
        Base64.isArrayByteBase64((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test2933() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, (byte[]) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test3034() throws Throwable {
    // Undeclared exception!
    try {
        Base64.discardWhitespace((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public byte[] encode(byte[] pArray) {
    reset();
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    long len = getEncodeLength(pArray, lineLength, lineSeparator);
    byte[] buf = new byte[(int) len];
    setInitialBuffer(buf, 0, buf.length);
    encode(pArray, 0, pArray.length);
    // Notify encoder of EOF.
    encode(pArray, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (buffer != buf) {
        readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (isUrlSafe() && pos < buf.length) {
        byte[] smallerBuf = new byte[pos];
        System.arraycopy(buf, 0, smallerBuf, 0, pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test3135() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64(0, byteArray0, true);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    assertArrayEquals(new byte[] { (byte) 65, (byte) 65 }, byteArray1);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only Base64 character data
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test3236() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, false, (int) (byte) 60);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test3337() throws Throwable {
    byte[] byteArray0 = new byte[0];
    byte[] byteArray1 = Base64.encodeBase64(byteArray0, true, false, 0);
    assertSame(byteArray0, byteArray1);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test3438() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, false, true, (-1365));
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3539() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 108);
    assertTrue(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3640() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 0);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3741() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 127);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3842() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) (-123));
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3943() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 61);
    assertTrue(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4044() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4145() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(1371);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test4246() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0, false);
    base64_0.decode(byteArray0, (-1), (-1177));
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
    if (lineSeparator == null) {
        // disable chunk-separating
        lineLength = 0;
        // this just gets ignored
        lineSeparator = CHUNK_SEPARATOR;
    }
    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
    this.lineSeparator = new byte[lineSeparator.length];
    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    if (lineLength > 0) {
        this.encodeSize = 4 + lineSeparator.length;
    } else {
        this.encodeSize = 4;
    }
    this.decodeSize = this.encodeSize - 1;
    if (containsBase64Byte(lineSeparator)) {
        String sep = StringUtils.newStringUtf8(lineSeparator);
        throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
    }
    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","public void test4347() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 101;
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, byteArray0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param urlSafe
 *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
 *            operations. Decoding seamlessly handles both modes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 * @since 1.4
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test4448() throws Throwable {
    // Undeclared exception!
    try {
        Base64.encodeInteger((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // encodeInteger called with null parameter
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
    if (lineSeparator == null) {
        // disable chunk-separating
        lineLength = 0;
        // this just gets ignored
        lineSeparator = CHUNK_SEPARATOR;
    }
    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
    this.lineSeparator = new byte[lineSeparator.length];
    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    if (lineLength > 0) {
        this.encodeSize = 4 + lineSeparator.length;
    } else {
        this.encodeSize = 4;
    }
    this.decodeSize = this.encodeSize - 1;
    if (containsBase64Byte(lineSeparator)) {
        String sep = StringUtils.newStringUtf8(lineSeparator);
        throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
    }
    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","public void test4549() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-2311), (byte[]) null, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param urlSafe
 *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
 *            operations. Decoding seamlessly handles both modes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4650() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((byte) 11);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","public void test4751() throws Throwable {
    byte[] byteArray0 = new byte[6];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 * @since 1.4
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test4852() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 9;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test4953() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[1] = (byte) 9;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 9, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test5056() throws Throwable {
    byte[] byteArray0 = new byte[2];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, false, (-3936));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Input array too big, the output array would be bigger (6) than the specified maxium size of -3936
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test5157() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeBase64("""");
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test5258() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 32;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test5359() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 73;
    byteArray0[1] = (byte) 123;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public static byte[] decodeBase64(byte[] base64Data) {
    return new Base64().decode(base64Data);
}","public void test5460() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 71;
    byteArray0[4] = (byte) 52;
    // Undeclared exception!
    try {
        Base64.decodeBase64(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes Base64 data into octets
 *
 * @param base64Data
 *            Byte array containing Base64 data
 * @return Array containing decoded data.
 */"
"public String encodeToString(byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test5561() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64(1, byteArray0, true);
    String string0 = base64_0.encodeToString(byteArray0);
    assertEquals(""AA"", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A String containing only Base64 character data
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test5662() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 32;
    Base64.discardWhitespace(byteArray0);
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((byte) 11);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"int readResults(byte[] b, int bPos, int bAvail) {
    if (buffer != null) {
        int len = Math.min(avail(), bAvail);
        if (buffer != b) {
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
        } else {
            // Re-using the original consumer's output array is only
            // allowed for one round.
            buffer = null;
        }
        return len;
    }
    return eof ? -1 : 0;
}","public void test5763() throws Throwable {
    byte[] byteArray0 = new byte[2];
    Base64 base64_0 = new Base64((-746), byteArray0);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    int int0 = base64_0.readResults(byteArray1, (byte) 0, (byte) 0);
    assertArrayEquals(new byte[] { (byte) 65, (byte) 65, (byte) 65, (byte) 61 }, byteArray1);
}","/**
 * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
 * bytes. Returns how many bytes were actually extracted.
 *
 * @param b
 *            byte[] array to extract the buffered data into.
 * @param bPos
 *            position in byte[] array to start extraction at.
 * @param bAvail
 *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
 * @return The number of bytes successfully extracted into the provided byte[] array.
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test5866() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-2045));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test5967() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[5] = (byte) 68;
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(1, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000\u0000\u0000\u0000\u0000D\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test6068() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(90, (byte[]) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test6169() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64Chunked(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test6270() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test6371() throws Throwable {
    byte[] byteArray0 = new byte[0];
    byte[] byteArray1 = Base64.encodeBase64(byteArray0, true);
    byte[] byteArray2 = Base64.encodeBase64URLSafe(byteArray1);
    assertSame(byteArray1, byteArray2);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 * @since 1.4
 */"
"public static String encodeBase64URLSafeString(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));
}","public void test6472() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        Base64.encodeBase64URLSafeString(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters
 * @since 1.4
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","public void test6573() throws Throwable {
    String string0 = Base64.encodeBase64String((byte[]) null);
    assertNull(string0);
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test6674() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    // Undeclared exception!
    try {
        Base64.encodeInteger(bigInteger0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [e\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
