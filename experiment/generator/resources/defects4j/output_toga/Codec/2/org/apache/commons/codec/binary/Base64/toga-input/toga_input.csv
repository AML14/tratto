focal_method,test_prefix,docstring
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[2] = (byte) (-30);
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    // Undeclared exception!
    try {
        Base64.encodeInteger(bigInteger0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param bigInt a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException if null is passed in
 */"
"static byte[] discardNonBase64(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        if (isBase64(data[i])) {
            groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[2] = (byte) 54;
    byte[] byteArray1 = Base64.discardNonBase64(byteArray0);
    assertEquals(1, byteArray1.length);
}","/**
 * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
 * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
 *
 * @param data
 *            The base-64 encoded data to groom
 * @return The data, less non-base64 characters (see RFC 2045).
 */"
"public static byte[] decodeBase64(byte[] base64Data) {
    if (base64Data == null || base64Data.length == 0) {
        return base64Data;
    }
    Base64 b64 = new Base64();
    long len = (base64Data.length * 3) / 4;
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.decode(base64Data, 0, base64Data.length);
    // Notify decoder of EOF.
    b64.decode(base64Data, 0, -1);
    // We have no idea what the line-length was, so we
    // cannot know how much of our array wasn't used.
    byte[] result = new byte[b64.pos];
    b64.readResults(result, 0, result.length);
    return result;
}","public void test023() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[1] = (byte) 123;
    // Undeclared exception!
    try {
        Base64.decodeBase64(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes Base64 data into octets
 *
 * @param base64Data Byte array containing Base64 data
 * @return Array containing decoded data.
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test034() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        Base64.encodeBase64Chunked(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test045() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(1);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test056() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) (-67);
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    // Undeclared exception!
    try {
        Base64.encodeInteger(bigInteger0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param bigInt a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException if null is passed in
 */"
"public Base64() {
    this(false);
}","public void test067() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64();
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Sets state for decoding and encoding.
 * <p>
 * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants can be decoded.
 * </p>
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test078() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    assertEquals(1, byteArray0.length);
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code>
 * without sign bit.
 *
 * @param bigInt <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test089() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    assertEquals(0, byteArray0.length);
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code>
 * without sign bit.
 *
 * @param bigInt <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test0910() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64URLSafe((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.
 * The url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test1011() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    byte[] byteArray1 = Base64.encodeBase64(byteArray0);
    byte[] byteArray2 = Base64.encodeBase64URLSafe(byteArray1);
    assertEquals(0, byteArray2.length);
}","/**
 * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.
 * The url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test1112() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, true);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test1213() throws Throwable {
    byte[] byteArray0 = new byte[0];
    byte[] byteArray1 = Base64.encodeBase64(byteArray0, false);
    assertEquals(0, byteArray1.length);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test1314() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test1415() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(87);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test1516() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertEquals(0, byteArray1.length);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param pArray a byte array containing base64 character data
 * @return A BigInteger
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test1617() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 95;
    byteArray0[1] = (byte) 95;
    byteArray0[2] = (byte) 95;
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param pArray a byte array containing base64 character data
 * @return A BigInteger
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test1718() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 80;
    byteArray0[1] = (byte) 72;
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test1819() throws Throwable {
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test1920() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is
 * supplied.
 *
 * When decoding: all variants can be decoded.
 *
 * @param urlSafe
 *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test2021() throws Throwable {
    // Undeclared exception!
    try {
        Base64.toIntegerBytes((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code>
 * without sign bit.
 *
 * @param bigInt <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test2122() throws Throwable {
    byte[] byteArray0 = new byte[4];
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test2223() throws Throwable {
    // Undeclared exception!
    try {
        Base64.isArrayByteBase64((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
 * Currently the method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
 *         empty; false, otherwise
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test2324() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is
 * supplied.
 *
 * When decoding: all variants can be decoded.
 *
 * @param urlSafe
 *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test2425() throws Throwable {
    // Undeclared exception!
    try {
        Base64.discardWhitespace((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"static byte[] discardNonBase64(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        if (isBase64(data[i])) {
            groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test2526() throws Throwable {
    // Undeclared exception!
    try {
        Base64.discardNonBase64((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
 * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
 *
 * @param data
 *            The base-64 encoded data to groom
 * @return The data, less non-base64 characters (see RFC 2045).
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param pArray a byte array containing base64 character data
 * @return A BigInteger
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test2627() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeInteger((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
    this.lineLength = lineLength;
    this.lineSeparator = new byte[lineSeparator.length];
    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    if (lineLength > 0) {
        this.encodeSize = 4 + lineSeparator.length;
    } else {
        this.encodeSize = 4;
    }
    this.decodeSize = this.encodeSize - 1;
    if (containsBase64Byte(lineSeparator)) {
        String sep;
        try {
            sep = new String(lineSeparator, ""UTF-8"");
        } catch (UnsupportedEncodingException uee) {
            sep = new String(lineSeparator);
        }
        throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
    }
    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","public void test2728() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, (byte[]) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Consumer can use this constructor to choose a different lineLength,
 * lineSeparator, and whether to use URL-SAFE mode when encoding.
 * All forms of data can be decoded.
 * </p><p>
 * Note:  lineLengths that aren't multiples of 4 will still essentially
 * end up being multiples of 4 in the encoded data.
 * </p>
 * @param lineLength    Each line of encoded data will be at most this long
 *                      (rounded up to nearest multiple of 4).  Ignored when decoding.
 *                      If <= 0, then output will not be divided into lines (chunks).
 * @param lineSeparator Each line of encoded data will end with this
 *                      sequence of bytes.
 *                      If lineLength <= 0, then the lineSeparator is not used.
 * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.
 *                      urlSafe is only applied to ""encode"" operations.  Decoding seamlessly
 *                      handles both modes.
 *
 * @throws IllegalArgumentException The provided lineSeparator included
 *                                  some base64 characters.  That's not going to work!
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test2829() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, (byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length and line separator when encoding. All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored
 *            when decoding. If <= 0, then output will not be divided into lines (chunks).
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 */"
"public static byte[] decodeBase64(byte[] base64Data) {
    if (base64Data == null || base64Data.length == 0) {
        return base64Data;
    }
    Base64 b64 = new Base64();
    long len = (base64Data.length * 3) / 4;
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.decode(base64Data, 0, base64Data.length);
    // Notify decoder of EOF.
    b64.decode(base64Data, 0, -1);
    // We have no idea what the line-length was, so we
    // cannot know how much of our array wasn't used.
    byte[] result = new byte[b64.pos];
    b64.readResults(result, 0, result.length);
    return result;
}","public void test2930() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    byte[] byteArray1 = Base64.decodeBase64(byteArray0);
    assertSame(byteArray1, byteArray0);
}","/**
 * Decodes Base64 data into octets
 *
 * @param base64Data Byte array containing Base64 data
 * @return Array containing decoded data.
 */"
"public static byte[] decodeBase64(byte[] base64Data) {
    if (base64Data == null || base64Data.length == 0) {
        return base64Data;
    }
    Base64 b64 = new Base64();
    long len = (base64Data.length * 3) / 4;
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.decode(base64Data, 0, base64Data.length);
    // Notify decoder of EOF.
    b64.decode(base64Data, 0, -1);
    // We have no idea what the line-length was, so we
    // cannot know how much of our array wasn't used.
    byte[] result = new byte[b64.pos];
    b64.readResults(result, 0, result.length);
    return result;
}","public void test3031() throws Throwable {
    byte[] byteArray0 = Base64.decodeBase64((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Decodes Base64 data into octets
 *
 * @param base64Data Byte array containing Base64 data
 * @return Array containing decoded data.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test3132() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test3233() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, false, false);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test3334() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    byte[] byteArray1 = Base64.encodeBase64(byteArray0, false, false);
    assertEquals(0, byteArray1.length);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3435() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 117);
    assertTrue(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3536() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) (-63));
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3637() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 123);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3738() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 4);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test3839() throws Throwable {
    byte[] byteArray0 = new byte[7];
    Base64 base64_0 = new Base64((-160), byteArray0, true);
    base64_0.encode(byteArray0, (int) (byte) 0, (int) (byte) 1);
    base64_0.decode(byteArray0, (int) (byte) 102, (-160));
    assertTrue(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test3940() throws Throwable {
    byte[] byteArray0 = new byte[7];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public Base64(boolean urlSafe) {
    this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test4041() throws Throwable {
    byte[] byteArray0 = new byte[26];
    byteArray0[4] = (byte) (-10);
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is
 * supplied.
 *
 * When decoding: all variants can be decoded.
 *
 * @param urlSafe
 *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.
 */"
"void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buf == null || buf.length - pos < decodeSize) {
            resizeBuf();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // WE'RE DONE!!!!
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buf[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as base64 decoder is concerned:  actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {
        x = x << 6;
        switch(modulus) {
            case 2:
                x = x << 6;
                buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}","public void test4142() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 124;
    Base64 base64_0 = new Base64((-160), byteArray0, true);
    // Undeclared exception!
    try {
        base64_0.decode(byteArray0, 0, (int) (byte) 124);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 7
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes.
 * Should be called at least twice:  once with the data to decode, and once
 * with inAvail set to ""-1"" to alert decoder that EOF has been reached.
 * The ""-1"" call is not necessary when decoding, but it doesn't hurt, either.
 * </p><p>
 * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)
 * data is handled, since CR and LF are silently ignored, but has implications
 * for other bytes, too.  This method subscribes to the garbage-in, garbage-out
 * philosophy:  it will not check the provided data for validity.
 * </p><p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations,
 * and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in byte[] array of ascii data to base64 decode.
 * @param inPos Position to start reading data from.
 * @param inAvail Amount of bytes available from input for encoding.
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4243() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(234);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test4344() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64((-2), byteArray0, true);
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4445() throws Throwable {
    byte[] byteArray0 = new byte[2];
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((byte) 0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test4546() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test4647() throws Throwable {
    byte[] byteArray0 = new byte[3];
    Base64 base64_0 = new Base64(2445, byteArray0, true);
    boolean boolean0 = base64_0.isUrlSafe();
    assertTrue(boolean0);
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test4748() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(1471);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test4849() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0, false);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test4950() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, false, false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test5051() throws Throwable {
    byte[] byteArray0 = new byte[3];
    Base64 base64_0 = new Base64((byte) 0, byteArray0);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test5152() throws Throwable {
    // Undeclared exception!
    try {
        Base64.encodeInteger((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // encodeInteger called with null parameter
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param bigInt a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException if null is passed in
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test5253() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 32;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
 * Currently the method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
 *         empty; false, otherwise
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test5354() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 9;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
 * Currently the method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
 *         empty; false, otherwise
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test5455() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[1] = (byte) 32;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertEquals(2, byteArray1.length);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test5558() throws Throwable {
    byte[] byteArray0 = new byte[2];
    // Undeclared exception!
    try {
        Base64.encodeBase64Chunked(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test5659() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[3] = (byte) 9;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 9, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test5762() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-46));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    long len = (binaryData.length * 4) / 3;
    long mod = len % 4;
    if (mod != 0) {
        len += 4 - mod;
    }
    if (isChunked) {
        len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
    }
    if (len > Integer.MAX_VALUE) {
        throw new IllegalArgumentException(""Input array too big, output array would be bigger than Integer.MAX_VALUE="" + Integer.MAX_VALUE);
    }
    byte[] buf = new byte[(int) len];
    b64.setInitialBuffer(buf, 0, buf.length);
    b64.encode(binaryData, 0, binaryData.length);
    // Notify encoder of EOF.
    b64.encode(binaryData, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (b64.buf != buf) {
        b64.readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (urlSafe && b64.pos < buf.length) {
        byte[] smallerBuf = new byte[b64.pos];
        System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test5863() throws Throwable {
    byte[] byteArray0 = new byte[7];
    Base64 base64_0 = new Base64((-160), byteArray0, true);
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test5964() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64Chunked((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test6065() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(97);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test6166() throws Throwable {
    byte[] byteArray0 = new byte[26];
    // Undeclared exception!
    try {
        Base64.encodeBase64Chunked(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"static byte[] discardNonBase64(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        if (isBase64(data[i])) {
            groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test6267() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[3] = (byte) 127;
    byte[] byteArray1 = Base64.discardNonBase64(byteArray0);
    assertEquals(0, byteArray1.length);
}","/**
 * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - ""Any
 * characters outside of the base64 alphabet are to be ignored in base64 encoded data.""
 *
 * @param data
 *            The base-64 encoded data to groom
 * @return The data, less non-base64 characters (see RFC 2045).
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto
 * standards such as W3C's XML-Signature
 *
 * @param pArray a byte array containing base64 character data
 * @return A BigInteger
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test6368() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[4] = (byte) 105;
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test6469() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    Base64.encodeInteger(bigInteger0);
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(2247);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test6570() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test6671() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-3580));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If
 *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test6772() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[6] = (byte) 101;
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(716, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000\u0000\u0000\u0000\u0000\u0000e\u0000\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Sets the line length and line separator when encoding. All forms of data can be decoded.
 * </p>
 * <p>
 * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded
 * data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored
 *            when decoding. If <= 0, then output will not be divided into lines (chunks).
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test6873() throws Throwable {
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test6974() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64URLSafe(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [6\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.
 * The url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters
 */"
