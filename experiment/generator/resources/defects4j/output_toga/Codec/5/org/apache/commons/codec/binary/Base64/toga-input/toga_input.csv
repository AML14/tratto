focal_method,test_prefix,docstring
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 127;
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertFalse(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
    if (lineSeparator == null) {
        // disable chunk-separating
        lineLength = 0;
        // this just gets ignored
        lineSeparator = CHUNK_SEPARATOR;
    }
    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
    this.lineSeparator = new byte[lineSeparator.length];
    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    if (lineLength > 0) {
        this.encodeSize = 4 + lineSeparator.length;
    } else {
        this.encodeSize = 4;
    }
    this.decodeSize = this.encodeSize - 1;
    if (containsBase64Byte(lineSeparator)) {
        String sep = StringUtils.newStringUtf8(lineSeparator);
        throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
    }
    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[2] = (byte) 61;
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(0, byteArray0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000\u0000=\u0000\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param urlSafe
 *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
 *            operations. Decoding seamlessly handles both modes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 * @since 1.4
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test022() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.encodeInteger(bigInteger0);
    assertEquals(0, byteArray0.length);
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
"static byte[] toIntegerBytes(BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = ((bitlen + 7) >> 3) << 3;
    byte[] bigBytes = bigInt.toByteArray();
    if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if ((bigInt.bitLength() % 8) == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    int startDst = bitlen / 8 - len;
    byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","public void test033() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    assertEquals(0, byteArray0.length);
}","/**
 * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.
 *
 * @param bigInt
 *            <code>BigInteger</code> to be converted
 * @return a byte array representation of the BigInteger parameter
 */"
"public static String encodeBase64URLSafeString(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));
}","public void test034() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    String string0 = Base64.encodeBase64URLSafeString(byteArray0);
    assertEquals("""", string0);
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters
 * @since 1.4
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","public void test045() throws Throwable {
    String string0 = Base64.encodeBase64String((byte[]) null);
    assertNull(string0);
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test056() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"public static byte[] encodeBase64URLSafe(byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","public void test067() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    byte[] byteArray1 = base64_0.decode(""Parameter supplied to Base64 encode is not a byte[]"");
    // Undeclared exception!
    try {
        Base64.encodeBase64URLSafe(byteArray1);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 * @since 1.4
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","public void test078() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64String(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
"public static byte[] encodeBase64Chunked(byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","public void test089() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64Chunked(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
 *
 * @param binaryData
 *            binary data to encode
 * @return Base64 characters chunked in 76 character blocks
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","public void test0910() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, false, false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","public void test1011() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
 */"
"// Implementation of the Encoder Interface
/**
 * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
 *
 * @param pObject
 *            Object to encode
 * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
 * @throws EncoderException
 *             if the parameter supplied is not of type byte[]
 */
public Object encode(Object pObject) throws EncoderException {
    if (!(pObject instanceof byte[])) {
        throw new EncoderException(""Parameter supplied to Base64 encode is not a byte[]"");
    }
    return encode((byte[]) pObject);
}","public void test1112() throws Throwable {
    byte[] byteArray0 = new byte[7];
    Base64 base64_0 = new Base64((byte) (-100), byteArray0);
    try {
        base64_0.encode((Object) ""vQ-VN{ ujU/"");
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Parameter supplied to Base64 encode is not a byte[]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public static byte[] decodeBase64(String base64String) {
    return new Base64().decode(base64String);
}","public void test1213() throws Throwable {
    // Undeclared exception!
    try {
        Base64.decodeBase64(""'RAcJ"");
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes a Base64 String into octets
 *
 * @param base64String
 *            String containing Base64 data
 * @return Array containing decoded data.
 * @since 1.4
 */"
"public Object decode(Object pObject) throws DecoderException {
    if (pObject instanceof byte[]) {
        return decode((byte[]) pObject);
    } else if (pObject instanceof String) {
        return decode((String) pObject);
    } else {
        throw new DecoderException(""Parameter supplied to Base64 decode is not a byte[] or a String"");
    }
}","public void test1314() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    BigInteger bigInteger0 = BigInteger.ZERO;
    try {
        base64_0.decode((Object) bigInteger0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Parameter supplied to Base64 decode is not a byte[] or a String
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
 * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
 *
 * @param pObject
 *            Object to decode
 * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.
 * @throws DecoderException
 *             if the parameter supplied is not of type byte[]
 */"
"public Base64(boolean urlSafe) {
    this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","public void test1415() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(false);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
 * <p>
 * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param urlSafe
 *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to
 *            <code>false</code>.
 * @since 1.4
 */"
"public Base64(int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","public void test1516() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-1));
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @since 1.4
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test1617() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 3;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertNotSame(byteArray1, byteArray0);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test1720() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray0, false, true, 1509);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public static boolean isArrayByteBase64(byte[] arrayOctet) {
    for (int i = 0; i < arrayOctet.length; i++) {
        if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
            return false;
        }
    }
    return true;
}","public void test1821() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    boolean boolean0 = Base64.isArrayByteBase64(byteArray0);
    assertTrue(boolean0);
}","/**
 * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
 * method treats whitespace as valid.
 *
 * @param arrayOctet
 *            byte array to test
 * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
 *         false, otherwise
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test1922() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 0);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test2023() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) (-100));
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"int readResults(byte[] b, int bPos, int bAvail) {
    if (buffer != null) {
        int len = Math.min(avail(), bAvail);
        if (buffer != b) {
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
        } else {
            // Re-using the original consumer's output array is only
            // allowed for one round.
            buffer = null;
        }
        return len;
    }
    return eof ? -1 : 0;
}","public void test2124() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64((-1142), byteArray0, true);
    base64_0.decode(byteArray0, (int) (byte) 0, 1);
    // Undeclared exception!
    try {
        base64_0.readResults((byte[]) null, (-209), (-1142));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
 * bytes. Returns how many bytes were actually extracted.
 *
 * @param b
 *            byte[] array to extract the buffered data into.
 * @param bPos
 *            position in byte[] array to start extraction at.
 * @param bAvail
 *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
 * @return The number of bytes successfully extracted into the provided byte[] array.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test2225() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    byte[] byteArray0 = Base64.toIntegerBytes(bigInteger0);
    Base64 base64_0 = new Base64(0, byteArray0, false);
    boolean boolean0 = base64_0.isUrlSafe();
    assertEquals(0, byteArray0.length);
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
    if (lineSeparator == null) {
        // disable chunk-separating
        lineLength = 0;
        // this just gets ignored
        lineSeparator = CHUNK_SEPARATOR;
    }
    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
    this.lineSeparator = new byte[lineSeparator.length];
    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    if (lineLength > 0) {
        this.encodeSize = 4 + lineSeparator.length;
    } else {
        this.encodeSize = 4;
    }
    this.decodeSize = this.encodeSize - 1;
    if (containsBase64Byte(lineSeparator)) {
        String sep = StringUtils.newStringUtf8(lineSeparator);
        throw new IllegalArgumentException(""lineSeperator must not contain base64 characters: ["" + sep + ""]"");
    }
    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","public void test2327() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64(87, (byte[]) null, true);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param urlSafe
 *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
 *            operations. Decoding seamlessly handles both modes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some base64 characters. That's not going to work!
 * @since 1.4
 */"
"// Implementation of integer encoding used for crypto
/**
 * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param pArray
 *            a byte array containing base64 character data
 * @return A BigInteger
 * @since 1.4
 */
public static BigInteger decodeInteger(byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","public void test2428() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        Base64.decodeInteger(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}",""
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test2529() throws Throwable {
    // Undeclared exception!
    try {
        Base64.encodeInteger((BigInteger) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // encodeInteger called with null parameter
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
"public static byte[] encodeInteger(BigInteger bigInt) {
    if (bigInt == null) {
        throw new NullPointerException(""encodeInteger called with null parameter"");
    }
    return encodeBase64(toIntegerBytes(bigInt), false);
}","public void test2630() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    // Undeclared exception!
    try {
        Base64.encodeInteger(bigInteger0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
 *
 * @param bigInt
 *            a BigInteger
 * @return A byte array containing base64 character data
 * @throws NullPointerException
 *             if null is passed in
 * @since 1.4
 */"
"public String encodeToString(byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test2731() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64((-1142), byteArray0, true);
    String string0 = base64_0.encodeToString(byteArray0);
    assertEquals(""AA"", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A String containing only Base64 character data
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test2832() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    String string0 = base64_0.encodeToString(byteArray0);
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public String encodeToString(byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test2833() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    String string0 = base64_0.encodeToString(byteArray0);
    assertEquals("""", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A String containing only Base64 character data
 * @since 1.4
 */"
"static byte[] discardWhitespace(byte[] data) {
    byte[] groomedData = new byte[data.length];
    int bytesCopied = 0;
    for (int i = 0; i < data.length; i++) {
        switch(data[i]) {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                break;
            default:
                groomedData[bytesCopied++] = data[i];
        }
    }
    byte[] packedData = new byte[bytesCopied];
    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
    return packedData;
}","public void test2934() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[6] = (byte) 9;
    byte[] byteArray1 = Base64.discardWhitespace(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray1);
}","/**
 * Discards any whitespace from a base-64 encoded block.
 *
 * @param data
 *            The base-64 encoded data to discard the whitespace from.
 * @return The data, less whitespace (see RFC 2045).
 * @deprecated This method is no longer needed
 */"
"public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","public void test3037() throws Throwable {
    byte[] byteArray0 = Base64.encodeBase64((byte[]) null, true, true, 0);
    assertNull(byteArray0);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test3138() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    base64_0.decode((Object) """");
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public static boolean isBase64(byte octet) {
    return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
}","public void test3239() throws Throwable {
    boolean boolean0 = Base64.isBase64((byte) 123);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
 *
 * @param octet
 *            The value to test
 * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
 * @since 1.4
 */"
"public static String encodeBase64URLSafeString(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));
}","public void test3340() throws Throwable {
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        Base64.encodeBase64URLSafeString(byteArray0);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
 * url-safe variation emits - and _ instead of + and / characters.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters
 * @since 1.4
 */"
"void decode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    if (inAvail < 0) {
        eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        if (buffer == null || buffer.length - pos < decodeSize) {
            resizeBuffer();
        }
        byte b = in[inPos++];
        if (b == PAD) {
            // We're done.
            eof = true;
            break;
        } else {
            if (b >= 0 && b < DECODE_TABLE.length) {
                int result = DECODE_TABLE[b];
                if (result >= 0) {
                    modulus = (++modulus) % 4;
                    x = (x << 6) + result;
                    if (modulus == 0) {
                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                        buffer[pos++] = (byte) (x & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as base64 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (eof && modulus != 0) {
        x = x << 6;
        switch(modulus) {
            case 2:
                x = x << 6;
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                break;
            case 3:
                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                break;
        }
    }
}","public void test3441() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-3431), byteArray0);
    base64_0.decode((Object) ""]"");
    base64_0.decode(byteArray0, (-2294), 0);
    assertEquals(0, byteArray0.length);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to base64 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"public byte[] encode(byte[] pArray) {
    reset();
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    long len = getEncodeLength(pArray, lineLength, lineSeparator);
    byte[] buf = new byte[(int) len];
    setInitialBuffer(buf, 0, buf.length);
    encode(pArray, 0, pArray.length);
    // Notify encoder of EOF.
    encode(pArray, 0, -1);
    // Encoder might have resized, even though it was unnecessary.
    if (buffer != buf) {
        readResults(buf, 0, buf.length);
    }
    // In URL-SAFE mode we skip the padding characters, so sometimes our
    // final length is a bit smaller.
    if (isUrlSafe() && pos < buf.length) {
        byte[] smallerBuf = new byte[pos];
        System.arraycopy(buf, 0, smallerBuf, 0, pos);
        buf = smallerBuf;
    }
    return buf;
}","public void test3542() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-1);
    Base64 base64_0 = new Base64(1, byteArray0);
    byte[] byteArray1 = base64_0.encode(byteArray0);
    assertArrayEquals(new byte[] { (byte) 47, (byte) 119, (byte) 65, (byte) 65 }, byteArray1);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only Base64 character data
 */"
"void encode(byte[] in, int inPos, int inAvail) {
    if (eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        eof = true;
        if (buffer == null || buffer.length - pos < encodeSize) {
            resizeBuffer();
        }
        switch(modulus) {
            case 1:
                buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                    buffer[pos++] = PAD;
                }
                break;
            case 2:
                buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[pos++] = PAD;
                }
                break;
        }
        if (lineLength > 0 && pos > 0) {
            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            modulus = (++modulus) % 3;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            x = (x << 8) + b;
            if (0 == modulus) {
                buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                buffer[pos++] = encodeTable[x & MASK_6BITS];
                currentLinePos += 4;
                if (lineLength > 0 && lineLength <= currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                    pos += lineSeparator.length;
                    currentLinePos = 0;
                }
            }
        }
    }
}","public void test3644() throws Throwable {
    byte[] byteArray0 = new byte[4];
    Base64 base64_0 = new Base64(45, byteArray0);
    // Undeclared exception!
    try {
        base64_0.encode(byteArray0, (int) (byte) 0, 40);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 3).
 * </p>
 * <p>
 * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
 * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
 * </p>
 *
 * @param in
 *            byte[] array of binary data to base64 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test3745() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    base64_0.encode(byteArray0, (-1), (-1790));
    assertFalse(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public boolean isUrlSafe() {
    return this.encodeTable == URL_SAFE_ENCODE_TABLE;
}","public void test3846() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base64 base64_0 = new Base64((-1142), byteArray0, true);
    base64_0.setInitialBuffer((byte[]) null, (-209), 0);
    assertTrue(base64_0.isUrlSafe());
}","/**
 * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
 *
 * @return true if we're in URL-SAFE mode, false otherwise.
 * @since 1.4
 */"
"public static byte[] encodeBase64(byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","public void test3947() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base64 base64_0 = new Base64((-1), byteArray0);
    byte[] byteArray1 = base64_0.decode(""Parameter supplied to Base64 encode is not a byte[]"");
    // Undeclared exception!
    try {
        Base64.encodeBase64(byteArray1);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Encodes binary data using the base64 algorithm but does not chunk the output.
 *
 * @param binaryData
 *            binary data to encode
 * @return byte[] containing Base64 characters in their UTF-8 representation.
 */"
"public Base64(int lineLength, byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","public void test4048() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64((-1918), (byte[]) null);
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length and line separator are given in the constructor, and the encoding table is
 * STANDARD_ENCODE_TABLE.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
 * </p>
 * <p>
 * When decoding all variants are supported.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
 *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             Thrown when the provided lineSeparator included some base64 characters.
 * @since 1.4
 */"
"public Base64() {
    this(0);
}","public void test4149() throws Throwable {
    Base64 base64_0 = null;
    try {
        base64_0 = new Base64();
        //  fail(""Expecting exception: IllegalArgumentException"");
        // Unstable assertion
    } catch (IllegalArgumentException e) {
        //
        // lineSeperator must not contain base64 characters: [\u0000A]
        //
        verifyException(""org.apache.commons.codec.binary.Base64"", e);
    }
}","/**
 * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
 * <p>
 * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.
 * </p>
 *
 * <p>
 * When decoding all variants are supported.
 * </p>
 */"
"public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","public void test4250() throws Throwable {
    byte[] byteArray0 = new byte[0];
    String string0 = Base64.encodeBase64String(byteArray0);
    assertEquals("""", string0);
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */"
