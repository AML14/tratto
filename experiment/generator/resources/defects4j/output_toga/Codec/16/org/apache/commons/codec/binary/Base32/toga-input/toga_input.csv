focal_method,test_prefix,docstring
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {
    this(lineLength, lineSeparator, useHex, PAD_DEFAULT);
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 91;
    Base32 base32_0 = new Base32(7, byteArray0, false);
    assertEquals(64, BaseNCodec.PEM_CHUNK_SIZE);
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof byte[])) {
        throw new EncoderException(""Parameter supplied to Base-N encode is not a byte[]"");
    }
    return encode((byte[]) obj);
}","public void test011() throws Throwable {
    Base32 base32_0 = new Base32(1633);
    Object object0 = base32_0.decode((Object) ""JZ"");
    Object object1 = base32_0.encode(object0);
    assertNotSame(object1, object0);
}","/**
 * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
 * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
 *
 * @param obj
 *            Object to encode
 * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.
 * @throws EncoderException
 *             if the parameter supplied is not of type byte[]
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test022() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) 0);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    baseNCodec_Context0.modulus = (int) (byte) 0;
    baseNCodec_Context0.modulus = (-1098);
    // Undeclared exception!
    try {
        base32_0.encode((byte[]) null, (-1098), (-1803), baseNCodec_Context0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Impossible modulus -1098
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test033() throws Throwable {
    Base32 base32_0 = new Base32((byte) 0);
    byte[] byteArray0 = new byte[2];
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    base32_0.encode(byteArray0, (-457), (int) (byte) 0, baseNCodec_Context0);
    assertEquals(76, BaseNCodec.MIME_CHUNK_SIZE);
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test044() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) 0);
    byte[] byteArray0 = new byte[6];
    byte[] byteArray1 = base32_0.encode(byteArray0);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    baseNCodec_Context0.lbitWorkArea = (long) (-2);
    base32_0.decode(byteArray1, 0, 564, baseNCodec_Context0);
    assertEquals(16, byteArray1.length);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    } else if (obj instanceof String) {
        return decode((String) obj);
    } else {
        throw new DecoderException(""Parameter supplied to Base-N decode is not a byte[] or a String"");
    }
}","public void test055() throws Throwable {
    Base32 base32_0 = new Base32((byte) 0);
    Object object0 = base32_0.decode((Object) ""Context[buffer=null, currentLinePos=0, eof=false, ibitWorkArea=0, lbitWorkArea=0, modulus=0, pos=0, readPos=0]"");
    assertNotNull(object0);
}","/**
 * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
 * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
 *
 * @param obj
 *            Object to decode
 * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String
 *         supplied.
 * @throws DecoderException
 *             if the parameter supplied is not of type byte[]
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test066() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) 0);
    byte[] byteArray0 = new byte[6];
    byte[] byteArray1 = base32_0.encode(byteArray0);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    baseNCodec_Context0.modulus = (-47);
    base32_0.decode(byteArray1, 0, 564, baseNCodec_Context0);
    assertEquals(16, byteArray1.length);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test077() throws Throwable {
    Base32 base32_0 = new Base32();
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        base32_0.encode(byteArray0, 84, (-23), (BaseNCodec.Context) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test088() throws Throwable {
    Base32 base32_0 = new Base32(true);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    // Undeclared exception!
    try {
        base32_0.decode((byte[]) null, 32, 32, baseNCodec_Context0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test099() throws Throwable {
    Base32 base32_0 = new Base32();
    byte[] byteArray0 = new byte[5];
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    // Undeclared exception!
    try {
        base32_0.decode(byteArray0, (-98), 2685, baseNCodec_Context0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -98
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"public Base32(final boolean useHex, final byte pad) {
    this(0, null, useHex, pad);
}","public void test1010() throws Throwable {
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(true, (byte) 67);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // pad must not be in alphabet or whitespace
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 codec used for decoding and encoding.
 * <p>
 * When encoding the line length is 0 (no chunking).
 * </p>
 * @param useHex if {@code true} then use Base32 Hex alphabet
 * @param pad byte used as padding byte.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator) {
    this(lineLength, lineSeparator, false, PAD_DEFAULT);
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[2] = (byte) 70;
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(7, byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeparator must not contain Base32 characters: [\u0000\u0000F]
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work!
 */"
"@Override
public boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","public void test1212() throws Throwable {
    Base32 base32_0 = new Base32();
    boolean boolean0 = base32_0.isInAlphabet((byte) 98);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the {@code octet} is in the Base32 alphabet.
 *
 * @param octet
 *            The value to test
 * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.
 */"
"@Override
public boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","public void test1313() throws Throwable {
    byte[] byteArray0 = new byte[0];
    Base32 base32_0 = new Base32(30, byteArray0, true, (byte) 37);
    boolean boolean0 = base32_0.isInAlphabet((byte) 37);
    assertFalse(boolean0);
}","/**
 * Returns whether or not the {@code octet} is in the Base32 alphabet.
 *
 * @param octet
 *            The value to test
 * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.
 */"
"@Override
public boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","public void test1414() throws Throwable {
    Base32 base32_0 = new Base32((byte) (-102));
    boolean boolean0 = base32_0.isInAlphabet((byte) (-102));
    assertFalse(boolean0);
}","/**
 * Returns whether or not the {@code octet} is in the Base32 alphabet.
 *
 * @param octet
 *            The value to test
 * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.
 */"
"@Override
public boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","public void test1515() throws Throwable {
    Base32 base32_0 = new Base32((byte) 0);
    boolean boolean0 = base32_0.isInAlphabet((byte) 86);
    assertTrue(boolean0);
}","/**
 * Returns whether or not the {@code octet} is in the Base32 alphabet.
 *
 * @param octet
 *            The value to test
 * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, lineSeparator == null ? 0 : lineSeparator.length, pad);
    if (useHex) {
        this.encodeTable = HEX_ENCODE_TABLE;
        this.decodeTable = HEX_DECODE_TABLE;
    } else {
        this.encodeTable = ENCODE_TABLE;
        this.decodeTable = DECODE_TABLE;
    }
    if (lineLength > 0) {
        if (lineSeparator == null) {
            throw new IllegalArgumentException(""lineLength "" + lineLength + "" > 0, but lineSeparator is null"");
        }
        // Must be done after initializing the tables
        if (containsAlphabetOrPad(lineSeparator)) {
            final String sep = StringUtils.newStringUtf8(lineSeparator);
            throw new IllegalArgumentException(""lineSeparator must not contain Base32 characters: ["" + sep + ""]"");
        }
        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
    this.decodeSize = this.encodeSize - 1;
    if (isInAlphabet(pad) || isWhiteSpace(pad)) {
        throw new IllegalArgumentException(""pad must not be in alphabet or whitespace"");
    }
}","public void test1616() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32((-154), byteArray0, true, (byte) 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // pad must not be in alphabet or whitespace
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @param pad byte used as padding byte.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, lineSeparator == null ? 0 : lineSeparator.length, pad);
    if (useHex) {
        this.encodeTable = HEX_ENCODE_TABLE;
        this.decodeTable = HEX_DECODE_TABLE;
    } else {
        this.encodeTable = ENCODE_TABLE;
        this.decodeTable = DECODE_TABLE;
    }
    if (lineLength > 0) {
        if (lineSeparator == null) {
            throw new IllegalArgumentException(""lineLength "" + lineLength + "" > 0, but lineSeparator is null"");
        }
        // Must be done after initializing the tables
        if (containsAlphabetOrPad(lineSeparator)) {
            final String sep = StringUtils.newStringUtf8(lineSeparator);
            throw new IllegalArgumentException(""lineSeparator must not contain Base32 characters: ["" + sep + ""]"");
        }
        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
    this.decodeSize = this.encodeSize - 1;
    if (isInAlphabet(pad) || isWhiteSpace(pad)) {
        throw new IllegalArgumentException(""pad must not be in alphabet or whitespace"");
    }
}","public void test1717() throws Throwable {
    byte[] byteArray0 = new byte[4];
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(69, byteArray0, true, (byte) 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeparator must not contain Base32 characters: [\u0000\u0000\u0000\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @param pad byte used as padding byte.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, lineSeparator == null ? 0 : lineSeparator.length, pad);
    if (useHex) {
        this.encodeTable = HEX_ENCODE_TABLE;
        this.decodeTable = HEX_DECODE_TABLE;
    } else {
        this.encodeTable = ENCODE_TABLE;
        this.decodeTable = DECODE_TABLE;
    }
    if (lineLength > 0) {
        if (lineSeparator == null) {
            throw new IllegalArgumentException(""lineLength "" + lineLength + "" > 0, but lineSeparator is null"");
        }
        // Must be done after initializing the tables
        if (containsAlphabetOrPad(lineSeparator)) {
            final String sep = StringUtils.newStringUtf8(lineSeparator);
            throw new IllegalArgumentException(""lineSeparator must not contain Base32 characters: ["" + sep + ""]"");
        }
        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
    this.decodeSize = this.encodeSize - 1;
    if (isInAlphabet(pad) || isWhiteSpace(pad)) {
        throw new IllegalArgumentException(""pad must not be in alphabet or whitespace"");
    }
}","public void test1818() throws Throwable {
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(393, (byte[]) null, false, (byte) 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineLength 393 > 0, but lineSeparator is null
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @param pad byte used as padding byte.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test1919() throws Throwable {
    Base32 base32_0 = new Base32(0, (byte[]) null, false, (byte) 2);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    base32_0.decode((byte[]) null, 0, 0, baseNCodec_Context0);
    assertEquals(76, BaseNCodec.MIME_CHUNK_SIZE);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"public boolean isInAlphabet(final String basen) {
    return isInAlphabet(StringUtils.getBytesUtf8(basen), true);
}","public void test2020() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base32 base32_0 = new Base32(1603, byteArray0);
    boolean boolean0 = base32_0.isInAlphabet(""R7^Y"");
    assertFalse(boolean0);
}","/**
 * Tests a given String to see if it contains only valid characters within the alphabet.
 * The method treats whitespace and PAD as valid.
 *
 * @param basen String to test
 * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if
 *         the String is empty; <code>false</code>, otherwise
 * @see #isInAlphabet(byte[], boolean)
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test2121() throws Throwable {
    Base32 base32_0 = new Base32(61);
    byte[] byteArray0 = new byte[7];
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    baseNCodec_Context0.currentLinePos = 61;
    // Undeclared exception!
    try {
        base32_0.encode(byteArray0, 0, (int) (byte) 16, baseNCodec_Context0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 7
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"public String encodeAsString(final byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test2222() throws Throwable {
    Base32 base32_0 = new Base32(99);
    byte[] byteArray0 = new byte[4];
    byteArray0[1] = (byte) (-1);
    String string0 = base32_0.encodeAsString(byteArray0);
    assertEquals(""AD7QAAA=\r\n"", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.
 * Uses UTF8 encoding.
 *
 * @param pArray a byte array containing binary data
 * @return String containing only character data in the appropriate alphabet.
 */"
"public String encodeAsString(final byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","public void test2323() throws Throwable {
    Base32 base32_0 = new Base32(99);
    byte[] byteArray0 = new byte[8];
    String string0 = base32_0.encodeAsString(byteArray0);
    assertEquals(""AAAAAAAAAAAAA===\r\n"", string0);
}","/**
 * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.
 * Uses UTF8 encoding.
 *
 * @param pArray a byte array containing binary data
 * @return String containing only character data in the appropriate alphabet.
 */"
"@Override
public byte[] encode(final byte[] pArray) {
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    final Context context = new Context();
    encode(pArray, 0, pArray.length, context);
    // Notify encoder of EOF.
    encode(pArray, 0, EOF, context);
    final byte[] buf = new byte[context.pos - context.readPos];
    readResults(buf, 0, buf.length, context);
    return buf;
}","public void test2424() throws Throwable {
    Base32 base32_0 = new Base32();
    byte[] byteArray0 = new byte[7];
    byte[] byteArray1 = base32_0.encode(byteArray0);
    assertEquals(16, byteArray1.length);
}","/**
 * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.
 *
 * @param pArray
 *            a byte array containing binary data
 * @return A byte array containing only the basen alphabetic character data
 */"
"@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    } else if (obj instanceof String) {
        return decode((String) obj);
    } else {
        throw new DecoderException(""Parameter supplied to Base-N decode is not a byte[] or a String"");
    }
}","public void test2525() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) 0);
    Object object0 = base32_0.decode((Object) ""&Bwo=2rauUB?"");
    assertNotNull(object0);
}","/**
 * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
 * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
 *
 * @param obj
 *            Object to decode
 * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String
 *         supplied.
 * @throws DecoderException
 *             if the parameter supplied is not of type byte[]
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test2626() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) (-117));
    byte[] byteArray0 = base32_0.decode(""%=F)H`0"");
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    base32_0.encode(byteArray0, (int) (byte) (-117), (-11), baseNCodec_Context0);
    assertArrayEquals(new byte[] { (byte) 124 }, byteArray0);
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"@Override
public byte[] decode(final byte[] pArray) {
    if (pArray == null || pArray.length == 0) {
        return pArray;
    }
    final Context context = new Context();
    decode(pArray, 0, pArray.length, context);
    // Notify decoder of EOF.
    decode(pArray, 0, EOF, context);
    final byte[] result = new byte[context.pos];
    readResults(result, 0, result.length, context);
    return result;
}","public void test2728() throws Throwable {
    Base32 base32_0 = new Base32(99);
    byte[] byteArray0 = new byte[4];
    byteArray0[1] = (byte) (-1);
    byte[] byteArray1 = base32_0.decode(byteArray0);
    assertEquals(0, byteArray1.length);
}","/**
 * Decodes a byte[] containing characters in the Base-N alphabet.
 *
 * @param pArray
 *            A byte array containing Base-N character data
 * @return a byte array containing binary data
 */"
"@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 =  7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 =  2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","public void test2829() throws Throwable {
    Base32 base32_0 = new Base32(true, (byte) 0);
    byte[] byteArray0 = new byte[6];
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    base32_0.decode(byteArray0, 0, 76, baseNCodec_Context0);
    base32_0.encode(byteArray0, 0, (int) (byte) 0, baseNCodec_Context0);
    assertEquals(6, byteArray0.length);
}","/**
 * <p>
 * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
 * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last
 * remaining bytes (if not multiple of 5).
 * </p>
 *
 * @param in
 *            byte[] array of binary data to Base32 encode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test2930() throws Throwable {
    Base32 base32_0 = new Base32(340);
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    byte[] byteArray0 = new byte[23];
    base32_0.encode(byteArray0, 340, (-876), baseNCodec_Context0);
    base32_0.decode(byteArray0, 340, (int) (byte) 53, baseNCodec_Context0);
    assertEquals(23, byteArray0.length);
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"public Base32(final byte pad) {
    this(false, pad);
}","public void test3031() throws Throwable {
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32((byte) 13);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // pad must not be in alphabet or whitespace
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 codec used for decoding and encoding.
 * <p>
 * When encoding the line length is 0 (no chunking).
 * </p>
 * @param pad byte used as padding byte.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, lineSeparator == null ? 0 : lineSeparator.length, pad);
    if (useHex) {
        this.encodeTable = HEX_ENCODE_TABLE;
        this.decodeTable = HEX_DECODE_TABLE;
    } else {
        this.encodeTable = ENCODE_TABLE;
        this.decodeTable = DECODE_TABLE;
    }
    if (lineLength > 0) {
        if (lineSeparator == null) {
            throw new IllegalArgumentException(""lineLength "" + lineLength + "" > 0, but lineSeparator is null"");
        }
        // Must be done after initializing the tables
        if (containsAlphabetOrPad(lineSeparator)) {
            final String sep = StringUtils.newStringUtf8(lineSeparator);
            throw new IllegalArgumentException(""lineSeparator must not contain Base32 characters: ["" + sep + ""]"");
        }
        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
    this.decodeSize = this.encodeSize - 1;
    if (isInAlphabet(pad) || isWhiteSpace(pad)) {
        throw new IllegalArgumentException(""pad must not be in alphabet or whitespace"");
    }
}","public void test3132() throws Throwable {
    byte[] byteArray0 = new byte[1];
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(1106, byteArray0, true, (byte) 48);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // pad must not be in alphabet or whitespace
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @param pad byte used as padding byte.
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {
    this(lineLength, lineSeparator, useHex, PAD_DEFAULT);
}","public void test3233() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 73;
    Base32 base32_0 = null;
    try {
        base32_0 = new Base32(1659, byteArray0, true);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // lineSeparator must not contain Base32 characters: [I\u0000]
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
 * <p>
 * When encoding the line length and line separator are given in the constructor.
 * </p>
 * <p>
 * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * </p>
 *
 * @param lineLength
 *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
 *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
 *            decoding.
 * @param lineSeparator
 *            Each line of encoded data will end with this sequence of bytes.
 * @param useHex
 *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
 * @throws IllegalArgumentException
 *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
 *             lineLength &gt; 0 and lineSeparator is null.
 */"
"public byte[] decode(final String pArray) {
    return decode(StringUtils.getBytesUtf8(pArray));
}","public void test3334() throws Throwable {
    Base32 base32_0 = new Base32(true);
    byte[] byteArray0 = base32_0.decode(""UTF-16LE"");
    assertArrayEquals(new byte[] { (byte) (-9), (byte) 94, (byte) 19, (byte) 85 }, byteArray0);
}","/**
 * Decodes a String containing characters in the Base-N alphabet.
 *
 * @param pArray
 *            A String containing Base-N character data
 * @return a byte array containing binary data
 */"
"@Override
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    for (int i = 0; i < inAvail; i++) {
        final byte b = in[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        } else {
            final byte[] buffer = ensureBufferSize(decodeSize, context);
            if (b >= 0 && b < this.decodeTable.length) {
                final int result = this.decodeTable[b];
                if (result >= 0) {
                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                    // collect decoded bytes
                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                    if (context.modulus == 0) {
                        // we can output the 5 bytes
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                    }
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus >= 2) {
        // if modulus < 2, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        //  we ignore partial bytes, i.e. only multiples of 8 count
        switch(context.modulus) {
            case // 10 bits, drop 2 and output one byte
            2:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte
            3:
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 25bits = 3*8 + 1
            5:
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 30bits = 3*8 + 6
            6:
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            case // 35 = 4*8 +3
            7:
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
                buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","public void test3436() throws Throwable {
    Base32 base32_0 = new Base32();
    byte[] byteArray0 = new byte[5];
    BaseNCodec.Context baseNCodec_Context0 = new BaseNCodec.Context();
    baseNCodec_Context0.modulus = 76;
    // Undeclared exception!
    try {
        base32_0.decode(byteArray0, (-20), (-20), baseNCodec_Context0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Impossible modulus 76
        //
        verifyException(""org.apache.commons.codec.binary.Base32"", e);
    }
}","/**
 * <p>
 * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
 * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
 * call is not necessary when decoding, but it doesn't hurt, either.
 * </p>
 * <p>
 * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
 * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
 * garbage-out philosophy: it will not check the provided data for validity.
 * </p>
 *
 * @param in
 *            byte[] array of ascii data to Base32 decode.
 * @param inPos
 *            Position to start reading data from.
 * @param inAvail
 *            Amount of bytes available from input for encoding.
 * @param context the context to be used
 *
 * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
 */"
"public byte[] decode(final String pArray) {
    return decode(StringUtils.getBytesUtf8(pArray));
}","public void test3537() throws Throwable {
    Base32 base32_0 = new Base32(340);
    byte[] byteArray0 = base32_0.decode(""8eTUas[3] BT"");
    assertArrayEquals(new byte[] { (byte) (-99), (byte) 54, (byte) 25 }, byteArray0);
}","/**
 * Decodes a String containing characters in the Base-N alphabet.
 *
 * @param pArray
 *            A String containing Base-N character data
 * @return a byte array containing binary data
 */"
"public byte[] decode(final String pArray) {
    return decode(StringUtils.getBytesUtf8(pArray));
}","public void test3639() throws Throwable {
    Base32 base32_0 = new Base32((byte) (-7));
    byte[] byteArray0 = base32_0.decode(""H$_VMWBde]]oUy"");
    assertArrayEquals(new byte[] { (byte) 61, (byte) 89, (byte) 96 }, byteArray0);
}","/**
 * Decodes a String containing characters in the Base-N alphabet.
 *
 * @param pArray
 *            A String containing Base-N character data
 * @return a byte array containing binary data
 */"
