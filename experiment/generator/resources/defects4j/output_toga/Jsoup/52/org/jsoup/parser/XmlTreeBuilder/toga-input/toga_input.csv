focal_method,test_prefix,docstring
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test00() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.Doctype token_Doctype0 = new Token.Doctype();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.process(token_Doctype0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"public final int childNodeSize() {
    return childNodes.size();
}","public void test22() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse("" wZJ<D[x>@%c/mV"", "" wZJ<D[x>@%c/mV"");
    assertEquals(2, document0.childNodeSize());
}","/**
 * Get the number of child nodes that this node holds.
 * @return the number of child nodes that this node holds.
 */"
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test23() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse("" wZJ<D[x>@%c/mV"", "" wZJ<D[x>@%c/mV"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""#document"");
    assertTrue(boolean0);
}",""
"public final int childNodeSize() {
    return childNodes.size();
}","public void test34() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""D:tHN<<wl@i/>-x(("", ""#doc,meGt"");
    assertEquals(3, document0.childNodeSize());
}","/**
 * Get the number of child nodes that this node holds.
 * @return the number of child nodes that this node holds.
 */"
"public String baseUri() {
    return baseUri;
}","public void test35() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""D:tHN<<wl@i/>-x(("", ""#doc,meGt"");
    assertEquals(""#doc,meGt"", document0.baseUri());
}","/**
 *     Get the base URI of this node.
 *     @return base URI
 */"
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test46() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parseFragment(""u.DPmaXvo'P"", ""u.DPmaXvo'P"", (ParseErrorList) null);
    Attributes attributes0 = new Attributes();
    Token.StartTag token_StartTag0 = new Token.StartTag();
    Token.StartTag token_StartTag1 = token_StartTag0.nameAttr(""u.DPmaXvo'P"", attributes0);
    token_StartTag1.selfClosing = true;
    token_StartTag1.nameAttr(""form"", attributes0);
    boolean boolean0 = xmlTreeBuilder0.process(token_StartTag1);
    assertTrue(boolean0);
}",""
"public String tagName() {
    return tag.getName();
}","public void test57() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""<!--"", ""<!--"");
    assertEquals(""#root"", document0.tagName());
}","/**
 * Get the name of the tag for this element. E.g. {@code div}
 *
 * @return the tag name
 */"
"public boolean updateMetaCharsetElement() {
    return updateMetaCharset;
}","public void test68() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""<!-"", ""<!-"");
    assertFalse(document0.updateMetaCharsetElement());
}","/**
 * Returns whether the element with charset information in this document is
 * updated on changes through {@link #charset(java.nio.charset.Charset)
 * Document.charset(Charset)} or not.
 *
 * @return Returns <tt>true</tt> if the element is updated on charset
 * changes, <tt>false</tt> if not
 */"
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test79() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""@</&DR"", ""@</&DR"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""@</&DR"");
    assertTrue(boolean0);
}",""
"public final int childNodeSize() {
    return childNodes.size();
}","public void test810() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""Q+:H|<?9;"", ""Q+:H|<?9;"");
    assertEquals(2, document0.childNodeSize());
}","/**
 * Get the number of child nodes that this node holds.
 * @return the number of child nodes that this node holds.
 */"
