focal_method,test_prefix,docstring
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test000() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = new Character('W');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test001() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = new Character('W');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertEquals(""#"", characterReader0.toString());
}",""
"void emit(String str) {
    // buffer strings up until last string token found, to emit only one token for a run of character refs etc.
    // does not set isEmitPending; read checks that
    charBuffer.append(str);
}","public void test012() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.emit("";"");
}",""
"void emitDoctypePending() {
    emit(doctypePending);
}","public void test023() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null);
    Token.Doctype token_Doctype0 = new Token.Doctype();
    tokeniser0.doctypePending = token_Doctype0;
    tokeniser0.emitDoctypePending();
}",""
"void emitCommentPending() {
    emit(commentPending);
}","public void test034() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""?O+3%"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.createCommentPending();
    tokeniser0.emitCommentPending();
}",""
"boolean isTrackErrors() {
    return trackErrors;
}","public void test045() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.setTrackErrors(false);
    boolean boolean0 = tokeniser0.isTrackErrors();
    assertFalse(boolean0);
}",""
"boolean isAppropriateEndTagToken() {
    return tagPending.tagName.equals(lastStartTag.tagName);
}","public void test056() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.EndTag token_EndTag0 = new Token.EndTag(""gamma"");
    tokeniser0.tagPending = (Token.Tag) token_EndTag0;
    Token.StartTag token_StartTag0 = new Token.StartTag();
    tokeniser0.emit(token_StartTag0);
    boolean boolean0 = tokeniser0.isAppropriateEndTagToken();
    assertFalse(boolean0);
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test067() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.ScriptDataEndTagName;
    tokeniser0.transition(tokeniserState0);
    // Undeclared exception!
    tokeniser0.read();
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test078() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""&Dg;V@q."");
    characterReader0.unconsume();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.read();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test089() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""mRb9w(\""4xGtwS "");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.DoctypeSystemIdentifier_doubleQuoted;
    tokeniser0.advanceTransition(tokeniserState0);
    // Undeclared exception!
    try {
        tokeniser0.read();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokeniserState$63"", e);
    }
}",""
"void error(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpected character in input"", reader.current(), state, reader.pos()));
}","public void test0910() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""5[H0K"");
    characterReader0.unconsume();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.AfterDoctypeSystemIdentifier;
    // Undeclared exception!
    try {
        tokeniser0.error(tokeniserState0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"void error(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpected character in input"", reader.current(), state, reader.pos()));
}","public void test1011() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null);
    TokeniserState tokeniserState0 = TokeniserState.RawtextEndTagOpen;
    // Undeclared exception!
    try {
        tokeniser0.error(tokeniserState0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void eofError(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpectedly reached end of file (EOF)"", state, reader.pos()));
}","public void test1112() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null);
    TokeniserState tokeniserState0 = TokeniserState.RawtextEndTagOpen;
    // Undeclared exception!
    try {
        tokeniser0.eofError(tokeniserState0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emitTagPending() {
    tagPending.finaliseTag();
    emit(tagPending);
}","public void test1213() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""m>g"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.createTagPending(false);
    tokeniser0.emitTagPending();
    // Undeclared exception!
    try {
        tokeniser0.emitTagPending();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // There is an unread token pending!
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"void emitDoctypePending() {
    emit(doctypePending);
}","public void test1314() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.EndTag token_EndTag0 = new Token.EndTag();
    tokeniser0.emit(token_EndTag0);
    // Undeclared exception!
    try {
        tokeniser0.emitDoctypePending();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // There is an unread token pending!
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"void emitCommentPending() {
    emit(commentPending);
}","public void test1415() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""cM(Y"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.EndTag token_EndTag0 = new Token.EndTag();
    tokeniser0.emit(token_EndTag0);
    // Undeclared exception!
    try {
        tokeniser0.emitCommentPending();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // There is an unread token pending!
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1516() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""8jfmDD"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.emit((Token) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1617() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""]"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.Comment token_Comment0 = new Token.Comment();
    Token.TokenType token_TokenType0 = Token.TokenType.EndTag;
    token_Comment0.type = token_TokenType0;
    // Undeclared exception!
    try {
        tokeniser0.emit(token_Comment0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.jsoup.parser.Token$Comment cannot be cast to org.jsoup.parser.Token$EndTag
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1718() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    characterReader0.unconsume();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = new Character('N');
    // Undeclared exception!
    try {
        tokeniser0.consumeCharacterReference(character0, false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1819() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null);
    Character character0 = Character.valueOf('J');
    // Undeclared exception!
    try {
        tokeniser0.consumeCharacterReference(character0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void advanceTransition(TokeniserState state) {
    reader.advance();
    this.state = state;
}","public void test1920() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null);
    TokeniserState tokeniserState0 = TokeniserState.CharacterReferenceInData;
    // Undeclared exception!
    try {
        tokeniser0.advanceTransition(tokeniserState0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test2021() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.EndTag token_EndTag0 = new Token.EndTag("""");
    tokeniser0.setTrackErrors(false);
    token_EndTag0.appendAttributeName("">On[.OET"");
    token_EndTag0.finaliseTag();
    tokeniser0.emit(token_EndTag0);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2122() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""org.jsoup.parser.Tokeniser"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.setTrackErrors(false);
    tokeniser0.consumeCharacterReference((Character) null, false);
    assertEquals(""g.jsoup.parser.Tokeniser"", characterReader0.toString());
}",""
"void eofError(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpectedly reached end of file (EOF)"", state, reader.pos()));
}","public void test2223() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.Doctype;
    tokeniser0.eofError(tokeniserState0);
}",""
"void error(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpected character in input"", reader.current(), state, reader.pos()));
}","public void test2324() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.Doctype;
    tokeniser0.error(tokeniserState0);
}",""
"void error(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpected character in input"", reader.current(), state, reader.pos()));
}","public void test2425() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.AttributeValue_singleQuoted;
    tokeniser0.setTrackErrors(false);
    tokeniser0.error(tokeniserState0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test2526() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.Tag token_Tag0 = tokeniser0.createTagPending(false);
    tokeniser0.emit(token_Tag0);
    // Undeclared exception!
    try {
        tokeniser0.emit(token_Tag0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // There is an unread token pending!
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2627() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""kcedil"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = new Character('O');
    tokeniser0.consumeCharacterReference(character0, true);
    assertEquals("""", characterReader0.toString());
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2728() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""org.jsoup.parser.Tokeniser"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = Character.valueOf('V');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2829() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""^Xc"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2930() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""^Xc"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = Character.valueOf('^');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test3031() throws Throwable {
    Character character0 = new Character('@');
    CharacterReader characterReader0 = new CharacterReader(""sup1"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError();
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError();
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError();
        return Entities.getCharacterByName(nameRef);
    }
}","public void test3132() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Character character0 = new Character('{');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test3334() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.EndTag token_EndTag0 = new Token.EndTag("""");
    token_EndTag0.appendAttributeName("">On[.OET"");
    token_EndTag0.finaliseTag();
    tokeniser0.emit(token_EndTag0);
}",""
"void emitTagPending() {
    tagPending.finaliseTag();
    emit(tagPending);
}","public void test3435() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""uArr"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.createTagPending(true);
    tokeniser0.emitTagPending();
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test3536() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    Token.StartTag token_StartTag0 = new Token.StartTag(""#"");
    token_StartTag0.selfClosing = true;
    tokeniser0.emit(token_StartTag0);
    Token token0 = tokeniser0.read();
    assertSame(token0, token_StartTag0);
}",""
"TokeniserState getState() {
    return state;
}","public void test3637() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.getState();
}",""
"void createDoctypePending() {
    doctypePending = new Token.Doctype();
}","public void test3738() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""J{ bu^-SqP Wom:Z*E;"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.createDoctypePending();
}",""
"boolean currentNodeInHtmlNS() {
    // todo: implememnt namespaces correctly
    return true;
    // Element currentNode = currentNode();
    // return currentNode != null && currentNode.namespace().equals(""HTML"");
}","public void test3839() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    boolean boolean0 = tokeniser0.currentNodeInHtmlNS();
    assertTrue(boolean0);
}",""
"void eofError(TokeniserState state) {
    if (trackErrors)
        errors.add(new ParseError(""Unexpectedly reached end of file (EOF)"", state, reader.pos()));
}","public void test3940() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.setTrackErrors(false);
    TokeniserState tokeniserState0 = TokeniserState.Comment;
    tokeniser0.eofError(tokeniserState0);
}",""
"void emitCommentPending() {
    emit(commentPending);
}","public void test4041() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""cM(Y"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.emitCommentPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emit(char c) {
    charBuffer.append(c);
}","public void test4142() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.emit('\'');
}",""
"boolean isTrackErrors() {
    return trackErrors;
}","public void test4243() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    boolean boolean0 = tokeniser0.isTrackErrors();
    assertTrue(boolean0);
}",""
"void emitTagPending() {
    tagPending.finaliseTag();
    emit(tagPending);
}","public void test4344() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""m>g"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.emitTagPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test4445() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""&Dg;V@q."");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    TokeniserState tokeniserState0 = TokeniserState.CharacterReferenceInData;
    tokeniser0.transition(tokeniserState0);
    tokeniser0.read();
    assertEquals("""", characterReader0.toString());
}",""
"boolean isAppropriateEndTagToken() {
    return tagPending.tagName.equals(lastStartTag.tagName);
}","public void test4546() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""2$\""4\""!NJW,?j f;"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.isAppropriateEndTagToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void acknowledgeSelfClosingFlag() {
    selfClosingFlagAcknowledged = true;
}","public void test4647() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.acknowledgeSelfClosingFlag();
}",""
"void emitDoctypePending() {
    emit(doctypePending);
}","public void test4748() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    // Undeclared exception!
    try {
        tokeniser0.emitDoctypePending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void createTempBuffer() {
    dataBuffer = new StringBuilder();
}","public void test4849() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""2$\""4\""!NJW,?j f;"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0);
    tokeniser0.createTempBuffer();
}",""
