focal_method,test_prefix,docstring
"public boolean isBlock() {
    return tag.isBlock();
}","public void test000() throws Throwable {
    Parser parser0 = Parser.xmlParser();
    Document document0 = Jsoup.parse("""", """", parser0);
    assertFalse(document0.isBlock());
}","/**
 * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
 * {@code <p> == false}).
 *
 * @return true if block, false if not (and thus inline)
 */"
"public String tagName() {
    return tag.getName();
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Parser parser0 = Parser.htmlParser();
    Document document0 = Jsoup.parse((InputStream) byteArrayInputStream0, (String) null, ""org.jsoup.safety.Whitelist$Protocol"", parser0);
    assertEquals(""#root"", document0.tagName());
}","/**
 * Get the name of the tag for this element. E.g. {@code div}
 *
 * @return the tag name
 */"
"public boolean isBlock() {
    return tag.isBlock();
}","public void test022() throws Throwable {
    File file0 = MockFile.createTempFile(""kBD)ja10p;"", ""fzcm~2`q ^lEDP:#"", (File) null);
    Document document0 = Jsoup.parse(file0, (String) null);
    assertFalse(document0.isBlock());
}","/**
 * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
 * {@code <p> == false}).
 *
 * @return true if block, false if not (and thus inline)
 */"
"public static String clean(String bodyHtml, Whitelist whitelist) {
    return clean(bodyHtml, """", whitelist);
}","public void test033() throws Throwable {
    Whitelist whitelist0 = new Whitelist();
    String string0 = Jsoup.clean("""", whitelist0);
    assertEquals("""", string0);
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    clean.outputSettings(outputSettings);
    return clean.body().html();
}","public void test044() throws Throwable {
    Whitelist whitelist0 = Whitelist.basicWithImages();
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Jsoup.clean("""", """", whitelist0, document_OutputSettings0);
    assertEquals("""", string0);
}","/**
 * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of
 * permitted tags and attributes.
 * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
 * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add
 * structural tags (<code>html, head, body</code> etc) to the whitelist.
 *
 * @param bodyHtml input untrusted HTML (body fragment)
 * @param baseUri URL to resolve relative URLs against
 * @param whitelist white-list of permitted HTML elements
 * @param outputSettings document output settings; use to control pretty-printing and entity escape modes
 * @return safe HTML (body fragment)
 * @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    return clean.body().html();
}","public void test055() throws Throwable {
    Whitelist whitelist0 = Whitelist.none();
    String string0 = Jsoup.clean("""", ""liJ'o%$>WujP"", whitelist0);
    assertEquals("""", string0);
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param baseUri   URL to resolve relative URLs against
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public static Document parseBodyFragment(String bodyHtml, String baseUri) {
    return Parser.parseBodyFragment(bodyHtml, baseUri);
}","public void test066() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parseBodyFragment((String) null, """");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // String input must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.
 *
 *     @param bodyHtml body HTML fragment
 *     @param baseUri  URL to resolve relative URLs against.
 *     @return sane HTML document
 *
 *     @see Document#body()
 */"
"public static Document parseBodyFragment(String bodyHtml) {
    return Parser.parseBodyFragment(bodyHtml, """");
}","public void test077() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parseBodyFragment((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // String input must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.
 *
 *     @param bodyHtml body HTML fragment
 *     @return sane HTML document
 *
 *     @see Document#body()
 */"
"public static Document parse(URL url, int timeoutMillis) throws IOException {
    Connection con = HttpConnection.connect(url);
    con.timeout(timeoutMillis);
    return con.get();
}","public void test088() throws Throwable {
    URL uRL0 = MockURL.getHttpExample();
    try {
        Jsoup.parse(uRL0, 0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // HTTP error fetching URL
        //
        verifyException(""org.jsoup.helper.HttpConnection$Response"", e);
    }
}","/**
 *     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.
 *     <p>
 *     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.
 *
 *     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
 *     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
 *     @return The parsed HTML.
 *
 *     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
 *     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
 *     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
 *     @throws java.net.SocketTimeoutException if the connection times out
 *     @throws IOException if a connection or read error occurs
 *
 *     @see #connect(String)
 */"
"public static Document parse(URL url, int timeoutMillis) throws IOException {
    Connection con = HttpConnection.connect(url);
    con.timeout(timeoutMillis);
    return con.get();
}","public void test099() throws Throwable {
    URL uRL0 = MockURL.getHttpExample();
    URLStreamHandler uRLStreamHandler0 = mock(URLStreamHandler.class, new ViolatedAssumptionAnswer());
    URL uRL1 = MockURL.URL(uRL0, ""9Xg43p9YL{[NQM"", uRLStreamHandler0);
    // Undeclared exception!
    try {
        Jsoup.parse(uRL1, 2211);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.HttpConnection$Response"", e);
    }
}","/**
 *     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.
 *     <p>
 *     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.
 *
 *     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
 *     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
 *     @return The parsed HTML.
 *
 *     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
 *     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
 *     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
 *     @throws java.net.SocketTimeoutException if the connection times out
 *     @throws IOException if a connection or read error occurs
 *
 *     @see #connect(String)
 */"
"public static Document parse(URL url, int timeoutMillis) throws IOException {
    Connection con = HttpConnection.connect(url);
    con.timeout(timeoutMillis);
    return con.get();
}","public void test1010() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse((URL) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URL must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.
 *     <p>
 *     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.
 *
 *     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
 *     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
 *     @return The parsed HTML.
 *
 *     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
 *     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
 *     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
 *     @throws java.net.SocketTimeoutException if the connection times out
 *     @throws IOException if a connection or read error occurs
 *
 *     @see #connect(String)
 */"
"public static Document parse(String html, String baseUri, Parser parser) {
    return parser.parseInput(html, baseUri);
}","public void test1111() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse(""*"", ""*"", (Parser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.Jsoup"", e);
    }
}","/**
 *     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param html    HTML to parse
 *     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
 *     before the HTML declares a {@code <base href>} tag.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 */"
"public static Document parse(String html, String baseUri, Parser parser) {
    return parser.parseInput(html, baseUri);
}","public void test1212() throws Throwable {
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        Jsoup.parse((String) null, ""%1M"", parser0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // String input must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param html    HTML to parse
 *     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
 *     before the HTML declares a {@code <base href>} tag.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 */"
"public static Document parse(String html, String baseUri) {
    return Parser.parse(html, baseUri);
}","public void test1313() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse("""", (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BaseURI must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.
 *
 *     @param html    HTML to parse
 *     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
 *     before the HTML declares a {@code <base href>} tag.
 *     @return sane HTML
 */"
"public static Document parse(String html) {
    return Parser.parse(html, """");
}","public void test1414() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // String input must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a
 *     {@code <base href>} tag.
 *
 *     @param html HTML to parse
 *     @return sane HTML
 *
 *     @see #parse(String, String)
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return DataUtil.load(in, charsetName, baseUri, parser);
}","public void test1515() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
    DataInputStream dataInputStream0 = new DataInputStream(pushbackInputStream0);
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) dataInputStream0, ""object"", ""<#[OOjOz"", parser0);
        fail(""Expecting exception: UnsupportedCharsetException"");
    } catch (UnsupportedCharsetException e) {
        //
        // object
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return DataUtil.load(in, charsetName, baseUri, parser);
}","public void test1616() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0, (byte) 60);
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) bufferedInputStream0, ""6#a2:S}/xzy"", ""\"";v|8)]e]*v2X"", parser0);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // 6#a2:S}/xzy
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return DataUtil.load(in, charsetName, baseUri, parser);
}","public void test1717() throws Throwable {
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) null, ""cA16d=Fg5ry"", ""cA16d=Fg5ry"", parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.DataUtil"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return DataUtil.load(in, charsetName, baseUri, parser);
}","public void test1818() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    Parser parser0 = Parser.htmlParser();
    try {
        Jsoup.parse((InputStream) pipedInputStream0, ""FVKr<;C$I7D<\""wbw&"", ""DBu~|Rs=Hwp)o=F@tr"", parser0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test1919() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 14, 233);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) pushbackInputStream0, ""z"", ""vagq'Rp"");
        fail(""Expecting exception: UnsupportedCharsetException"");
    } catch (UnsupportedCharsetException e) {
        //
        // z
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2020() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) null, ""_ktI9=zg"", ""_ktI9=zg"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.DataUtil"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2121() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) sequenceInputStream0, """", "")Y`s:"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2222() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-1), (byte) 32);
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) byteArrayInputStream0, ""4/2c(3#k&&nCC+?>E"", """");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.ByteArrayInputStream"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2323() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(48);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, 3124);
    try {
        Jsoup.parse((InputStream) bufferedInputStream0, ""Cahr1Cm/{Vt[FG"", ""Cahr1Cm/{Vt[FG"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2424() throws Throwable {
    MockFile mockFile0 = new MockFile(""org.jsoup.nodes.Entities"", ""org.jsoup.nodes.Entities"");
    File file0 = MockFile.createTempFile(""org.jsoup.nodes.Entities"", ""CWU"", (File) mockFile0);
    // Undeclared exception!
    try {
        Jsoup.parse(file0, ""org.jsoup.nodes.Entities"", ""org.jsoup.nodes.Entities"");
        fail(""Expecting exception: UnsupportedCharsetException"");
    } catch (UnsupportedCharsetException e) {
        //
        // org.jsoup.nodes.Entities
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2525() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse((File) null, ""bY9!MMj+93d?}aW`"", ""bY9!MMj+93d?}aW`"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockRandomAccessFile"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2626() throws Throwable {
    MockFile mockFile0 = new MockFile("""");
    File file0 = MockFile.createTempFile(""sq3{"", ""dXoV'?"", (File) mockFile0);
    // Undeclared exception!
    try {
        Jsoup.parse(file0, """", ""P"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2727() throws Throwable {
    MockFile mockFile0 = new MockFile("""");
    try {
        Jsoup.parse((File) mockFile0, """", """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.NativeMockedIO"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test2828() throws Throwable {
    MockFile mockFile0 = new MockFile(""90?$?`.+m]aLt!(9v"", ""90?$?`.+m]aLt!(9v"");
    try {
        Jsoup.parse((File) mockFile0, ""90?$?`.+m]aLt!(9v"", ""90?$?`.+m]aLt!(9v"");
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // File does not exist, and RandomAccessFile is not open in write mode
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockRandomAccessFile"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test2929() throws Throwable {
    File file0 = MockFile.createTempFile(""code"", ""code"");
    // Undeclared exception!
    try {
        Jsoup.parse(file0, ""code"");
        fail(""Expecting exception: UnsupportedCharsetException"");
    } catch (UnsupportedCharsetException e) {
        //
        // code
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test3030() throws Throwable {
    File file0 = MockFile.createTempFile(""gMi-n,VrJ$e@BZ];s2"", ""k&k#"");
    // Undeclared exception!
    try {
        Jsoup.parse(file0, ""k&k#"");
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // k&k#
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test3131() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.parse((File) null, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.Jsoup"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test3232() throws Throwable {
    File file0 = MockFile.createTempFile(""CUdWjy8=xhB"", """");
    // Undeclared exception!
    try {
        Jsoup.parse(file0, """");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test3333() throws Throwable {
    MockFile mockFile0 = new MockFile(""pf1?dV6"", ""entities-xhtml.properties"");
    try {
        Jsoup.parse((File) mockFile0, ""pf1?dV6"");
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // File does not exist, and RandomAccessFile is not open in write mode
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockRandomAccessFile"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static boolean isValid(String bodyHtml, Whitelist whitelist) {
    return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, """"));
}","public void test3434() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.isValid(""org.jsoup.Jsoup"", (Whitelist) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.
 *     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.
 *     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)
 *     @param bodyHtml HTML to test
 *     @param whitelist whitelist to test against
 *     @return true if no tags or attributes were removed; false otherwise
 *     @see #clean(String, org.jsoup.safety.Whitelist)
 */"
"public static String clean(String bodyHtml, Whitelist whitelist) {
    return clean(bodyHtml, """", whitelist);
}","public void test3535() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.clean("""", (Whitelist) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    clean.outputSettings(outputSettings);
    return clean.body().html();
}","public void test3636() throws Throwable {
    Whitelist whitelist0 = Whitelist.simpleText();
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    Document.OutputSettings document_OutputSettings1 = document_OutputSettings0.charset((Charset) null);
    // Undeclared exception!
    try {
        Jsoup.clean(""del"", ""CP[C?$# G#AT WV"", whitelist0, document_OutputSettings1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Document$OutputSettings"", e);
    }
}","/**
 * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of
 * permitted tags and attributes.
 * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
 * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add
 * structural tags (<code>html, head, body</code> etc) to the whitelist.
 *
 * @param bodyHtml input untrusted HTML (body fragment)
 * @param baseUri URL to resolve relative URLs against
 * @param whitelist white-list of permitted HTML elements
 * @param outputSettings document output settings; use to control pretty-printing and entity escape modes
 * @return safe HTML (body fragment)
 * @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    clean.outputSettings(outputSettings);
    return clean.body().html();
}","public void test3737() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    // Undeclared exception!
    try {
        Jsoup.clean("""", """", (Whitelist) null, document_OutputSettings0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of
 * permitted tags and attributes.
 * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
 * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add
 * structural tags (<code>html, head, body</code> etc) to the whitelist.
 *
 * @param bodyHtml input untrusted HTML (body fragment)
 * @param baseUri URL to resolve relative URLs against
 * @param whitelist white-list of permitted HTML elements
 * @param outputSettings document output settings; use to control pretty-printing and entity escape modes
 * @return safe HTML (body fragment)
 * @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    return clean.body().html();
}","public void test3838() throws Throwable {
    Whitelist whitelist0 = Whitelist.basicWithImages();
    // Undeclared exception!
    try {
        Jsoup.clean("""", (String) null, whitelist0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param baseUri   URL to resolve relative URLs against
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    return clean.body().html();
}","public void test3939() throws Throwable {
    Whitelist whitelist0 = Whitelist.none();
    String string0 = Jsoup.clean(""u}E3,4vQN,%"", ""lOuDBz&e lv:\""W"", whitelist0);
    assertEquals(""u}E3,4vQN,%"", string0);
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param baseUri   URL to resolve relative URLs against
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public String location() {
    return location;
}","public void test4040() throws Throwable {
    Document document0 = Jsoup.parseBodyFragment("""", ""Axn(5sbLt,JWd'}"");
    assertEquals(""Axn(5sbLt,JWd'}"", document0.location());
}","/**
 * Get the URL this Document was parsed from. If the starting URL is a redirect,
 * this will return the final URL from which the document was served from.
 * @return location
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test4141() throws Throwable {
    EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""<yA"");
    FileSystemHandling.appendStringToFile(evoSuiteFile0, """");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(""<yA"");
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) mockFileInputStream0, ""<yA"", (String) null);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // <yA
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Connection connect(String url) {
    return HttpConnection.connect(url);
}","public void test4242() throws Throwable {
    // Undeclared exception!
    try {
        Jsoup.connect((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must supply a valid URL
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Creates a new {@link Connection} to a URL. Use to fetch and parse a HTML page.
 * <p>
 * Use examples:
 * <ul>
 *  <li><code>Document doc = Jsoup.connect(""http://example.com"").userAgent(""Mozilla"").data(""name"", ""jsoup"").get();</code></li>
 *  <li><code>Document doc = Jsoup.connect(""http://example.com"").cookie(""auth"", ""token"").post();</code></li>
 * </ul>
 * @param url URL to connect to. The protocol must be {@code http} or {@code https}.
 * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.
 */"
"@Override
public String nodeName() {
    return ""#document"";
}","public void test4343() throws Throwable {
    Parser parser0 = Parser.htmlParser();
    Document document0 = Jsoup.parse("""", """", parser0);
    assertEquals(""#document"", document0.nodeName());
}",""
"public static Document parse(URL url, int timeoutMillis) throws IOException {
    Connection con = HttpConnection.connect(url);
    con.timeout(timeoutMillis);
    return con.get();
}","public void test4444() throws Throwable {
    URLStreamHandler uRLStreamHandler0 = mock(URLStreamHandler.class, new ViolatedAssumptionAnswer());
    URL uRL0 = MockURL.URL(""K&ro"", ""device"", 0, ""Nq@+@<E{eZ\"" A#&`0'"", uRLStreamHandler0);
    try {
        Jsoup.parse(uRL0, 76);
        fail(""Expecting exception: MalformedURLException"");
    } catch (MalformedURLException e) {
        //
        // Only http & https protocols supported
        //
        verifyException(""org.jsoup.helper.HttpConnection$Response"", e);
    }
}","/**
 *     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.
 *     <p>
 *     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.
 *
 *     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
 *     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
 *     @return The parsed HTML.
 *
 *     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
 *     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
 *     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
 *     @throws java.net.SocketTimeoutException if the connection times out
 *     @throws IOException if a connection or read error occurs
 *
 *     @see #connect(String)
 */"
"public static Document parse(File in, String charsetName) throws IOException {
    return DataUtil.load(in, charsetName, in.getAbsolutePath());
}","public void test4545() throws Throwable {
    MockFile mockFile0 = new MockFile("""");
    try {
        Jsoup.parse((File) mockFile0, """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.NativeMockedIO"", e);
    }
}","/**
 *     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 *     @see #parse(File, String, String)
 */"
"public static boolean isValid(String bodyHtml, Whitelist whitelist) {
    return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, """"));
}","public void test4646() throws Throwable {
    Whitelist whitelist0 = new Whitelist();
    boolean boolean0 = Jsoup.isValid(""l<9s,:"", whitelist0);
    assertTrue(boolean0);
}","/**
 *     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.
 *     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.
 *     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)
 *     @param bodyHtml HTML to test
 *     @param whitelist whitelist to test against
 *     @return true if no tags or attributes were removed; false otherwise
 *     @see #clean(String, org.jsoup.safety.Whitelist)
 */"
"public static Document parse(File in, String charsetName, String baseUri) throws IOException {
    return DataUtil.load(in, charsetName, baseUri);
}","public void test4747() throws Throwable {
    File file0 = MockFile.createTempFile(""T]bUjnNE,o[*.xh3"", ""!8?_uN:{9"");
    // Undeclared exception!
    try {
        Jsoup.parse(file0, ""'DgO6![}VK]5#a-w:_"", ""'DgO6![}VK]5#a-w:_"");
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // 'DgO6![}VK]5#a-w:_
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 *     Parse the contents of a file as HTML.
 *
 *     @param in          file to load HTML from
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return DataUtil.load(in, charsetName, baseUri, parser);
}","public void test4848() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    Parser parser0 = Parser.xmlParser();
    // Undeclared exception!
    try {
        Jsoup.parse((InputStream) bufferedInputStream0, """", """", parser0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
 *     (non-HTML) parser.
 *
 *     @param in          input stream to read. Make sure to close it after parsing.
 *     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
 *     present, or fall back to {@code UTF-8} (which is often safe to do).
 *     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
 *     @param parser alternate {@link Parser#xmlParser() parser} to use.
 *     @return sane HTML
 *
 *     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
 */"
"public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
    Document dirty = parseBodyFragment(bodyHtml, baseUri);
    Cleaner cleaner = new Cleaner(whitelist);
    Document clean = cleaner.clean(dirty);
    clean.outputSettings(outputSettings);
    return clean.body().html();
}","public void test4949() throws Throwable {
    Whitelist whitelist0 = Whitelist.simpleText();
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Jsoup.clean(""del"", ""CP[C?$# G#AT WV"", whitelist0, document_OutputSettings0);
    assertEquals(""del"", string0);
}","/**
 * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of
 * permitted tags and attributes.
 * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
 * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add
 * structural tags (<code>html, head, body</code> etc) to the whitelist.
 *
 * @param bodyHtml input untrusted HTML (body fragment)
 * @param baseUri URL to resolve relative URLs against
 * @param whitelist white-list of permitted HTML elements
 * @param outputSettings document output settings; use to control pretty-printing and entity escape modes
 * @return safe HTML (body fragment)
 * @see Cleaner#clean(Document)
 */"
"public boolean updateMetaCharsetElement() {
    return updateMetaCharset;
}","public void test5050() throws Throwable {
    Document document0 = Jsoup.parse(""6^2aU(8*wN9L|W@"");
    assertFalse(document0.updateMetaCharsetElement());
}","/**
 * Returns whether the element with charset information in this document is
 * updated on changes through {@link #charset(java.nio.charset.Charset)
 * Document.charset(Charset)} or not.
 *
 * @return Returns <tt>true</tt> if the element is updated on charset
 * changes, <tt>false</tt> if not
 */"
"public static String clean(String bodyHtml, Whitelist whitelist) {
    return clean(bodyHtml, """", whitelist);
}","public void test5151() throws Throwable {
    Whitelist whitelist0 = Whitelist.simpleText();
    String string0 = Jsoup.clean(""HD.,HZm?C$GDU3I"", whitelist0);
    assertEquals(""HD.,HZm?C$GDU3I"", string0);
}","/**
 *     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
 *     tags and attributes.
 *
 *     @param bodyHtml  input untrusted HTML (body fragment)
 *     @param whitelist white-list of permitted HTML elements
 *     @return safe HTML (body fragment)
 *
 *     @see Cleaner#clean(Document)
 */"
"public String location() {
    return location;
}","public void test5252() throws Throwable {
    Document document0 = Jsoup.parse(""<yA"", """");
    assertEquals("""", document0.location());
}","/**
 * Get the URL this Document was parsed from. If the starting URL is a redirect,
 * this will return the final URL from which the document was served from.
 * @return location
 */"
"public static Document parseBodyFragment(String bodyHtml) {
    return Parser.parseBodyFragment(bodyHtml, """");
}","public void test5353() throws Throwable {
    Jsoup.parseBodyFragment(""del"");
}","/**
 *     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.
 *
 *     @param bodyHtml body HTML fragment
 *     @return sane HTML document
 *
 *     @see Document#body()
 */"
