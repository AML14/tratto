focal_method,test_prefix,docstring
"static String unescape(String string, boolean strict) {
    return Parser.unescapeEntities(string, strict);
}","public void test011() throws Throwable {
    String string0 = Entities.unescape("""", true);
    assertEquals("""", string0);
}","/**
 * Unescape the input string.
 * @param string to un-HTML-escape
 * @param strict if ""strict"" (that is, requires trailing ';' char, otherwise that's optional)
 * @return unescaped string
 */"
"static String unescape(String string) {
    return unescape(string, false);
}","public void test022() throws Throwable {
    String string0 = Entities.unescape("""");
    assertEquals("""", string0);
}",""
"public static Character getCharacterByName(String name) {
    return full.get(name);
}","public void test033() throws Throwable {
    Character character0 = Entities.getCharacterByName(""ShortDownArrow"");
    assertEquals('\u2193', (char) character0);
}","/**
 * Get the Character value of the named entity
 * @param name named entity (e.g. ""lt"" or ""amp"")
 * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')
 */"
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test044() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Entities.escape("""", document_OutputSettings0);
    assertEquals("""", string0);
}",""
"static String unescape(String string, boolean strict) {
    return Parser.unescapeEntities(string, strict);
}","public void test055() throws Throwable {
    // Undeclared exception!
    try {
        Entities.unescape((String) null, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Unescape the input string.
 * @param string to un-HTML-escape
 * @param strict if ""strict"" (that is, requires trailing ';' char, otherwise that's optional)
 * @return unescaped string
 */"
"static String unescape(String string) {
    return unescape(string, false);
}","public void test066() throws Throwable {
    // Undeclared exception!
    try {
        Entities.unescape((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"// this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations
static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {
    boolean lastWasWhite = false;
    boolean reachedNonWhite = false;
    final EscapeMode escapeMode = out.escapeMode();
    final CharsetEncoder encoder = out.encoder();
    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
    final Map<Character, String> map = escapeMode.getMap();
    final int length = string.length();
    int codePoint;
    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
        codePoint = string.codePointAt(offset);
        if (normaliseWhite) {
            if (StringUtil.isWhitespace(codePoint)) {
                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)
                    continue;
                accum.append(' ');
                lastWasWhite = true;
                continue;
            } else {
                lastWasWhite = false;
                reachedNonWhite = true;
            }
        }
        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):
        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
            final char c = (char) codePoint;
            // html specific and required escapes:
            switch(c) {
                case '&':
                    accum.append(""&amp;"");
                    break;
                case 0xA0:
                    if (escapeMode != EscapeMode.xhtml)
                        accum.append(""&nbsp;"");
                    else
                        accum.append(""&#xa0;"");
                    break;
                case '<':
                    // escape when in character data or when in a xml attribue val; not needed in html attr val
                    if (!inAttribute)
                        accum.append(""&lt;"");
                    else
                        accum.append(c);
                    break;
                case '>':
                    if (!inAttribute)
                        accum.append(""&gt;"");
                    else
                        accum.append(c);
                    break;
                case '""':
                    if (inAttribute)
                        accum.append(""&quot;"");
                    else
                        accum.append(c);
                    break;
                default:
                    if (canEncode(coreCharset, c, encoder))
                        accum.append(c);
                    else if (map.containsKey(c))
                        accum.append('&').append(map.get(c)).append(';');
                    else
                        accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
            }
        } else {
            final String c = new String(Character.toChars(codePoint));
            if (// uses fallback encoder for simplicity
            encoder.canEncode(c))
                accum.append(c);
            else
                accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
        }
    }
}","public void test077() throws Throwable {
    // Undeclared exception!
    try {
        Entities.escape((StringBuilder) null, ""leftrightarrow"", (Document.OutputSettings) null, true, true, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Entities"", e);
    }
}",""
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test088() throws Throwable {
    // Undeclared exception!
    try {
        Entities.escape(""Cedilla"", (Document.OutputSettings) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Entities"", e);
    }
}",""
"public static boolean isBaseNamedEntity(String name) {
    return base.containsKey(name);
}","public void test099() throws Throwable {
    boolean boolean0 = Entities.isBaseNamedEntity(""gt"");
    assertTrue(boolean0);
}","/**
 * Check if the input is a known named entity in the base entity set.
 * @param name the possible entity name (e.g. ""lt"" or ""amp"")
 * @return true if a known named entity in the base set
 * @see #isNamedEntity(String)
 */"
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test1111() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    Charset charset0 = Charset.forName(""US-ASCII"");
    document_OutputSettings0.charset(charset0);
    String string0 = Entities.escape(""US-ASCII"", document_OutputSettings0);
    assertEquals(""US-ASCII"", string0);
}",""
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test1414() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;
    document_OutputSettings0.escapeMode(entities_EscapeMode0);
    String string0 = Entities.escape(""\u00A0"", document_OutputSettings0);
    assertEquals(""&#xa0;"", string0);
}",""
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test1515() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Entities.escape(""\u00A0"", document_OutputSettings0);
    assertEquals(""&nbsp;"", string0);
}",""
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test1616() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Entities.escape(""gk)9GE2xPi&FtC~"", document_OutputSettings0);
    assertEquals(""gk)9GE2xPi&amp;FtC~"", string0);
}",""
"static String unescape(String string, boolean strict) {
    return Parser.unescapeEntities(string, strict);
}","public void test1919() throws Throwable {
    String string0 = Entities.unescape(""&gt;"", true);
    assertEquals("">"", string0);
}","/**
 * Unescape the input string.
 * @param string to un-HTML-escape
 * @param strict if ""strict"" (that is, requires trailing ';' char, otherwise that's optional)
 * @return unescaped string
 */"
"public static boolean isBaseNamedEntity(String name) {
    return base.containsKey(name);
}","public void test2020() throws Throwable {
    boolean boolean0 = Entities.isBaseNamedEntity((String) null);
    assertFalse(boolean0);
}","/**
 * Check if the input is a known named entity in the base entity set.
 * @param name the possible entity name (e.g. ""lt"" or ""amp"")
 * @return true if a known named entity in the base set
 * @see #isNamedEntity(String)
 */"
"public static boolean isNamedEntity(String name) {
    return full.containsKey(name);
}","public void test2121() throws Throwable {
    boolean boolean0 = Entities.isNamedEntity(""vDash"");
    assertTrue(boolean0);
}","/**
 * Check if the input is a known named entity
 * @param name the possible entity name (e.g. ""lt"" or ""amp"")
 * @return true if a known named entity
 */"
"public static boolean isNamedEntity(String name) {
    return full.containsKey(name);
}","public void test2222() throws Throwable {
    boolean boolean0 = Entities.isNamedEntity(""8o|:W{sm?j"");
    assertFalse(boolean0);
}","/**
 * Check if the input is a known named entity
 * @param name the possible entity name (e.g. ""lt"" or ""amp"")
 * @return true if a known named entity
 */"
"static String escape(String string, Document.OutputSettings out) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    escape(accum, string, out, false, false, false);
    return accum.toString();
}","public void test2323() throws Throwable {
    Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();
    String string0 = Entities.escape("">q<xJw01\""a!9-$C"", document_OutputSettings0);
    assertEquals(""&gt;q&lt;xJw01\""a!9-$C"", string0);
}",""
"static String unescape(String string) {
    return unescape(string, false);
}","public void test2424() throws Throwable {
    String string0 = Entities.unescape("">q<xJw01\""a!9-$C"");
    assertEquals("">q<xJw01\""a!9-$C"", string0);
}",""
"public static Character getCharacterByName(String name) {
    return full.get(name);
}","public void test2525() throws Throwable {
    Character character0 = Entities.getCharacterByName(""8o|:W{sm?j"");
    assertNull(character0);
}","/**
 * Get the Character value of the named entity
 * @param name named entity (e.g. ""lt"" or ""amp"")
 * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')
 */"
