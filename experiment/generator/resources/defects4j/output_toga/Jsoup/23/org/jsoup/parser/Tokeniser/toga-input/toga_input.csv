focal_method,test_prefix,docstring
"void createTempBuffer() {
    dataBuffer = new StringBuilder();
}","public void test000() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    tokeniser0.createTempBuffer();
}",""
"String appropriateEndTagName() {
    return lastStartTag.tagName;
}","public void test011() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""P#fU2u2;RkV/OVC_N}{"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.appropriateEndTagName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emitDoctypePending() {
    emit(doctypePending);
}","public void test022() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""NotLessTilde"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.emitDoctypePending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"void acknowledgeSelfClosingFlag() {
    selfClosingFlagAcknowledged = true;
}","public void test033() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    tokeniser0.acknowledgeSelfClosingFlag();
}",""
"void createCommentPending() {
    commentPending = new Token.Comment();
}","public void test044() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    tokeniser0.createCommentPending();
}",""
"boolean isAppropriateEndTagToken() {
    return tagPending.tagName.equals(lastStartTag.tagName);
}","public void test055() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""varphi"");
    ParseErrorList parseErrorList0 = new ParseErrorList(10765, 10765);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.isAppropriateEndTagToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test066() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""oO#k]W=uBw6Dy=~&"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token token0 = tokeniser0.read();
    assertEquals("""", characterReader0.toString());
}",""
"void emitTagPending() {
    tagPending.finaliseTag();
    emit(tagPending);
}","public void test078() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    // Undeclared exception!
    try {
        tokeniser0.emitTagPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emitCommentPending() {
    emit(commentPending);
}","public void test089() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    // Undeclared exception!
    try {
        tokeniser0.emitCommentPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"boolean currentNodeInHtmlNS() {
    // todo: implememnt namespaces correctly
    return true;
    // Element currentNode = currentNode();
    // return currentNode != null && currentNode.namespace().equals(""HTML"");
}","public void test0910() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""varphi"");
    ParseErrorList parseErrorList0 = new ParseErrorList(10765, 10765);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    boolean boolean0 = tokeniser0.currentNodeInHtmlNS();
    assertTrue(boolean0);
}",""
"void createDoctypePending() {
    doctypePending = new Token.Doctype();
}","public void test1011() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    tokeniser0.createDoctypePending();
}",""
"TokeniserState getState() {
    return state;
}","public void test1112() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""P#fU2u2;RkV/OVC_N}{"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.getState();
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test1213() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.tracking(881);
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.Tag token_Tag0 = tokeniser0.createTagPending(true);
    token_Tag0.selfClosing = true;
    tokeniser0.emit(token_Tag0);
    // Undeclared exception!
    try {
        tokeniser0.read();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test1314() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("""");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, (ParseErrorList) null);
    Token token0 = tokeniser0.read();
    assertNotNull(token0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1415() throws Throwable {
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, (ParseErrorList) null);
    Token.StartTag token_StartTag0 = new Token.StartTag();
    tokeniser0.emit(token_StartTag0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1516() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.EndTag token_EndTag0 = new Token.EndTag();
    tokeniser0.emit(token_EndTag0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes.size() > 0)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1617() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.EndTag token_EndTag0 = new Token.EndTag();
    token_EndTag0.appendAttributeName(""[__KIY65"");
    token_EndTag0.newAttribute();
    tokeniser0.emit(token_EndTag0);
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test1718() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""Xb>/:&CH'<B^oZI|y{"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token token0 = tokeniser0.read();
    assertNotNull(token0);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test1821() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""ii;>,Xd1)2,tCu~"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = Character.valueOf('7');
    tokeniser0.consumeCharacterReference(character0, true);
    assertEquals("">,Xd1)2,tCu~"", characterReader0.toString());
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        // for error reporting. nameRef gets chomped looking for matches
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1922() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""There is an unread token pending!"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, (ParseErrorList) null);
    Character character0 = Character.valueOf('T');
    Character character1 = tokeniser0.consumeCharacterReference(character0, false);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        // for error reporting. nameRef gets chomped looking for matches
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2023() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""&]5_I/<z9qJ"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2124() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#X3"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.consumeCharacterReference((Character) null, true);
    assertEquals("""", characterReader0.toString());
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2225() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#1"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.consumeCharacterReference((Character) null, false);
    assertEquals("""", characterReader0.toString());
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        // for error reporting. nameRef gets chomped looking for matches
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2326() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2328() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertEquals(""#"", characterReader0.toString());
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2430() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""E=F&;bMGiwQG^+>F"");
    ParseErrorList parseErrorList0 = ParseErrorList.tracking(3301);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.read();
    assertEquals("""", characterReader0.toString());
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2531() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""planck"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.consumeCharacterReference((Character) null, false);
    assertEquals("""", characterReader0.toString());
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
        String nameRef = reader.consumeLetterSequence();
        // for error reporting. nameRef gets chomped looking for matches
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            reader.rewindToMark();
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2633() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""numeric reference with no numerals"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Token.Tag createTagPending(boolean start) {
    tagPending = start ? new Token.StartTag() : new Token.EndTag();
    return tagPending;
}","public void test2836() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.Tag token_Tag0 = tokeniser0.createTagPending(false);
    assertNotNull(token_Tag0);
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test2937() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""BW{A@<"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.read();
    assertEquals("""", characterReader0.toString());
}",""
"@Override
public String toString() {
    return input.substring(pos);
}","public void test3039() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader("" X<"");
    ParseErrorList parseErrorList0 = ParseErrorList.tracking(88);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token token0 = tokeniser0.read();
    assertEquals("""", characterReader0.toString());
}",""
