focal_method,test_prefix,docstring
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test000() throws Throwable {
    TokenQueue.unescape(""X-kXc[-oD(+(y?l!"");
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    return (end >= 0) ? queue.substring(start, end) : """";
}","public void test011() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeElementSelector();
    tokenQueue0.chompBalanced('#', '#');
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"public String chompTo(String seq) {
    String data = consumeTo(seq);
    matchChomp(seq);
    return data;
}","public void test022() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.addFirst(""Queue did not match expected sequence"");
    tokenQueue0.consumeWord();
    tokenQueue0.chompTo(""Queue did not match expected sequence"");
}","/**
 * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).
 * <p>
 * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go
 * isEmpty() == true).
 * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>
 * @return Data matched from queue.
 */"
"public void consume(String seq) {
    if (!matches(seq))
        throw new IllegalStateException(""Queue did not match expected sequence"");
    int len = seq.length();
    if (len > remainingLength())
        throw new IllegalStateException(""Queue not long enough to consume sequence"");
    pos += len;
}","public void test033() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
}","/**
 * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
 * throw an illegal state exception -- but you should be running match() against that condition.
 *     <p>
 *     Case insensitive.
 * @param seq sequence to remove from head of queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test044() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""p`DL^"");
    tokenQueue0.matchesStartTag();
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test055() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.matchesStartTag();
}",""
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test066() throws Throwable {
    TokenQueue.unescape("""");
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test077() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeWord();
    tokenQueue0.toString();
}",""
"public String remainder() {
    final String remainder = queue.substring(pos, queue.length());
    pos = queue.length();
    return remainder;
}","public void test088() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.remainder();
}","/**
 *     Consume and return whatever is left on the queue.
 *     @return remained of queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test099() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    tokenQueue0.chompBalanced('*', 'C');
    tokenQueue0.peek();
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesCS(String seq) {
    return queue.startsWith(seq, pos);
}","public void test1010() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""MunxBE4TmJ$O6brhQZ6"");
    tokenQueue0.consumeWord();
    tokenQueue0.matchesCS(""MunxBE4TmJ"");
}","/**
 * Case sensitive match test.
 * @param seq string to case sensitively check for
 * @return true if matched, false if not
 */"
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test1111() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ET1.K7YMPRyV"");
    tokenQueue0.matches(""i`g%R6{fv:n"");
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"public String consumeWord() {
    int start = pos;
    while (matchesWord()) pos++;
    return queue.substring(start, pos);
}","public void test1212() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.consumeWord();
}","/**
 * Retrieves the next run of word type (letter or digit) off the queue.
 * @return String of word characters from queue, or empty string if none.
 */"
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test1313() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.consumeTo(""C-c}Cvo"");
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test1414() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    tokenQueue0.consumeElementSelector();
    tokenQueue0.consumeAttributeKey();
    assertEquals(""["", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test1515() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    tokenQueue0.consumeTagName();
    tokenQueue0.consume();
    char char0 = tokenQueue0.consume();
    assertEquals('>', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test1516() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    tokenQueue0.consumeTagName();
    tokenQueue0.consume();
    char char0 = tokenQueue0.consume();
    assertEquals('1', char0);
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test1617() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.chompToIgnoreCase(""ZPENtVIS-1O4V"");
    assertEquals('#', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test1718() throws Throwable {
    // Undeclared exception!
    try {
        TokenQueue.unescape((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public boolean matchesCS(String seq) {
    return queue.startsWith(seq, pos);
}","public void test1819() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    // Undeclared exception!
    try {
        tokenQueue0.matchesCS((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Case sensitive match test.
 * @param seq string to case sensitively check for
 * @return true if matched, false if not
 */"
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test1920() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""zV}gOohc<nl"");
    // Undeclared exception!
    try {
        tokenQueue0.matchesAny((char[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test2021() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    // Undeclared exception!
    try {
        tokenQueue0.matches((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test2122() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    // Undeclared exception!
    try {
        tokenQueue0.matchChomp((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test2223() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToIgnoreCase("""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test2324() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToIgnoreCase((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"// todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this
// is is a case sensitive time...
public String consumeToAny(String... seq) {
    int start = pos;
    while (!isEmpty() && !matchesAny(seq)) {
        pos++;
    }
    return queue.substring(start, pos);
}","public void test2425() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToAny((String[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 *     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.
 *     @param seq any number of terminators to consume to. <b>Case insensitive.</b>
 *     @return consumed string
 */"
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test2526() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.consumeTo((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"public void consume(String seq) {
    if (!matches(seq))
        throw new IllegalStateException(""Queue did not match expected sequence"");
    int len = seq.length();
    if (len > remainingLength())
        throw new IllegalStateException(""Queue not long enough to consume sequence"");
    pos += len;
}","public void test2627() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    // Undeclared exception!
    try {
        tokenQueue0.consume((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
 * throw an illegal state exception -- but you should be running match() against that condition.
 *     <p>
 *     Case insensitive.
 * @param seq sequence to remove from head of queue.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test2728() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.consume();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public String chompToIgnoreCase(String seq) {
    // case insensitive scan
    String data = consumeToIgnoreCase(seq);
    matchChomp(seq);
    return data;
}","public void test2829() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.chompToIgnoreCase("""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public String chompToIgnoreCase(String seq) {
    // case insensitive scan
    String data = consumeToIgnoreCase(seq);
    matchChomp(seq);
    return data;
}","public void test2930() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""foma::+6g|fqwm}a"");
    // Undeclared exception!
    try {
        tokenQueue0.chompToIgnoreCase((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"public String chompTo(String seq) {
    String data = consumeTo(seq);
    matchChomp(seq);
    return data;
}","public void test3031() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    // Undeclared exception!
    try {
        tokenQueue0.chompTo((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).
 * <p>
 * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go
 * isEmpty() == true).
 * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>
 * @return Data matched from queue.
 */"
"public void addFirst(Character c) {
    addFirst(c.toString());
}","public void test3132() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.addFirst((Character) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 *     Add a character to the start of the queue (will be the next character retrieved).
 *     @param c character to add
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test3233() throws Throwable {
    TokenQueue tokenQueue0 = null;
    try {
        tokenQueue0 = new TokenQueue((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3334() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""_U\u0006"");
    tokenQueue0.chompBalanced('_', 'c');
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3435() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""\""xiJ&`M[0Y_* x"");
    tokenQueue0.consumeToIgnoreCase(""*`l@X17Z["");
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test3536() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$t/2XW"");
    tokenQueue0.consumeToIgnoreCase(""$t/2XW"");
    assertEquals('$', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3637() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    tokenQueue0.consumeWord();
    tokenQueue0.consumeTo(""PsQsP"");
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3738() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    tokenQueue0.consumeTo("""");
    assertEquals(""8rVVhr["", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3839() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals(""#f"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test3840() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test3941() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test3942() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test4043() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertTrue(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test4144() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals("" did not match expected sequence"", tokenQueue0.toString());
}",""
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test4145() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertTrue(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test4246() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test4247() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test4348() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    Character character0 = Character.valueOf('u');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchChomp(""PsQsP"");
    assertEquals('u', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test4349() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    Character character0 = Character.valueOf('u');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchChomp(""PsQsP"");
    assertFalse(boolean0);
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test4450() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test4451() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertTrue(boolean0);
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test4552() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals(""!"", tokenQueue0.toString());
}",""
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test4553() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertTrue(boolean0);
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test4654() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals(""!"", tokenQueue0.toString());
}",""
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test4655() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(boolean0);
}",""
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test4756() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String[] stringArray0 = new String[8];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertTrue(boolean0);
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test4857() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""MKf2*BS>:okK]H<"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""y9?Q{4"";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(boolean0);
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test4958() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String[] stringArray0 = new String[8];
    // Undeclared exception!
    try {
        tokenQueue0.matchesAny(stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test5059() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s@zD6]"");
    Character character0 = new Character('L');
    tokenQueue0.addFirst(character0);
    tokenQueue0.chompBalanced('L', 'L');
    boolean boolean0 = tokenQueue0.isEmpty();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test5060() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s@zD6]"");
    Character character0 = new Character('L');
    tokenQueue0.addFirst(character0);
    tokenQueue0.chompBalanced('L', 'L');
    boolean boolean0 = tokenQueue0.isEmpty();
    assertTrue(boolean0);
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test5161() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(boolean0);
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String remainder() {
    final String remainder = queue.substring(pos, queue.length());
    pos = queue.length();
    return remainder;
}","public void test5262() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s@zD6]"");
    String string0 = tokenQueue0.remainder();
    assertEquals(""s@zD6]"", string0);
}","/**
 *     Consume and return whatever is left on the queue.
 *     @return remained of queue.
 */"
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test5363() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s@zD6]"");
    boolean boolean0 = tokenQueue0.matches(""s@zD6]"");
    assertTrue(boolean0);
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test5464() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeAttributeKey();
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test5565() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""0Z-T~R7~7 izo"");
    tokenQueue0.consumeCssIdentifier();
    assertEquals('~', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test5666() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.consume();
    tokenQueue0.consumeToIgnoreCase(""Queue did not match expected sequence"");
    tokenQueue0.consumeCssIdentifier();
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test5767() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    tokenQueue0.consumeElementSelector();
    assertEquals('$', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test5868() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeElementSelector();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test5969() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""I:xt}ChItIVC=~!{"");
    tokenQueue0.consumeTagName();
    assertEquals(""}ChItIVC=~!{"", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test6070() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    tokenQueue0.consumeTagName();
    tokenQueue0.chompToIgnoreCase(""X"");
    tokenQueue0.consumeTagName();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test6171() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""_U\u0006"");
    tokenQueue0.chompBalanced('c', '_');
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test6272() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""String must not be empty"");
    tokenQueue0.advance();
    String[] stringArray0 = new String[7];
    stringArray0[0] = ""String must not be empty"";
    stringArray0[1] = ""String must not be empty"";
    stringArray0[2] = ""]NF"";
    stringArray0[3] = ""String must not be empty"";
    stringArray0[4] = ""String must not be empty"";
    stringArray0[5] = ""String must not be empty"";
    stringArray0[6] = ""String must not be empty"";
    tokenQueue0.consumeToAny(stringArray0);
    tokenQueue0.chompBalanced('\""', '\""');
    assertEquals("""", tokenQueue0.toString());
}",""
"public void consume(String seq) {
    if (!matches(seq))
        throw new IllegalStateException(""Queue did not match expected sequence"");
    int len = seq.length();
    if (len > remainingLength())
        throw new IllegalStateException(""Queue not long enough to consume sequence"");
    pos += len;
}","public void test6373() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".Rw %Y-cF[9:Oy"");
    Character character0 = Character.valueOf('#');
    tokenQueue0.addFirst(character0);
    // Undeclared exception!
    try {
        tokenQueue0.consume("".Rw %Y-cF[9:Oy"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Queue did not match expected sequence
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
 * throw an illegal state exception -- but you should be running match() against that condition.
 *     <p>
 *     Case insensitive.
 * @param seq sequence to remove from head of queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test6474() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consume("""");
    assertEquals('Z', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test6575() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue did not match expected sequence"");
    tokenQueue0.consume();
    tokenQueue0.consumeToIgnoreCase(""Queue did not match expected sequence"");
    tokenQueue0.advance();
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test6676() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""String must not be empty"");
    tokenQueue0.consumeTagName();
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertEquals(""must not be empty"", tokenQueue0.toString());
}",""
"public boolean consumeWhitespace() {
    boolean seen = false;
    while (matchesWhitespace()) {
        pos++;
        seen = true;
    }
    return seen;
}","public void test6677() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""String must not be empty"");
    tokenQueue0.consumeTagName();
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertTrue(boolean0);
}","/**
 * Pulls the next run of whitespace characters of the queue.
 * @return Whether consuming whitespace or not
 */"
"public boolean consumeWhitespace() {
    boolean seen = false;
    while (matchesWhitespace()) {
        pos++;
        seen = true;
    }
    return seen;
}","public void test6778() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertFalse(boolean0);
}","/**
 * Pulls the next run of whitespace characters of the queue.
 * @return Whether consuming whitespace or not
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test6779() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test6880() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test6881() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test6982() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.chompTo("""");
    assertEquals('Z', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test7083() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""<]CY\""1}kOU&tb3>#)*"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test7084() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""<]CY\""1}kOU&tb3>#)*"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test7185() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""FL<x48V1,UNy`}6o"");
    tokenQueue0.consumeTagName();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals(""<x48V1,UNy`}6o"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test7186() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""FL<x48V1,UNy`}6o"");
    tokenQueue0.consumeTagName();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertTrue(boolean0);
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test7287() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals('f', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test7288() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test7389() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    String[] stringArray0 = new String[18];
    stringArray0[0] = """";
    tokenQueue0.consumeToAny(stringArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test7490() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""String must not be empty"");
    tokenQueue0.advance();
    String[] stringArray0 = new String[7];
    stringArray0[0] = ""String must not be empty"";
    stringArray0[1] = ""String must not be empty"";
    stringArray0[2] = ""]NF"";
    stringArray0[3] = ""String must not be empty"";
    stringArray0[4] = ""String must not be empty"";
    stringArray0[5] = ""String must not be empty"";
    stringArray0[6] = ""String must not be empty"";
    tokenQueue0.consumeToAny(stringArray0);
    char[] charArray0 = new char[3];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test7491() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""String must not be empty"");
    tokenQueue0.advance();
    String[] stringArray0 = new String[7];
    stringArray0[0] = ""String must not be empty"";
    stringArray0[1] = ""String must not be empty"";
    stringArray0[2] = ""]NF"";
    stringArray0[3] = ""String must not be empty"";
    stringArray0[4] = ""String must not be empty"";
    stringArray0[5] = ""String must not be empty"";
    stringArray0[6] = ""String must not be empty"";
    tokenQueue0.consumeToAny(stringArray0);
    char[] charArray0 = new char[3];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(boolean0);
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test7592() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeWord();
    char char0 = tokenQueue0.peek();
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test7593() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    tokenQueue0.consumeAttributeKey();
    tokenQueue0.chompBalanced('/', '/');
    tokenQueue0.consumeWord();
    char char0 = tokenQueue0.peek();
    assertEquals('\u0000', char0);
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test7694() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    char char0 = tokenQueue0.peek();
    assertEquals('Z', char0);
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test7795() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    String string0 = tokenQueue0.toString();
    assertEquals(""ZPENtVIS-1O4V#f"", string0);
}",""
"public boolean matchesCS(String seq) {
    return queue.startsWith(seq, pos);
}","public void test7896() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertTrue(boolean0);
}","/**
 * Case sensitive match test.
 * @param seq string to case sensitively check for
 * @return true if matched, false if not
 */"
