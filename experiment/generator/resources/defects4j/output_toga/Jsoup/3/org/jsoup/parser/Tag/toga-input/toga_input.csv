focal_method,test_prefix,docstring
"public static Tag valueOf(String tagName) {
    Validate.notNull(tagName);
    tagName = tagName.trim().toLowerCase();
    Validate.notEmpty(tagName);
    synchronized (tags) {
        Tag tag = tags.get(tagName);
        if (tag == null) {
            // not defined: create default; go anywhere, do anything! (incl be inside a <p>)
            tag = new Tag(tagName);
            tag.setAncestor(defaultAncestor.tagName);
            tag.isBlock = false;
            tag.canContainBlock = true;
        }
        return tag;
    }
}","public void test000() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    assertNotNull(tag0);
}","/**
 *     Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
 *     <p>
 *     Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
 *     @param tagName Name of tag, e.g. ""p"". Case insensitive.
 *     @return The tag, either defined or new generic.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test001() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    tag0.getName();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test002() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    tag0.getName();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isEmpty() {
    return empty;
}","public void test003() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    tag0.getName();
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test004() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    tag0.getName();
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test005() throws Throwable {
    Tag tag0 = Tag.valueOf(""DFtik7iwk"");
    tag0.getName();
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean isEmpty() {
    return empty;
}","public void test016() throws Throwable {
    Tag tag0 = Tag.valueOf(""0"");
    boolean boolean0 = tag0.canContainBlock();
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test017() throws Throwable {
    Tag tag0 = Tag.valueOf(""0"");
    boolean boolean0 = tag0.canContainBlock();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test018() throws Throwable {
    Tag tag0 = Tag.valueOf(""0"");
    boolean boolean0 = tag0.canContainBlock();
    assertTrue(boolean0);
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test019() throws Throwable {
    Tag tag0 = Tag.valueOf(""0"");
    boolean boolean0 = tag0.canContainBlock();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test0110() throws Throwable {
    Tag tag0 = Tag.valueOf(""0"");
    boolean boolean0 = tag0.canContainBlock();
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test0211() throws Throwable {
    Tag tag0 = Tag.valueOf(""title"");
    boolean boolean0 = tag0.isData();
    assertTrue(boolean0);
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test0312() throws Throwable {
    Tag tag0 = Tag.valueOf(""object"");
    boolean boolean0 = tag0.preserveWhitespace();
    assertFalse(boolean0);
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test0413() throws Throwable {
    Tag tag0 = Tag.valueOf(""MBc"");
    tag0.toString();
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test0414() throws Throwable {
    Tag tag0 = Tag.valueOf(""MBc"");
    tag0.toString();
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test0415() throws Throwable {
    Tag tag0 = Tag.valueOf(""MBc"");
    tag0.toString();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test0416() throws Throwable {
    Tag tag0 = Tag.valueOf(""MBc"");
    tag0.toString();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean isEmpty() {
    return empty;
}","public void test0417() throws Throwable {
    Tag tag0 = Tag.valueOf(""MBc"");
    tag0.toString();
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isBlock() {
    return isBlock;
}","public void test0518() throws Throwable {
    Tag tag0 = Tag.valueOf("" at index: "");
    boolean boolean0 = tag0.isBlock();
    assertFalse(boolean0);
}","/**
 *     Gets if this is a block tag.
 *     @return if block tag
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test0519() throws Throwable {
    Tag tag0 = Tag.valueOf("" at index: "");
    boolean boolean0 = tag0.isBlock();
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test0520() throws Throwable {
    Tag tag0 = Tag.valueOf("" at index: "");
    boolean boolean0 = tag0.isBlock();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test0521() throws Throwable {
    Tag tag0 = Tag.valueOf("" at index: "");
    boolean boolean0 = tag0.isBlock();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isEmpty() {
    return empty;
}","public void test0522() throws Throwable {
    Tag tag0 = Tag.valueOf("" at index: "");
    boolean boolean0 = tag0.isBlock();
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test0623() throws Throwable {
    Tag tag0 = Tag.valueOf(""THEAD"");
    boolean boolean0 = tag0.canContain(tag0);
    assertFalse(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test0724() throws Throwable {
    Tag tag0 = Tag.valueOf(""link"");
    boolean boolean0 = tag0.canContain(tag0);
    assertFalse(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test0825() throws Throwable {
    Tag tag0 = Tag.valueOf(""base"");
    boolean boolean0 = tag0.canContain(tag0);
    assertFalse(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"Tag getImplicitParent() {
    return (!ancestors.isEmpty()) ? ancestors.get(0) : null;
}","public void test0926() throws Throwable {
    Tag tag0 = Tag.valueOf(""style"");
    Tag tag1 = tag0.getImplicitParent();
    assertNotNull(tag1);
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test0927() throws Throwable {
    Tag tag0 = Tag.valueOf(""style"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String toString() {
    return tagName;
}","public void test0928() throws Throwable {
    Tag tag0 = Tag.valueOf(""style"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.toString());
}",""
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test1029() throws Throwable {
    Tag tag0 = Tag.valueOf(""dd"");
    Tag tag1 = Tag.valueOf(""dt"");
    tag0.canContain(tag1);
    assertFalse(tag1.equals((Object) tag0));
}",""
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test1030() throws Throwable {
    Tag tag0 = Tag.valueOf(""dd"");
    Tag tag1 = Tag.valueOf(""dt"");
    tag0.canContain(tag1);
    assertFalse(tag1.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1131() throws Throwable {
    Tag tag0 = Tag.valueOf(""base"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String getName() {
    return tagName;
}","public void test1132() throws Throwable {
    Tag tag0 = Tag.valueOf(""base"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.getName());
}",""
"public String toString() {
    return tagName;
}","public void test1233() throws Throwable {
    Tag tag0 = Tag.valueOf(""script"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.toString());
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1234() throws Throwable {
    Tag tag0 = Tag.valueOf(""script"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1335() throws Throwable {
    Tag tag0 = Tag.valueOf(""noscript"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String toString() {
    return tagName;
}","public void test1336() throws Throwable {
    Tag tag0 = Tag.valueOf(""noscript"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.toString());
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1437() throws Throwable {
    Tag tag0 = Tag.valueOf(""link"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String getName() {
    return tagName;
}","public void test1438() throws Throwable {
    Tag tag0 = Tag.valueOf(""link"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.getName());
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1539() throws Throwable {
    Tag tag0 = Tag.valueOf(""meta"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String toString() {
    return tagName;
}","public void test1540() throws Throwable {
    Tag tag0 = Tag.valueOf(""meta"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.toString());
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1641() throws Throwable {
    Tag tag0 = Tag.valueOf(""title"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String toString() {
    return tagName;
}","public void test1642() throws Throwable {
    Tag tag0 = Tag.valueOf(""title"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.toString());
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1743() throws Throwable {
    Tag tag0 = Tag.valueOf(""HEAD"");
    boolean boolean0 = tag0.canContain(tag0);
    assertFalse(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test1744() throws Throwable {
    Tag tag0 = Tag.valueOf(""HEAD"");
    boolean boolean0 = tag0.canContain(tag0);
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1845() throws Throwable {
    Tag tag0 = Tag.valueOf(""object"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public String getName() {
    return tagName;
}","public void test1846() throws Throwable {
    Tag tag0 = Tag.valueOf(""object"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.canContain(tag0);
    assertEquals(""head"", tag1.getName());
}",""
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test1947() throws Throwable {
    Tag tag0 = Tag.valueOf(""dd"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(tag1.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test1948() throws Throwable {
    Tag tag0 = Tag.valueOf(""dd"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(tag1.equals((Object) tag0));
}",""
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test1949() throws Throwable {
    Tag tag0 = Tag.valueOf(""dd"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test2050() throws Throwable {
    Tag tag0 = Tag.valueOf(""lb"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test2051() throws Throwable {
    Tag tag0 = Tag.valueOf(""lb"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test2052() throws Throwable {
    Tag tag0 = Tag.valueOf(""lb"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test2053() throws Throwable {
    Tag tag0 = Tag.valueOf(""lb"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean isEmpty() {
    return empty;
}","public void test2054() throws Throwable {
    Tag tag0 = Tag.valueOf(""lb"");
    Tag tag1 = Tag.valueOf(""dt"");
    boolean boolean0 = tag1.canContain(tag0);
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"boolean canContain(Tag child) {
    Validate.notNull(child);
    if (child.isBlock && !this.canContainBlock)
        return false;
    if (// not block == inline
    !child.isBlock && !this.canContainInline)
        return false;
    if (this.optionalClosing && this.equals(child))
        return false;
    if (this.empty || this.isData())
        return false;
    // head can only contain a few. if more than head in here, modify to have a list of valids
    // TODO: (could solve this with walk for ancestor)
    if (this.tagName.equals(""head"")) {
        if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") || child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
            return true;
        }
        return false;
    }
    // dt and dd (in dl)
    if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
        return false;
    if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
        return false;
    // don't allow children to contain their parent (directly)
    return true;
}","public void test2155() throws Throwable {
    Tag tag0 = Tag.valueOf(""object"");
    Tag tag1 = Tag.valueOf(""dd"");
    boolean boolean0 = tag1.canContain(tag0);
    assertTrue(boolean0);
}","/**
 *     Test if this tag, the prospective parent, can accept the proposed child.
 *     @param child potential child tag.
 *     @return true if this can contain child.
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test2256() throws Throwable {
    Tag tag0 = Tag.valueOf(""DL"");
    boolean boolean0 = tag0.isInline();
    assertFalse(boolean0);
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test2357() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated collection contains an element not of type "");
    boolean boolean0 = tag0.isInline();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test2358() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated collection contains an element not of type "");
    boolean boolean0 = tag0.isInline();
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test2359() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated collection contains an element not of type "");
    boolean boolean0 = tag0.isInline();
    assertTrue(boolean0);
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test2360() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated collection contains an element not of type "");
    boolean boolean0 = tag0.isInline();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean isEmpty() {
    return empty;
}","public void test2361() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated collection contains an element not of type "");
    boolean boolean0 = tag0.isInline();
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test2462() throws Throwable {
    Tag tag0 = Tag.valueOf(""base"");
    boolean boolean0 = tag0.isData();
    assertFalse(boolean0);
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"Tag getImplicitParent() {
    return (!ancestors.isEmpty()) ? ancestors.get(0) : null;
}","public void test2563() throws Throwable {
    Tag tag0 = Tag.valueOf(""html"");
    Tag tag1 = tag0.getImplicitParent();
    assertNull(tag1);
}",""
"boolean isValidParent(Tag child) {
    if (child.ancestors.isEmpty())
        // HTML tag
        return true;
    for (Tag tag : child.ancestors) {
        if (this.equals(tag))
            return true;
    }
    return false;
}","public void test2664() throws Throwable {
    Tag tag0 = Tag.valueOf(""PARAM"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(boolean0);
}",""
"boolean isValidParent(Tag child) {
    if (child.ancestors.isEmpty())
        // HTML tag
        return true;
    for (Tag tag : child.ancestors) {
        if (this.equals(tag))
            return true;
    }
    return false;
}","public void test2765() throws Throwable {
    Tag tag0 = Tag.valueOf(""html"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertTrue(boolean0);
}",""
"Tag getImplicitParent() {
    return (!ancestors.isEmpty()) ? ancestors.get(0) : null;
}","public void test2866() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    assertNotNull(tag1);
}",""
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test2867() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertFalse(tag1.equals((Object) tag0));
}",""
"public boolean isEmpty() {
    return empty;
}","public void test2868() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test2869() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"boolean isValidParent(Tag child) {
    if (child.ancestors.isEmpty())
        // HTML tag
        return true;
    for (Tag tag : child.ancestors) {
        if (this.equals(tag))
            return true;
    }
    return false;
}","public void test2870() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertTrue(boolean0);
}",""
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test2871() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test2872() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test2873() throws Throwable {
    Tag tag0 = Tag.valueOf(""ECP`FJm5-&"");
    Tag tag1 = tag0.getImplicitParent();
    boolean boolean0 = tag1.isValidParent(tag0);
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test2974() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test2975() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test2976() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public boolean isBlock() {
    return isBlock;
}","public void test2977() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertFalse(tag0.isBlock());
}","/**
 *     Gets if this is a block tag.
 *     @return if block tag
 */"
"public boolean isEmpty() {
    return empty;
}","public void test2978() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test2979() throws Throwable {
    Tag tag0 = Tag.valueOf(""n]XK"");
    boolean boolean0 = tag0.equals((Object) null);
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test3080() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean isEmpty() {
    return empty;
}","public void test3081() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test3082() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test3083() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test3084() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertFalse(boolean0);
}",""
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test3085() throws Throwable {
    Tag tag0 = Tag.valueOf(""]XK"");
    boolean boolean0 = tag0.equals(""]XK"");
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test3186() throws Throwable {
    Tag tag0 = Tag.valueOf(""BR"");
    Tag tag1 = Tag.valueOf(""script"");
    boolean boolean0 = tag0.equals(tag1);
    assertFalse(boolean0);
}",""
"public boolean isEmpty() {
    return empty;
}","public void test3287() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(tag0.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"boolean isValidParent(Tag child) {
    if (child.ancestors.isEmpty())
        // HTML tag
        return true;
    for (Tag tag : child.ancestors) {
        if (this.equals(tag))
            return true;
    }
    return false;
}","public void test3288() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(boolean0);
}",""
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test3289() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test3290() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertTrue(tag0.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"public boolean isBlock() {
    return isBlock;
}","public void test3291() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(tag0.isBlock());
}","/**
 *     Gets if this is a block tag.
 *     @return if block tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test3292() throws Throwable {
    Tag tag0 = Tag.valueOf(""Te valQQhteN exreso isflse"");
    boolean boolean0 = tag0.isValidParent(tag0);
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test3393() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertFalse(tag1.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isEmpty() {
    return empty;
}","public void test3394() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertFalse(tag1.isEmpty());
}","/**
 *     Get if this is an empty tag
 *     @return if this is an emtpy tag
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test3395() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertFalse(tag1.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"public boolean canContainBlock() {
    return canContainBlock;
}","public void test3396() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertTrue(tag1.canContainBlock());
}","/**
 *     Gets if this tag can contain block tags.
 *     @return if tag can contain block tags
 */"
"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Tag tag = (Tag) o;
    if (canContainBlock != tag.canContainBlock)
        return false;
    if (canContainInline != tag.canContainInline)
        return false;
    if (empty != tag.empty)
        return false;
    if (isBlock != tag.isBlock)
        return false;
    if (optionalClosing != tag.optionalClosing)
        return false;
    if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null)
        return false;
    return true;
}","public void test3397() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertTrue(boolean0);
}",""
"public boolean isBlock() {
    return isBlock;
}","public void test3398() throws Throwable {
    Tag tag0 = Tag.valueOf(""The validated expression is false"");
    Tag tag1 = Tag.valueOf(""The validated expression is false"");
    boolean boolean0 = tag1.equals(tag0);
    assertFalse(tag1.isBlock());
}","/**
 *     Gets if this is a block tag.
 *     @return if block tag
 */"
"@Override
public int hashCode() {
    int result = tagName != null ? tagName.hashCode() : 0;
    result = 31 * result + (isBlock ? 1 : 0);
    result = 31 * result + (canContainBlock ? 1 : 0);
    result = 31 * result + (canContainInline ? 1 : 0);
    result = 31 * result + (optionalClosing ? 1 : 0);
    result = 31 * result + (empty ? 1 : 0);
    return result;
}","public void test3499() throws Throwable {
    Tag tag0 = Tag.valueOf(""link"");
    tag0.hashCode();
}",""
"public boolean preserveWhitespace() {
    return preserveWhitespace;
}","public void test35100() throws Throwable {
    Tag tag0 = Tag.valueOf(""r[zmHb.(TH"");
    tag0.hashCode();
    assertFalse(tag0.preserveWhitespace());
}","/**
 *     Get if this tag should preserve whitespace within child text nodes.
 *     @return if preserve whitepace
 */"
"public boolean isInline() {
    return !isBlock;
}","public void test35101() throws Throwable {
    Tag tag0 = Tag.valueOf(""r[zmHb.(TH"");
    tag0.hashCode();
    assertTrue(tag0.isInline());
}","/**
 *     Gets if this tag is an inline tag.
 *     @return if this tag is an inline tag.
 */"
"public boolean isData() {
    return !canContainInline && !isEmpty();
}","public void test35102() throws Throwable {
    Tag tag0 = Tag.valueOf(""r[zmHb.(TH"");
    tag0.hashCode();
    assertFalse(tag0.isData());
}","/**
 *     Gets if this tag is a data only tag.
 *     @return if this tag is a data only tag
 */"
"@Override
public int hashCode() {
    int result = tagName != null ? tagName.hashCode() : 0;
    result = 31 * result + (isBlock ? 1 : 0);
    result = 31 * result + (canContainBlock ? 1 : 0);
    result = 31 * result + (canContainInline ? 1 : 0);
    result = 31 * result + (optionalClosing ? 1 : 0);
    result = 31 * result + (empty ? 1 : 0);
    return result;
}","public void test36103() throws Throwable {
    Tag tag0 = Tag.valueOf(""FORM"");
    tag0.hashCode();
}",""
