focal_method,test_prefix,docstring
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test000() throws Throwable {
    String string0 = TokenQueue.unescape(""(9,g5k)gArvQ#q9al"");
    assertNotNull(string0);
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test012() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test013() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test014() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test015() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test016() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertEquals("""", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test017() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test018() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test019() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0110() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0111() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    assertEquals(""Js'S9{B9xJr"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0112() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0113() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0114() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertEquals('\'', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0115() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0116() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0117() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertEquals(""'S9{B9xJr"", tokenQueue0.toString());
}",""
"public String consumeWord() {
    int start = pos;
    while (matchesWord()) pos++;
    return queue.substring(start, pos);
}","public void test0118() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    assertNotNull(string0);
}","/**
 * Retrieves the next run of word type (letter or digit) off the queue.
 * @return String of word characters from queue, or empty string if none.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0121() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0122() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertEquals(""S9{B9xJr"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0123() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertEquals('S', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0124() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0125() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if ((c.equals('\'') || c.equals('""')) && c != open)
                inQuote = !inQuote;
            if (inQuote)
                continue;
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    final String out = (end >= 0) ? queue.substring(start, end) : """";
    return out;
}","public void test0126() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    tokenQueue0.addFirst(""Js'S9{B9xJr"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.chompBalanced('!', '!');
    assertNotNull(string1);
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0228() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertEquals(""s7,]zDXFG>2mpqc'&5"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0229() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertEquals('s', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0230() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0231() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0232() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test0233() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0234() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    assertEquals(""X`2*j.pd*IbJ_s7,]zDXFG>2mpqc'&5"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0235() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0236() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0237() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0238() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    assertEquals('X', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0239() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertEquals(""s7,]zDXFG>2mpqc'&5"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0240() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertEquals('s', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0241() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0242() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0243() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test0244() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""s7,]zDXFG>2mpqc'&5"");
    tokenQueue0.addFirst(""X`2*j.pd*IbJ_"");
    String string0 = tokenQueue0.consumeTo(""s7,]zDXFG>2mpqc'&5"");
    assertNotNull(string0);
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0346() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertEquals('-', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0347() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0348() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0349() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertEquals(""-^1"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0350() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test0351() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0352() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0353() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0354() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0355() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0356() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-^1"");
    tokenQueue0.consume(""-^1"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0457() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0458() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertEquals('.', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0459() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0460() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertEquals("".k"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0461() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test0462() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0463() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0464() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals('.', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0465() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0466() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals("".k"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0467() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0468() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("".k"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test0569() throws Throwable {
    String string0 = TokenQueue.unescape(""\\1hrMjv"");
    assertNotNull(string0);
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test0671() throws Throwable {
    String string0 = TokenQueue.unescape("""");
    assertNotNull(string0);
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0773() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0774() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0775() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    assertEquals('7', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0776() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test0777() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0778() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    String string0 = tokenQueue0.toString();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0779() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    String string0 = tokenQueue0.toString();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0780() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    String string0 = tokenQueue0.toString();
    assertEquals('7', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0781() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    String string0 = tokenQueue0.toString();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0782() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7$@{0)7d@9 2zNlqO"");
    String string0 = tokenQueue0.toString();
    assertNotNull(string0);
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0889() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0890() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test0891() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0892() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0893() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public String remainder() {
    final String remainder = queue.substring(pos, queue.length());
    pos = queue.length();
    return remainder;
}","public void test0894() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.remainder();
    assertNotNull(string0);
}","/**
 *     Consume and return whatever is left on the queue.
 *     @return remained of queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test0996() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test0997() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertEquals(""$79t<8"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test0998() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test0999() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertEquals('$', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test09100() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test09101() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test09102() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertEquals('7', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test09103() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test09104() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertEquals(""79t<8"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test09105() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test09106() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if ((c.equals('\'') || c.equals('""')) && c != open)
                inQuote = !inQuote;
            if (inQuote)
                continue;
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    final String out = (end >= 0) ? queue.substring(start, end) : """";
    return out;
}","public void test09107() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    assertNotNull(string0);
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test09109() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertEquals('7', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test09110() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test09111() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertEquals(""79t<8"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test09112() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test09113() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test09114() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    String string0 = tokenQueue0.chompBalanced('*', 'C');
    char char0 = tokenQueue0.peek();
    assertEquals('7', char0);
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test10121() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test10122() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test10123() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test10124() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test10125() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesCS(String seq) {
    return queue.startsWith(seq, pos);
}","public void test10126() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchesCS("""");
    assertTrue(boolean0);
}","/**
 * Case sensitive match test.
 * @param seq string to case sensitively check for
 * @return true if matched, false if not
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test11127() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test11128() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test11129() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test11130() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertEquals(""Js'S9{B9xJrJs'S9{B9xJr"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test11131() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test11132() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test11133() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test11134() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test11135() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test11136() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertEquals(""Js'S9{B9xJrJs'S9{B9xJr"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test11137() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test11138() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    boolean boolean0 = tokenQueue0.matches(""org.jsoup.parser.TokenQueue"");
    assertFalse(boolean0);
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test12139() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test12140() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertEquals('C', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test12141() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertEquals(""C-c}Cvo"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test12142() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test12143() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test12144() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test12145() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test12146() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertEquals(""}Cvo"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test12147() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertEquals('}', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test12148() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test12149() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeAttributeKey() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':'))) pos++;
    return queue.substring(start, pos);
}","public void test12150() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    assertNotNull(string0);
}","/**
 *     Consume an attribute key off the queue (letter, digit, -, _, :"")
 *     @return attribute key
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test12153() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test12154() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test12155() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test12156() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test12157() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test12158() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    String string0 = tokenQueue0.consumeAttributeKey();
    String string1 = tokenQueue0.consumeTo(""C-c}Cvo"");
    assertNotNull(string1);
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test13160() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test13161() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertEquals(':', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test13162() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test13163() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertEquals("":8l8 "", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test13164() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test13165() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test13166() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test13167() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals(':', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test13168() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test13169() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals("":8l8 "", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test13170() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeCssIdentifier() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny('-', '_'))) pos++;
    return queue.substring(start, pos);
}","public void test13171() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertNotNull(string0);
}","/**
 *     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
 *     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
 *     @return identifier
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test14173() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertEquals('x', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test14174() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test14175() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test14176() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test14177() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertEquals(""xc?1>u8j]awS\""t\""PufP"", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test14178() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test14179() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test14180() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test14181() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertEquals('?', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test14182() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test14183() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertEquals(""?1>u8j]awS\""t\""PufP"", tokenQueue0.toString());
}",""
"public String consumeTagName() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-'))) pos++;
    return queue.substring(start, pos);
}","public void test14184() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    assertNotNull(string0);
}","/**
 * Consume an tag name off the queue (word or :, _, -)
 *
 * @return tag name
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test14186() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertEquals(""1>u8j]awS\""t\""PufP"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test14187() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test14188() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test14189() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test14190() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertEquals('1', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test14191() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    assertEquals('?', char0);
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test14192() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertFalse(char1 == char0);
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test14193() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test14194() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test14195() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertEquals('>', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test14196() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test14197() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    String string0 = tokenQueue0.consumeTagName();
    char char0 = tokenQueue0.consume();
    char char1 = tokenQueue0.consume();
    assertEquals("">u8j]awS\""t\""PufP"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test15199() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test15200() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test15201() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test15202() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test15203() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertEquals(""JfT\""0wbkOCfxRdb%F"", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test15204() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test15205() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test15206() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertEquals(""fT\""0wbkOCfxRdb%F"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test15207() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test15208() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertEquals('f', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test15209() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test15210() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""JfT\""0wbkOCfxRdb%F"");
    char char0 = tokenQueue0.consume();
    assertEquals('J', char0);
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public static String unescape(String in) {
    StringBuilder out = new StringBuilder();
    char last = 0;
    for (char c : in.toCharArray()) {
        if (c == ESC) {
            if (last != 0 && last == ESC)
                out.append(c);
        } else
            out.append(c);
        last = c;
    }
    return out.toString();
}","public void test16211() throws Throwable {
    // Undeclared exception!
    try {
        TokenQueue.unescape((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 * Unescaped a \ escaped string.
 * @param in backslash escaped string
 * @return unescaped string
 */"
"public boolean matchesCS(String seq) {
    return queue.startsWith(seq, pos);
}","public void test17218() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""C-c}Cvo"");
    // Undeclared exception!
    try {
        tokenQueue0.matchesCS((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Case sensitive match test.
 * @param seq string to case sensitively check for
 * @return true if matched, false if not
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test18219() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertEquals(""kBNV|dXq&bBD1O"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test18220() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test18221() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test18222() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test18223() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertEquals('k', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test18224() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test18225() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    // Undeclared exception!
    try {
        tokenQueue0.matchesAny((char[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test19232() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    // Undeclared exception!
    try {
        tokenQueue0.matches((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test20233() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test20234() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test20235() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertEquals('P', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test20236() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test20237() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertEquals(""PsQsP"", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test20238() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test20239() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    // Undeclared exception!
    try {
        tokenQueue0.matchChomp((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test21246() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToIgnoreCase("""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test22247() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test22248() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertEquals(""1^=$YvJ?!Czi]S{%s"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test22249() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test22250() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertEquals('1', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test22251() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test22252() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test22253() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""1^=$YvJ?!Czi]S{%s"");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToIgnoreCase((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test23254() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test23255() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertEquals('W', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test23256() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test23257() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertEquals(""WPI"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test23258() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test23259() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"// todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this
// is is a case sensitive time...
public String consumeToAny(String... seq) {
    int start = pos;
    while (!isEmpty() && !matchesAny(seq)) {
        pos++;
    }
    return queue.substring(start, pos);
}","public void test23260() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""WPI"");
    // Undeclared exception!
    try {
        tokenQueue0.consumeToAny((String[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 *     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.
 *     @param seq any number of terminators to consume to. <b>Case insensitive.</b>
 *     @return consumed string
 */"
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test24267() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.consumeTo((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test25268() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test25269() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertEquals(""7LS<jn2]+9v"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test25270() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test25271() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test25272() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertEquals('7', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test25273() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public void consume(String seq) {
    if (!matches(seq))
        throw new IllegalStateException(""Queue did not match expected sequence"");
    int len = seq.length();
    if (len > remainingLength())
        throw new IllegalStateException(""Queue not long enough to consume sequence"");
    pos += len;
}","public void test25274() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""7LS<jn2]+9v"");
    // Undeclared exception!
    try {
        tokenQueue0.consume((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
 * throw an illegal state exception -- but you should be running match() against that condition.
 *     <p>
 *     Case insensitive.
 * @param seq sequence to remove from head of queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test26275() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertEquals("";}&+Bk.?"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test26276() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test26277() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertEquals(';', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test26278() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test26279() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test26280() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test26281() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test26282() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test26283() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test26284() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test26285() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test26286() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    assertNotNull(string0);
}",""
"public char consume() {
    return queue.charAt(pos++);
}","public void test26288() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("";}&+Bk.?"");
    String string0 = tokenQueue0.consumeToIgnoreCase(""org.jsoup.parser.TokenQueue"");
    // Undeclared exception!
    try {
        tokenQueue0.consume();
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"public String chompToIgnoreCase(String seq) {
    // case insensitive scan
    String data = consumeToIgnoreCase(seq);
    matchChomp(seq);
    return data;
}","public void test27295() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.chompToIgnoreCase("""");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"public String chompToIgnoreCase(String seq) {
    // case insensitive scan
    String data = consumeToIgnoreCase(seq);
    matchChomp(seq);
    return data;
}","public void test28302() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String[] stringArray0 = new String[5];
    // Undeclared exception!
    try {
        tokenQueue0.chompToIgnoreCase(stringArray0[1]);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test29303() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertEquals(""8rVVhr["", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test29304() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test29305() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test29306() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertEquals('8', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test29307() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test29308() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public String chompTo(String seq) {
    String data = consumeTo(seq);
    matchChomp(seq);
    return data;
}","public void test29309() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    // Undeclared exception!
    try {
        tokenQueue0.chompTo((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).
 * <p>
 * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go
 * isEmpty() == true).
 * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>
 * @return Data matched from queue.
 */"
"public void addFirst(Character c) {
    addFirst(c.toString());
}","public void test30316() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    // Undeclared exception!
    try {
        tokenQueue0.addFirst((Character) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 *     Add a character to the start of the queue (will be the next character retrieved).
 *     @param c character to add
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test31317() throws Throwable {
    TokenQueue tokenQueue0 = null;
    try {
        tokenQueue0 = new TokenQueue((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Object must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test32318() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertEquals('*', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test32319() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test32320() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertEquals(""*|"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test32321() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test32322() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test32323() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test32324() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertEquals('|', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test32325() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertEquals(""|"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test32326() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test32327() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test32328() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char consume() {
    return queue.charAt(pos++);
}","public void test32329() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    assertEquals('*', char0);
}","/**
 * Consume one character off queue.
 * @return first character on queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test32330() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test32331() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test32332() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test32333() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test32334() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test32335() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    char char0 = tokenQueue0.consume();
    String string0 = tokenQueue0.consumeToIgnoreCase(""*|"");
    assertNotNull(string0);
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test33343() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test33344() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertEquals(':', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test33345() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertEquals("":8l8 "", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test33346() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test33347() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test33348() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    String string0 = tokenQueue0.consumeToIgnoreCase("":8l8 "");
    assertNotNull(string0);
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test34356() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test34357() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test34358() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test34359() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test34360() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeWord() {
    int start = pos;
    while (matchesWord()) pos++;
    return queue.substring(start, pos);
}","public void test34361() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    assertNotNull(string0);
}","/**
 * Retrieves the next run of word type (letter or digit) off the queue.
 * @return String of word characters from queue, or empty string if none.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test34364() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test34365() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test34366() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test34367() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test34368() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeTo(String seq) {
    int offset = queue.indexOf(seq, pos);
    if (offset != -1) {
        String consumed = queue.substring(pos, offset);
        pos += consumed.length();
        return consumed;
    } else {
        return remainder();
    }
}","public void test34369() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    String string0 = tokenQueue0.consumeWord();
    String string1 = tokenQueue0.consumeTo(""PsQsP"");
    assertNotNull(string1);
}","/**
 * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
 * @return The matched data consumed from queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test35379() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    assertEquals('!', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test35380() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    assertEquals(""!"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test35381() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test35382() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test35383() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test35384() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals('!', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test35385() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals(""!"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test35386() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test35387() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test35388() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test35389() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test36390() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test36391() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test36392() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertEquals(""Queue not long enough to consume sequence"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test36393() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test36394() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertEquals('Q', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test36395() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test36396() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test36397() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test36398() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test36399() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test36400() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public String chompToIgnoreCase(String seq) {
    // case insensitive scan
    String data = consumeToIgnoreCase(seq);
    matchChomp(seq);
    return data;
}","public void test36401() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    assertNotNull(string0);
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test36403() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test36404() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test36405() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test36406() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test36407() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test36408() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Queue not long enough to consume sequence"");
    String string0 = tokenQueue0.chompToIgnoreCase(""(@#fgg0X"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test37415() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals('P', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test37416() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test37417() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertEquals(""PsQsP"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test37418() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test37419() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test37420() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""PsQsP"");
    boolean boolean0 = tokenQueue0.matchesWord();
    assertTrue(boolean0);
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test38421() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertEquals("" "", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test38422() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test38423() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test38424() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test38425() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test38426() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test38427() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals("" "", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test38428() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test38429() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test38430() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test38431() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test38432() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertTrue(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test39439() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test39440() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test39441() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals(""$79t<8"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test39442() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test39443() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals('$', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test39444() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""$79t<8"");
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test40451() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertEquals(""["", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test40452() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertEquals('[', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test40453() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test40454() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test40455() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeElementSelector() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny(""*|"", ""|"", ""_"", ""-""))) pos++;
    return queue.substring(start, pos);
}","public void test40456() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    assertNotNull(string0);
}","/**
 * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
 *
 * @return tag name
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test40458() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test40459() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test40460() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test40461() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test40462() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test40463() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test40464() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test40465() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test40466() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test40467() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesWhitespace() {
    return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
}","public void test40468() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""8rVVhr["");
    String string0 = tokenQueue0.consumeElementSelector();
    tokenQueue0.advance();
    boolean boolean0 = tokenQueue0.matchesWhitespace();
    assertFalse(boolean0);
}","/**
 *     Tests if queue starts with a whitespace character.
 *     @return if starts with whitespace
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test41475() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertEquals("":8l8 "", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test41476() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test41477() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertEquals(':', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test41478() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test41479() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test41480() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("":8l8 "");
    boolean boolean0 = tokenQueue0.matchChomp(""|Ey7@T|GTw?"");
    assertFalse(boolean0);
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test42487() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test42488() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test42489() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test42490() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test42491() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchChomp(String seq) {
    if (matches(seq)) {
        pos += seq.length();
        return true;
    } else {
        return false;
    }
}","public void test42492() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    boolean boolean0 = tokenQueue0.matchChomp("""");
    assertTrue(boolean0);
}","/**
 * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
 * queue.
 * @param seq String to search for, and if found, remove from queue.
 * @return true if found and removed, false if not found.
 */"
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test43506() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertArrayEquals(new char[] { '!', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000' }, charArray0);
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test43508() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test43509() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test43510() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals(""!"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test43511() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals('!', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test43512() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    Character character0 = new Character('!');
    tokenQueue0.addFirst(character0);
    char[] charArray0 = new char[6];
    charArray0[0] = '!';
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test44520() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertArrayEquals(new char[] { '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000' }, charArray0);
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test44522() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test44523() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals("" "", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test44524() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test44525() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test44526() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test45528() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test45529() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test45530() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test45531() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertEquals('=', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test45532() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertEquals(""=BxLN+"", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test45533() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test45534() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals(1, stringArray0.length);
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test45535() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test45536() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test45537() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test45538() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals('=', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test45539() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""=BxLN+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals(""=BxLN+"", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test46541() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test46542() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test46543() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertEquals(""-"", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test46544() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test46545() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertEquals('-', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test46546() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test46547() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test46548() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test46549() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test46550() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test46551() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeCssIdentifier() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny('-', '_'))) pos++;
    return queue.substring(start, pos);
}","public void test46552() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertNotNull(string0);
}","/**
 *     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
 *     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
 *     @return identifier
 */"
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test46554() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    String[] stringArray0 = new String[6];
    stringArray0[0] = ""-"";
    // Undeclared exception!
    try {
        tokenQueue0.matchesAny(stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test47555() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test47556() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test47557() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertEquals(""       "", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test47558() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test47559() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test47560() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesAny(String... seq) {
    for (String s : seq) {
        if (matches(s))
            return true;
    }
    return false;
}","public void test47561() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals(0, stringArray0.length);
}","/**
 *     Tests if the next characters match any of the sequences. Case insensitive.
 *     @param seq list of strings to case insensitively check for
 *     @return true of any matched, false if none did
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test47562() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test47563() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test47564() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertEquals(""       "", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test47565() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test47566() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    boolean boolean0 = tokenQueue0.matchesAny(stringArray0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test48574() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test48575() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test48576() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test48577() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test48578() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String consumeToIgnoreCase(String seq) {
    int start = pos;
    String first = seq.substring(0, 1);
    // if first is not cased, use index of
    boolean canScan = first.toLowerCase().equals(first.toUpperCase());
    while (!isEmpty()) {
        if (matches(seq))
            break;
        if (canScan) {
            int skip = queue.indexOf(first, pos) - pos;
            if (// this char is the skip char, but not match, so force advance of pos
            skip == 0)
                pos++;
            else if (// no chance of finding, grab to end
            skip < 0)
                pos = queue.length();
            else
                pos += skip;
        } else
            pos++;
    }
    return queue.substring(start, pos);
}","public void test48579() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    assertNotNull(string0);
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test48581() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test48582() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test48583() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test48584() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test48585() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test48586() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertTrue(boolean0);
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test49593() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test49594() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test49595() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test49596() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test49597() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertEquals("" "", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test49598() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.isEmpty();
    assertFalse(boolean0);
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test50605() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test50606() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test50607() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test50608() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test50609() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public String remainder() {
    final String remainder = queue.substring(pos, queue.length());
    pos = queue.length();
    return remainder;
}","public void test50610() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    String string0 = tokenQueue0.remainder();
    assertNotNull(string0);
}","/**
 *     Consume and return whatever is left on the queue.
 *     @return remained of queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test51612() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test51613() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test51614() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertEquals('|', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test51615() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test51616() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertEquals(""|"", tokenQueue0.toString());
}",""
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test51617() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test51618() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test51619() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test51620() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertEquals('|', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test51621() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test51622() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertEquals(""|"", tokenQueue0.toString());
}",""
"public boolean matches(String seq) {
    return queue.regionMatches(true, pos, seq, 0, seq.length());
}","public void test51623() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""|"");
    boolean boolean0 = tokenQueue0.matches("""");
    assertTrue(boolean0);
}","/**
 * Tests if the next characters on the queue match the sequence. Case insensitive.
 * @param seq String to check queue for.
 * @return true if the next characters match.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test52638() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test52639() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test52640() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test52641() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test52642() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeAttributeKey() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':'))) pos++;
    return queue.substring(start, pos);
}","public void test52643() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeToIgnoreCase(""  "");
    String string1 = tokenQueue0.consumeAttributeKey();
    assertNotNull(string1);
}","/**
 *     Consume an attribute key off the queue (letter, digit, -, _, :"")
 *     @return attribute key
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test53651() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test53652() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test53653() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals(""|dXq&bBD1O"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test53654() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test53655() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertEquals('|', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public String consumeCssIdentifier() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny('-', '_'))) pos++;
    return queue.substring(start, pos);
}","public void test53656() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""kBNV|dXq&bBD1O"");
    String string0 = tokenQueue0.consumeCssIdentifier();
    assertNotNull(string0);
}","/**
 *     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
 *     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
 *     @return identifier
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test54658() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test54659() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test54660() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertEquals(""et1*|7ympryv"", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test54661() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertEquals('e', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test54662() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test54663() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test54664() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertEquals('', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test54665() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test54666() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test54667() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertEquals(""7ympryv"", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test54668() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String consumeElementSelector() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny(""*|"", ""|"", ""_"", ""-""))) pos++;
    return queue.substring(start, pos);
}","public void test54669() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""et1*|7ympryv"");
    String string0 = tokenQueue0.consumeElementSelector();
    assertNotNull(string0);
}","/**
 * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
 *
 * @return tag name
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test55677() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test55678() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test55679() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test55680() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test55681() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertEquals("""", tokenQueue0.toString());
}",""
"public String consumeTagName() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-'))) pos++;
    return queue.substring(start, pos);
}","public void test55682() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    String string0 = tokenQueue0.consumeTagName();
    assertNotNull(string0);
}","/**
 * Consume an tag name off the queue (word or :, _, -)
 *
 * @return tag name
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test56684() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertEquals(""Js'S9{B9xJrJs'S9{B9xJr "", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test56685() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test56686() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test56687() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test56688() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test56689() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test56692() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    assertEquals('H', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test56693() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test56694() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test56695() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test56696() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    assertEquals(""HJs'S9{B9xJrJs'S9{B9xJr "", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test56697() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertEquals(""Js'S9{B9xJrJs'S9{B9xJr "", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test56698() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test56699() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test56700() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertEquals('J', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test56701() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if ((c.equals('\'') || c.equals('""')) && c != open)
                inQuote = !inQuote;
            if (inQuote)
                continue;
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    final String out = (end >= 0) ? queue.substring(start, end) : """";
    return out;
}","public void test56702() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('7', 'H');
    assertNotNull(string0);
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test57717() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test57718() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test57719() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test57720() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test57721() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertEquals("""", tokenQueue0.toString());
}",""
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if ((c.equals('\'') || c.equals('""')) && c != open)
                inQuote = !inQuote;
            if (inQuote)
                continue;
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    final String out = (end >= 0) ? queue.substring(start, end) : """";
    return out;
}","public void test57722() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr "");
    Character character0 = Character.valueOf('H');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('H', 'H');
    assertNotNull(string0);
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test58724() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test58725() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertEquals('I', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test58726() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertEquals(""IsN%4W93r0-\"""", tokenQueue0.toString());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test58727() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test58728() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public TokenQueue(String data) {
    Validate.notNull(data);
    queue = data;
}","public void test58729() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    assertNotNull(tokenQueue0);
}","/**
 *     Create a new TokenQueue.
 *     @param data string of data to back queue.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test58732() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test58733() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test58734() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    assertEquals('*', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test58735() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    assertEquals(""*IsN%4W93r0-\"""", tokenQueue0.toString());
}",""
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test58736() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test58737() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test58738() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertFalse(tokenQueue0.matchesStartTag());
}",""
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test58739() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertFalse(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test58740() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertEquals('\u0000', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test58741() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertTrue(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public String chompBalanced(char open, char close) {
    int start = -1;
    int end = -1;
    int depth = 0;
    char last = 0;
    boolean inQuote = false;
    do {
        if (isEmpty())
            break;
        Character c = consume();
        if (last == 0 || last != ESC) {
            if ((c.equals('\'') || c.equals('""')) && c != open)
                inQuote = !inQuote;
            if (inQuote)
                continue;
            if (c.equals(open)) {
                depth++;
                if (start == -1)
                    start = pos;
            } else if (c.equals(close))
                depth--;
        }
        if (depth > 0 && last != 0)
            // don't include the outer match pair in the return
            end = pos;
        last = c;
    } while (depth > 0);
    final String out = (end >= 0) ? queue.substring(start, end) : """";
    return out;
}","public void test58742() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""IsN%4W93r0-\"""");
    Character character0 = new Character('*');
    tokenQueue0.addFirst(character0);
    String string0 = tokenQueue0.chompBalanced('*', '\uDC05');
    assertNotNull(string0);
}","/**
 * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
 * and leave "" four"" on the queue. Unbalanced openers and closers can quoted (with ' or "") or escaped (with \). Those escapes will be left
 * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
 * contains text strings; use unescape for that.
 * @param open opener
 * @param close closer
 * @return data matched from the queue
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test59744() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[0];
    tokenQueue0.consumeToAny(stringArray0);
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test60745() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    tokenQueue0.consumeCssIdentifier();
    String[] stringArray0 = new String[6];
    tokenQueue0.consumeToAny(stringArray0);
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test61746() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    tokenQueue0.addFirst(""Js'S9{BAxJr"");
    tokenQueue0.consumeToIgnoreCase(""  "");
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test62747() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    tokenQueue0.consumeToIgnoreCase(""  "");
    tokenQueue0.consumeElementSelector();
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test63748() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""xc?1>u8j]awS\""t\""PufP"");
    tokenQueue0.chompTo("""");
    assertEquals('x', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public void consume(String seq) {
    if (!matches(seq))
        throw new IllegalStateException(""Queue did not match expected sequence"");
    int len = seq.length();
    if (len > remainingLength())
        throw new IllegalStateException(""Queue not long enough to consume sequence"");
    pos += len;
}","public void test64749() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<7u"");
    // Undeclared exception!
    try {
        tokenQueue0.consume(""Js'k9{BAx^Vwr"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Queue did not match expected sequence
        //
        verifyException(""org.jsoup.parser.TokenQueue"", e);
    }
}","/**
 * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
 * throw an illegal state exception -- but you should be running match() against that condition.
 *     <p>
 *     Case insensitive.
 * @param seq sequence to remove from head of queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test65750() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    tokenQueue0.consume("""");
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test66751() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ET1.K7YMPRyV"");
    tokenQueue0.consumeElementSelector();
    tokenQueue0.chompTo(""ET1"");
    tokenQueue0.advance();
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test67752() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""-"");
    tokenQueue0.consumeCssIdentifier();
    tokenQueue0.consumeWord();
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test68753() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertEquals("""", tokenQueue0.toString());
}",""
"public boolean consumeWhitespace() {
    boolean seen = false;
    while (matchesWhitespace()) {
        pos++;
        seen = true;
    }
    return seen;
}","public void test68754() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertTrue(boolean0);
}","/**
 * Pulls the next run of whitespace characters of the queue.
 * @return Whether consuming whitespace or not
 */"
"public boolean consumeWhitespace() {
    boolean seen = false;
    while (matchesWhitespace()) {
        pos++;
        seen = true;
    }
    return seen;
}","public void test69755() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<Ru"");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertFalse(boolean0);
}","/**
 * Pulls the next run of whitespace characters of the queue.
 * @return Whether consuming whitespace or not
 */"
"public boolean matchesWord() {
    return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
}","public void test69756() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<Ru"");
    boolean boolean0 = tokenQueue0.consumeWhitespace();
    assertTrue(tokenQueue0.matchesWord());
}","/**
 *     Test if the queue matches a word character (letter or digit).
 *     @return if matches a word character
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test70757() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<Ru"");
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals('<', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test70758() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<Ru"");
    tokenQueue0.consumeWord();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertTrue(boolean0);
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test71759() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<7u"");
    tokenQueue0.consumeElementSelector();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals('<', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test71760() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<7u"");
    tokenQueue0.consumeElementSelector();
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test72761() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<7u"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test72762() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""M<7u"");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals('M', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test73763() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public boolean matchesStartTag() {
    // micro opt for matching ""<x""
    return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos + 1)));
}","public void test73764() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    boolean boolean0 = tokenQueue0.matchesStartTag();
    assertFalse(boolean0);
}",""
"public boolean matchesAny(char... seq) {
    if (isEmpty())
        return false;
    for (char c : seq) {
        if (queue.charAt(pos) == c)
            return true;
    }
    return false;
}","public void test74765() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    char[] charArray0 = new char[9];
    boolean boolean0 = tokenQueue0.matchesAny(charArray0);
    assertFalse(boolean0);
}",""
"public String consumeTagName() {
    int start = pos;
    while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-'))) pos++;
    return queue.substring(start, pos);
}","public void test75766() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeTagName();
    assertEquals("""", string0);
}","/**
 * Consume an tag name off the queue (word or :, _, -)
 *
 * @return tag name
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test75767() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    String string0 = tokenQueue0.consumeTagName();
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"// todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this
// is is a case sensitive time...
public String consumeToAny(String... seq) {
    int start = pos;
    while (!isEmpty() && !matchesAny(seq)) {
        pos++;
    }
    return queue.substring(start, pos);
}","public void test76768() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[6];
    stringArray0[0] = ""       "";
    String string0 = tokenQueue0.consumeToAny(stringArray0);
    assertEquals("""", string0);
}","/**
 *     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.
 *     @param seq any number of terminators to consume to. <b>Case insensitive.</b>
 *     @return consumed string
 */"
"public boolean isEmpty() {
    return remainingLength() == 0;
}","public void test76769() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""       "");
    String[] stringArray0 = new String[6];
    stringArray0[0] = ""       "";
    String string0 = tokenQueue0.consumeToAny(stringArray0);
    assertFalse(tokenQueue0.isEmpty());
}","/**
 * Is the queue empty?
 * @return true if no data left in queue.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test77771() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    char char0 = tokenQueue0.peek();
    assertEquals('\u0000', char0);
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test78772() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""ZPENtVIS-1O4V#f"");
    char char0 = tokenQueue0.peek();
    assertEquals('Z', char0);
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test79773() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""Js'S9{B9xJrJs'S9{B9xJr"");
    Character character0 = new Character('\'');
    tokenQueue0.addFirst(character0);
    tokenQueue0.chompBalanced('\'', '\'');
    assertEquals("""", tokenQueue0.toString());
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test80774() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("""");
    String string0 = tokenQueue0.toString();
    assertEquals("""", string0);
}",""
"@Override
public String toString() {
    return queue.substring(pos);
}","public void test81775() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue(""*|"");
    tokenQueue0.chompToIgnoreCase(""*|"");
    assertEquals("""", tokenQueue0.toString());
}",""
"public char peek() {
    return isEmpty() ? 0 : queue.charAt(pos);
}","public void test82776() throws Throwable {
    TokenQueue tokenQueue0 = new TokenQueue("" "");
    tokenQueue0.matchesCS(""Js'S9{BAxJr"");
    assertEquals(' ', tokenQueue0.peek());
}","/**
 * Retrieves but does not remove the first character from the queue.
 * @return First character, or 0 if empty.
 */"
