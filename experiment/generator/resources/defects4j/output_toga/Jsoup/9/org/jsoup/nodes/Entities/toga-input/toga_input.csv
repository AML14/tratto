focal_method,test_prefix,docstring
"static String unescape(String string) {
    if (!string.contains(""&""))
        return string;
    // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
    Matcher m = unescapePattern.matcher(string);
    // pity matcher can't use stringbuilder, avoid syncs
    StringBuffer accum = new StringBuffer(string.length());
    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                // 2 is hex indicator
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.valueOf(num, base);
            } catch (NumberFormatException e) {
            }
            // skip
        } else {
            String name = m.group(1);
            if (full.containsKey(name))
                charval = full.get(name);
        }
        if (charval != -1 || charval > 0xFFFF) {
            // out of range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            // replace with original string
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}","public void test000() throws Throwable {
    String string0 = Entities.unescape(""\""*8*s&#b8&PCUv"");
    assertEquals(""\""*8*s&#b8&PCUv"", string0);
}",""
"static String unescape(String string) {
    if (!string.contains(""&""))
        return string;
    // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
    Matcher m = unescapePattern.matcher(string);
    // pity matcher can't use stringbuilder, avoid syncs
    StringBuffer accum = new StringBuffer(string.length());
    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                // 2 is hex indicator
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.valueOf(num, base);
            } catch (NumberFormatException e) {
            }
            // skip
        } else {
            String name = m.group(1);
            if (full.containsKey(name))
                charval = full.get(name);
        }
        if (charval != -1 || charval > 0xFFFF) {
            // out of range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            // replace with original string
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}","public void test011() throws Throwable {
    String string0 = Entities.unescape("""");
    assertEquals("""", string0);
}",""
"static String escape(String string, Document.OutputSettings out) {
    return escape(string, out.encoder(), out.escapeMode());
}","public void test022() throws Throwable {
    Document document0 = new Document("""");
    Document.OutputSettings document_OutputSettings0 = document0.new OutputSettings();
    String string0 = Entities.escape("""", document_OutputSettings0);
    assertEquals("""", string0);
}",""
"static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    Map<Character, String> map = escapeMode.getMap();
    for (int pos = 0; pos < string.length(); pos++) {
        Character c = string.charAt(pos);
        if (map.containsKey(c))
            accum.append('&').append(map.get(c)).append(';');
        else if (encoder.canEncode(c))
            accum.append(c.charValue());
        else
            accum.append(""&#"").append((int) c).append(';');
    }
    return accum.toString();
}","public void test033() throws Throwable {
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.base;
    String string0 = Entities.escape(""VJH87i u?7SyC3"", charsetEncoder0, entities_EscapeMode0);
    assertEquals(""VJH87i u?7SyC3"", string0);
}",""
"static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    Map<Character, String> map = escapeMode.getMap();
    for (int pos = 0; pos < string.length(); pos++) {
        Character c = string.charAt(pos);
        if (map.containsKey(c))
            accum.append('&').append(map.get(c)).append(';');
        else if (encoder.canEncode(c))
            accum.append(c.charValue());
        else
            accum.append(""&#"").append((int) c).append(';');
    }
    return accum.toString();
}","public void test044() throws Throwable {
    Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;
    String string0 = Entities.escape("""", (CharsetEncoder) null, entities_EscapeMode0);
    assertEquals("""", string0);
}",""
"static String unescape(String string) {
    if (!string.contains(""&""))
        return string;
    // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
    Matcher m = unescapePattern.matcher(string);
    // pity matcher can't use stringbuilder, avoid syncs
    StringBuffer accum = new StringBuffer(string.length());
    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                // 2 is hex indicator
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.valueOf(num, base);
            } catch (NumberFormatException e) {
            }
            // skip
        } else {
            String name = m.group(1);
            if (full.containsKey(name))
                charval = full.get(name);
        }
        if (charval != -1 || charval > 0xFFFF) {
            // out of range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            // replace with original string
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}","public void test055() throws Throwable {
    // Undeclared exception!
    try {
        Entities.unescape((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Entities"", e);
    }
}",""
"static String escape(String string, Document.OutputSettings out) {
    return escape(string, out.encoder(), out.escapeMode());
}","public void test066() throws Throwable {
    // Undeclared exception!
    try {
        Entities.escape(""vdu)C"", (Document.OutputSettings) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Entities"", e);
    }
}",""
"static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {
    StringBuilder accum = new StringBuilder(string.length() * 2);
    Map<Character, String> map = escapeMode.getMap();
    for (int pos = 0; pos < string.length(); pos++) {
        Character c = string.charAt(pos);
        if (map.containsKey(c))
            accum.append('&').append(map.get(c)).append(';');
        else if (encoder.canEncode(c))
            accum.append(c.charValue());
        else
            accum.append(""&#"").append((int) c).append(';');
    }
    return accum.toString();
}","public void test077() throws Throwable {
    Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;
    // Undeclared exception!
    try {
        Entities.escape((String) null, (CharsetEncoder) null, entities_EscapeMode0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.nodes.Entities"", e);
    }
}",""
"static String unescape(String string) {
    if (!string.contains(""&""))
        return string;
    // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
    Matcher m = unescapePattern.matcher(string);
    // pity matcher can't use stringbuilder, avoid syncs
    StringBuffer accum = new StringBuffer(string.length());
    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                // 2 is hex indicator
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.valueOf(num, base);
            } catch (NumberFormatException e) {
            }
            // skip
        } else {
            String name = m.group(1);
            if (full.containsKey(name))
                charval = full.get(name);
        }
        if (charval != -1 || charval > 0xFFFF) {
            // out of range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            // replace with original string
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}","public void test099() throws Throwable {
    String string0 = Entities.unescape(""*]*&#2K'&paJ^Ut"");
    assertEquals(""*]*\u0002K'&paJ^Ut"", string0);
}",""
"static String unescape(String string) {
    if (!string.contains(""&""))
        return string;
    // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
    Matcher m = unescapePattern.matcher(string);
    // pity matcher can't use stringbuilder, avoid syncs
    StringBuffer accum = new StringBuffer(string.length());
    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
    while (m.find()) {
        int charval = -1;
        String num = m.group(3);
        if (num != null) {
            try {
                // 2 is hex indicator
                int base = m.group(2) != null ? 16 : 10;
                charval = Integer.valueOf(num, base);
            } catch (NumberFormatException e) {
            }
            // skip
        } else {
            String name = m.group(1);
            if (full.containsKey(name))
                charval = full.get(name);
        }
        if (charval != -1 || charval > 0xFFFF) {
            // out of range
            String c = Character.toString((char) charval);
            m.appendReplacement(accum, Matcher.quoteReplacement(c));
        } else {
            // replace with original string
            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
        }
    }
    m.appendTail(accum);
    return accum.toString();
}","public void test1010() throws Throwable {
    String string0 = Entities.unescape(""/`j=ZW-WY&gt;o1vM"");
    assertEquals(""/`j=ZW-WY>o1vM"", string0);
}",""
"static String escape(String string, Document.OutputSettings out) {
    return escape(string, out.encoder(), out.escapeMode());
}","public void test1212() throws Throwable {
    Document document0 = new Document(""/`j=ZW-WY>o1vM"");
    Document.OutputSettings document_OutputSettings0 = document0.new OutputSettings();
    String string0 = Entities.escape(""/`j=ZW-WY>o1vM"", document_OutputSettings0);
    assertEquals(""/`j=ZW-WY&gt;o1vM"", string0);
}",""
