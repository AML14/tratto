focal_method,test_prefix,docstring
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test000() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""^"", ""^"");
    xmlTreeBuilder0.processStartTag(""^"");
    Elements elements0 = document0.getElementsByTag(""^"");
    xmlTreeBuilder0.stack = (ArrayList<Element>) elements0;
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""^"");
    assertTrue(boolean0);
}",""
"void insert(Token.Character token) {
    final String data = token.getData();
    insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));
}","public void test011() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    xmlTreeBuilder0.parseFragment("""", """", parseErrorList0, (ParseSettings) null);
    Token.Character token_Character0 = new Token.Character();
    xmlTreeBuilder0.insert(token_Character0);
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test033() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    StringReader stringReader0 = new StringReader(""6`=!;_v"");
    CharacterReader characterReader0 = new CharacterReader(stringReader0, 0);
    ParseErrorList parseErrorList0 = new ParseErrorList(0, 67);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    xmlTreeBuilder0.parse(stringReader0, ""6`=!;_v"");
    Token.Doctype token_Doctype0 = tokeniser0.doctypePending;
    boolean boolean0 = xmlTreeBuilder0.process(token_Doctype0);
    assertTrue(boolean0);
}",""
"@Override
public String nodeName() {
    return ""#document"";
}","public void test055() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    StringReader stringReader0 = new StringReader("""");
    Document document0 = xmlTreeBuilder0.parse(stringReader0, """");
    assertEquals(""#document"", document0.nodeName());
}",""
"@Override
public String baseUri() {
    return baseUri;
}","public void test066() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""<h5xDRirQxe&hfA."", ""<h5xDRirQxe&hfA."");
    Tokeniser tokeniser0 = xmlTreeBuilder0.tokeniser;
    Token.StartTag token_StartTag0 = tokeniser0.startPending;
    Element element0 = xmlTreeBuilder0.insert(token_StartTag0);
    assertEquals(""<h5xDRirQxe&hfA."", element0.baseUri());
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test077() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.StartTag token_StartTag0 = new Token.StartTag();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.process(token_StartTag0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must be false
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test088() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.CData token_CData0 = new Token.CData(""<!--"");
    Token.TokenType token_TokenType0 = Token.TokenType.Doctype;
    token_CData0.type = token_TokenType0;
    // Undeclared exception!
    try {
        xmlTreeBuilder0.process(token_CData0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.jsoup.parser.Token$CData cannot be cast to org.jsoup.parser.Token$Doctype
        //
        verifyException(""org.jsoup.parser.Token"", e);
    }
}",""
"List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {
    initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);
    runParser();
    return doc.childNodes();
}","public void test099() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    ParseSettings parseSettings0 = new ParseSettings(true, false);
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parseFragment((String) null, "">"", parseErrorList0, parseSettings0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {
    initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);
    runParser();
    return doc.childNodes();
}","public void test1010() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseSettings parseSettings0 = ParseSettings.preserveCase;
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parseFragment("";"", (String) null, (ParseErrorList) null, parseSettings0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BaseURI must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"Document parse(String input, String baseUri) {
    return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
}","public void test1111() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parse((String) null, ""@tlf$1"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.StringReader"", e);
    }
}",""
"Document parse(String input, String baseUri) {
    return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
}","public void test1212() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parse(""cD@LCr`-tuV?;1L@Y"", (String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BaseURI must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"Document parse(Reader input, String baseUri) {
    return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
}","public void test1313() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    StringReader stringReader0 = new StringReader(""6`=!;_v"");
    stringReader0.close();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parse(stringReader0, ""6`=!;_v"");
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.io.IOException: Stream closed
        //
        verifyException(""org.jsoup.parser.CharacterReader"", e);
    }
}",""
"Element insert(Token.StartTag startTag) {
    Tag tag = Tag.valueOf(startTag.name(), settings);
    // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
    Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
    insertNode(el);
    if (startTag.isSelfClosing()) {
        if (// unknown tag, remember this is self closing for output. see above.
        !tag.isKnownTag())
            tag.setSelfClosing();
    } else {
        stack.add(el);
    }
    return el;
}","public void test1414() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.StartTag token_StartTag0 = new Token.StartTag();
    CDataNode cDataNode0 = new CDataNode(""i#IWVpcB''hy7"");
    Attributes attributes0 = cDataNode0.attributes();
    Token.StartTag token_StartTag1 = token_StartTag0.nameAttr(""i#IWVpcB''hy7"", attributes0);
    // Undeclared exception!
    try {
        xmlTreeBuilder0.insert(token_StartTag1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tag"", e);
    }
}",""
"Element insert(Token.StartTag startTag) {
    Tag tag = Tag.valueOf(startTag.name(), settings);
    // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
    Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
    insertNode(el);
    if (startTag.isSelfClosing()) {
        if (// unknown tag, remember this is self closing for output. see above.
        !tag.isKnownTag())
            tag.setSelfClosing();
    } else {
        stack.add(el);
    }
    return el;
}","public void test1515() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.StartTag token_StartTag0 = new Token.StartTag();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.insert(token_StartTag0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must be false
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"void insert(Token.Doctype d) {
    DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());
    doctypeNode.setPubSysKey(d.getPubSysKey());
    insertNode(doctypeNode);
}","public void test1616() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.Doctype token_Doctype0 = new Token.Doctype();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.insert(token_Doctype0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.XmlTreeBuilder"", e);
    }
}",""
"void insert(Token.Comment commentToken) {
    Comment comment = new Comment(commentToken.getData());
    Node insert = comment;
    if (commentToken.bogus) {
        // xml declarations are emitted as bogus comments (which is right for html, but not xml)
        // so we do a bit of a hack and parse the data as an element to pull the attributes out
        String data = comment.getData();
        if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
            Document doc = Jsoup.parse(""<"" + data.substring(1, data.length() - 1) + "">"", baseUri, Parser.xmlParser());
            Element el = doc.child(0);
            insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(""!""));
            insert.attributes().addAll(el.attributes());
        }
    }
    insertNode(insert);
}","public void test1717() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.Comment token_Comment0 = new Token.Comment();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.insert(token_Comment0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TreeBuilder"", e);
    }
}",""
"void insert(Token.Character token) {
    final String data = token.getData();
    insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));
}","public void test1818() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.CData token_CData0 = new Token.CData(""~"");
    // Undeclared exception!
    try {
        xmlTreeBuilder0.insert(token_CData0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TreeBuilder"", e);
    }
}",""
"@Override
protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {
    super.initialiseParse(input, baseUri, errors, settings);
    // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
    stack.add(doc);
    doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
}","public void test1919() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseSettings parseSettings0 = ParseSettings.preserveCase;
    // Undeclared exception!
    try {
        xmlTreeBuilder0.initialiseParse((Reader) null, (String) null, (ParseErrorList) null, parseSettings0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // String input must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test2020() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""_"", ""_"");
    xmlTreeBuilder0.processStartTag(""_"");
    xmlTreeBuilder0.processStartTag(""a"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""_"");
    assertTrue(boolean0);
}",""
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test2121() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""y:u,=jJZmotx%"", ""y:u,=jJZmotx%"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""y:u,=jJZmotx%"");
    assertTrue(boolean0);
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test2222() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.CData token_CData0 = new Token.CData(""x3`?~O_#o@Y{XT"");
    // Undeclared exception!
    try {
        xmlTreeBuilder0.process(token_CData0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.TreeBuilder"", e);
    }
}",""
"void insert(Token.Comment commentToken) {
    Comment comment = new Comment(commentToken.getData());
    Node insert = comment;
    if (commentToken.bogus) {
        // xml declarations are emitted as bogus comments (which is right for html, but not xml)
        // so we do a bit of a hack and parse the data as an element to pull the attributes out
        String data = comment.getData();
        if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
            Document doc = Jsoup.parse(""<"" + data.substring(1, data.length() - 1) + "">"", baseUri, Parser.xmlParser());
            Element el = doc.child(0);
            insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(""!""));
            insert.attributes().addAll(el.attributes());
        }
    }
    insertNode(insert);
}","public void test2323() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseErrorList parseErrorList0 = ParseErrorList.tracking((-1943));
    ParseSettings parseSettings0 = xmlTreeBuilder0.defaultSettings();
    xmlTreeBuilder0.parseFragment(""sflFb)p>v"", ""sflFb)p>v"", parseErrorList0, parseSettings0);
    Tokeniser tokeniser0 = xmlTreeBuilder0.tokeniser;
    Token.Comment token_Comment0 = tokeniser0.commentPending;
    token_Comment0.bogus = true;
    xmlTreeBuilder0.insert(token_Comment0);
}",""
"public boolean hasParent() {
    return parentNode != null;
}","public void test2424() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    StringReader stringReader0 = new StringReader(""li"");
    CharacterReader characterReader0 = new CharacterReader(stringReader0, 0);
    ParseErrorList parseErrorList0 = new ParseErrorList(0, 0);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    xmlTreeBuilder0.parse(stringReader0, ""li"");
    Token.StartTag token_StartTag0 = tokeniser0.startPending;
    CDataNode cDataNode0 = new CDataNode(""li"");
    Attributes attributes0 = cDataNode0.attributes();
    Token.StartTag token_StartTag1 = token_StartTag0.nameAttr(""li"", attributes0);
    token_StartTag1.selfClosing = true;
    Element element0 = xmlTreeBuilder0.insert(token_StartTag1);
    assertTrue(element0.hasParent());
}",""
"public boolean isBlock() {
    return tag.isBlock();
}","public void test2525() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    StringReader stringReader0 = new StringReader(""6`=!;_v"");
    CharacterReader characterReader0 = new CharacterReader(stringReader0, 0);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, (ParseErrorList) null);
    xmlTreeBuilder0.parse(stringReader0, ""6`=!;_v"");
    Token.StartTag token_StartTag0 = tokeniser0.startPending;
    CDataNode cDataNode0 = new CDataNode(""6`=!;_v"");
    Attributes attributes0 = cDataNode0.attributes();
    Token.StartTag token_StartTag1 = token_StartTag0.nameAttr(""6`=!;_v"", attributes0);
    token_StartTag1.selfClosing = true;
    Element element0 = xmlTreeBuilder0.insert(token_StartTag1);
    assertFalse(element0.isBlock());
}","/**
 * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
 * {@code <p> == false}).
 *
 * @return true if block, false if not (and thus inline)
 */"
"Document parse(Reader input, String baseUri) {
    return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
}","public void test2626() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    PipedWriter pipedWriter0 = new PipedWriter();
    PipedReader pipedReader0 = new PipedReader(pipedWriter0);
    // Undeclared exception!
    try {
        xmlTreeBuilder0.parse(pipedReader0, "">cz@9R"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must be true
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test2727() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    ParseErrorList parseErrorList0 = ParseErrorList.tracking((-1943));
    ParseSettings parseSettings0 = xmlTreeBuilder0.defaultSettings();
    xmlTreeBuilder0.parseFragment(""sflFb)p>v"", ""sflFb)p>v"", parseErrorList0, parseSettings0);
    Tokeniser tokeniser0 = xmlTreeBuilder0.tokeniser;
    Token.Comment token_Comment0 = tokeniser0.commentPending;
    xmlTreeBuilder0.process(token_Comment0);
}",""
