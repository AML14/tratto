focal_method,test_prefix,docstring
"void createTempBuffer() {
    dataBuffer = new StringBuilder();
}","public void test000() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#2r95ex"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.createTempBuffer();
}",""
"String appropriateEndTagName() {
    return lastStartTag.tagName;
}","public void test011() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#63322"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.appropriateEndTagName();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emitDoctypePending() {
    emit(doctypePending);
}","public void test022() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.emitDoctypePending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void acknowledgeSelfClosingFlag() {
    selfClosingFlagAcknowledged = true;
}","public void test033() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""invalid n med\""referenece '%s'"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.acknowledgeSelfClosingFlag();
}",""
"void createCommentPending() {
    commentPending = new Token.Comment();
}","public void test044() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    tokeniser0.createCommentPending();
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test056() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""/n;u*Y\""5l:Esx&lH*X"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token token0 = tokeniser0.read();
    assertNotNull(token0);
}",""
"void emitTagPending() {
    tagPending.finaliseTag();
    emit(tagPending);
}","public void test067() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.emitTagPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"void emitCommentPending() {
    emit(commentPending);
}","public void test078() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    // Undeclared exception!
    try {
        tokeniser0.emitCommentPending();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"boolean currentNodeInHtmlNS() {
    // todo: implement namespaces correctly
    return true;
    // Element currentNode = currentNode();
    // return currentNode != null && currentNode.namespace().equals(""HTML"");
}","public void test089() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""o"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    boolean boolean0 = tokeniser0.currentNodeInHtmlNS();
    assertTrue(boolean0);
}",""
"void createDoctypePending() {
    doctypePending = new Token.Doctype();
}","public void test0910() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""FUgfDGN"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.createDoctypePending();
}",""
"TokeniserState getState() {
    return state;
}","public void test1011() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""w"");
    ParseErrorList parseErrorList0 = ParseErrorList.tracking((-15));
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    tokeniser0.getState();
}",""
"Token read() {
    if (!selfClosingFlagAcknowledged) {
        error(""Self closing flag not acknowledged"");
        selfClosingFlagAcknowledged = true;
    }
    while (!isEmitPending) state.read(this, reader);
    // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
    if (charBuffer.length() > 0) {
        String str = charBuffer.toString();
        charBuffer.delete(0, charBuffer.length());
        return new Token.Character(str);
    } else {
        isEmitPending = false;
        return emitPending;
    }
}","public void test1112() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.StartTag token_StartTag0 = new Token.StartTag();
    token_StartTag0.selfClosing = true;
    tokeniser0.emit(token_StartTag0);
    Token token0 = tokeniser0.read();
    assertSame(token0, token_StartTag0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes != null)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1213() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""+M@[uWo/x"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token.EndTag token_EndTag0 = new Token.EndTag(""+M@[uWo/x"");
    tokeniser0.emit(token_EndTag0);
}",""
"void emit(Token token) {
    Validate.isFalse(isEmitPending, ""There is an unread token pending!"");
    emitPending = token;
    isEmitPending = true;
    if (token.type == Token.TokenType.StartTag) {
        Token.StartTag startTag = (Token.StartTag) token;
        lastStartTag = startTag;
        if (startTag.selfClosing)
            selfClosingFlagAcknowledged = false;
    } else if (token.type == Token.TokenType.EndTag) {
        Token.EndTag endTag = (Token.EndTag) token;
        if (endTag.attributes != null)
            error(""Attributes incorrectly present on end tag"");
    }
}","public void test1314() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.tracking(56);
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.EndTag token_EndTag0 = new Token.EndTag(""_#:Z3n,Y"");
    token_EndTag0.newAttribute();
    // Undeclared exception!
    try {
        tokeniser0.emit(token_EndTag0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1517() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""mp;)*|"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Character character0 = new Character('2');
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character1 = tokeniser0.consumeCharacterReference(character0, false);
    assertEquals('\u2213', (char) character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1618() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""quot"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = new Character('q');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1719() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader("" H"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1820() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#X63322"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertEquals('\u3322', (char) character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test1924() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""#6699750"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = new Character('{');
    Character character1 = tokeniser0.consumeCharacterReference(character0, false);
    assertNotNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2026() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#xy422"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2129() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""#2;dD1U^-"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, false);
    assertEquals('\u0002', (char) character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2332() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""Mu=IuX,3}eJfcF+B!"");
    ParseErrorList parseErrorList0 = ParseErrorList.tracking((-1778));
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = Character.valueOf('X');
    Character character1 = tokeniser0.consumeCharacterReference(character0, true);
    assertNull(character1);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2433() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader(""invalid n med\""referenece '%s'"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2534() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""ang7-=@=z}ww=1t"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNull(character0);
}",""
"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
    if (reader.isEmpty())
        return null;
    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
        return null;
    if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
        return null;
    reader.mark();
    if (reader.matchConsume(""#"")) {
        // numbered
        boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
        if (numRef.length() == 0) {
            // didn't match anything
            characterReferenceError(""numeric reference with no numerals"");
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        int charval = -1;
        try {
            int base = isHexMode ? 16 : 10;
            charval = Integer.valueOf(numRef, base);
        } catch (NumberFormatException e) {
        }
        // skip
        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
            characterReferenceError(""character outside of valid range"");
            return replacementChar;
        } else {
            // todo: implement number replacement table
            // todo: check for extra illegal unicode points as parse errors
            return (char) charval;
        }
    } else {
        // named
        // get as many letters as possible, and look for matching entities.
        String nameRef = reader.consumeLetterThenDigitSequence();
        String origNameRef = new String(nameRef);
        boolean looksLegit = reader.matches(';');
        // found if a base named entity without a ;, or an extended entity with the ;.
        boolean found = false;
        while (nameRef.length() > 0 && !found) {
            if (Entities.isNamedEntity(nameRef))
                found = true;
            else {
                nameRef = nameRef.substring(0, nameRef.length() - 1);
                reader.unconsume();
            }
        }
        if (!found) {
            reader.rewindToMark();
            if (// named with semicolon
            looksLegit)
                characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
            return null;
        }
        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
            // don't want that to match
            reader.rewindToMark();
            return null;
        }
        if (!reader.matchConsume("";""))
            // missing semi
            characterReferenceError(""missing semicolon"");
        return Entities.getCharacterByName(nameRef);
    }
}","public void test2635() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""in|v8Y}xF@"");
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Character character0 = tokeniser0.consumeCharacterReference((Character) null, true);
    assertNotNull(character0);
}",""
"Token.Tag createTagPending(boolean start) {
    tagPending = start ? new Token.StartTag() : new Token.EndTag();
    return tagPending;
}","public void test2738() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    Token.Tag token_Tag0 = tokeniser0.createTagPending(false);
    assertNotNull(token_Tag0);
}",""
"boolean isAppropriateEndTagToken() {
    if (lastStartTag == null)
        return false;
    return tagPending.tagName.equals(lastStartTag.tagName);
}","public void test2941() throws Throwable {
    CharacterReader characterReader0 = new CharacterReader(""e%p@XtA`N856w{D<X"");
    ParseErrorList parseErrorList0 = ParseErrorList.tracking(36);
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    Token.StartTag token_StartTag0 = new Token.StartTag();
    tokeniser0.emit(token_StartTag0);
    // Undeclared exception!
    try {
        tokeniser0.isAppropriateEndTagToken();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.Tokeniser"", e);
    }
}",""
"boolean isAppropriateEndTagToken() {
    if (lastStartTag == null)
        return false;
    return tagPending.tagName.equals(lastStartTag.tagName);
}","public void test3042() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    CharacterReader characterReader0 = new CharacterReader("";"");
    Tokeniser tokeniser0 = new Tokeniser(characterReader0, parseErrorList0);
    boolean boolean0 = tokeniser0.isAppropriateEndTagToken();
    assertFalse(boolean0);
}",""
"void eofError(TokeniserState state) {
    if (errors.canAddError())
        errors.add(new ParseError(reader.pos(), ""Unexpectedly reached end of file (EOF) in input state [%s]"", state));
}","public void test3347() throws Throwable {
    ParseErrorList parseErrorList0 = ParseErrorList.noTracking();
    Tokeniser tokeniser0 = new Tokeniser((CharacterReader) null, parseErrorList0);
    TokeniserState tokeniserState0 = TokeniserState.Rawtext;
    tokeniser0.eofError(tokeniserState0);
}",""
