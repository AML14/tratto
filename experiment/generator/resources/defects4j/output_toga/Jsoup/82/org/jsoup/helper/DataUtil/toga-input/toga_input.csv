focal_method,test_prefix,docstring
"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (// empty body
    input == null)
        return new Document(baseUri);
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);
    Document doc = null;
    boolean fullyRead = false;
    // read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);
    fullyRead = input.read() == -1;
    input.reset();
    // look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null)
        charsetName = bomCharset.charset;
    if (charsetName == null) {
        // determine from meta. safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);
        // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        // if not found, will keep utf-8 as best attempt
        String foundCharset = null;
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv""))
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            if (foundCharset == null && meta.hasAttr(""charset""))
                foundCharset = meta.attr(""charset"");
            if (foundCharset != null)
                break;
        }
        // look for <?xml encoding='ISO-8859-1'?>
        if (foundCharset == null && doc.childNodeSize() > 0) {
            Node first = doc.childNode(0);
            XmlDeclaration decl = null;
            if (first instanceof XmlDeclaration)
                decl = (XmlDeclaration) first;
            else if (first instanceof Comment) {
                Comment comment = (Comment) first;
                if (comment.isXmlDeclaration())
                    decl = comment.asXmlDeclaration();
            }
            if (decl != null) {
                if (decl.name().equalsIgnoreCase(""xml""))
                    foundCharset = decl.attr(""encoding"");
            }
        }
        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
            // need to re-decode. (case insensitive check here to match how validate works)
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null;
        } else if (!fullyRead) {
            doc = null;
        }
    } else {
        // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }
    if (doc == null) {
        if (charsetName == null)
            charsetName = defaultCharset;
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        if (// creating the buffered reader ignores the input pos, so must skip here
        bomCharset != null && bomCharset.offset)
            reader.skip(1);
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (UncheckedIOException e) {
            // io exception when parsing (not seen before because reading the stream as we go)
            throw e.ioException();
        }
        Charset charset = Charset.forName(charsetName);
        doc.outputSettings().charset(charset);
        // some charsets can read but not encode; switch to an encodable charset and update the meta el
    }
    input.close();
    return doc;
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 85;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Parser parser0 = Parser.xmlParser();
    try {
        DataUtil.parseInputStream(byteArrayInputStream0, ""maxSize must be 0 (unlimited) or larger"", ""maxSize must be 0 (unlimited) or larger"", parser0);
        fail(""Expecting exception: UnsupportedEncodingException"");
    } catch (UnsupportedEncodingException e) {
    }
}",""
"@Override
public String baseUri() {
    return baseUri;
}","public void test022() throws Throwable {
    Parser parser0 = Parser.xmlParser();
    Document document0 = DataUtil.parseInputStream((InputStream) null, ""{s :nRKS"", ""{s :nRKS"", parser0);
    assertEquals(""{s :nRKS"", document0.baseUri());
}",""
"public String location() {
    return location;
}","public void test033() throws Throwable {
    Parser parser0 = Parser.xmlParser();
    Document document0 = DataUtil.load((InputStream) null, ""B1{8D6O+?{Yyd8MDK"", ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"", parser0);
    assertEquals(""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"", document0.location());
}","/**
 * Get the URL this Document was parsed from. If the starting URL is a redirect,
 * this will return the final URL from which the document was served from.
 * @return location
 */"
"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (// empty body
    input == null)
        return new Document(baseUri);
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);
    Document doc = null;
    boolean fullyRead = false;
    // read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);
    fullyRead = input.read() == -1;
    input.reset();
    // look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null)
        charsetName = bomCharset.charset;
    if (charsetName == null) {
        // determine from meta. safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);
        // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        // if not found, will keep utf-8 as best attempt
        String foundCharset = null;
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv""))
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            if (foundCharset == null && meta.hasAttr(""charset""))
                foundCharset = meta.attr(""charset"");
            if (foundCharset != null)
                break;
        }
        // look for <?xml encoding='ISO-8859-1'?>
        if (foundCharset == null && doc.childNodeSize() > 0) {
            Node first = doc.childNode(0);
            XmlDeclaration decl = null;
            if (first instanceof XmlDeclaration)
                decl = (XmlDeclaration) first;
            else if (first instanceof Comment) {
                Comment comment = (Comment) first;
                if (comment.isXmlDeclaration())
                    decl = comment.asXmlDeclaration();
            }
            if (decl != null) {
                if (decl.name().equalsIgnoreCase(""xml""))
                    foundCharset = decl.attr(""encoding"");
            }
        }
        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
            // need to re-decode. (case insensitive check here to match how validate works)
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null;
        } else if (!fullyRead) {
            doc = null;
        }
    } else {
        // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }
    if (doc == null) {
        if (charsetName == null)
            charsetName = defaultCharset;
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        if (// creating the buffered reader ignores the input pos, so must skip here
        bomCharset != null && bomCharset.offset)
            reader.skip(1);
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (UncheckedIOException e) {
            // io exception when parsing (not seen before because reading the stream as we go)
            throw e.ioException();
        }
        Charset charset = Charset.forName(charsetName);
        doc.outputSettings().charset(charset);
        // some charsets can read but not encode; switch to an encodable charset and update the meta el
    }
    input.close();
    return doc;
}","public void test044() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 0);
    // Undeclared exception!
    try {
        DataUtil.parseInputStream(byteArrayInputStream0, (String) null, ""th"", (Parser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.DataUtil"", e);
    }
}",""
"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (// empty body
    input == null)
        return new Document(baseUri);
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);
    Document doc = null;
    boolean fullyRead = false;
    // read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);
    fullyRead = input.read() == -1;
    input.reset();
    // look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null)
        charsetName = bomCharset.charset;
    if (charsetName == null) {
        // determine from meta. safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);
        // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        // if not found, will keep utf-8 as best attempt
        String foundCharset = null;
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv""))
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            if (foundCharset == null && meta.hasAttr(""charset""))
                foundCharset = meta.attr(""charset"");
            if (foundCharset != null)
                break;
        }
        // look for <?xml encoding='ISO-8859-1'?>
        if (foundCharset == null && doc.childNodeSize() > 0) {
            Node first = doc.childNode(0);
            XmlDeclaration decl = null;
            if (first instanceof XmlDeclaration)
                decl = (XmlDeclaration) first;
            else if (first instanceof Comment) {
                Comment comment = (Comment) first;
                if (comment.isXmlDeclaration())
                    decl = comment.asXmlDeclaration();
            }
            if (decl != null) {
                if (decl.name().equalsIgnoreCase(""xml""))
                    foundCharset = decl.attr(""encoding"");
            }
        }
        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
            // need to re-decode. (case insensitive check here to match how validate works)
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null;
        } else if (!fullyRead) {
            doc = null;
        }
    } else {
        // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }
    if (doc == null) {
        if (charsetName == null)
            charsetName = defaultCharset;
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        if (// creating the buffered reader ignores the input pos, so must skip here
        bomCharset != null && bomCharset.offset)
            reader.skip(1);
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (UncheckedIOException e) {
            // io exception when parsing (not seen before because reading the stream as we go)
            throw e.ioException();
        }
        Charset charset = Charset.forName(charsetName);
        doc.outputSettings().charset(charset);
        // some charsets can read but not encode; switch to an encodable charset and update the meta el
    }
    input.close();
    return doc;
}","public void test055() throws Throwable {
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        DataUtil.parseInputStream(pushbackInputStream0, """", """", parser0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}",""
"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {
    if (// empty body
    input == null)
        return new Document(baseUri);
    input = ConstrainableInputStream.wrap(input, bufferSize, 0);
    Document doc = null;
    boolean fullyRead = false;
    // read the start of the stream and look for a BOM or meta charset
    input.mark(bufferSize);
    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);
    fullyRead = input.read() == -1;
    input.reset();
    // look for BOM - overrides any other header or input
    BomCharset bomCharset = detectCharsetFromBom(firstBytes);
    if (bomCharset != null)
        charsetName = bomCharset.charset;
    if (charsetName == null) {
        // determine from meta. safe first parse as UTF-8
        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
        doc = parser.parseInput(docData, baseUri);
        // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
        Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        // if not found, will keep utf-8 as best attempt
        String foundCharset = null;
        for (Element meta : metaElements) {
            if (meta.hasAttr(""http-equiv""))
                foundCharset = getCharsetFromContentType(meta.attr(""content""));
            if (foundCharset == null && meta.hasAttr(""charset""))
                foundCharset = meta.attr(""charset"");
            if (foundCharset != null)
                break;
        }
        // look for <?xml encoding='ISO-8859-1'?>
        if (foundCharset == null && doc.childNodeSize() > 0) {
            Node first = doc.childNode(0);
            XmlDeclaration decl = null;
            if (first instanceof XmlDeclaration)
                decl = (XmlDeclaration) first;
            else if (first instanceof Comment) {
                Comment comment = (Comment) first;
                if (comment.isXmlDeclaration())
                    decl = comment.asXmlDeclaration();
            }
            if (decl != null) {
                if (decl.name().equalsIgnoreCase(""xml""))
                    foundCharset = decl.attr(""encoding"");
            }
        }
        foundCharset = validateCharset(foundCharset);
        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {
            // need to re-decode. (case insensitive check here to match how validate works)
            foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
            charsetName = foundCharset;
            doc = null;
        } else if (!fullyRead) {
            doc = null;
        }
    } else {
        // specified by content type header (or by user on file load)
        Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
    }
    if (doc == null) {
        if (charsetName == null)
            charsetName = defaultCharset;
        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
        if (// creating the buffered reader ignores the input pos, so must skip here
        bomCharset != null && bomCharset.offset)
            reader.skip(1);
        try {
            doc = parser.parseInput(reader, baseUri);
        } catch (UncheckedIOException e) {
            // io exception when parsing (not seen before because reading the stream as we go)
            throw e.ioException();
        }
        Charset charset = Charset.forName(charsetName);
        doc.outputSettings().charset(charset);
        // some charsets can read but not encode; switch to an encodable charset and update the meta el
    }
    input.close();
    return doc;
}","public void test066() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    Parser parser0 = Parser.xmlParser();
    try {
        DataUtil.parseInputStream(pipedInputStream0, (String) null, "";RzBx"", parser0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return parseInputStream(in, charsetName, baseUri, parser);
}","public void test077() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (byte) (-56));
    // Undeclared exception!
    try {
        DataUtil.load((InputStream) byteArrayInputStream0, (String) null, ""map"", (Parser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.DataUtil"", e);
    }
}","/**
 * Parses a Document from an input steam, using the provided Parser.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @param parser alternate {@link Parser#xmlParser() parser} to use.
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());
}","public void test088() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
    try {
        DataUtil.load((InputStream) pushbackInputStream0, ""'{t@(KG04Kq_<$ctRsQ"", ""'{t@(KG04Kq_<$ctRsQ"");
        fail(""Expecting exception: UnsupportedEncodingException"");
    } catch (UnsupportedEncodingException e) {
    }
}","/**
 * Parses a Document from an input steam.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());
}","public void test099() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    try {
        DataUtil.load((InputStream) pipedInputStream0, """", """");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 * Parses a Document from an input steam.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(File in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());
}","public void test1010() throws Throwable {
    // Undeclared exception!
    try {
        DataUtil.load((File) null, ""U\""(.s>>e#=*>"", ""U\""(.s>>e#=*>"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Loads a file to a Document.
 * @param in file to load
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(File in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());
}","public void test1111() throws Throwable {
    File file0 = MockFile.createTempFile(""UTF-16"", ""qrsU(UVwya%h"");
    try {
        DataUtil.load(file0, ""}ToZN/#\""Hzslw/Ey>g"", ""}ToZN/#\""Hzslw/Ey>g"");
        fail(""Expecting exception: UnsupportedEncodingException"");
    } catch (UnsupportedEncodingException e) {
    }
}","/**
 * Loads a file to a Document.
 * @param in file to load
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(File in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());
}","public void test1212() throws Throwable {
    MockFile mockFile0 = new MockFile(""N mU\r irs"");
    try {
        DataUtil.load((File) mockFile0, ""charset"", ""N mU\r irs"");
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Loads a file to a Document.
 * @param in file to load
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"static void crossStreams(final InputStream in, final OutputStream out) throws IOException {
    final byte[] buffer = new byte[bufferSize];
    int len;
    while ((len = in.read(buffer)) != -1) {
        out.write(buffer, 0, len);
    }
}","public void test1313() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(12);
    // Undeclared exception!
    try {
        DataUtil.crossStreams((InputStream) null, byteArrayOutputStream0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.helper.DataUtil"", e);
    }
}","/**
 * Writes the input stream to the output stream. Doesn't close them.
 * @param in input stream to read from
 * @param out output stream to write to
 * @throws IOException on IO error
 */"
"static void crossStreams(final InputStream in, final OutputStream out) throws IOException {
    final byte[] buffer = new byte[bufferSize];
    int len;
    while ((len = in.read(buffer)) != -1) {
        out.write(buffer, 0, len);
    }
}","public void test1414() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    try {
        DataUtil.crossStreams(pipedInputStream0, byteArrayOutputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 * Writes the input stream to the output stream. Doesn't close them.
 * @param in input stream to read from
 * @param out output stream to write to
 * @throws IOException on IO error
 */"
"public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {
    Validate.isTrue(maxSize >= 0, ""maxSize must be 0 (unlimited) or larger"");
    final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);
    return input.readToByteBuffer(maxSize);
}","public void test1515() throws Throwable {
    try {
        DataUtil.readToByteBuffer((InputStream) null, 0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedInputStream"", e);
    }
}","/**
 * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this
 * method is executing on. The data read until being interrupted will be available.
 * @param inStream the input stream to read from
 * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.
 * @return the filled byte buffer
 * @throws IOException if an exception occurs whilst reading from the input stream.
 */"
"public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return parseInputStream(in, charsetName, baseUri, parser);
}","public void test1616() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[1] = (byte) (-29);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    Parser parser0 = Parser.htmlParser();
    // Undeclared exception!
    try {
        DataUtil.load((InputStream) byteArrayInputStream0, (String) null, (String) null, parser0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BaseURI must not be null
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Parses a Document from an input steam, using the provided Parser.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @param parser alternate {@link Parser#xmlParser() parser} to use.
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());
}","public void test1717() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) (-72);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    // Undeclared exception!
    try {
        DataUtil.load((InputStream) byteArrayInputStream0, """", "".f K#;m1veQ?,K1+V3"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Parses a Document from an input steam.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
"static String mimeBoundary() {
    final StringBuilder mime = new StringBuilder(boundaryLength);
    final Random rand = new Random();
    for (int i = 0; i < boundaryLength; i++) {
        mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);
    }
    return mime.toString();
}","public void test1818() throws Throwable {
    String string0 = DataUtil.mimeBoundary();
    assertEquals(""--------------------------------"", string0);
}","/**
 * Creates a random string, suitable for use as a mime boundary
 */"
"static String getCharsetFromContentType(String contentType) {
    if (contentType == null)
        return null;
    Matcher m = charsetPattern.matcher(contentType);
    if (m.find()) {
        String charset = m.group(1).trim();
        charset = charset.replace(""charset="", """");
        return validateCharset(charset);
    }
    return null;
}","public void test1919() throws Throwable {
    String string0 = DataUtil.getCharsetFromContentType(""PUBLIC"");
    assertNull(string0);
}","/**
 * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default
 * will kick in.)
 * @param contentType e.g. ""text/html; charset=EUC-JP""
 * @return ""EUC-JP"", or null if not found. Charset is trimmed and uppercased.
 */"
"static String getCharsetFromContentType(String contentType) {
    if (contentType == null)
        return null;
    Matcher m = charsetPattern.matcher(contentType);
    if (m.find()) {
        String charset = m.group(1).trim();
        charset = charset.replace(""charset="", """");
        return validateCharset(charset);
    }
    return null;
}","public void test2020() throws Throwable {
    String string0 = DataUtil.getCharsetFromContentType((String) null);
    assertNull(string0);
}","/**
 * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default
 * will kick in.)
 * @param contentType e.g. ""text/html; charset=EUC-JP""
 * @return ""EUC-JP"", or null if not found. Charset is trimmed and uppercased.
 */"
"static String getCharsetFromContentType(String contentType) {
    if (contentType == null)
        return null;
    Matcher m = charsetPattern.matcher(contentType);
    if (m.find()) {
        String charset = m.group(1).trim();
        charset = charset.replace(""charset="", """");
        return validateCharset(charset);
    }
    return null;
}","public void test2121() throws Throwable {
    String string0 = DataUtil.getCharsetFromContentType(""charset="");
    assertNull(string0);
}","/**
 * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default
 * will kick in.)
 * @param contentType e.g. ""text/html; charset=EUC-JP""
 * @return ""EUC-JP"", or null if not found. Charset is trimmed and uppercased.
 */"
"public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {
    Validate.isTrue(maxSize >= 0, ""maxSize must be 0 (unlimited) or larger"");
    final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);
    return input.readToByteBuffer(maxSize);
}","public void test2222() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(byteArrayInputStream0);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(bufferedInputStream0, byteArrayInputStream0);
    // Undeclared exception!
    try {
        DataUtil.readToByteBuffer(sequenceInputStream0, (-30));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // maxSize must be 0 (unlimited) or larger
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this
 * method is executing on. The data read until being interrupted will be available.
 * @param inStream the input stream to read from
 * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.
 * @return the filled byte buffer
 * @throws IOException if an exception occurs whilst reading from the input stream.
 */"
"@Override
public String baseUri() {
    return baseUri;
}","public void test2323() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    DataInputStream dataInputStream0 = new DataInputStream(byteArrayInputStream0);
    Document document0 = DataUtil.load((InputStream) dataInputStream0, ""UTF-16"", ""--------------------------------"");
    assertEquals(""--------------------------------"", document0.baseUri());
}",""
"@Override
public String baseUri() {
    return baseUri;
}","public void test2424() throws Throwable {
    File file0 = MockFile.createTempFile(""EAjjvqAW3`yfhFko "", (String) null);
    Document document0 = DataUtil.load(file0, (String) null, ""9xl8cN~IO2 d"");
    assertEquals(""9xl8cN~IO2 d"", document0.baseUri());
}",""
"public String location() {
    return location;
}","public void test2525() throws Throwable {
    Document document0 = DataUtil.load((InputStream) null, ""limitedQuirks"", ""limitedQuirks"");
    assertEquals(""limitedQuirks"", document0.location());
}","/**
 * Get the URL this Document was parsed from. If the starting URL is a redirect,
 * this will return the final URL from which the document was served from.
 * @return location
 */"
"static void crossStreams(final InputStream in, final OutputStream out) throws IOException {
    final byte[] buffer = new byte[bufferSize];
    int len;
    while ((len = in.read(buffer)) != -1) {
        out.write(buffer, 0, len);
    }
}","public void test2626() throws Throwable {
    Enumeration<ObjectInputStream> enumeration0 = (Enumeration<ObjectInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(sequenceInputStream0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pushbackInputStream0);
    DataUtil.crossStreams(bufferedInputStream0, (OutputStream) null);
}","/**
 * Writes the input stream to the output stream. Doesn't close them.
 * @param in input stream to read from
 * @param out output stream to write to
 * @throws IOException on IO error
 */"
"public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {
    return parseInputStream(in, charsetName, baseUri, parser);
}","public void test2727() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
    pipedOutputStream0.close();
    try {
        DataUtil.load((InputStream) pipedInputStream0, ""CONTINUE"", ""maxSize must be 0 (unlimited) or larger"", (Parser) null);
        fail(""Expecting exception: UnsupportedEncodingException"");
    } catch (UnsupportedEncodingException e) {
    }
}","/**
 * Parses a Document from an input steam, using the provided Parser.
 * @param in input stream to parse. You will need to close it.
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @param parser alternate {@link Parser#xmlParser() parser} to use.
 * @return Document
 * @throws IOException on IO error
 */"
"public static Document load(File in, String charsetName, String baseUri) throws IOException {
    return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());
}","public void test2828() throws Throwable {
    File file0 = MockFile.createTempFile(""y7:"", ""y7:"");
    // Undeclared exception!
    try {
        DataUtil.load(file0, """", ""[\""']"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML
        //
        verifyException(""org.jsoup.helper.Validate"", e);
    }
}","/**
 * Loads a file to a Document.
 * @param in file to load
 * @param charsetName character set of input
 * @param baseUri base URI of document, to resolve relative links against
 * @return Document
 * @throws IOException on IO error
 */"
