focal_method,test_prefix,docstring
"Document parse(String input, String baseUri) {
    return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
}","public void test000() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""PK<!!F/EC"", ""PK<!!F/EC"");
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test022() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Token.Doctype token_Doctype0 = new Token.Doctype();
    // Undeclared exception!
    try {
        xmlTreeBuilder0.process(token_Doctype0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jsoup.parser.XmlTreeBuilder"", e);
    }
}",""
"@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch(token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case // could put some normalisation here if desired
        EOF:
            break;
        default:
            Validate.fail(""Unexpected token type: "" + token.type);
    }
    return true;
}","public void test033() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""colgroup"", ""colgroup"");
    Token.StartTag token_StartTag0 = new Token.StartTag();
    Token.Tag token_Tag0 = token_StartTag0.name(""colgroup"");
    token_Tag0.selfClosing = true;
    boolean boolean0 = xmlTreeBuilder0.process(token_StartTag0);
    assertTrue(boolean0);
}",""
"public final int childNodeSize() {
    return childNodes.size();
}","public void test044() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""<P% a$ne?tFiy/>d"", ""<P% a$ne?tFiy/>d"");
    assertEquals(2, document0.childNodeSize());
}","/**
 * Get the number of child nodes that this node holds.
 * @return the number of child nodes that this node holds.
 */"
"public boolean isBlock() {
    return tag.isBlock();
}","public void test055() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""<!--"", ""<!--"");
    assertFalse(document0.isBlock());
}","/**
 * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
 * {@code <p> == false}).
 *
 * @return true if block, false if not (and thus inline)
 */"
"public String baseUri() {
    return baseUri;
}","public void test066() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""<!"", ""<!"");
    assertEquals(""<!"", document0.baseUri());
}","/**
 *     Get the base URI of this node.
 *     @return base URI
 */"
"@Override
public String nodeName() {
    return ""#document"";
}","public void test077() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""jT: <?n&F$mcbjfk"", ""jT: <?n&F$mcbjfk"");
    assertEquals(""#document"", document0.nodeName());
}",""
"public boolean isBlock() {
    return tag.isBlock();
}","public void test088() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    Document document0 = xmlTreeBuilder0.parse(""r<!YXKBj"", ""r<!YXKBj"");
    assertFalse(document0.isBlock());
}","/**
 * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
 * {@code <p> == false}).
 *
 * @return true if block, false if not (and thus inline)
 */"
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test099() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""colgroup"", ""colgroup"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""colgroup"");
    assertTrue(boolean0);
}",""
"protected boolean processEndTag(String name) {
    if (currentToken == end) {
        // don't recycle an in-use token
        return process(new Token.EndTag().name(name));
    }
    return process(end.reset().name(name));
}","public void test1010() throws Throwable {
    XmlTreeBuilder xmlTreeBuilder0 = new XmlTreeBuilder();
    xmlTreeBuilder0.parse(""b<sefomn>"", ""b<sefomn>"");
    boolean boolean0 = xmlTreeBuilder0.processEndTag(""#document"");
    assertTrue(boolean0);
}",""
