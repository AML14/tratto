focal_method,test_prefix,docstring
"public static int readFully(InputStream input, byte[] b) throws IOException {
    return readFully(input, b, 0, b.length);
}","public void test001() throws Throwable {
    byte[] byteArray0 = new byte[7];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    byteArrayInputStream0.read();
    int int0 = IOUtils.readFully((InputStream) byteArrayInputStream0, byteArray0);
    assertEquals(6, int0);
}","/**
 * Reads as much from input as possible to fill the given array.
 *
 * <p>This method may invoke read repeatedly to fill the array and
 * only read less bytes than the length of the array if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @return the number of bytes actually read
 * @throws IOException
 */"
"public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    return available - numToSkip;
}","public void test012() throws Throwable {
    byte[] byteArray0 = new byte[0];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    long long0 = IOUtils.skip(byteArrayInputStream0, 0L);
    assertEquals(0L, long0);
}","/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */"
"// toByteArray(InputStream) copied from:
// commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941
// January 8th, 2013
//
// Assuming our copy() works just as well as theirs!  :-)
/**
 * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
 * <p>
 * This method buffers the input internally, so there is no need to use a
 * <code>BufferedInputStream</code>.
 *
 * @param input  the <code>InputStream</code> to read from
 * @return the requested byte array
 * @throws NullPointerException if the input is null
 * @throws IOException if an I/O error occurs
 * @since 1.5
 */
public static byte[] toByteArray(final InputStream input) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
}","public void test034() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    byte[] byteArray1 = IOUtils.toByteArray(byteArrayInputStream0);
    assertEquals(1, byteArray1.length);
}",""
"public static long copy(final InputStream input, final OutputStream output) throws IOException {
    return copy(input, output, COPY_BUF_SIZE);
}","public void test045() throws Throwable {
    byte[] byteArray0 = new byte[0];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    long long0 = IOUtils.copy((InputStream) byteArrayInputStream0, (OutputStream) null);
    assertEquals(0L, long0);
}","/**
 * Copies the content of a InputStream into an OutputStream.
 * Uses a default buffer size of 8024 bytes.
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @throws IOException
 *             if an error occurs
 */"
"// toByteArray(InputStream) copied from:
// commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941
// January 8th, 2013
//
// Assuming our copy() works just as well as theirs!  :-)
/**
 * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
 * <p>
 * This method buffers the input internally, so there is no need to use a
 * <code>BufferedInputStream</code>.
 *
 * @param input  the <code>InputStream</code> to read from
 * @return the requested byte array
 * @throws NullPointerException if the input is null
 * @throws IOException if an I/O error occurs
 * @since 1.5
 */
public static byte[] toByteArray(final InputStream input) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
}","public void test056() throws Throwable {
    // Undeclared exception!
    try {
        IOUtils.toByteArray((InputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}",""
"// toByteArray(InputStream) copied from:
// commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941
// January 8th, 2013
//
// Assuming our copy() works just as well as theirs!  :-)
/**
 * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
 * <p>
 * This method buffers the input internally, so there is no need to use a
 * <code>BufferedInputStream</code>.
 *
 * @param input  the <code>InputStream</code> to read from
 * @return the requested byte array
 * @throws NullPointerException if the input is null
 * @throws IOException if an I/O error occurs
 * @since 1.5
 */
public static byte[] toByteArray(final InputStream input) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
}","public void test067() throws Throwable {
    byte[] byteArray0 = new byte[0];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (-1), 2752);
    // Undeclared exception!
    try {
        IOUtils.toByteArray(byteArrayInputStream0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.ByteArrayInputStream"", e);
    }
}",""
"// toByteArray(InputStream) copied from:
// commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941
// January 8th, 2013
//
// Assuming our copy() works just as well as theirs!  :-)
/**
 * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
 * <p>
 * This method buffers the input internally, so there is no need to use a
 * <code>BufferedInputStream</code>.
 *
 * @param input  the <code>InputStream</code> to read from
 * @return the requested byte array
 * @throws NullPointerException if the input is null
 * @throws IOException if an I/O error occurs
 * @since 1.5
 */
public static byte[] toByteArray(final InputStream input) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
}","public void test078() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    try {
        IOUtils.toByteArray(pipedInputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    return available - numToSkip;
}","public void test089() throws Throwable {
    // Undeclared exception!
    try {
        IOUtils.skip((InputStream) null, 2792L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */"
"public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    return available - numToSkip;
}","public void test0910() throws Throwable {
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream((InputStream) null);
    DataInputStream dataInputStream0 = new DataInputStream(bufferedInputStream0);
    try {
        IOUtils.skip(dataInputStream0, 1622L);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedInputStream"", e);
    }
}","/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */"
"public static int readFully(InputStream input, byte[] b, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > b.length) {
        throw new IndexOutOfBoundsException();
    }
    int count = 0, x = 0;
    while (count != len) {
        x = input.read(b, offset + count, len - count);
        if (x == -1) {
            break;
        }
        count += x;
    }
    return count;
}","public void test1011() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    DataInputStream dataInputStream0 = new DataInputStream(sequenceInputStream0);
    // Undeclared exception!
    try {
        IOUtils.readFully((InputStream) dataInputStream0, (byte[]) null, 543, 8024);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array
 * with the given amount of bytes.
 *
 * <p>This method may invoke read repeatedly to read the bytes and
 * only read less bytes than the requested length if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @param offset offset into the buffer to start filling at
 * @param len of bytes to read
 * @return the number of bytes actually read
 * @throws IOException
 *             if an I/O error has occurred
 */"
"public static int readFully(InputStream input, byte[] b) throws IOException {
    return readFully(input, b, 0, b.length);
}","public void test1112() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(sequenceInputStream0);
    // Undeclared exception!
    try {
        IOUtils.readFully((InputStream) pushbackInputStream0, (byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array.
 *
 * <p>This method may invoke read repeatedly to fill the array and
 * only read less bytes than the length of the array if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @return the number of bytes actually read
 * @throws IOException
 */"
"public static int readFully(InputStream input, byte[] b) throws IOException {
    return readFully(input, b, 0, b.length);
}","public void test1213() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    byte[] byteArray0 = new byte[5];
    try {
        IOUtils.readFully((InputStream) dataInputStream0, byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array.
 *
 * <p>This method may invoke read repeatedly to fill the array and
 * only read less bytes than the length of the array if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @return the number of bytes actually read
 * @throws IOException
 */"
"public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {
    final byte[] buffer = new byte[buffersize];
    int n = 0;
    long count = 0;
    while (-1 != (n = input.read(buffer))) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}","public void test1314() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    // Undeclared exception!
    try {
        IOUtils.copy((InputStream) null, (OutputStream) byteArrayOutputStream0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Copies the content of a InputStream into an OutputStream
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @param buffersize
 *            the buffer size to use
 * @throws IOException
 *             if an error occurs
 */"
"public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {
    final byte[] buffer = new byte[buffersize];
    int n = 0;
    long count = 0;
    while (-1 != (n = input.read(buffer))) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}","public void test1415() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(528);
    try {
        IOUtils.copy((InputStream) pipedInputStream0, (OutputStream) byteArrayOutputStream0, 528);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 * Copies the content of a InputStream into an OutputStream
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @param buffersize
 *            the buffer size to use
 * @throws IOException
 *             if an error occurs
 */"
"public static long copy(final InputStream input, final OutputStream output) throws IOException {
    return copy(input, output, COPY_BUF_SIZE);
}","public void test1516() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""@9R#W8%Q&dA}l\"""");
    // Undeclared exception!
    try {
        IOUtils.copy((InputStream) null, (OutputStream) mockPrintStream0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Copies the content of a InputStream into an OutputStream.
 * Uses a default buffer size of 8024 bytes.
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @throws IOException
 *             if an error occurs
 */"
"public static long copy(final InputStream input, final OutputStream output) throws IOException {
    return copy(input, output, COPY_BUF_SIZE);
}","public void test1617() throws Throwable {
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null);
    try {
        IOUtils.copy((InputStream) pushbackInputStream0, (OutputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}","/**
 * Copies the content of a InputStream into an OutputStream.
 * Uses a default buffer size of 8024 bytes.
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @throws IOException
 *             if an error occurs
 */"
"public static int readFully(InputStream input, byte[] b, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > b.length) {
        throw new IndexOutOfBoundsException();
    }
    int count = 0, x = 0;
    while (count != len) {
        x = input.read(b, offset + count, len - count);
        if (x == -1) {
            break;
        }
        count += x;
    }
    return count;
}","public void test1718() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    int int0 = IOUtils.readFully((InputStream) byteArrayInputStream0, byteArray0, 0, (int) (byte) 0);
    assertEquals(0, int0);
}","/**
 * Reads as much from input as possible to fill the given array
 * with the given amount of bytes.
 *
 * <p>This method may invoke read repeatedly to read the bytes and
 * only read less bytes than the requested length if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @param offset offset into the buffer to start filling at
 * @param len of bytes to read
 * @return the number of bytes actually read
 * @throws IOException
 *             if an I/O error has occurred
 */"
"public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {
    final byte[] buffer = new byte[buffersize];
    int n = 0;
    long count = 0;
    while (-1 != (n = input.read(buffer))) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}","public void test1820() throws Throwable {
    byte[] byteArray0 = new byte[7];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    long long0 = IOUtils.copy((InputStream) byteArrayInputStream0, (OutputStream) byteArrayOutputStream0, (int) (byte) 114);
    assertEquals(7L, long0);
}","/**
 * Copies the content of a InputStream into an OutputStream
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @param buffersize
 *            the buffer size to use
 * @throws IOException
 *             if an error occurs
 */"
"public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {
    final byte[] buffer = new byte[buffersize];
    int n = 0;
    long count = 0;
    while (-1 != (n = input.read(buffer))) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}","public void test1921() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""a E!VIPqv^n? *"");
    long long0 = IOUtils.copy((InputStream) sequenceInputStream0, (OutputStream) mockFileOutputStream0, 0);
    assertEquals(0L, long0);
}","/**
 * Copies the content of a InputStream into an OutputStream
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @param buffersize
 *            the buffer size to use
 * @throws IOException
 *             if an error occurs
 */"
"public static void closeQuietly(Closeable c) {
    if (c != null) {
        try {
            c.close();
        } catch (IOException ignored) {
            // NOPMD
        }
    }
}","public void test2022() throws Throwable {
    Enumeration<MockFileInputStream> enumeration0 = (Enumeration<MockFileInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false, true).when(enumeration0).hasMoreElements();
    doReturn((Object) null).when(enumeration0).nextElement();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    // Undeclared exception!
    try {
        IOUtils.closeQuietly(sequenceInputStream0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.SequenceInputStream"", e);
    }
}","/**
 * Closes the given Closeable and swallows any IOException that may occur.
 * @param c Closeable to close, can be null
 * @since 1.7
 */"
"public static void closeQuietly(Closeable c) {
    if (c != null) {
        try {
            c.close();
        } catch (IOException ignored) {
            // NOPMD
        }
    }
}","public void test2123() throws Throwable {
    IOUtils.closeQuietly((Closeable) null);
}","/**
 * Closes the given Closeable and swallows any IOException that may occur.
 * @param c Closeable to close, can be null
 * @since 1.7
 */"
"public static int readFully(InputStream input, byte[] b) throws IOException {
    return readFully(input, b, 0, b.length);
}","public void test2224() throws Throwable {
    byte[] byteArray0 = new byte[0];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
    int int0 = IOUtils.readFully((InputStream) sequenceInputStream0, byteArray0);
    assertEquals(0, int0);
}","/**
 * Reads as much from input as possible to fill the given array.
 *
 * <p>This method may invoke read repeatedly to fill the array and
 * only read less bytes than the length of the array if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @return the number of bytes actually read
 * @throws IOException
 */"
"public static int readFully(InputStream input, byte[] b, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > b.length) {
        throw new IndexOutOfBoundsException();
    }
    int count = 0, x = 0;
    while (count != len) {
        x = input.read(b, offset + count, len - count);
        if (x == -1) {
            break;
        }
        count += x;
    }
    return count;
}","public void test2325() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    // Undeclared exception!
    try {
        IOUtils.readFully((InputStream) byteArrayInputStream0, byteArray0, 543, 8024);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array
 * with the given amount of bytes.
 *
 * <p>This method may invoke read repeatedly to read the bytes and
 * only read less bytes than the requested length if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @param offset offset into the buffer to start filling at
 * @param len of bytes to read
 * @return the number of bytes actually read
 * @throws IOException
 *             if an I/O error has occurred
 */"
"public static int readFully(InputStream input, byte[] b, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > b.length) {
        throw new IndexOutOfBoundsException();
    }
    int count = 0, x = 0;
    while (count != len) {
        x = input.read(b, offset + count, len - count);
        if (x == -1) {
            break;
        }
        count += x;
    }
    return count;
}","public void test2426() throws Throwable {
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    // Undeclared exception!
    try {
        IOUtils.readFully((InputStream) byteArrayInputStream0, byteArray0, (int) (byte) (-44), 0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array
 * with the given amount of bytes.
 *
 * <p>This method may invoke read repeatedly to read the bytes and
 * only read less bytes than the requested length if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @param offset offset into the buffer to start filling at
 * @param len of bytes to read
 * @return the number of bytes actually read
 * @throws IOException
 *             if an I/O error has occurred
 */"
"public static int readFully(InputStream input, byte[] b, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > b.length) {
        throw new IndexOutOfBoundsException();
    }
    int count = 0, x = 0;
    while (count != len) {
        x = input.read(b, offset + count, len - count);
        if (x == -1) {
            break;
        }
        count += x;
    }
    return count;
}","public void test2527() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 1, (-809));
    // Undeclared exception!
    try {
        IOUtils.readFully((InputStream) byteArrayInputStream0, byteArray0, (int) (byte) 1, (-322));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}","/**
 * Reads as much from input as possible to fill the given array
 * with the given amount of bytes.
 *
 * <p>This method may invoke read repeatedly to read the bytes and
 * only read less bytes than the requested length if the end of
 * the stream has been reached.</p>
 *
 * @param input stream to read from
 * @param b buffer to fill
 * @param offset offset into the buffer to start filling at
 * @param len of bytes to read
 * @return the number of bytes actually read
 * @throws IOException
 *             if an I/O error has occurred
 */"
"public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    return available - numToSkip;
}","public void test2629() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 69, 0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0);
    long long0 = IOUtils.skip(pushbackInputStream0, 1291L);
    assertEquals((-66L), long0);
}","/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */"
"public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0) {
        long skipped = input.skip(numToSkip);
        if (skipped == 0) {
            break;
        }
        numToSkip -= skipped;
    }
    return available - numToSkip;
}","public void test2730() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    long long0 = IOUtils.skip(byteArrayInputStream0, (-1157L));
    assertEquals(0L, long0);
}","/**
 * Skips the given number of bytes by repeatedly invoking skip on
 * the given input stream if necessary.
 *
 * <p>In a case where the stream's skip() method returns 0 before
 * the requested number of bytes has been skip this implementation
 * will fall back to using the read() method.</p>
 *
 * <p>This method will only skip less than the requested number of
 * bytes if the end of the input stream has been reached.</p>
 *
 * @param input stream to skip bytes in
 * @param numToSkip the number of bytes to skip
 * @return the number of bytes actually skipped
 * @throws IOException
 */"
"public static long copy(final InputStream input, final OutputStream output) throws IOException {
    return copy(input, output, COPY_BUF_SIZE);
}","public void test2831() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    MockFile mockFile0 = new MockFile(""qayi"", ""/GC`"");
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
    long long0 = IOUtils.copy((InputStream) byteArrayInputStream0, (OutputStream) mockFileOutputStream0);
    assertEquals(3L, long0);
}","/**
 * Copies the content of a InputStream into an OutputStream.
 * Uses a default buffer size of 8024 bytes.
 *
 * @param input
 *            the InputStream to copy
 * @param output
 *            the target Stream
 * @throws IOException
 *             if an error occurs
 */"
"// toByteArray(InputStream) copied from:
// commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941
// January 8th, 2013
//
// Assuming our copy() works just as well as theirs!  :-)
/**
 * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
 * <p>
 * This method buffers the input internally, so there is no need to use a
 * <code>BufferedInputStream</code>.
 *
 * @param input  the <code>InputStream</code> to read from
 * @return the requested byte array
 * @throws NullPointerException if the input is null
 * @throws IOException if an I/O error occurs
 * @since 1.5
 */
public static byte[] toByteArray(final InputStream input) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
}","public void test2933() throws Throwable {
    Enumeration<MockFileInputStream> enumeration0 = (Enumeration<MockFileInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    byte[] byteArray0 = IOUtils.toByteArray(sequenceInputStream0);
    assertArrayEquals(new byte[] {}, byteArray0);
}",""
