focal_method,test_prefix,docstring
"public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor) {
    this.encoding = encoding;
    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    in = new PushbackInputStream(inputStream, buf.capacity());
    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;
    // haven't read anything so far
    buf.limit(0);
}","public void test000() throws Throwable {
    File file0 = MockFile.createTempFile(""Truncated ZIP entry: "", ""uncompressed size is required for STORED method when not writing to a file"");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream(mockFileInputStream0, ""Truncated ZIP entry: "", true, true);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // Truncated ZIP entry:
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * Create an instance using the specified encoding
 * @param inputStream the stream to wrap
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @param useUnicodeExtraFields whether to use InfoZIP Unicode
 * Extra Fields (if present) to set the file names.
 * @param allowStoredEntriesWithDataDescriptor whether the stream
 * will try to read STORED entries that use a data descriptor
 * @since 1.1
 */"
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test011() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    try {
        zipArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}",""
"@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test022() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, (String) null, false);
    JarArchiveEntry jarArchiveEntry0 = new JarArchiveEntry("""");
    boolean boolean0 = zipArchiveInputStream0.canReadEntryData(jarArchiveEntry0);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}","public void test033() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, (String) null, false);
    byte[] byteArray0 = new byte[2];
    int int0 = zipArchiveInputStream0.read(byteArray0, (int) (byte) 106, (-2770));
    assertEquals((-1), int0);
}",""
"@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}","public void test044() throws Throwable {
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(mockFileInputStream0, (String) null);
    zipArchiveInputStream0.close();
    byte[] byteArray0 = new byte[8];
    try {
        zipArchiveInputStream0.read(byteArray0, 0, (int) (byte) 0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // The stream is closed
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}",""
"public long getBytesRead() {
    return bytesRead;
}","public void test055() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(1576);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, ""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"");
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.close();
    assertEquals(0L, zipArchiveInputStream0.getBytesRead());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @since 1.1
 */"
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test066() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (byte) 11);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    // Undeclared exception!
    try {
        zipArchiveInputStream0.skip((-291L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test077() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    long long0 = zipArchiveInputStream0.skip(86L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test088() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    zipArchiveInputStream0.skip(1041L);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test099() throws Throwable {
    // Undeclared exception!
    try {
        ZipArchiveInputStream.matches((byte[]) null, 703);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1010() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ZipArchiveInputStream.matches(byteArray0, 0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[3];
    ZipArchiveInputStream.matches(byteArray0, 2048);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test1212() throws Throwable {
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, ""0"");
    zipArchiveInputStream0.getNextEntry();
}",""
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        return null;
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;
        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;
        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }
    entriesRead++;
    return current.entry;
}","public void test1313() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, (String) null, false);
    try {
        zipArchiveInputStream0.getNextZipEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}",""
"public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {
    this(inputStream, encoding, true);
}","public void test1414() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, ""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$1"");
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$1
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * Create an instance using the specified encoding
 * @param inputStream the stream to wrap
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @since 1.5
 */"
"public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {
    this(inputStream, encoding, useUnicodeExtraFields, false);
}","public void test1515() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(407);
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, """", false);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        //
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * Create an instance using the specified encoding
 * @param inputStream the stream to wrap
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @param useUnicodeExtraFields whether to use InfoZIP Unicode
 * Extra Fields (if present) to set the file names.
 */"
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        return null;
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;
        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;
        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }
    entriesRead++;
    return current.entry;
}","public void test1616() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, (byte) 11);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.getNextZipEntry();
}",""
"public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor) {
    this.encoding = encoding;
    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    in = new PushbackInputStream(inputStream, buf.capacity());
    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;
    // haven't read anything so far
    buf.limit(0);
}","public void test1717() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(1576);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, ""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"");
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(zipArchiveInputStream0, 1576);
    ZipArchiveInputStream zipArchiveInputStream1 = new ZipArchiveInputStream(pushbackInputStream0, ""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", true, true);
}","/**
 * Create an instance using the specified encoding
 * @param inputStream the stream to wrap
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @param useUnicodeExtraFields whether to use InfoZIP Unicode
 * Extra Fields (if present) to set the file names.
 * @param allowStoredEntriesWithDataDescriptor whether the stream
 * will try to read STORED entries that use a data descriptor
 * @since 1.1
 */"
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1818() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 117;
    ZipArchiveInputStream.matches(byteArray0, 1367);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
