focal_method,test_prefix,docstring
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 46;
    byteArray0[2] = (byte) 18;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 21;
    byteArray0[5] = (byte) (-10);
    byteArray0[6] = (byte) (-10);
    byteArray0[7] = (byte) 49;
    byteArray0[8] = (byte) (-70);
    ZipArchiveInputStream.matches(byteArray0, (-1076));
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    byteArrayInputStream0.reset();
    byteArrayInputStream0.read();
    byteArrayInputStream0.mark(15);
    byteArrayInputStream0.mark(8192);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.read(byteArray0, (int) (byte) 46, (int) (byte) 46);
    ZipArchiveInputStream.matches(byteArray0, (byte) 21);
    zipArchiveInputStream0.getNextEntry();
}",""
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    long currentHeaderOffset = getBytesRead();
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(lfhBuf);
        } else {
            readFully(lfhBuf);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(lfhBuf);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format(""Unexpected record signature: 0X%X"", sig.getValue()));
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(lfhBuf, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(lfhBuf, off));
        off += WORD;
        cSize = new ZipLong(lfhBuf, off);
        off += WORD;
        size = new ZipLong(lfhBuf, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(lfhBuf, off);
    // NOSONAR - assignment as documentation
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    if (hasUTF8Flag) {
        current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
    }
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    current.entry.setLocalHeaderOffset(currentHeaderOffset);
    current.entry.setDataOffset(getBytesRead());
    current.entry.setStreamContiguous(true);
    ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
            InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());
            switch(m) {
                case UNSHRINKING:
                    current.in = new UnshrinkingInputStream(bis);
                    break;
                case IMPLODING:
                    current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);
                    break;
                case BZIP2:
                    current.in = new BZip2CompressorInputStream(bis);
                    break;
                case ENHANCED_DEFLATED:
                    current.in = new Deflate64CompressorInputStream(bis);
                    break;
                default:
                    // we should never get here as all supported methods have been covered
                    // will cause an error when read is invoked, don't throw an exception here so people can
                    // skip unsupported entries
                    break;
            }
        }
    } else if (m == ZipMethod.ENHANCED_DEFLATED) {
        current.in = new Deflate64CompressorInputStream(in);
    }
    entriesRead++;
    return current.entry;
}","public void test011() throws Throwable {
    Enumeration<PushbackInputStream> enumeration0 = (Enumeration<PushbackInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false, false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    sequenceInputStream0.mark(0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(bufferedInputStream0, ""UTF8"");
    sequenceInputStream0.read((byte[]) null, 46, 46);
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""N856"");
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
    zipArchiveInputStream0.skip(16877);
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 83;
    byteArray0[1] = (byte) 15;
    byteArray0[2] = (byte) (-50);
    byteArray0[3] = (byte) 99;
    byteArray0[4] = (byte) 120;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) (-5);
    ZipArchiveInputStream.matches(byteArray0, (byte) (-50));
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.skip((byte) (-5));
    zipArchiveInputStream0.getNextZipEntry();
}",""
"public void addExtraField(final ZipExtraField ze) {
    if (ze instanceof UnparseableExtraFieldData) {
        unparseableExtra = (UnparseableExtraFieldData) ze;
    } else {
        if (extraFields == null) {
            extraFields = new ZipExtraField[] { ze };
        } else {
            if (getExtraField(ze.getHeaderId()) != null) {
                removeExtraField(ze.getHeaderId());
            }
            final ZipExtraField[] zipExtraFields = copyOf(extraFields, extraFields.length + 1);
            zipExtraFields[zipExtraFields.length - 1] = ze;
            extraFields = zipExtraFields;
        }
    }
    setExtra();
}","public void test022() throws Throwable {
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry(""unsupported feature method '"");
    AsiExtraField asiExtraField0 = new AsiExtraField();
    zipArchiveEntry0.addExtraField(asiExtraField0);
}","/**
 * Adds an extra field - replacing an already present extra field
 * of the same type.
 *
 * <p>If no extra field of the same type exists, the field will be
 * added as last field.</p>
 * @param ze an extra field
 */"
"@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test044() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) (-103);
    byteArray0[2] = (byte) 82;
    byteArray0[2] = (byte) 10;
    byteArray0[3] = (byte) 3;
    byteArray0[4] = (byte) 80;
    byteArray0[5] = (byte) 90;
    byteArray0[6] = (byte) 123;
    ZipArchiveInputStream.matches(byteArray0, 98496370);
    byte[] byteArray1 = new byte[3];
    byteArray1[0] = (byte) 123;
    byteArray1[1] = (byte) 82;
    byteArray1[2] = (byte) 90;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray1);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    byteArrayInputStream0.mark((-419));
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""Z:P[Q"", (byte) 118, false);
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
    zipArchiveInputStream0.getNextZipEntry();
    byteArrayInputStream0.read(byteArray0, 512, (int) (byte) 0);
    byteArrayInputStream0.read();
    long long0 = 0L;
    zipArchiveInputStream0.skip(long0);
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test055() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) (-103);
    byteArray0[1] = (byte) 82;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 3;
    byteArray0[4] = (byte) 80;
    byteArray0[5] = (byte) 90;
    byteArray0[6] = (byte) 123;
    ZipArchiveInputStream.matches(byteArray0, 98496370);
    byte[] byteArray1 = new byte[3];
    byteArray1[0] = (byte) 123;
    byteArray1[1] = (byte) 82;
    byteArray1[2] = (byte) 90;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray1);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.skip((byte) 90);
    byteArrayInputStream0.mark((-419));
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""Z:P[Q"", (byte) 118, false);
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.getNextZipEntry();
    int int0 = 512;
    zipArchiveInputStream0.read(byteArray0, 16877, (int) (byte) 82);
    byteArrayInputStream0.read(byteArray0, int0, (int) byteArray0[1]);
    byteArrayInputStream0.read();
    long long0 = 0L;
    zipArchiveInputStream0.skip(long0);
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test088() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    ZipArchiveEntry zipArchiveEntry0 = zipArchiveInputStream0.getNextZipEntry();
    // Undeclared exception!
    try {
        zipArchiveInputStream0.canReadEntryData(zipArchiveEntry0);
        fail(""Expecting exception: IOException"");
    } catch (Throwable e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    long currentHeaderOffset = getBytesRead();
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(lfhBuf);
        } else {
            readFully(lfhBuf);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(lfhBuf);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format(""Unexpected record signature: 0X%X"", sig.getValue()));
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(lfhBuf, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(lfhBuf, off));
        off += WORD;
        cSize = new ZipLong(lfhBuf, off);
        off += WORD;
        size = new ZipLong(lfhBuf, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(lfhBuf, off);
    // NOSONAR - assignment as documentation
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    if (hasUTF8Flag) {
        current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
    }
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    current.entry.setLocalHeaderOffset(currentHeaderOffset);
    current.entry.setDataOffset(getBytesRead());
    current.entry.setStreamContiguous(true);
    ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
            InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());
            switch(m) {
                case UNSHRINKING:
                    current.in = new UnshrinkingInputStream(bis);
                    break;
                case IMPLODING:
                    current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);
                    break;
                case BZIP2:
                    current.in = new BZip2CompressorInputStream(bis);
                    break;
                case ENHANCED_DEFLATED:
                    current.in = new Deflate64CompressorInputStream(bis);
                    break;
                default:
                    // we should never get here as all supported methods have been covered
                    // will cause an error when read is invoked, don't throw an exception here so people can
                    // skip unsupported entries
                    break;
            }
        }
    } else if (m == ZipMethod.ENHANCED_DEFLATED) {
        current.in = new Deflate64CompressorInputStream(in);
    }
    entriesRead++;
    return current.entry;
}","public void test099() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(18);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, ""alphaSize"");
    ZipArchiveInputStream zipArchiveInputStream1 = new ZipArchiveInputStream(zipArchiveInputStream0, ""alphaSize"", true, false);
    ZipArchiveInputStream zipArchiveInputStream2 = new ZipArchiveInputStream(zipArchiveInputStream1, ""alphaSize"", false);
    ZipArchiveInputStream zipArchiveInputStream3 = new ZipArchiveInputStream(zipArchiveInputStream2);
    zipArchiveInputStream3.getNextZipEntry();
}",""
"@Override
public int read(final byte[] buffer, final int offset, final int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}","public void test1010() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    MockFile mockFile0 = new MockFile((File) null, """");
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry(mockFile0, """");
    SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException("""", "" ~aM"", 18);
    SQLDataException sQLDataException0 = new SQLDataException(sQLNonTransientConnectionException0);
    MockIOException mockIOException0 = new MockIOException("""", sQLDataException0);
    zipArchiveEntry0.equals(mockIOException0);
    zipArchiveInputStream0.canReadEntryData(zipArchiveEntry0);
    byte[] byteArray0 = null;
    int int0 = zipArchiveInputStream0.read();
    zipArchiveInputStream0.read((byte[]) null, 3811, (-1927));
    int int1 = 1870;
    zipArchiveInputStream0.reset();
    zipArchiveInputStream0.mark(int1);
    long long0 = 255L;
    zipArchiveInputStream0.skip(long0);
    zipArchiveInputStream0.close();
    int int2 = (-1494);
    try {
        zipArchiveInputStream0.read(byteArray0, int0, int2);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // mark/reset not supported
        //
        verifyException(""java.io.InputStream"", e);
    }
}",""
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test1111() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(611);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, (String) null, false);
    ZipArchiveInputStream zipArchiveInputStream1 = new ZipArchiveInputStream(zipArchiveInputStream0, """", false, true);
    zipArchiveInputStream1.getNextEntry();
}",""
"@Override
public void close() throws IOException {
    if (!closed) {
        closed = true;
        try {
            in.close();
        } finally {
            inf.end();
        }
    }
}","public void test1313() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 100;
    byteArray0[1] = (byte) (-19);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-56);
    byteArray0[4] = (byte) (-80);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) (-101);
    byteArray0[7] = (byte) 2;
    byteArray0[8] = (byte) 0;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 0, (-1));
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.close();
}",""
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1414() throws Throwable {
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null, 3048);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pushbackInputStream0, (String) null, false);
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) (-38);
    byteArray0[1] = (byte) 62;
    byteArray0[2] = (byte) (-83);
    byteArray0[3] = (byte) 41;
    zipArchiveInputStream0.mark(3207);
    byteArray0[4] = (byte) 76;
    zipArchiveInputStream0.canReadEntryData((ArchiveEntry) null);
    int int0 = 20;
    zipArchiveInputStream0.read(byteArray0, 20, (int) (byte) (-83));
    zipArchiveInputStream0.skip(3048);
    zipArchiveInputStream0.skip(3048);
    zipArchiveInputStream0.getNextEntry();
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.read(byteArray0, int0, (int) byteArray0[4]);
    long long0 = 0L;
    zipArchiveInputStream0.skip(long0);
    zipArchiveInputStream0.getNextEntry();
    zipArchiveInputStream0.getNextZipEntry();
    zipArchiveInputStream0.getNextEntry();
    int int1 = 3191;
    ZipArchiveInputStream.matches(byteArray0, int1);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1616() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 65;
    byteArray0[1] = (byte) (-125);
    byteArray0[2] = (byte) 26;
    byteArray0[3] = (byte) 55;
    byteArray0[4] = (byte) 16;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 52;
    ZipArchiveInputStream.matches(byteArray0, (byte) 52);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1717() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(2568);
    int int0 = 1400;
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, 1400);
    bufferedInputStream0.markSupported();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(bufferedInputStream0, """", true);
    zipArchiveInputStream0.getNextZipEntry();
    ZipArchiveEntry zipArchiveEntry0 = zipArchiveInputStream0.getNextZipEntry();
    // Undeclared exception!
    try {
        zipArchiveInputStream0.skip(zipArchiveEntry0.PLATFORM_FAT);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        //
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public void close() throws IOException {
    if (!closed) {
        closed = true;
        try {
            in.close();
        } finally {
            inf.end();
        }
    }
}","public void test1818() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 54;
    zipArchiveInputStream0.read(byteArray0, (int) (byte) 54, (int) (byte) 54);
    zipArchiveInputStream0.getNextZipEntry();
    try {
        zipArchiveInputStream0.close();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1919() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = 45;
    // Undeclared exception!
    try {
        ZipArchiveInputStream.matches((byte[]) null, 45);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"@Override
public void close() throws IOException {
    if (!closed) {
        closed = true;
        try {
            in.close();
        } finally {
            inf.end();
        }
    }
}","public void test2020() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 119;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 41;
    byteArray0[3] = (byte) (-76);
    byteArray0[4] = (byte) (-104);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 85;
    byteArray0[7] = (byte) 123;
    ZipArchiveInputStream.matches(byteArray0, 1447);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    byteArrayInputStream0.markSupported();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, """");
    zipArchiveInputStream0.markSupported();
    zipArchiveInputStream0.getNextZipEntry();
    zipArchiveInputStream0.close();
}",""
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test2222() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(17);
    pipedInputStream0.skip((-45L));
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    zipArchiveInputStream0.getNextEntry();
}",""
"@Override
public void close() throws IOException {
    if (!closed) {
        closed = true;
        try {
            in.close();
        } finally {
            inf.end();
        }
    }
}","public void test2323() throws Throwable {
    byte[] byteArray0 = new byte[4];
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, """");
    byteArray0[0] = (byte) (-78);
    byteArray0[1] = (byte) (-28);
    byteArray0[2] = (byte) 57;
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
    byteArray0[3] = (byte) 0;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    byteArrayInputStream0.mark((byte) (-28));
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, ""UTF8"", false, true);
    zipArchiveInputStream0.getNextEntry();
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.markSupported();
    zipArchiveInputStream0.close();
}",""
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test2424() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 63;
    byteArray0[1] = (byte) (-69);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-40);
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 0;
    byteArray0[7] = (byte) 107;
    byteArray0[8] = (byte) 0;
    ZipArchiveInputStream.matches(byteArray0, (byte) 0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    zipArchiveInputStream0.skip(0L);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(final long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            final long rem = value - skipped;
            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test2525() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(128);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pushbackInputStream0, ""BZLIB"", false, false);
    DataInputStream dataInputStream0 = new DataInputStream(zipArchiveInputStream0);
    ZipArchiveInputStream zipArchiveInputStream1 = new ZipArchiveInputStream(dataInputStream0, (String) null, false);
    zipArchiveInputStream1.skip(16L);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    long currentHeaderOffset = getBytesRead();
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(lfhBuf);
        } else {
            readFully(lfhBuf);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(lfhBuf);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format(""Unexpected record signature: 0X%X"", sig.getValue()));
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(lfhBuf, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(lfhBuf, off));
        off += WORD;
        cSize = new ZipLong(lfhBuf, off);
        off += WORD;
        size = new ZipLong(lfhBuf, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(lfhBuf, off);
    // NOSONAR - assignment as documentation
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    if (hasUTF8Flag) {
        current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
    }
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    current.entry.setLocalHeaderOffset(currentHeaderOffset);
    current.entry.setDataOffset(getBytesRead());
    current.entry.setStreamContiguous(true);
    ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
            InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());
            switch(m) {
                case UNSHRINKING:
                    current.in = new UnshrinkingInputStream(bis);
                    break;
                case IMPLODING:
                    current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);
                    break;
                case BZIP2:
                    current.in = new BZip2CompressorInputStream(bis);
                    break;
                case ENHANCED_DEFLATED:
                    current.in = new Deflate64CompressorInputStream(bis);
                    break;
                default:
                    // we should never get here as all supported methods have been covered
                    // will cause an error when read is invoked, don't throw an exception here so people can
                    // skip unsupported entries
                    break;
            }
        }
    } else if (m == ZipMethod.ENHANCED_DEFLATED) {
        current.in = new Deflate64CompressorInputStream(in);
    }
    entriesRead++;
    return current.entry;
}","public void test2929() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 54;
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.read(byteArray0, (int) (byte) 54, (int) (byte) 54);
    try {
        zipArchiveInputStream0.getNextZipEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // The stream is closed
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}",""
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    long currentHeaderOffset = getBytesRead();
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(lfhBuf);
        } else {
            readFully(lfhBuf);
        }
    } catch (final EOFException e) {
        return null;
    }
    final ZipLong sig = new ZipLong(lfhBuf);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format(""Unexpected record signature: 0X%X"", sig.getValue()));
    }
    int off = WORD;
    current = new CurrentEntry();
    final int versionMadeBy = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(lfhBuf, off));
    off += SHORT;
    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(lfhBuf, off));
        off += WORD;
        cSize = new ZipLong(lfhBuf, off);
        off += WORD;
        size = new ZipLong(lfhBuf, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    final int fileNameLen = ZipShort.getValue(lfhBuf, off);
    off += SHORT;
    final int extraLen = ZipShort.getValue(lfhBuf, off);
    // NOSONAR - assignment as documentation
    off += SHORT;
    final byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    if (hasUTF8Flag) {
        current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
    }
    final byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    current.entry.setLocalHeaderOffset(currentHeaderOffset);
    current.entry.setDataOffset(getBytesRead());
    current.entry.setStreamContiguous(true);
    ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());
    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
            InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());
            switch(m) {
                case UNSHRINKING:
                    current.in = new UnshrinkingInputStream(bis);
                    break;
                case IMPLODING:
                    current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);
                    break;
                case BZIP2:
                    current.in = new BZip2CompressorInputStream(bis);
                    break;
                case ENHANCED_DEFLATED:
                    current.in = new Deflate64CompressorInputStream(bis);
                    break;
                default:
                    // we should never get here as all supported methods have been covered
                    // will cause an error when read is invoked, don't throw an exception here so people can
                    // skip unsupported entries
                    break;
            }
        }
    } else if (m == ZipMethod.ENHANCED_DEFLATED) {
        current.in = new Deflate64CompressorInputStream(in);
    }
    entriesRead++;
    return current.entry;
}","public void test3030() throws Throwable {
    Enumeration<PushbackInputStream> enumeration0 = (Enumeration<PushbackInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false, true).when(enumeration0).hasMoreElements();
    doReturn((Object) null).when(enumeration0).nextElement();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    sequenceInputStream0.mark(0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(bufferedInputStream0, ""UTF8"");
    sequenceInputStream0.read((byte[]) null, 46, 46);
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""N856"");
    zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
    zipArchiveInputStream0.skip(16877);
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 83;
    byteArray0[1] = (byte) 15;
    byteArray0[2] = (byte) (-50);
    byteArray0[3] = (byte) 99;
    byteArray0[4] = (byte) 120;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) (-5);
    ZipArchiveInputStream.matches(byteArray0, (byte) (-50));
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.skip(byteArray0[6]);
    zipArchiveInputStream0.getNextZipEntry();
}",""
"public static boolean matches(final byte[] signature, final int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test3131() throws Throwable {
    FileSystemHandling.shouldAllThrowIOExceptions();
    byte[] byteArray0 = new byte[0];
    int int0 = 2181;
    // Undeclared exception!
    try {
        ZipArchiveInputStream.matches(byteArray0, 2181);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
