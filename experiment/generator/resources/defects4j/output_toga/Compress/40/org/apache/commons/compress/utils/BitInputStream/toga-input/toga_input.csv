focal_method,test_prefix,docstring
"public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count) {
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= (nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;
    }
    // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
    final long bitsOut;
    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
        bitsOut = (bitsCached & MASKS[count]);
        bitsCached >>>= count;
    } else {
        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
    }
    bitsCachedSize -= count;
    return bitsOut;
}","public void test088() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) (-114);
    byteArray0[3] = (byte) (-17);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 0, 8);
    byteArrayInputStream0.read();
    byteArrayInputStream0.mark(64);
    BitInputStream bitInputStream0 = new BitInputStream(byteArrayInputStream0, (ByteOrder) null);
    bitInputStream0.clearBitCache();
    bitInputStream0.clearBitCache();
    bitInputStream0.clearBitCache();
    bitInputStream0.readBits(0);
    bitInputStream0.readBits((byte) 1);
}","/**
 * Returns at most 63 bits read from the underlying stream.
 *
 * @param count the number of bits to read, must be a positive
 * number not bigger than 63.
 * @return the bits concatenated as a long using the stream's byte order.
 *         -1 if the end of the underlying stream has been reached before reading
 *         the requested number of bits
 * @throws IOException on error
 */"
"public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count) {
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= (nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;
    }
    // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
    final long bitsOut;
    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
        bitsOut = (bitsCached & MASKS[count]);
        bitsCached >>>= count;
    } else {
        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
    }
    bitsCachedSize -= count;
    return bitsOut;
}","public void test1010() throws Throwable {
    ByteOrder byteOrder0 = ByteOrder.LITTLE_ENDIAN;
    BitInputStream bitInputStream0 = new BitInputStream((InputStream) null, byteOrder0);
    bitInputStream0.readBits((-1));
}","/**
 * Returns at most 63 bits read from the underlying stream.
 *
 * @param count the number of bits to read, must be a positive
 * number not bigger than 63.
 * @return the bits concatenated as a long using the stream's byte order.
 *         -1 if the end of the underlying stream has been reached before reading
 *         the requested number of bits
 * @throws IOException on error
 */"
"@Override
public void close() throws IOException {
    in.close();
}","public void test1111() throws Throwable {
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    DataInputStream dataInputStream0 = new DataInputStream(mockFileInputStream0);
    ByteOrder byteOrder0 = ByteOrder.nativeOrder();
    BitInputStream bitInputStream0 = new BitInputStream(dataInputStream0, byteOrder0);
    bitInputStream0.close();
}",""
"public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count) {
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= (nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;
    }
    // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
    final long bitsOut;
    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
        bitsOut = (bitsCached & MASKS[count]);
        bitsCached >>>= count;
    } else {
        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
    }
    bitsCachedSize -= count;
    return bitsOut;
}","public void test1212() throws Throwable {
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    ByteOrder byteOrder0 = ByteOrder.nativeOrder();
    BitInputStream bitInputStream0 = new BitInputStream(mockFileInputStream0, byteOrder0);
    bitInputStream0.readBits(2581);
}","/**
 * Returns at most 63 bits read from the underlying stream.
 *
 * @param count the number of bits to read, must be a positive
 * number not bigger than 63.
 * @return the bits concatenated as a long using the stream's byte order.
 *         -1 if the end of the underlying stream has been reached before reading
 *         the requested number of bits
 * @throws IOException on error
 */"
"public void clearBitCache() {
    bitsCached = 0;
    bitsCachedSize = 0;
}","public void test1414() throws Throwable {
    ByteOrder byteOrder0 = ByteOrder.LITTLE_ENDIAN;
    ByteOrder.nativeOrder();
    BitInputStream bitInputStream0 = new BitInputStream((InputStream) null, byteOrder0);
    bitInputStream0.clearBitCache();
    bitInputStream0.clearBitCache();
    ByteOrder.nativeOrder();
    ByteOrder.nativeOrder();
    bitInputStream0.readBits(0);
    ByteOrder.nativeOrder();
    bitInputStream0.clearBitCache();
    bitInputStream0.clearBitCache();
}","/**
 * Clears the cache of bits that have been read from the
 * underlying stream but not yet provided via {@link #readBits}.
 */"
"public long readBits(final int count) throws IOException {
    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
        throw new IllegalArgumentException(""count must not be negative or greater than "" + MAXIMUM_CACHE_SIZE);
    }
    while (bitsCachedSize < count) {
        final long nextByte = in.read();
        if (nextByte < 0) {
            return nextByte;
        }
        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
            bitsCached |= (nextByte << bitsCachedSize);
        } else {
            bitsCached <<= 8;
            bitsCached |= nextByte;
        }
        bitsCachedSize += 8;
    }
    // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
    final long bitsOut;
    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
        bitsOut = (bitsCached & MASKS[count]);
        bitsCached >>>= count;
    } else {
        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
    }
    bitsCachedSize -= count;
    return bitsOut;
}","public void test1515() throws Throwable {
    ByteOrder byteOrder0 = ByteOrder.nativeOrder();
    BitInputStream bitInputStream0 = new BitInputStream((InputStream) null, byteOrder0);
    bitInputStream0.clearBitCache();
    ByteOrder.nativeOrder();
    bitInputStream0.clearBitCache();
    int int0 = 0;
    ByteOrder.nativeOrder();
    bitInputStream0.close();
    // Undeclared exception!
    try {
        bitInputStream0.readBits(int0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.BitInputStream"", e);
    }
}","/**
 * Returns at most 63 bits read from the underlying stream.
 *
 * @param count the number of bits to read, must be a positive
 * number not bigger than 63.
 * @return the bits concatenated as a long using the stream's byte order.
 *         -1 if the end of the underlying stream has been reached before reading
 *         the requested number of bits
 * @throws IOException on error
 */"
"public void clearBitCache() {
    bitsCached = 0;
    bitsCachedSize = 0;
}","public void test1616() throws Throwable {
    ByteOrder byteOrder0 = ByteOrder.LITTLE_ENDIAN;
    ByteOrder.nativeOrder();
    BitInputStream bitInputStream0 = new BitInputStream((InputStream) null, byteOrder0);
    bitInputStream0.readBits(8);
    bitInputStream0.close();
    // Undeclared exception!
    try {
        bitInputStream0.clearBitCache();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.BitInputStream"", e);
    }
}","/**
 * Clears the cache of bits that have been read from the
 * underlying stream but not yet provided via {@link #readBits}.
 */"
