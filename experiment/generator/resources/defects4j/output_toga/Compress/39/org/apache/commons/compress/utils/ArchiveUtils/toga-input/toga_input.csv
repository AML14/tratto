focal_method,test_prefix,docstring
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byte byte0 = (byte) 1;
    byteArray0[2] = (byte) 0;
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isArrayZero(byteArray0, (byte) 1);
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) 0, (byte) 1, byteArray0, (byte) 0, (byte) 1);
    ArchiveUtils.sanitize(""\u0000\u0000\u0000"");
    ArchiveUtils.isEqualWithNull(byteArray0, (-123), (byte) 0, byteArray0, (-1455), 10);
    byte[] byteArray1 = new byte[0];
    ArchiveUtils.isEqual(byteArray0, byteArray1);
    ArchiveUtils.isEqual(byteArray0, byteArray1);
    // Undeclared exception!
    try {
        ArchiveUtils.isEqual(byteArray0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1455
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static String toString(final ArchiveEntry entry) {
    final StringBuilder sb = new StringBuilder();
    // c.f. ""ls -l"" output
    sb.append(entry.isDirectory() ? 'd' : '-');
    final String size = Long.toString(entry.getSize());
    sb.append(' ');
    // Pad output to 7 places, leading spaces
    for (int i = 7; i > size.length(); i--) {
        sb.append(' ');
    }
    sb.append(size);
    sb.append(' ').append(entry.getName());
    return sb.toString();
}","public void test022() throws Throwable {
    MockFile mockFile0 = new MockFile("""", """");
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(mockFile0, """");
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
}","/**
 * Generates a string containing the name, isDirectory setting and size of an entry.
 * <p>
 * For example:
 * <pre>
 * -    2000 main.c
 * d     100 testfiles
 * </pre>
 *
 * @param entry the entry
 * @return the representation of the entry
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test044() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byte byte0 = (byte) (-4);
    byteArray0[0] = (byte) (-4);
    byteArray0[1] = (byte) (-4);
    byteArray0[2] = (byte) (-5);
    byteArray0[5] = (byte) (-4);
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 0, (int) (byte) (-4), byteArray0, (-2722), (int) (byte) (-5), true);
    String string0 = ""p[K"";
    ArchiveUtils.sanitize(string0);
    int int0 = 409;
    boolean boolean0 = true;
    // Undeclared exception!
    try {
        ArchiveUtils.isEqual(byteArray0, (int) byteArray0[0], (int) byte0, byteArray0, (int) byte0, int0, boolean0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -5
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test055() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[5] = (byte) 2;
    byteArray0[4] = (byte) 2;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 2, (int) (byte) 2, byteArray0, (-2722), (int) (byte) (-5), false);
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 0, (int) (byte) 2, byteArray0, (int) (byte) 2, 409, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static String sanitize(String s) {
    final char[] chars = s.toCharArray();
    final int len = chars.length;
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < len; i++) {
        final char c = chars[i];
        if (!Character.isISOControl(c)) {
            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
            if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                sb.append(c);
                continue;
            }
        }
        sb.append('?');
    }
    return sb.toString();
}","public void test066() throws Throwable {
    ArchiveUtils.sanitize(""p[K"");
}","/**
 * Returns a ""sanitized"" version of the string given as arguments,
 * where sanitized means non-printable characters have been
 * replaced with a question mark and the outcome is not longer
 * than 255 chars.
 *
 * <p>This method is used to clean up file names when they are
 * used in exception messages as they may end up in log files or
 * as console output and may have been read from a corrupted
 * input.</p>
 *
 * @param s the string to sanitize
 * @return a sanitized version of the argument
 * @since Compress 1.12
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test077() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-55);
    byteArray0[1] = (byte) 36;
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
    byteArray0[2] = (byte) 7;
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isEqual(byteArray0, (int) (byte) (-55), (int) (byte) 7, byteArray0, (int) (byte) 7, (int) (byte) (-55), false);
    System.setCurrentTimeMillis(4096L);
    byte[] byteArray1 = ArchiveUtils.toAsciiBytes(""\uFFFD$\u0007"");
    ArchiveUtils.sanitize(""\uFFFD$\u0007"");
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 7, (int) (byte) 36, byteArray1, 9, 32, false);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test099() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""iA=K0M9Yl\""%-Oy]`"");
    byte[] byteArray0 = new byte[4];
    ArchiveUtils.isEqual(byteArray0, 1, (-1), byteArray0, 1, 1, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test1010() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 0;
    ArchiveUtils.matchAsciiBuffer("">_FwLvb.Fsa#"", byteArray0, (int) (byte) 0, (int) (byte) 0);
    ArchiveUtils.isEqualWithNull((byte[]) null, (byte) 0, 0, byteArray0, 32, 1);
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);
}","public void test1212() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 0;
    ArchiveUtils.isEqual(byteArray0, byteArray0);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean matchAsciiBuffer(final String expected, final byte[] buffer) {
    return matchAsciiBuffer(expected, buffer, 0, buffer.length);
}","public void test1313() throws Throwable {
    ArchiveUtils.matchAsciiBuffer("""", (byte[]) null);
}","/**
 * Check if buffer contents matches Ascii String.
 *
 * @param expected the expected strin
 * @param buffer the buffer
 * @return {@code true} if buffer is the same as the expected string
 */"
"public static String toString(final ArchiveEntry entry) {
    final StringBuilder sb = new StringBuilder();
    // c.f. ""ls -l"" output
    sb.append(entry.isDirectory() ? 'd' : '-');
    final String size = Long.toString(entry.getSize());
    sb.append(' ');
    // Pad output to 7 places, leading spaces
    for (int i = 7; i > size.length(); i--) {
        sb.append(' ');
    }
    sb.append(size);
    sb.append(' ').append(entry.getName());
    return sb.toString();
}","public void test1414() throws Throwable {
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry("""");
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
}","/**
 * Generates a string containing the name, isDirectory setting and size of an entry.
 * <p>
 * For example:
 * <pre>
 * -    2000 main.c
 * d     100 testfiles
 * </pre>
 *
 * @param entry the entry
 * @return the representation of the entry
 */"
"public static String toAsciiString(final byte[] inputBytes) {
    try {
        return new String(inputBytes, CharsetNames.US_ASCII);
    } catch (final UnsupportedEncodingException e) {
        // Should never happen
        throw new RuntimeException(e);
    }
}","public void test1515() throws Throwable {
    byte[] byteArray0 = null;
    // Undeclared exception!
    try {
        ArchiveUtils.toAsciiString((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * Convert an input byte array to a String using the ASCII character set.
 *
 * @param inputBytes bytes to convert
 * @return the bytes, interpreted as an Ascii string
 */"
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);
}","public void test1616() throws Throwable {
    byte[] byteArray0 = null;
    // Undeclared exception!
    try {
        ArchiveUtils.isEqual((byte[]) null, (byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test1818() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-103);
    byteArray0[2] = (byte) 85;
    byteArray0[3] = (byte) 47;
    byteArray0[4] = (byte) (-45);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 68;
    byteArray0[7] = (byte) 29;
    ArchiveUtils.isEqual(byteArray0, 1020, 1020, byteArray0, (int) (byte) (-45), (int) (byte) 47, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test1919() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) (-105);
    byteArray0[1] = (byte) 68;
    byteArray0[2] = (byte) (-53);
    byte byte0 = (byte) (-88);
    byteArray0[3] = (byte) (-88);
    byteArray0[4] = (byte) (-48);
    byteArray0[5] = (byte) 121;
    byteArray0[6] = (byte) 100;
    ArchiveUtils.toAsciiString(byteArray0);
    String string0 = ""<fn1Z["";
    int int0 = 141;
    ArchiveUtils.matchAsciiBuffer(""<fn1Z["", byteArray0, 141, (int) (byte) (-105));
    ArchiveUtils.toString((ArchiveEntry) null);
    int int1 = 30062;
    ArchiveUtils.isArrayZero(byteArray0, int1);
    boolean boolean0 = true;
    boolean boolean1 = ArchiveUtils.isEqual(byteArray0, byteArray0, boolean0);
    ArchiveUtils.isEqual(byteArray0, byteArray0, boolean1);
    ArchiveUtils.toAsciiBytes(string0);
    // Undeclared exception!
    try {
        ArchiveUtils.isArrayZero(byteArray0, byte0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, final boolean ignoreTrailingNulls) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, ignoreTrailingNulls);
}","public void test2020() throws Throwable {
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes(""-6Zz^j k?ow"");
    ArchiveUtils.isEqual(byteArray0, byteArray0, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @param ignoreTrailingNulls whether to ignore tariling nulls
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test2121() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 63;
    ArchiveUtils.isArrayZero(byteArray0, (byte) 63);
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test2222() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 76;
    byteArray0[1] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray0, 0);
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static String toString(final ArchiveEntry entry) {
    final StringBuilder sb = new StringBuilder();
    // c.f. ""ls -l"" output
    sb.append(entry.isDirectory() ? 'd' : '-');
    final String size = Long.toString(entry.getSize());
    sb.append(' ');
    // Pad output to 7 places, leading spaces
    for (int i = 7; i > size.length(); i--) {
        sb.append(' ');
    }
    sb.append(size);
    sb.append(' ').append(entry.getName());
    return sb.toString();
}","public void test2323() throws Throwable {
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes("""");
    ArchiveUtils.matchAsciiBuffer("""", byteArray0, (-2516), 0);
    ArchiveUtils.sanitize("""");
    ArchiveUtils.isEqual(byteArray0, byteArray0, false);
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry("",WVp0"", (byte) 0);
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
}","/**
 * Generates a string containing the name, isDirectory setting and size of an entry.
 * <p>
 * For example:
 * <pre>
 * -    2000 main.c
 * d     100 testfiles
 * </pre>
 *
 * @param entry the entry
 * @return the representation of the entry
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test2525() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 0;
    ArchiveUtils.isEqual(byteArray0, (-1139), (int) (byte) 0, byteArray0, 5800, 4574);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public SevenZArchiveEntry() {
}","public void test2626() throws Throwable {
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes(""F~+?x1bgjG2'0"");
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    byte[] byteArray1 = ArchiveUtils.toAsciiBytes(""F~+?x1bgjG2'0"");
    ArchiveUtils.isEqual(byteArray1, (byte[]) null, true);
    String string0 = ""org.apache.commons.compress.utils.ArchiveUtils"";
    ArchiveUtils.matchAsciiBuffer(string0, byteArray1);
    SevenZArchiveEntry sevenZArchiveEntry0 = null;
    try {
        sevenZArchiveEntry0 = new SevenZArchiveEntry();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}",""
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);
}","public void test2727() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byte byte0 = (byte) 45;
    byteArray0[0] = (byte) 45;
    ArchiveUtils.toAsciiString(byteArray0, 28789, (int) (byte) 45);
    // Undeclared exception!
    try {
        ArchiveUtils.isEqual(byteArray0, byteArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test2828() throws Throwable {
    ArchiveUtils.isEqual((byte[]) null, (-1433), 4095, (byte[]) null, 0, 0, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test2929() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-58);
    byteArray0[1] = (byte) (-114);
    ArchiveUtils.isEqual(byteArray0, 7, (int) (byte) (-114), byteArray0, (int) (byte) (-58), 1142, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test3030() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-110);
    byte[] byteArray1 = new byte[5];
    byteArray1[0] = (byte) (-110);
    byteArray1[1] = (byte) (-110);
    byteArray1[2] = (byte) (-110);
    byteArray1[3] = (byte) (-110);
    byteArray1[4] = (byte) (-110);
    ArchiveUtils.isEqual(byteArray0, (int) (byte) (-110), (int) (byte) (-110), byteArray1, (int) (byte) (-110), (int) (byte) (-110));
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqual(final byte[] buffer1, final byte[] buffer2) {
    return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);
}","public void test3131() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 125;
    byteArray0[1] = (byte) 14;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-7);
    byteArray0[4] = (byte) (-99);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) (-84);
    byte[] byteArray1 = new byte[6];
    byteArray1[0] = (byte) (-99);
    byteArray1[1] = (byte) (-7);
    byteArray1[2] = (byte) 14;
    byteArray1[3] = (byte) (-99);
    byteArray1[4] = (byte) 0;
    byteArray1[5] = (byte) 14;
    ArchiveUtils.isEqual(byteArray0, byteArray1);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param buffer2 the second buffer
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test3232() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 109;
    byteArray0[1] = (byte) 0;
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) 109, (byte) 0, byteArray0, (byte) 109, (byte) 0);
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test3333() throws Throwable {
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes(""ql(=UKz+F3W="");
    ArchiveUtils.isEqualWithNull(byteArray0, (-2447), 32, byteArray0, 146, (-2280));
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test3434() throws Throwable {
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""N8u9WyEI]'7rN"", true);
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes(""-       0 N8u9WyEI]'7rN"");
    tarArchiveEntry0.setSize(1L);
    tarArchiveEntry0.setName(""-       0 N8u9WyEI]'7rN"");
    ArchiveUtils.matchAsciiBuffer(""-       0 N8u9WyEI]'7rN"", byteArray0);
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
    ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
    ArchiveUtils.isEqual(byteArray0, byteArray0, true);
    ArchiveUtils.isArrayZero(byteArray0, 31);
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test3737() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) (-32);
    byteArray0[1] = (byte) (-44);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 121;
    byte[] byteArray1 = new byte[2];
    byteArray1[0] = (byte) 121;
    byteArray1[1] = (byte) (-44);
    ArchiveUtils.isEqualWithNull(byteArray0, 0, 7, byteArray1, 5899, (byte) (-44));
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test3838() throws Throwable {
    ArchiveUtils.isArrayZero((byte[]) null, (-874));
    ArchiveUtils.isEqual((byte[]) null, (-1207), (-2876), (byte[]) null, 3161, 0);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test3939() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-3);
    byteArray0[1] = (byte) (-33);
    byteArray0[2] = (byte) 62;
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.matchAsciiBuffer(""{2"", byteArray0);
    ArchiveUtils.isEqual(byteArray0, (-3614), (int) (byte) (-33), byteArray0, (-820), 7);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test4040() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray0, 7);
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test4141() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 30;
    byteArray0[1] = (byte) 25;
    byteArray0[2] = (byte) 63;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 16;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 63, (int) (byte) 30, byteArray0, 0, 832);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test4242() throws Throwable {
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes("""");
    ArchiveUtils.isEqual(byteArray0, (-766), 0, byteArray0, 45, (-4159), true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean matchAsciiBuffer(final String expected, final byte[] buffer) {
    return matchAsciiBuffer(expected, buffer, 0, buffer.length);
}","public void test4343() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byte byte0 = (byte) 0;
    byteArray0[0] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray0, (byte) 0);
    ArchiveUtils.isEqual(byteArray0, byteArray0, false);
    int int0 = 702;
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) 0, 702, byteArray0, 0, (byte) 0);
    String string0 = ""RIPEND160"";
    // Undeclared exception!
    try {
        ArchiveUtils.matchAsciiBuffer(string0, byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Check if buffer contents matches Ascii String.
 *
 * @param expected the expected strin
 * @param buffer the buffer
 * @return {@code true} if buffer is the same as the expected string
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test4444() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-128);
    ArchiveUtils.isEqual(byteArray0, (int) (byte) (-128), 0, byteArray0, 0, (-982), false);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static String sanitize(String s) {
    final char[] chars = s.toCharArray();
    final int len = chars.length;
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < len; i++) {
        final char c = chars[i];
        if (!Character.isISOControl(c)) {
            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
            if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                sb.append(c);
                continue;
            }
        }
        sb.append('?');
    }
    return sb.toString();
}","public void test4545() throws Throwable {
    byte[] byteArray0 = null;
    ArchiveUtils.isEqual((byte[]) null, (-2141), (-2141), (byte[]) null, (-2141), (-2141), false);
    String string0 = """";
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry("""", (byte) 9);
    DumpArchiveEntry dumpArchiveEntry0 = new DumpArchiveEntry("""", """");
    Date date0 = tarArchiveEntry0.getLastModifiedDate();
    dumpArchiveEntry0.setAccessTime(date0);
    Date date1 = dumpArchiveEntry0.getAccessTime();
    tarArchiveEntry0.setModTime(date1);
    String string1 = ArchiveUtils.toString((ArchiveEntry) tarArchiveEntry0);
    ArchiveUtils.isEqual((byte[]) null, (byte[]) null, true);
    int int0 = (-1065);
    int int1 = 0;
    ArchiveUtils.matchAsciiBuffer(string0, byteArray0, int0, int1);
    // Undeclared exception!
    try {
        ArchiveUtils.sanitize(string1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Returns a ""sanitized"" version of the string given as arguments,
 * where sanitized means non-printable characters have been
 * replaced with a question mark and the outcome is not longer
 * than 255 chars.
 *
 * <p>This method is used to clean up file names when they are
 * used in exception messages as they may end up in log files or
 * as console output and may have been read from a corrupted
 * input.</p>
 *
 * @param s the string to sanitize
 * @return a sanitized version of the argument
 * @since Compress 1.12
 */"
"public static String toAsciiString(final byte[] inputBytes, final int offset, final int length) {
    try {
        return new String(inputBytes, offset, length, CharsetNames.US_ASCII);
    } catch (final UnsupportedEncodingException e) {
        // Should never happen
        throw new RuntimeException(e);
    }
}","public void test4646() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 32;
    byteArray0[3] = (byte) (-35);
    byteArray0[4] = (byte) 0;
    ArchiveUtils.toAsciiString(byteArray0, (int) (byte) 0, 0);
}","/**
 * Convert an input byte array to a String using the ASCII character set.
 *
 * @param inputBytes input byte array
 * @param offset offset within array
 * @param length length of array
 * @return the bytes, interpreted as an Ascii string
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test4747() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-8);
    byteArray0[1] = (byte) 100;
    byte byte0 = (byte) 83;
    byteArray0[2] = (byte) 83;
    ArchiveUtils.isArrayZero(byteArray0, (byte) 83);
    String string0 = ""o]]Ec"";
    ArchiveUtils.matchAsciiBuffer(""o]]Ec"", byteArray0, (int) (byte) 100, (int) (byte) 100);
    int int0 = (-53);
    // Undeclared exception!
    try {
        ArchiveUtils.isArrayZero(byteArray0, int0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 100
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test4848() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 126;
    byte[] byteArray1 = new byte[3];
    byteArray1[0] = (byte) 0;
    byteArray1[1] = (byte) 0;
    byteArray1[2] = (byte) (-62);
    ArchiveUtils.isEqual(byteArray0, byteArray1, false);
    ArchiveUtils.matchAsciiBuffer("""", byteArray1, (int) (byte) 0, (int) (byte) (-62));
    byte[] byteArray2 = new byte[9];
    byteArray2[0] = (byte) (-62);
    byteArray2[1] = (byte) 126;
    byteArray2[2] = (byte) 126;
    byteArray2[3] = (byte) 0;
    byteArray2[4] = (byte) 126;
    byteArray2[5] = (byte) 126;
    byteArray2[6] = (byte) 0;
    byteArray2[7] = (byte) 0;
    byteArray2[8] = (byte) 0;
    ArchiveUtils.isEqual(byteArray2, (-1306), (-780), byteArray0, (int) (byte) 0, 3312);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean matchAsciiBuffer(final String expected, final byte[] buffer) {
    return matchAsciiBuffer(expected, buffer, 0, buffer.length);
}","public void test5050() throws Throwable {
    String string0 = "" but is "";
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 125;
    ArchiveUtils.matchAsciiBuffer("" but is "", byteArray0);
    ArchiveUtils.isEqual(byteArray0, 32, 0, byteArray0, 0, (int) (byte) 125, false);
    ArchiveUtils.toAsciiString(byteArray0, (int) (byte) 125, 4050);
    byte[] byteArray1 = null;
    ArchiveUtils.isEqual(byteArray0, byteArray1);
    ArchiveUtils.sanitize(string0);
    // Undeclared exception!
    try {
        ArchiveUtils.matchAsciiBuffer(string0, byteArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Check if buffer contents matches Ascii String.
 *
 * @param expected the expected strin
 * @param buffer the buffer
 * @return {@code true} if buffer is the same as the expected string
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test5252() throws Throwable {
    ArchiveUtils.sanitize(""uX':elDq# !hTb="");
    ArchiveUtils.isEqual((byte[]) null, 1779, 0, (byte[]) null, 0, 904);
    byte[] byteArray0 = ArchiveUtils.toAsciiBytes("""");
    ArchiveUtils.toAsciiString(byteArray0);
    byte[] byteArray1 = new byte[2];
    byteArray1[0] = (byte) 0;
    byteArray1[1] = (byte) (-82);
    ArchiveUtils.isEqual(byteArray1, 707, (-61), byteArray0, (int) (byte) (-82), 327, false);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static String toAsciiString(final byte[] inputBytes) {
    try {
        return new String(inputBytes, CharsetNames.US_ASCII);
    } catch (final UnsupportedEncodingException e) {
        // Should never happen
        throw new RuntimeException(e);
    }
}","public void test5353() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-94);
    ArchiveUtils.isEqualWithNull(byteArray0, 430, (byte) (-94), byteArray0, (byte) (-94), (byte) (-94));
    ArchiveUtils.sanitize(""Lwlq8hR*hLL`$^%"");
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.matchAsciiBuffer("""", byteArray0, (-1096), (int) (byte) 0);
    byte[] byteArray1 = new byte[8];
    byteArray1[0] = (byte) (-1);
    byteArray1[1] = (byte) 32;
    byteArray1[2] = (byte) 100;
    byteArray1[3] = (byte) (-94);
    byteArray1[4] = (byte) 0;
    byteArray1[5] = (byte) (-94);
    byteArray1[6] = (byte) 0;
    byteArray1[7] = (byte) (-94);
    ArchiveUtils.toAsciiString(byteArray1);
}","/**
 * Convert an input byte array to a String using the ASCII character set.
 *
 * @param inputBytes bytes to convert
 * @return the bytes, interpreted as an Ascii string
 */"
"public static boolean matchAsciiBuffer(final String expected, final byte[] buffer, final int offset, final int length) {
    byte[] buffer1;
    try {
        buffer1 = expected.getBytes(CharsetNames.US_ASCII);
    } catch (final UnsupportedEncodingException e) {
        // Should not happen
        throw new RuntimeException(e);
    }
    return isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);
}","public void test5555() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 45;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 53;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 45;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) (-126);
    byteArray0[7] = (byte) (-46);
    byteArray0[8] = (byte) 0;
    ArchiveUtils.matchAsciiBuffer((String) null, byteArray0, (-846), (int) (byte) 0);
}","/**
 * Check if buffer contents matches Ascii String.
 *
 * @param expected expected string
 * @param buffer the buffer
 * @param offset offset to read from
 * @param length length of the buffer
 * @return {@code true} if buffer is the same as the expected string
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test5656() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) (-79);
    byteArray0[1] = (byte) (-55);
    byteArray0[2] = (byte) (-65);
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 79;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 56;
    byteArray0[7] = (byte) 0;
    byteArray0[8] = (byte) 108;
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) (-79), 0, byteArray0, (byte) 0, 198);
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test5757() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) (-116);
    byte byte0 = (byte) (-54);
    byteArray0[1] = (byte) (-54);
    byte byte1 = (byte) 1;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) (-30);
    byteArray0[4] = (byte) 27;
    int int0 = 0;
    ArchiveUtils.matchAsciiBuffer(""SoQ0ad"", byteArray0, 0, 0);
    ArchiveUtils.isEqual(byteArray0, 0, (int) (byte) 1, byteArray0, (int) (byte) 27, (-1441), false);
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isEqual(byteArray0, 0, 0, byteArray0, (int) (byte) 1, 0, false);
    ArchiveUtils.toAsciiString(byteArray0, 0, (int) (byte) 1);
    ArchiveUtils.isArrayZero(byteArray0, 600);
    ArchiveUtils.toAsciiString(byteArray0, (int) (byte) 1, 100);
    int int1 = (-5274);
    ArchiveUtils.toAsciiString(byteArray0, (int) byte0, int1);
    int int2 = 498;
    int int3 = 0;
    boolean boolean0 = false;
    ArchiveUtils.isEqual(byteArray0, int0, int2, byteArray0, int3, (int) byte1, boolean0);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static String toAsciiString(final byte[] inputBytes) {
    try {
        return new String(inputBytes, CharsetNames.US_ASCII);
    } catch (final UnsupportedEncodingException e) {
        // Should never happen
        throw new RuntimeException(e);
    }
}","public void test5858() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 0;
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    int int0 = 7;
    int int1 = 110;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 0, 7, byteArray0, (int) (byte) 0, 110, true);
    // Undeclared exception!
    try {
        ArchiveUtils.toAsciiString(byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Convert an input byte array to a String using the ASCII character set.
 *
 * @param inputBytes bytes to convert
 * @return the bytes, interpreted as an Ascii string
 */"
"public CpioArchiveEntry(final String name) {
    this(FORMAT_NEW, name);
}","public void test6161() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byte byte0 = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) (-5);
    byte byte1 = (byte) 32;
    byteArray0[3] = (byte) 32;
    byte byte2 = (byte) 0;
    byte byte3 = (byte) 21;
    byteArray0[5] = (byte) 21;
    int int0 = 0;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 0, (int) (byte) 21, byteArray0, (-2722), 0, true);
    int int1 = (-4592);
    ArchiveUtils.toAsciiString(byteArray0, (-4592), (int) (byte) 0);
    int int2 = 63;
    String string0 = ""C<uY43s"";
    CpioArchiveEntry cpioArchiveEntry0 = null;
    try {
        cpioArchiveEntry0 = new CpioArchiveEntry(string0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Creates a CPIOArchiveEntry with a specified name. The format of
 * this entry will be the new format.
 *
 * @param name
 *            The name of this entry.
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test6262() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 63;
    byteArray0[1] = (byte) 63;
    byteArray0[2] = (byte) (-65);
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 79;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 56;
    byteArray0[7] = (byte) 0;
    byteArray0[8] = (byte) 108;
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) 63, 0, byteArray0, (byte) 0, 198);
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqualWithNull(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);
}","public void test6363() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray0, (-252));
    ArchiveUtils.matchAsciiBuffer("""", byteArray0, (int) (byte) 0, (int) (byte) 0);
    ArchiveUtils.matchAsciiBuffer("""", byteArray0, 0, 667);
    ArchiveUtils.matchAsciiBuffer(""CRC32"", byteArray0, (int) (byte) 0, (-252));
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    byte[] byteArray1 = ArchiveUtils.toAsciiBytes(""org.apache.commons.compress.utils.ArchiveUtils"");
    byte[] byteArray2 = new byte[4];
    byteArray2[0] = (byte) 0;
    byteArray2[1] = (byte) 0;
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ""OF$a?$p(%q."");
    byteArray2[2] = (byte) 0;
    byteArray2[3] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray2, (byte) 0);
    ArchiveUtils.isEqual(byteArray1, (int) (byte) 0, (int) (byte) 0, byteArray2, (int) (byte) 0, (int) (byte) 0, true);
    ArArchiveEntry arArchiveEntry0 = new ArArchiveEntry("""", (byte) 0);
    arArchiveEntry0.getLastModifiedDate();
    arArchiveEntry0.getLastModifiedDate();
    ArchiveUtils.toString((ArchiveEntry) arArchiveEntry0);
    ArchiveUtils.isEqual(byteArray1, byteArray0, true);
    ArchiveUtils.isEqual(byteArray1, (int) (byte) 0, 22, byteArray2, (int) (byte) 0, 7, false);
    ArchiveUtils.isEqualWithNull(byteArray2, 0, (byte) 0, byteArray1, (byte) 0, (-2090));
}","/**
 * Compare byte buffers, ignoring trailing nulls
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static String toString(final ArchiveEntry entry) {
    final StringBuilder sb = new StringBuilder();
    // c.f. ""ls -l"" output
    sb.append(entry.isDirectory() ? 'd' : '-');
    final String size = Long.toString(entry.getSize());
    sb.append(' ');
    // Pad output to 7 places, leading spaces
    for (int i = 7; i > size.length(); i--) {
        sb.append(' ');
    }
    sb.append(size);
    sb.append(' ').append(entry.getName());
    return sb.toString();
}","public void test6464() throws Throwable {
    byte[] byteArray0 = new byte[0];
    FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
    MockFile mockFile0 = new MockFile("""");
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry(mockFile0, """");
    ArchiveUtils.toString((ArchiveEntry) zipArchiveEntry0);
}","/**
 * Generates a string containing the name, isDirectory setting and size of an entry.
 * <p>
 * For example:
 * <pre>
 * -    2000 main.c
 * d     100 testfiles
 * </pre>
 *
 * @param entry the entry
 * @return the representation of the entry
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2) {
    return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);
}","public void test6565() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 0;
    ArchiveUtils.isArrayZero(byteArray0, (byte) 0);
    ArchiveUtils.matchAsciiBuffer(""%Xg{Rzf)"", byteArray0);
    ArchiveUtils.sanitize("""");
    ArchiveUtils.isEqualWithNull((byte[]) null, (byte) 0, (-358), (byte[]) null, (-358), (byte) 0);
    byte[] byteArray1 = null;
    int int0 = 0;
    int int1 = (-2648);
    ArchiveUtils.isEqual(byteArray1, (int) byteArray0[0], int0, byteArray0, (int) byteArray0[0], int1);
}","/**
 * Compare byte buffers
 *
 * @param buffer1 the first buffer
 * @param offset1 the first offset
 * @param length1 the first length
 * @param buffer2 the second buffer
 * @param offset2 the second offset
 * @param length2 the second length
 * @return {@code true} if buffer1 and buffer2 have same contents
 */"
"public static boolean isArrayZero(final byte[] a, final int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != 0) {
            return false;
        }
    }
    return true;
}","public void test6666() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 1;
    byteArray0[0] = (byte) (-8);
    byte byte0 = (byte) 0;
    byteArray0[2] = (byte) 0;
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isArrayZero(byteArray0, (byte) 0);
    ArchiveUtils.toAsciiString(byteArray0);
    ArchiveUtils.isEqual(byteArray0, byteArray0);
    ArchiveUtils.toAsciiString(byteArray0, 0, (int) (byte) 1);
    ArchiveUtils.isEqualWithNull(byteArray0, (-1455), (byte) (-8), byteArray0, (byte) (-8), (byte) (-8));
    ArchiveUtils.isEqualWithNull(byteArray0, (byte) 0, (byte) 1, byteArray0, (byte) 0, (byte) 1);
    ArchiveUtils.sanitize(""\uFFFD\u0000\u0000"");
    byte[] byteArray1 = null;
    ArchiveUtils.isEqualWithNull(byteArray0, (-123), (byte) (-8), (byte[]) null, (-802), (-1850));
    byte[] byteArray2 = new byte[0];
    ArchiveUtils.isEqual(byteArray0, byteArray2);
    ArchiveUtils.isEqual(byteArray1, byteArray2);
    ArchiveUtils.isEqual(byteArray1, byteArray1);
    int int0 = 380;
    ArchiveUtils.isArrayZero(byteArray1, int0);
    // Undeclared exception!
    try {
        ArchiveUtils.isArrayZero(byteArray1, byte0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1973
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Returns true if the first N bytes of an array are all zero
 *
 * @param a
 *            The array to check
 * @param size
 *            The number of characters to check (not the size of the array)
 * @return true if the first N bytes are zero
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test6868() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 2;
    byteArray0[4] = (byte) 2;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 2, (int) (byte) 0, byteArray0, (-2722), (int) (byte) (-5), false);
    ArchiveUtils.sanitize(""p[K"");
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 2, (int) (byte) 2, byteArray0, (int) (byte) 2, 409, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
"public static boolean isEqual(final byte[] buffer1, final int offset1, final int length1, final byte[] buffer2, final int offset2, final int length2, final boolean ignoreTrailingNulls) {
    final int minLen = length1 < length2 ? length1 : length2;
    for (int i = 0; i < minLen; i++) {
        if (buffer1[offset1 + i] != buffer2[offset2 + i]) {
            return false;
        }
    }
    if (length1 == length2) {
        return true;
    }
    if (ignoreTrailingNulls) {
        if (length1 > length2) {
            for (int i = length2; i < length1; i++) {
                if (buffer1[offset1 + i] != 0) {
                    return false;
                }
            }
        } else {
            for (int i = length1; i < length2; i++) {
                if (buffer2[offset2 + i] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    return false;
}","public void test6969() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 2;
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 0, (int) (byte) 0, byteArray0, (-2722), (int) (byte) (-5), false);
    ArchiveUtils.sanitize(""p[K"");
    ArchiveUtils.isEqual(byteArray0, (int) (byte) 2, (int) (byte) 2, byteArray0, (int) (byte) 2, 409, true);
}","/**
 * Compare byte buffers, optionally ignoring trailing nulls
 *
 * @param buffer1 first buffer
 * @param offset1 first offset
 * @param length1 first length
 * @param buffer2 second buffer
 * @param offset2 second offset
 * @param length2 second length
 * @param ignoreTrailingNulls whether to ignore trailing nulls
 * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls
 */"
