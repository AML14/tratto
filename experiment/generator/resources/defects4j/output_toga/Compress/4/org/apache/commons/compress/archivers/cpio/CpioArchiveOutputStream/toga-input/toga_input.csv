focal_method,test_prefix,docstring
"public boolean isDirectory() {
    return (this.mode & S_IFMT) == C_ISDIR;
}","public void test000() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""}U*Q$D"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""}U*Q$D"");
    cpioArchiveEntry0.setTime((-1906L));
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    assertFalse(cpioArchiveEntry0.isDirectory());
}","/**
 * Check if this entry represents a directory.
 *
 * @return TRUE if this entry is a directory.
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test011() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    byte[] byteArray0 = new byte[4];
    cpioArchiveOutputStream0.write(byteArray0, (int) (byte) 0, (int) (byte) 0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public int getHeaderPadCount() {
    if (this.alignmentBoundary == 0)
        return 0;
    // Name has terminating null
    int size = this.headerSize + this.name.length() + 1;
    int remain = size % this.alignmentBoundary;
    if (remain > 0) {
        return this.alignmentBoundary - remain;
    }
    return 0;
}","public void test022() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""4l]<dXp<75<ps`yF"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    MockFile mockFile0 = new MockFile("""", ""4l]<dXp<75<ps`yF"");
    mockFile0.mkdirs();
    CpioArchiveEntry cpioArchiveEntry0 = (CpioArchiveEntry) cpioArchiveOutputStream0.createArchiveEntry(mockFile0, ""57A=bIz*i\""|3<sq"");
    assertEquals(2, cpioArchiveEntry0.getHeaderPadCount());
}","/**
 * Get the number of bytes needed to pad the header to the alignment boundary.
 *
 * @return the number of bytes needed to pad the header (0,1,2,3)
 */"
"public String getName();","public void test033() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""4l]<dXp<75<ps`yF"");
    mockPrintStream0.append((CharSequence) ""4l]<dXp<75<ps`yF"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    MockFile mockFile0 = new MockFile(""4l]<dXp<75<ps`yF"");
    ArchiveEntry archiveEntry0 = cpioArchiveOutputStream0.createArchiveEntry(mockFile0, """");
    assertEquals("""", archiveEntry0.getName());
}","/**
 * The name of the entry in the archive. May refer to a file or directory or other item
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test044() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.write((byte[]) null, 26, 26);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test055() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0, false);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    cpioArchiveOutputStream0.close();
    byte[] byteArray0 = new byte[0];
    try {
        cpioArchiveOutputStream0.write(byteArray0, 3858, 2438);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void putArchiveEntry(ArchiveEntry entry) throws IOException {
    CpioArchiveEntry e = (CpioArchiveEntry) entry;
    ensureOpen();
    if (this.entry != null) {
        // close previous entry
        closeArchiveEntry();
    }
    if (e.getTime() == -1) {
        e.setTime(System.currentTimeMillis());
    }
    final short format = e.getFormat();
    if (format != this.entryFormat) {
        throw new IOException(""Header format: "" + format + "" does not match existing format: "" + this.entryFormat);
    }
    if (this.names.put(e.getName(), e) != null) {
        throw new IOException(""duplicate entry: "" + e.getName());
    }
    writeHeader(e);
    this.entry = e;
    this.written = 0;
}","public void test066() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""6hqo$Jh4!6\u0004"", true);
    DataOutputStream dataOutputStream0 = new DataOutputStream(mockFileOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(dataOutputStream0);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.putArchiveEntry((ArchiveEntry) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Begins writing a new CPIO file entry and positions the stream to the
 * start of the entry data. Closes the current entry if still active. The
 * current time will be used if the entry has no set modification time and
 * the default header format will be used if no other format is specified in
 * the entry.
 *
 * @param entry
 *            the CPIO cpioEntry to be written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 * @throws ClassCastException if entry is not an instance of CpioArchiveEntry
 */"
"public void putArchiveEntry(ArchiveEntry entry) throws IOException {
    CpioArchiveEntry e = (CpioArchiveEntry) entry;
    ensureOpen();
    if (this.entry != null) {
        // close previous entry
        closeArchiveEntry();
    }
    if (e.getTime() == -1) {
        e.setTime(System.currentTimeMillis());
    }
    final short format = e.getFormat();
    if (format != this.entryFormat) {
        throw new IOException(""Header format: "" + format + "" does not match existing format: "" + this.entryFormat);
    }
    if (this.names.put(e.getName(), e) != null) {
        throw new IOException(""duplicate entry: "" + e.getName());
    }
    writeHeader(e);
    this.entry = e;
    this.written = 0;
}","public void test077() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    ArArchiveEntry arArchiveEntry0 = new ArArchiveEntry("""", 29127L);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.putArchiveEntry(arArchiveEntry0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.compress.archivers.ar.ArArchiveEntry cannot be cast to org.apache.commons.compress.archivers.cpio.CpioArchiveEntry
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Begins writing a new CPIO file entry and positions the stream to the
 * start of the entry data. Closes the current entry if still active. The
 * current time will be used if the entry has no set modification time and
 * the default header format will be used if no other format is specified in
 * the entry.
 *
 * @param entry
 *            the CPIO cpioEntry to be written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 * @throws ClassCastException if entry is not an instance of CpioArchiveEntry
 */"
"public void finish() throws IOException {
    ensureOpen();
    if (this.finished) {
        return;
    }
    if (this.entry != null) {
        throw new IOException(""This archives contains unclosed entries."");
    }
    this.entry = new CpioArchiveEntry(this.entryFormat);
    this.entry.setName(CPIO_TRAILER);
    this.entry.setNumberOfLinks(1);
    writeHeader(this.entry);
    closeArchiveEntry();
}","public void test088() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.finish();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Finishes writing the contents of the CPIO output stream without closing
 * the underlying stream. Use this method when applying multiple filters in
 * succession to the same output stream.
 *
 * @throws IOException
 *             if an I/O exception has occurred or if a CPIO file error has
 *             occurred
 */"
"/*(non-Javadoc)
     * 
     * @see
     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry
     * ()
     */
public void closeArchiveEntry() throws IOException {
    ensureOpen();
    if (this.entry.getSize() != this.written) {
        throw new IOException(""invalid entry size (expected "" + this.entry.getSize() + "" but got "" + this.written + "" bytes)"");
    }
    pad(this.entry.getDataPadCount());
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        if (this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error"");
        }
    }
    this.entry = null;
    this.crc = 0;
    this.written = 0;
}","public void test099() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""#p<`9]?z~"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.closeArchiveEntry();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}",""
"public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}","public void test1010() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.close();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}","public void test1111() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""#p<`9]?z~"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""#p<`9]?z~"");
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    try {
        cpioArchiveOutputStream0.close();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // This archives contains unclosed entries.
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"/*(non-Javadoc)
     * 
     * @see
     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry
     * ()
     */
public void closeArchiveEntry() throws IOException {
    ensureOpen();
    if (this.entry.getSize() != this.written) {
        throw new IOException(""invalid entry size (expected "" + this.entry.getSize() + "" but got "" + this.written + "" bytes)"");
    }
    pad(this.entry.getDataPadCount());
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        if (this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error"");
        }
    }
    this.entry = null;
    this.crc = 0;
    this.written = 0;
}","public void test1515() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""#p<`9]?z~"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""#p<`9]?z~"");
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    cpioArchiveOutputStream0.closeArchiveEntry();
}",""
"public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}","public void test1616() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""N!=MR-2Hz"", true);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockFileOutputStream0, (short) 1);
    cpioArchiveOutputStream0.close();
}","/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}","public void test1717() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0, false);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    cpioArchiveOutputStream0.close();
    cpioArchiveOutputStream0.close();
}","/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void finish() throws IOException {
    ensureOpen();
    if (this.finished) {
        return;
    }
    if (this.entry != null) {
        throw new IOException(""This archives contains unclosed entries."");
    }
    this.entry = new CpioArchiveEntry(this.entryFormat);
    this.entry.setName(CPIO_TRAILER);
    this.entry.setNumberOfLinks(1);
    writeHeader(this.entry);
    closeArchiveEntry();
}","public void test1818() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""}U*Q$D"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""}U*Q$D"");
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    try {
        cpioArchiveOutputStream0.finish();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // This archives contains unclosed entries.
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Finishes writing the contents of the CPIO output stream without closing
 * the underlying stream. Use this method when applying multiple filters in
 * succession to the same output stream.
 *
 * @throws IOException
 *             if an I/O exception has occurred or if a CPIO file error has
 *             occurred
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test2020() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(24609);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) 4);
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.write(byteArray0, 24608, 1);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test2121() throws Throwable {
    byte[] byteArray0 = new byte[4];
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("">QDkwC/'"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockFileOutputStream0);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.write(byteArray0, 6, (-746));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public void write(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    if (this.entry == null) {
        throw new IOException(""no current CPIO entry"");
    }
    if (this.written + len > this.entry.getSize()) {
        throw new IOException(""attempt to write past end of STORED entry"");
    }
    out.write(b, off, len);
    this.written += len;
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < len; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
}","public void test2222() throws Throwable {
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream((OutputStream) null);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(bufferedOutputStream0, (short) 2);
    byte[] byteArray0 = new byte[8];
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.write(byteArray0, (int) (byte) (-2), (int) (byte) 0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Writes an array of bytes to the current CPIO entry data. This method will
 * block until all the bytes are written.
 *
 * @param b
 *            the data to be written
 * @param off
 *            the start offset in the data
 * @param len
 *            the number of bytes that are written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"/*(non-Javadoc)
     * 
     * @see
     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry
     * ()
     */
public void closeArchiveEntry() throws IOException {
    ensureOpen();
    if (this.entry.getSize() != this.written) {
        throw new IOException(""invalid entry size (expected "" + this.entry.getSize() + "" but got "" + this.written + "" bytes)"");
    }
    pad(this.entry.getDataPadCount());
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        if (this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error"");
        }
    }
    this.entry = null;
    this.crc = 0;
    this.written = 0;
}","public void test2323() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""}U*Q$D"");
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockPrintStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""}U*Q$D"");
    cpioArchiveEntry0.setSize(4L);
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    try {
        cpioArchiveOutputStream0.closeArchiveEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // invalid entry size (expected 4 but got 0 bytes)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}",""
"public void putArchiveEntry(ArchiveEntry entry) throws IOException {
    CpioArchiveEntry e = (CpioArchiveEntry) entry;
    ensureOpen();
    if (this.entry != null) {
        // close previous entry
        closeArchiveEntry();
    }
    if (e.getTime() == -1) {
        e.setTime(System.currentTimeMillis());
    }
    final short format = e.getFormat();
    if (format != this.entryFormat) {
        throw new IOException(""Header format: "" + format + "" does not match existing format: "" + this.entryFormat);
    }
    if (this.names.put(e.getName(), e) != null) {
        throw new IOException(""duplicate entry: "" + e.getName());
    }
    writeHeader(e);
    this.entry = e;
    this.written = 0;
}","public void test2424() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(24576);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) 4);
    File file0 = MockFile.createTempFile(""org.apache.commons.compress.archivers.zip.UnicodePathExtraField"", ""org.apache.commons.compress.archivers.zip.UnicodePathExtraField"");
    ArchiveEntry archiveEntry0 = cpioArchiveOutputStream0.createArchiveEntry(file0, """");
    try {
        cpioArchiveOutputStream0.putArchiveEntry(archiveEntry0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Header format: 1 does not match existing format: 4
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Begins writing a new CPIO file entry and positions the stream to the
 * start of the entry data. Closes the current entry if still active. The
 * current time will be used if the entry has no set modification time and
 * the default header format will be used if no other format is specified in
 * the entry.
 *
 * @param entry
 *            the CPIO cpioEntry to be written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 * @throws ClassCastException if entry is not an instance of CpioArchiveEntry
 */"
"public CpioArchiveOutputStream(final OutputStream out, final short format) {
    this.out = new FilterOutputStream(out);
    switch(format) {
        case FORMAT_NEW:
        case FORMAT_NEW_CRC:
        case FORMAT_OLD_ASCII:
        case FORMAT_OLD_BINARY:
            break;
        default:
            throw new IllegalArgumentException(""Unknown format: "" + format);
    }
    this.entryFormat = format;
}","public void test2525() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    CpioArchiveOutputStream cpioArchiveOutputStream0 = null;
    try {
        cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) (-893));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown format: -893
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Construct the cpio output stream with a specified format
 *
 * @param out
 *            The cpio stream
 * @param format
 *            The format of the stream
 */"
"public CpioArchiveOutputStream(final OutputStream out, final short format) {
    this.out = new FilterOutputStream(out);
    switch(format) {
        case FORMAT_NEW:
        case FORMAT_NEW_CRC:
        case FORMAT_OLD_ASCII:
        case FORMAT_OLD_BINARY:
            break;
        default:
            throw new IllegalArgumentException(""Unknown format: "" + format);
    }
    this.entryFormat = format;
}","public void test2626() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    CpioArchiveOutputStream cpioArchiveOutputStream0 = null;
    try {
        cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) 7);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown format: 7
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Construct the cpio output stream with a specified format
 *
 * @param out
 *            The cpio stream
 * @param format
 *            The format of the stream
 */"
"public CpioArchiveOutputStream(final OutputStream out, final short format) {
    this.out = new FilterOutputStream(out);
    switch(format) {
        case FORMAT_NEW:
        case FORMAT_NEW_CRC:
        case FORMAT_OLD_ASCII:
        case FORMAT_OLD_BINARY:
            break;
        default:
            throw new IllegalArgumentException(""Unknown format: "" + format);
    }
    this.entryFormat = format;
}","public void test2727() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(255);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = null;
    try {
        cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) 6);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown format: 6
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Construct the cpio output stream with a specified format
 *
 * @param out
 *            The cpio stream
 * @param format
 *            The format of the stream
 */"
"public CpioArchiveOutputStream(final OutputStream out, final short format) {
    this.out = new FilterOutputStream(out);
    switch(format) {
        case FORMAT_NEW:
        case FORMAT_NEW_CRC:
        case FORMAT_OLD_ASCII:
        case FORMAT_OLD_BINARY:
            break;
        default:
            throw new IllegalArgumentException(""Unknown format: "" + format);
    }
    this.entryFormat = format;
}","public void test2828() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = null;
    try {
        cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short) 5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown format: 5
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Construct the cpio output stream with a specified format
 *
 * @param out
 *            The cpio stream
 * @param format
 *            The format of the stream
 */"
"public CpioArchiveOutputStream(final OutputStream out, final short format) {
    this.out = new FilterOutputStream(out);
    switch(format) {
        case FORMAT_NEW:
        case FORMAT_NEW_CRC:
        case FORMAT_OLD_ASCII:
        case FORMAT_OLD_BINARY:
            break;
        default:
            throw new IllegalArgumentException(""Unknown format: "" + format);
    }
    this.entryFormat = format;
}","public void test2929() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""org.apache.commons.compress.archivers.cpio.CpioArchiveEntry"", false);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = null;
    try {
        cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockFileOutputStream0, (short) 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown format: 3
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Construct the cpio output stream with a specified format
 *
 * @param out
 *            The cpio stream
 * @param format
 *            The format of the stream
 */"
"public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {
    return new CpioArchiveEntry(inputFile, entryName);
}","public void test3132() throws Throwable {
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream((OutputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveOutputStream0.createArchiveEntry((File) null, ""070702"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveEntry"", e);
    }
}",""
"public void finish() throws IOException {
    ensureOpen();
    if (this.finished) {
        return;
    }
    if (this.entry != null) {
        throw new IOException(""This archives contains unclosed entries."");
    }
    this.entry = new CpioArchiveEntry(this.entryFormat);
    this.entry.setName(CPIO_TRAILER);
    this.entry.setNumberOfLinks(1);
    writeHeader(this.entry);
    closeArchiveEntry();
}","public void test3335() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""l~NBve2S~3U=0MB"", false);
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(mockFileOutputStream0, (short) 8);
    cpioArchiveOutputStream0.finish();
}","/**
 * Finishes writing the contents of the CPIO output stream without closing
 * the underlying stream. Use this method when applying multiple filters in
 * succession to the same output stream.
 *
 * @throws IOException
 *             if an I/O exception has occurred or if a CPIO file error has
 *             occurred
 */"
"public void putArchiveEntry(ArchiveEntry entry) throws IOException {
    CpioArchiveEntry e = (CpioArchiveEntry) entry;
    ensureOpen();
    if (this.entry != null) {
        // close previous entry
        closeArchiveEntry();
    }
    if (e.getTime() == -1) {
        e.setTime(System.currentTimeMillis());
    }
    final short format = e.getFormat();
    if (format != this.entryFormat) {
        throw new IOException(""Header format: "" + format + "" does not match existing format: "" + this.entryFormat);
    }
    if (this.names.put(e.getName(), e) != null) {
        throw new IOException(""duplicate entry: "" + e.getName());
    }
    writeHeader(e);
    this.entry = e;
    this.written = 0;
}","public void test3436() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0);
    CpioArchiveEntry cpioArchiveEntry0 = new CpioArchiveEntry(""WHnZv6"");
    cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
    try {
        cpioArchiveOutputStream0.putArchiveEntry(cpioArchiveEntry0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // duplicate entry: WHnZv6
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"", e);
    }
}","/**
 * Begins writing a new CPIO file entry and positions the stream to the
 * start of the entry data. Closes the current entry if still active. The
 * current time will be used if the entry has no set modification time and
 * the default header format will be used if no other format is specified in
 * the entry.
 *
 * @param entry
 *            the CPIO cpioEntry to be written
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 * @throws ClassCastException if entry is not an instance of CpioArchiveEntry
 */"
