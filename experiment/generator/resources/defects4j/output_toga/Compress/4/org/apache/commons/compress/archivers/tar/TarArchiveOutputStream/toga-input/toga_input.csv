focal_method,test_prefix,docstring
"// used to be implemented via FilterOutputStream
public void flush() throws IOException {
    out.flush();
}","public void test000() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0);
    tarArchiveOutputStream0.flush();
    assertEquals(0, TarArchiveOutputStream.LONGFILE_ERROR);
}",""
"public TarArchiveOutputStream(OutputStream os, int blockSize) {
    this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
}","public void test011() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0, 223);
    assertEquals(1, TarArchiveOutputStream.LONGFILE_TRUNCATE);
}","/**
 * Constructor for TarInputStream.
 * @param os the output stream to use
 * @param blockSize the block size to use
 */"
"public int getRecordSize() {
    return buffer.getRecordSize();
}","public void test022() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0, 1756, 1756);
    int int0 = tarArchiveOutputStream0.getRecordSize();
    assertEquals(1756, int0);
}","/**
 * Get the record size being used by this stream's TarBuffer.
 *
 * @return The TarBuffer record size.
 */"
"public void close() throws IOException {
    if (!closed) {
        finish();
        buffer.close();
        out.close();
        closed = true;
    }
}","public void test033() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""V!^/XJ_6vB*2="");
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);
    MockFile mockFile0 = new MockFile("""", ""V!^/XJ_6vB*2="");
    ArchiveEntry archiveEntry0 = tarArchiveOutputStream0.createArchiveEntry(mockFile0, ""V!^/XJ_6vB*2="");
    tarArchiveOutputStream0.putArchiveEntry(archiveEntry0);
    try {
        tarArchiveOutputStream0.close();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // This archives contains unclosed entries.
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"", e);
    }
}","/**
 * Closes the underlying OutputStream.
 * @throws IOException on error
 */"
"public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;
    if (entry.getName().length() >= TarConstants.NAMELEN) {
        if (longFileMode == LONGFILE_GNU) {
            // create a TarEntry for the LongLink, the contents
            // of which are the entry's name
            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);
            // TODO is it correct to use the default charset here?
            final byte[] nameBytes = entry.getName().getBytes();
            // +1 for NUL
            longLinkEntry.setSize(nameBytes.length + 1);
            putArchiveEntry(longLinkEntry);
            write(nameBytes);
            // NUL terminator
            write(0);
            closeArchiveEntry();
        } else if (longFileMode != LONGFILE_TRUNCATE) {
            throw new RuntimeException(""file name '"" + entry.getName() + ""' is too long ( > "" + TarConstants.NAMELEN + "" bytes)"");
        }
    }
    entry.writeEntryHeader(recordBuf);
    buffer.writeRecord(recordBuf);
    currBytes = 0;
    if (entry.isDirectory()) {
        currSize = 0;
    } else {
        currSize = entry.getSize();
    }
    currName = entry.getName();
    haveUnclosedEntry = true;
}","public void test055() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(475);
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0, 475, 475);
    MockFile mockFile0 = new MockFile(""org.apache.com+ons.compress.archivers.zip.ZipArchiveEntGy"", ""org.apache.com+ons.compress.archivers.zip.ZipArchiveEntGy"");
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(mockFile0);
    // Undeclared exception!
    try {
        tarArchiveOutputStream0.putArchiveEntry(tarArchiveEntry0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // file name 'Users/elliottzackrone/IdeaProjects/defects4jprefix/org.apache.com+ons.compress.archivers.zip.ZipArchiveEntGy/org.apache.com+ons.compress.archivers.zip.ZipArchiveEntGy' is too long ( > 100 bytes)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"", e);
    }
}","/**
 * Put an entry on the output stream. This writes the entry's
 * header record and positions the output stream for writing
 * the contents of the entry. Once this method is called, the
 * stream is ready for calls to write() to write the entry's
 * contents. Once the contents are written, closeArchiveEntry()
 * <B>MUST</B> be called to ensure that all buffered data
 * is completely written to the output stream.
 *
 * @param archiveEntry The TarEntry to be written to the archive.
 * @throws IOException on error
 * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry
 */"
"public int getMode() {
    return mode;
}","public void test077() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    MockFile mockFile0 = new MockFile("""");
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(mockFile0);
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0);
    tarArchiveOutputStream0.putArchiveEntry(tarArchiveEntry0);
    assertEquals(16877, tarArchiveEntry0.getMode());
}","/**
 * Get this entry's mode.
 *
 * @return This entry's mode.
 */"
"public void closeArchiveEntry() throws IOException {
    if (assemLen > 0) {
        for (int i = assemLen; i < assemBuf.length; ++i) {
            assemBuf[i] = 0;
        }
        buffer.writeRecord(assemBuf);
        currBytes += assemLen;
        assemLen = 0;
    }
    if (currBytes < currSize) {
        throw new IOException(""entry '"" + currName + ""' closed at '"" + currBytes + ""' before the '"" + currSize + ""' bytes specified in the header were written"");
    }
    haveUnclosedEntry = false;
}","public void test0910() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(2090);
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0, 2090, 2090);
    tarArchiveOutputStream0.setLongFileMode(2);
    MockFile mockFile0 = new MockFile(""org.apache.commons.compress.archivers.zip.ZipArchiveEntry"", ""org.apache.commons.compress.archivers.zip.ZipArchiveEntry"");
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(mockFile0);
    tarArchiveEntry0.setSize(1L);
    tarArchiveOutputStream0.putArchiveEntry(tarArchiveEntry0);
    try {
        tarArchiveOutputStream0.closeArchiveEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // entry 'Users/elliottzackrone/IdeaProjects/defects4jprefix/org.apache.commons.compress.archivers.zip.ZipArchiveEntry/org.apache.commons.compress.archivers.zip.ZipArchiveEntry' closed at '0' before the '1' bytes specified in the header were written
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"", e);
    }
}","/**
 * Close an entry. This method MUST be called for all file
 * entries that contain data. The reason is that we must
 * buffer data written to the stream in order to satisfy
 * the buffer's record based writes. Thus, there may be
 * data fragments still being assembled that must be written
 * to the output stream before this entry is closed and the
 * next entry written.
 * @throws IOException on error
 */"
"// Generic implementations of OutputStream methods that may be useful to sub-classes
/**
 * Writes a byte to the current archive entry.
 *
 * This method simply calls write( byte[], 0, 1 ).
 *
 * MUST be overridden if the {@link #write(byte[], int, int)} method
 * is not overridden; may be overridden otherwise.
 *
 * @param b The byte to be written.
 * @throws IOException on error
 */
public void write(int b) throws IOException {
    oneByte[0] = (byte) (b & BYTE_MASK);
    write(oneByte, 0, 1);
}","public void test1011() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(byteArrayOutputStream0);
    try {
        tarArchiveOutputStream0.write(0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // request to write '1' bytes exceeds size in header of '0' bytes for entry 'null'
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"", e);
    }
}",""
