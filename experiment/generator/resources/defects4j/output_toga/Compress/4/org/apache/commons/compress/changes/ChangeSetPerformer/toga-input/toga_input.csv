focal_method,test_prefix,docstring
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test00() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-93);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    // Undeclared exception!
    try {
        changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.changes.ChangeSetPerformer"", e);
    }
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test11() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    changeSet0.deleteDir(""U"");
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    ChangeSetResults changeSetResults0 = changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
    assertNotNull(changeSetResults0);
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test22() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""U"", (byte) 121);
    changeSet0.add((ArchiveEntry) tarArchiveEntry0, (InputStream) byteArrayInputStream0, false);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    // Undeclared exception!
    try {
        changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.changes.ChangeSetPerformer"", e);
    }
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test33() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    ArArchiveEntry arArchiveEntry0 = new ArArchiveEntry(""a"", 0L);
    JarArchiveInputStream jarArchiveInputStream0 = new JarArchiveInputStream((InputStream) null);
    changeSet0.add((ArchiveEntry) arArchiveEntry0, (InputStream) jarArchiveInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    // Undeclared exception!
    try {
        changeSetPerformer0.perform(jarArchiveInputStream0, (ArchiveOutputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.changes.ChangeSetPerformer"", e);
    }
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test44() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    changeSet0.deleteDir(""U"");
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-93);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    // Undeclared exception!
    try {
        changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.changes.ChangeSetPerformer"", e);
    }
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test55() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-12);
    changeSet0.delete(""@5IOC/=*+)P<bsy"");
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    // Undeclared exception!
    try {
        changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.changes.ChangeSetPerformer"", e);
    }
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test66() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    byte[] byteArray0 = new byte[9];
    byteArray0[8] = (byte) (-63);
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    changeSet0.delete("""");
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    ChangeSetResults changeSetResults0 = changeSetPerformer0.perform(tarArchiveInputStream0, (ArchiveOutputStream) null);
    assertNotNull(changeSetResults0);
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","public void test77() throws Throwable {
    ChangeSet changeSet0 = new ChangeSet();
    byte[] byteArray0 = new byte[2];
    byteArray0[1] = (byte) 1;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""~Wc,v'a?KG+#;>TG"");
    TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);
    ArArchiveEntry arArchiveEntry0 = new ArArchiveEntry("""", 1);
    changeSet0.add((ArchiveEntry) arArchiveEntry0, (InputStream) byteArrayInputStream0, false);
    ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);
    ChangeSetResults changeSetResults0 = changeSetPerformer0.perform(tarArchiveInputStream0, tarArchiveOutputStream0);
    assertNotNull(changeSetResults0);
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */"
