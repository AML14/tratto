focal_method,test_prefix,docstring
"public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                // only look at the first octal digit sequence
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum || // COMPRESS-177
    storedSum > unsignedSum;
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-15);
    TarUtils.verifyCheckSum(byteArray0);
}","/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * In addition there are
 * <a href=""https://issues.apache.org/jira/browse/COMPRESS-117"">some tar files</a>
 * that seem to have parts of their header cleared to zero (no detectable
 * magic bytes, etc.) but still have a reasonable-looking checksum field
 * present. It looks like we can detect such cases reasonably well by
 * checking whether the stored checksum is <em>greater than</em> the
 * computed unsigned checksum. That check is unlikely to pass on some
 * random file header, as it would need to have a valid sequence of
 * octal digits in just the right place.
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes((-1L), byteArray0, (byte) 14, (byte) 9);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test022() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes(8589934591L, (byte[]) null, 1, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8589934591=77777777777 will not fit in octal number buffer of length 0
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test033() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, 1407, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1405
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    final boolean negative = buffer[offset] == (byte) 0xff;
    if (length < 9) {
        return parseBinaryLong(buffer, offset, length, negative);
    }
    return parseBinaryBigInteger(buffer, offset, length, negative);
}","public void test044() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byteArray0[0] = (byte) 38;
    byteArray0[1] = (byte) (-111);
    // Undeclared exception!
    try {
        TarUtils.parseOctalOrBinary(byteArray0, 0, 2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 38 at offset 0 in '&\uFFFD' len=2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since 1.4
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test055() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[8] = (byte) (-86);
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 8, 5396);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5403
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test066() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes(0L, byteArray0, (byte) 32, (byte) 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 33
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    try {
        return parseName(buffer, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return parseName(buffer, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test077() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byteArray0[0] = (byte) 61;
    TarUtils.parseName(byteArray0, 0, 10);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test088() throws Throwable {
    byte[] byteArray0 = new byte[22];
    TarUtils.formatOctalBytes(0L, byteArray0, (byte) 20, (byte) 0);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = name.length();
    ByteBuffer b = encoding.encode(name);
    while (b.limit() > length && len > 0) {
        b = encoding.encode(name.substring(0, --len));
    }
    final int limit = b.limit() - b.position();
    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);
    // Pad any remaining output bytes with NUL
    for (int i = limit; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test099() throws Throwable {
    byte[] byteArray0 = new byte[1];
    ZipEncoding zipEncoding0 = TarUtils.DEFAULT_ENCODING;
    TarUtils.formatNameBytes(""AEp]<"", byteArray0, (int) (byte) 0, (int) (byte) 0, zipEncoding0);
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = name.length();
    ByteBuffer b = encoding.encode(name);
    while (b.limit() > length && len > 0) {
        b = encoding.encode(name.substring(0, --len));
    }
    final int limit = b.limit() - b.position();
    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);
    // Pad any remaining output bytes with NUL
    for (int i = limit; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test1010() throws Throwable {
    byte[] byteArray0 = new byte[14];
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    TarUtils.formatNameBytes(""{NUL}"", byteArray0, (int) (byte) 1, (int) (byte) 1, zipEncoding0);
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    try {
        return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return formatNameBytes(name, buf, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[3];
    TarUtils.formatNameBytes(""org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding"", byteArray0, (int) (byte) 0, 0);
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    try {
        return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return formatNameBytes(name, buf, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test1212() throws Throwable {
    byte[] byteArray0 = new byte[1];
    TarUtils.formatNameBytes("" is too large for "", byteArray0, (int) (byte) 1, 0);
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    try {
        return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return formatNameBytes(name, buf, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test1313() throws Throwable {
    byte[] byteArray0 = new byte[7];
    TarUtils.formatNameBytes(""Jx0DNRLj<alwcB8)!l"", byteArray0, 0, (int) (byte) (-7));
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (byte element : buf) {
        sum += BYTE_MASK & element;
    }
    return sum;
}","public void test1414() throws Throwable {
    byte[] byteArray0 = new byte[14];
    byteArray0[0] = (byte) 43;
    TarUtils.computeCheckSum(byteArray0);
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                // only look at the first octal digit sequence
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum || // COMPRESS-177
    storedSum > unsignedSum;
}","public void test1515() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.verifyCheckSum((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * In addition there are
 * <a href=""https://issues.apache.org/jira/browse/COMPRESS-117"">some tar files</a>
 * that seem to have parts of their header cleared to zero (no detectable
 * magic bytes, etc.) but still have a reasonable-looking checksum field
 * present. It looks like we can detect such cases reasonably well by
 * checking whether the stored checksum is <em>greater than</em> the
 * computed unsigned checksum. That check is unlikely to pass on some
 * random file header, as it would need to have a valid sequence of
 * octal digits in just the right place.
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    final boolean negative = buffer[offset] == (byte) 0xff;
    if (length < 9) {
        return parseBinaryLong(buffer, offset, length, negative);
    }
    return parseBinaryBigInteger(buffer, offset, length, negative);
}","public void test1616() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseOctalOrBinary((byte[]) null, (-1010), 2270);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since 1.4
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test1717() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseOctal((byte[]) null, (-2971), 9);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = length;
    for (; len > 0; len--) {
        if (buffer[offset + len - 1] != 0) {
            break;
        }
    }
    if (len > 0) {
        byte[] b = new byte[len];
        System.arraycopy(buffer, offset, b, 0, len);
        return encoding.decode(b);
    }
    return """";
}","public void test1818() throws Throwable {
    ZipEncoding zipEncoding0 = TarUtils.DEFAULT_ENCODING;
    // Undeclared exception!
    try {
        TarUtils.parseName((byte[]) null, (-4302), 253, zipEncoding0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = length;
    for (; len > 0; len--) {
        if (buffer[offset + len - 1] != 0) {
            break;
        }
    }
    if (len > 0) {
        byte[] b = new byte[len];
        System.arraycopy(buffer, offset, b, 0, len);
        return encoding.decode(b);
    }
    return """";
}","public void test1919() throws Throwable {
    byte[] byteArray0 = new byte[4];
    ZipEncoding zipEncoding0 = TarUtils.DEFAULT_ENCODING;
    // Undeclared exception!
    try {
        TarUtils.parseName(byteArray0, (int) (byte) 0, 7, zipEncoding0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 6
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    try {
        return parseName(buffer, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return parseName(buffer, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test2020() throws Throwable {
    byte[] byteArray0 = new byte[7];
    // Undeclared exception!
    try {
        TarUtils.parseName(byteArray0, (-3843), 1663);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2181
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test2121() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseBoolean((byte[]) null, (-49));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test2222() throws Throwable {
    byte[] byteArray0 = new byte[8];
    // Undeclared exception!
    try {
        TarUtils.parseBoolean(byteArray0, 55);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 55
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test2323() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(0L, (byte[]) null, 3293, 3293);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test2424() throws Throwable {
    byte[] byteArray0 = new byte[7];
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(929L, byteArray0, 225, (-3730));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 929=1641 will not fit in octal number buffer of length -3732
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = name.length();
    ByteBuffer b = encoding.encode(name);
    while (b.limit() > length && len > 0) {
        b = encoding.encode(name.substring(0, --len));
    }
    final int limit = b.limit() - b.position();
    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);
    // Pad any remaining output bytes with NUL
    for (int i = limit; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test2525() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(""\""jpGIED/po-SHzQnU"", byteArray0, 0, (int) (byte) 106, (ZipEncoding) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    try {
        return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return formatNameBytes(name, buf, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test2626() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes("""", byteArray0, 1846, 566);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test2727() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes(818L, (byte[]) null, 8730, 8730);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2828() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes(0L, (byte[]) null, 9, 2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2929() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes((-20L), byteArray0, (byte) 1, (byte) 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -20=1777777777777777777754 will not fit in octal number buffer of length 2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test3030() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes(0L, (byte[]) null, 789, 789);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test3131() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes((-1L), byteArray0, 168, 6);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 171
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (byte element : buf) {
        sum += BYTE_MASK & element;
    }
    return sum;
}","public void test3232() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test3333() throws Throwable {
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString((-570L), byteArray0, (byte) (-63), (byte) 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -570=1777777777777777776706 will not fit in octal number buffer of length 0
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test3434() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString(0L, byteArray0, 4572, 913);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5484
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = length;
    for (; len > 0; len--) {
        if (buffer[offset + len - 1] != 0) {
            break;
        }
    }
    if (len > 0) {
        byte[] b = new byte[len];
        System.arraycopy(buffer, offset, b, 0, len);
        return encoding.decode(b);
    }
    return """";
}","public void test3535() throws Throwable {
    byte[] byteArray0 = new byte[0];
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    TarUtils.parseName(byteArray0, (-1173), (-1173), zipEncoding0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The entry name.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3636() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[2] = (byte) 24;
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, (byte) 2, (byte) 2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 24 at offset 0 in '\u0018{NUL}' len=2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3737() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 116;
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 0, (byte) 9);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 116 at offset 0 in 't{NUL}{NUL}{NUL}{NUL}{NUL}{NUL}{NUL}{NUL}' len=9
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                // only look at the first octal digit sequence
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum || // COMPRESS-177
    storedSum > unsignedSum;
}","public void test3838() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 33;
    boolean boolean0 = TarUtils.verifyCheckSum(byteArray0);
    assertFalse(boolean0);
}","/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * In addition there are
 * <a href=""https://issues.apache.org/jira/browse/COMPRESS-117"">some tar files</a>
 * that seem to have parts of their header cleared to zero (no detectable
 * magic bytes, etc.) but still have a reasonable-looking checksum field
 * present. It looks like we can detect such cases reasonably well by
 * checking whether the stored checksum is <em>greater than</em> the
 * computed unsigned checksum. That check is unlikely to pass on some
 * random file header, as it would need to have a valid sequence of
 * octal digits in just the right place.
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */"
"public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                // only look at the first octal digit sequence
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum || // COMPRESS-177
    storedSum > unsignedSum;
}","public void test3939() throws Throwable {
    byte[] byteArray0 = new byte[1];
    boolean boolean0 = TarUtils.verifyCheckSum(byteArray0);
    assertTrue(boolean0);
}","/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * In addition there are
 * <a href=""https://issues.apache.org/jira/browse/COMPRESS-117"">some tar files</a>
 * that seem to have parts of their header cleared to zero (no detectable
 * magic bytes, etc.) but still have a reasonable-looking checksum field
 * present. It looks like we can detect such cases reasonably well by
 * checking whether the stored checksum is <em>greater than</em> the
 * computed unsigned checksum. That check is unlikely to pass on some
 * random file header, as it would need to have a valid sequence of
 * octal digits in just the right place.
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (byte element : buf) {
        sum += BYTE_MASK & element;
    }
    return sum;
}","public void test4040() throws Throwable {
    byte[] byteArray0 = new byte[14];
    long long0 = TarUtils.computeCheckSum(byteArray0);
    assertEquals(0L, long0);
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test4141() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes((-939L), byteArray0, 799, (-786));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test4242() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes((-4136L), byteArray0, 0, (byte) (-63));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value -4136 is too large for -63 byte field.
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test4343() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes(2305843009213693949L, byteArray0, (byte) (-86), 228);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","public void test4444() throws Throwable {
    byte[] byteArray0 = new byte[2];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes((-808L), byteArray0, (byte) 45, 8);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 52
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = name.length();
    ByteBuffer b = encoding.encode(name);
    while (b.limit() > length && len > 0) {
        b = encoding.encode(name.substring(0, --len));
    }
    final int limit = b.limit() - b.position();
    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);
    // Pad any remaining output bytes with NUL
    for (int i = limit; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test4545() throws Throwable {
    byte[] byteArray0 = new byte[14];
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(""{NUL}"", byteArray0, (int) (byte) 1, 162, zipEncoding0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 14
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The updated offset, i.e. offset + length
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test4646() throws Throwable {
    byte[] byteArray0 = new byte[14];
    byteArray0[1] = (byte) 1;
    boolean boolean0 = TarUtils.parseBoolean(byteArray0, (byte) 1);
    assertTrue(boolean0);
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test4747() throws Throwable {
    byte[] byteArray0 = new byte[14];
    boolean boolean0 = TarUtils.parseBoolean(byteArray0, (byte) 1);
    assertFalse(boolean0);
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    final boolean negative = buffer[offset] == (byte) 0xff;
    if (length < 9) {
        return parseBinaryLong(buffer, offset, length, negative);
    }
    return parseBinaryBigInteger(buffer, offset, length, negative);
}","public void test4848() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[1] = (byte) (-71);
    long long0 = TarUtils.parseOctalOrBinary(byteArray0, 1, (byte) (-71));
    assertEquals(0L, long0);
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since 1.4
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    final boolean negative = buffer[offset] == (byte) 0xff;
    if (length < 9) {
        return parseBinaryLong(buffer, offset, length, negative);
    }
    return parseBinaryBigInteger(buffer, offset, length, negative);
}","public void test4949() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) (-1);
    long long0 = TarUtils.parseOctalOrBinary(byteArray0, 0, (byte) (-1));
    assertEquals(0L, long0);
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since 1.4
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    final boolean negative = buffer[offset] == (byte) 0xff;
    if (length < 9) {
        return parseBinaryLong(buffer, offset, length, negative);
    }
    return parseBinaryBigInteger(buffer, offset, length, negative);
}","public void test5050() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[1] = (byte) (-7);
    // Undeclared exception!
    try {
        TarUtils.parseOctalOrBinary(byteArray0, 1, (byte) 113);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since 1.4
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test5151() throws Throwable {
    byte[] byteArray0 = new byte[9];
    TarUtils.formatUnsignedOctalString(540L, byteArray0, 0, 9);
    long long0 = TarUtils.parseOctal(byteArray0, 0, (byte) 2);
    assertArrayEquals(new byte[] { (byte) 48, (byte) 48, (byte) 48, (byte) 48, (byte) 48, (byte) 49, (byte) 48, (byte) 51, (byte) 52 }, byteArray0);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test5253() throws Throwable {
    byte[] byteArray0 = new byte[9];
    long long0 = TarUtils.parseOctal(byteArray0, 8, 5396);
    assertEquals(0L, long0);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test5354() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseOctal((byte[]) null, (-2971), (-2971));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Length -2971 must be at least 2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = length;
    for (; len > 0; len--) {
        if (buffer[offset + len - 1] != 0) {
            break;
        }
    }
    if (len > 0) {
        byte[] b = new byte[len];
        System.arraycopy(buffer, offset, b, 0, len);
        return encoding.decode(b);
    }
    return """";
}","public void test5455() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[2] = (byte) 3;
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    String string0 = TarUtils.parseName(byteArray0, 0, (int) (byte) 3, zipEncoding0);
    assertEquals("""", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = length;
    for (; len > 0; len--) {
        if (buffer[offset + len - 1] != 0) {
            break;
        }
    }
    if (len > 0) {
        byte[] b = new byte[len];
        System.arraycopy(buffer, offset, b, 0, len);
        return encoding.decode(b);
    }
    return """";
}","public void test5556() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 3;
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    String string0 = TarUtils.parseName(byteArray0, 0, (int) (byte) 3, zipEncoding0);
    assertEquals(""\u0003"", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The entry name.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length, final ZipEncoding encoding) throws IOException {
    int len = name.length();
    ByteBuffer b = encoding.encode(name);
    while (b.limit() > length && len > 0) {
        b = encoding.encode(name.substring(0, --len));
    }
    final int limit = b.limit() - b.position();
    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);
    // Pad any remaining output bytes with NUL
    for (int i = limit; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test5657() throws Throwable {
    byte[] byteArray0 = new byte[14];
    ZipEncoding zipEncoding0 = TarUtils.FALLBACK_ENCODING;
    int int0 = TarUtils.formatNameBytes(""{NUL}"", byteArray0, (int) (byte) 1, (-668), zipEncoding0);
    assertEquals((-667), int0);
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @param encoding name of the encoding to use for file names
 * @since 1.4
 * @return The updated offset, i.e. offset + length
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    try {
        return parseName(buffer, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return parseName(buffer, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test5758() throws Throwable {
    byte[] byteArray0 = new byte[0];
    String string0 = TarUtils.parseName(byteArray0, 0, 0);
    assertEquals("""", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test5859() throws Throwable {
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(0L, byteArray0, (byte) 3, (byte) 48);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 48
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test5960() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes((-1260L), byteArray0, 55, (-3132));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1260=1777777777777777775424 will not fit in octal number buffer of length -3134
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    try {
        return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);
    } catch (IOException ex) {
        try {
            return formatNameBytes(name, buf, offset, length, FALLBACK_ENCODING);
        } catch (IOException ex2) {
            // impossible
            throw new RuntimeException(ex2);
        }
    }
}","public void test6061() throws Throwable {
    byte[] byteArray0 = new byte[7];
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes((String) null, byteArray0, (int) (byte) 0, (int) (byte) (-128));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
