focal_method,test_prefix,docstring
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[8];
    int int0 = TarUtils.formatCheckSumOctalBytes(0L, byteArray0, (byte) 7, (byte) 0);
    assertEquals(7, int0);
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test012() throws Throwable {
    byte[] byteArray0 = new byte[7];
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString((-1423L), byteArray0, 0, (byte) 55);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 54
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test023() throws Throwable {
    byte[] byteArray0 = new byte[26];
    int int0 = TarUtils.formatNameBytes(""KgOvcZ"", byteArray0, (byte) 0, (byte) 26);
    assertEquals(26, int0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test034() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(""9IuUA1QX[`2ptEo8"", byteArray0, (byte) 44, (byte) 44);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 44
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test045() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 59;
    byteArray0[1] = (byte) (-18);
    String string0 = TarUtils.parseName(byteArray0, (byte) 0, 3);
    assertEquals("";\u00EE"", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test056() throws Throwable {
    byte[] byteArray0 = new byte[0];
    String string0 = TarUtils.parseName(byteArray0, 2138345419, 2138345419);
    assertEquals("""", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test067() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[1] = (byte) 1;
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, (byte) 1, (byte) 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 1 at offset 0 in '\u0001' len=1
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test078() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[1] = (byte) 1;
    TarUtils.formatUnsignedOctalString(3L, byteArray0, 0, (byte) 1);
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 0, (byte) 51);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test089() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-1);
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 0, (byte) 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte -1 at offset 0 in '\uFFFD' len=1
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test0910() throws Throwable {
    byte[] byteArray0 = new byte[1];
    long long0 = TarUtils.parseOctal(byteArray0, (byte) 23, (-1466));
    assertEquals(0L, long0);
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test1011() throws Throwable {
    byte[] byteArray0 = new byte[9];
    int int0 = TarUtils.formatNameBytes("""", byteArray0, 0, (byte) 0);
    assertEquals(0, int0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test1112() throws Throwable {
    byte[] byteArray0 = new byte[20];
    int int0 = TarUtils.formatNameBytes("""", byteArray0, (byte) 29, (-1));
    assertEquals(28, int0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test1213() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 23;
    long long0 = TarUtils.computeCheckSum(byteArray0);
    assertEquals(23L, long0);
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test1314() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseOctal((byte[]) null, (byte) 28, (byte) 28);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test1415() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 0, 2);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test1516() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.parseName((byte[]) null, 1684, 490);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test1617() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        TarUtils.parseName(byteArray0, (byte) 82, (-4785));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test1718() throws Throwable {
    byte[] byteArray0 = new byte[1];
    // Undeclared exception!
    try {
        TarUtils.parseName(byteArray0, (-1298), (byte) 23);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1298
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test1819() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString(0L, (byte[]) null, 1522, 1522);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test1920() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(0L, (byte[]) null, (-669), (-1));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test2021() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(162L, (byte[]) null, 0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 162=242 will not fit in octal number buffer of length -2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test2122() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarUtils.formatOctalBytes(1902L, byteArray0, (-1), 48);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 44
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test2223() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(""(kT"", (byte[]) null, 0, 32);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2324() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes((-4119L), (byte[]) null, 500, 500);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2425() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes((-1734L), byteArray0, (byte) 0, (byte) (-42));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1734=1777777777777777774472 will not fit in octal number buffer of length -43
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2526() throws Throwable {
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes(0L, byteArray0, (byte) 122, (byte) 122);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 242
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2627() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes(7L, (byte[]) null, 0, 2457);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test2728() throws Throwable {
    byte[] byteArray0 = new byte[8];
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes(0L, byteArray0, (byte) 48, (byte) 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 48
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test2829() throws Throwable {
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test2930() throws Throwable {
    byte[] byteArray0 = new byte[16];
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString((-1L), byteArray0, (-2912), (-2912));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1=1777777777777777777777 will not fit in octal number buffer of length -2912
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test3031() throws Throwable {
    byte[] byteArray0 = new byte[4];
    long long0 = TarUtils.computeCheckSum(byteArray0);
    assertEquals(0L, long0);
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test3132() throws Throwable {
    byte[] byteArray0 = new byte[6];
    int int0 = TarUtils.formatNameBytes("""", byteArray0, (byte) 0, (-2961));
    assertEquals((-2961), int0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test3233() throws Throwable {
    byte[] byteArray0 = new byte[11];
    byteArray0[0] = (byte) 59;
    byteArray0[1] = (byte) 127;
    byteArray0[2] = (byte) 127;
    String string0 = TarUtils.parseName(byteArray0, (byte) 0, 3);
    assertEquals("";"", string0);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3334() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[3] = (byte) 127;
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, 3, 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3435() throws Throwable {
    byte[] byteArray0 = new byte[2];
    TarUtils.formatUnsignedOctalString(3L, byteArray0, 0, (byte) 1);
    long long0 = TarUtils.parseOctal(byteArray0, 0, (byte) 1);
    assertEquals(3L, long0);
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3537() throws Throwable {
    byte[] byteArray0 = new byte[2];
    TarUtils.formatUnsignedOctalString(0L, byteArray0, 0, (byte) 1);
    long long0 = TarUtils.parseOctal(byteArray0, 0, (byte) 1);
    assertArrayEquals(new byte[] { (byte) 48, (byte) 0 }, byteArray0);
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    boolean stillPadding = true;
    int end = offset + length;
    int start = offset;
    for (int i = start; i < end; i++) {
        final byte currentByte = buffer[i];
        if (currentByte == 0) {
            break;
        }
        // Skip leading spaces
        if (currentByte == (byte) ' ' || currentByte == '0') {
            if (stillPadding) {
                continue;
            }
            if (currentByte == (byte) ' ') {
                break;
            }
        }
        // Must have trailing NUL or space
        // May have additional NUL or space
        stillPadding = false;
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test3639() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[1] = (byte) 32;
    long long0 = TarUtils.parseOctal(byteArray0, (byte) 1, (byte) 32);
    assertEquals(0L, long0);
}","/**
 * Parse an octal string from a buffer.
 * Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.
 *
 * The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test3740() throws Throwable {
    byte[] byteArray0 = new byte[20];
    int int0 = TarUtils.formatOctalBytes((byte) 48, byteArray0, 0, (byte) 8);
    assertEquals(8, int0);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test3841() throws Throwable {
    byte[] byteArray0 = new byte[2];
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes((-998L), byteArray0, (byte) (-1), (byte) (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -998=1777777777777777776032 will not fit in octal number buffer of length -3
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test3942() throws Throwable {
    byte[] byteArray0 = new byte[20];
    int int0 = TarUtils.formatLongOctalBytes(1875L, byteArray0, 0, 7);
    assertEquals(7, int0);
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
