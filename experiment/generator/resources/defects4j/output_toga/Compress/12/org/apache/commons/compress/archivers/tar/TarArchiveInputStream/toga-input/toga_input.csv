focal_method,test_prefix,docstring
"@Override
public long skip(long numToSkip) throws IOException {
    // REVIEW
    // This is horribly inefficient, but it ensures that we
    // properly skip over bytes via the TarBuffer...
    //
    byte[] skipBuf = new byte[BUFFER_SIZE];
    long skip = numToSkip;
    while (skip > 0) {
        int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
        int numRead = read(skipBuf, 0, realSkip);
        if (numRead == -1) {
            break;
        }
        skip -= numRead;
    }
    return (numToSkip - skip);
}","public void test000() throws Throwable {
    File file0 = MockFile.createTempFile(""input buffer is closed"", ""input buffer is closed"");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 0);
    long long0 = tarArchiveInputStream0.skip(0);
    assertEquals(0L, long0);
}","/**
 * Skip bytes in the input buffer. This skips bytes in the
 * current entry's data, not the entire archive, and will
 * stop at the end of the current entry's data if the number
 * to skip extends beyond that point.
 *
 * @param numToSkip The number of bytes to skip.
 * @return the number actually skipped
 * @throws IOException on error
 */"
"protected final boolean isAtEOF() {
    return hasHitEOF;
}","public void test011() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    tarArchiveInputStream0.setAtEOF(true);
    boolean boolean0 = tarArchiveInputStream0.isAtEOF();
    assertTrue(boolean0);
}",""
"public int getRecordSize() {
    return buffer.getRecordSize();
}","public void test022() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(891);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(pipedInputStream0, 891, (-1356));
    int int0 = tarArchiveInputStream0.getRecordSize();
    assertEquals((-1356), int0);
}","/**
 * Get the record size being used by this stream's TarBuffer.
 *
 * @return The TarBuffer record size.
 */"
"Map<String, String> parsePaxHeaders(Reader br) throws IOException {
    Map<String, String> headers = new HashMap<String, String>();
    // Format is ""length keyword=value\n"";
    while (true) {
        // get length
        int ch;
        int len = 0;
        int read = 0;
        while ((ch = br.read()) != -1) {
            read++;
            if (ch == ' ') {
                // End of length string
                // Get keyword
                StringBuffer sb = new StringBuffer();
                while ((ch = br.read()) != -1) {
                    read++;
                    if (ch == '=') {
                        // end of keyword
                        String keyword = sb.toString();
                        // Get rest of entry
                        char[] cbuf = new char[len - read];
                        int got = br.read(cbuf);
                        if (got != len - read) {
                            throw new IOException(""Failed to read "" + ""Paxheader. Expected "" + (len - read) + "" chars, read "" + got);
                        }
                        // Drop trailing NL
                        String value = new String(cbuf, 0, len - read - 1);
                        headers.put(keyword, value);
                        break;
                    }
                    sb.append((char) ch);
                }
                // Processed single header
                break;
            }
            len *= 10;
            len += ch - '0';
        }
        if (ch == -1) {
            // EOF
            break;
        }
    }
    return headers;
}","public void test033() throws Throwable {
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 65, 0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, (byte) 59);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(pushbackInputStream0, 65, (-1052));
    // Undeclared exception!
    try {
        tarArchiveInputStream0.parsePaxHeaders((Reader) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarArchiveInputStream"", e);
    }
}",""
"Map<String, String> parsePaxHeaders(Reader br) throws IOException {
    Map<String, String> headers = new HashMap<String, String>();
    // Format is ""length keyword=value\n"";
    while (true) {
        // get length
        int ch;
        int len = 0;
        int read = 0;
        while ((ch = br.read()) != -1) {
            read++;
            if (ch == ' ') {
                // End of length string
                // Get keyword
                StringBuffer sb = new StringBuffer();
                while ((ch = br.read()) != -1) {
                    read++;
                    if (ch == '=') {
                        // end of keyword
                        String keyword = sb.toString();
                        // Get rest of entry
                        char[] cbuf = new char[len - read];
                        int got = br.read(cbuf);
                        if (got != len - read) {
                            throw new IOException(""Failed to read "" + ""Paxheader. Expected "" + (len - read) + "" chars, read "" + got);
                        }
                        // Drop trailing NL
                        String value = new String(cbuf, 0, len - read - 1);
                        headers.put(keyword, value);
                        break;
                    }
                    sb.append((char) ch);
                }
                // Processed single header
                break;
            }
            len *= 10;
            len += ch - '0';
        }
        if (ch == -1) {
            // EOF
            break;
        }
    }
    return headers;
}","public void test044() throws Throwable {
    byte[] byteArray0 = new byte[8];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-103), (-2820));
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    PipedReader pipedReader0 = new PipedReader();
    try {
        tarArchiveInputStream0.parsePaxHeaders(pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}",""
"public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
            // Bugzilla: 40334
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
        // Process Pax headers
        paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
        // Process sparse files
        readGNUSparse();
    }
    // If the size of the next element in the archive has changed
    // due to a new size being reported in the posix header
    // information, we update entrySize here so that it contains
    // the correct value.
    entrySize = currEntry.getSize();
    return currEntry;
}","public void test055() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(pipedInputStream0);
    try {
        tarArchiveInputStream0.getNextTarEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}","/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */"
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextTarEntry();
}","public void test066() throws Throwable {
    File file0 = MockFile.createTempFile(""input buffer is closed"", ""input buffer is closed"");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 0);
    // Undeclared exception!
    try {
        tarArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}",""
"public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {
    this.buffer = new TarBuffer(is, blockSize, recordSize);
    this.readBuf = null;
    this.hasHitEOF = false;
}","public void test077() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    TarArchiveInputStream tarArchiveInputStream0 = null;
    try {
        tarArchiveInputStream0 = new TarArchiveInputStream(sequenceInputStream0, (-2880), (-2880));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarBuffer"", e);
    }
}","/**
 * Constructor for TarInputStream.
 * @param is the input stream to use
 * @param blockSize the block size to use
 * @param recordSize the record size to use
 */"
"public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {
    this.buffer = new TarBuffer(is, blockSize, recordSize);
    this.readBuf = null;
    this.hasHitEOF = false;
}","public void test088() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = null;
    try {
        tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0, 0, (byte) 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // / by zero
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarBuffer"", e);
    }
}","/**
 * Constructor for TarInputStream.
 * @param is the input stream to use
 * @param blockSize the block size to use
 * @param recordSize the record size to use
 */"
"public TarArchiveInputStream(InputStream is, int blockSize) {
    this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
}","public void test099() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = null;
    try {
        tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null, (-257));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarBuffer"", e);
    }
}","/**
 * Constructor for TarInputStream.
 * @param is the input stream to use
 * @param blockSize the block size to use
 */"
"@Override
public int read(byte[] buf, int offset, int numToRead) throws IOException {
    int totalRead = 0;
    if (entryOffset >= entrySize) {
        return -1;
    }
    if ((numToRead + entryOffset) > entrySize) {
        numToRead = (int) (entrySize - entryOffset);
    }
    if (readBuf != null) {
        int sz = (numToRead > readBuf.length) ? readBuf.length : numToRead;
        System.arraycopy(readBuf, 0, buf, offset, sz);
        if (sz >= readBuf.length) {
            readBuf = null;
        } else {
            int newLen = readBuf.length - sz;
            byte[] newBuf = new byte[newLen];
            System.arraycopy(readBuf, sz, newBuf, 0, newLen);
            readBuf = newBuf;
        }
        totalRead += sz;
        numToRead -= sz;
        offset += sz;
    }
    while (numToRead > 0) {
        byte[] rec = buffer.readRecord();
        if (rec == null) {
            // Unexpected EOF!
            throw new IOException(""unexpected EOF with "" + numToRead + "" bytes unread. Occured at byte: "" + getBytesRead());
        }
        count(rec.length);
        int sz = numToRead;
        int recLen = rec.length;
        if (recLen > sz) {
            System.arraycopy(rec, 0, buf, offset, sz);
            readBuf = new byte[recLen - sz];
            System.arraycopy(rec, sz, readBuf, 0, recLen - sz);
        } else {
            sz = recLen;
            System.arraycopy(rec, 0, buf, offset, recLen);
        }
        totalRead += sz;
        numToRead -= sz;
        offset += sz;
    }
    entryOffset += totalRead;
    return totalRead;
}","public void test1010() throws Throwable {
    FileDescriptor fileDescriptor0 = new FileDescriptor();
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0);
    byte[] byteArray0 = new byte[5];
    int int0 = tarArchiveInputStream0.read(byteArray0, 0, (int) (byte) 40);
    assertEquals((-1), int0);
}","/**
 * Reads bytes from the current tar archive entry.
 *
 * This method is aware of the boundaries of the current
 * entry in the archive and will deal with them as if they
 * were this stream's start and EOF.
 *
 * @param buf The buffer into which to place bytes read.
 * @param offset The offset at which to place bytes read.
 * @param numToRead The number of bytes to read.
 * @return The number of bytes read, or -1 at EOF.
 * @throws IOException on error
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < TarConstants.VERSION_OFFSET + TarConstants.VERSIONLEN) {
        return false;
    }
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)) {
        return true;
    }
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && (ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) || ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN))) {
        return true;
    }
    // COMPRESS-107 - recognise Ant tar files
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)) {
        return true;
    }
    return false;
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[2];
    boolean boolean0 = TarArchiveInputStream.matches(byteArray0, (byte) 67);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a tar file.
 *
 * @param signature
 *            the bytes to check
 * @param length
 *            the number of bytes to check
 * @return true, if this stream is a tar archive stream, false otherwise
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < TarConstants.VERSION_OFFSET + TarConstants.VERSIONLEN) {
        return false;
    }
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)) {
        return true;
    }
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && (ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) || ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN))) {
        return true;
    }
    // COMPRESS-107 - recognise Ant tar files
    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)) {
        return true;
    }
    return false;
}","public void test1212() throws Throwable {
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        TarArchiveInputStream.matches(byteArray0, 1811);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 257
        //
        verifyException(""org.apache.commons.compress.utils.ArchiveUtils"", e);
    }
}","/**
 * Checks if the signature matches what is expected for a tar file.
 *
 * @param signature
 *            the bytes to check
 * @param length
 *            the number of bytes to check
 * @return true, if this stream is a tar archive stream, false otherwise
 */"
"@Override
public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof TarArchiveEntry) {
        TarArchiveEntry te = (TarArchiveEntry) ae;
        return !te.isGNUSparse();
    }
    return false;
}","public void test1313() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-126), 1039);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0, 2599);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(bufferedInputStream0, 2599);
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry(""?mXq[jk3"");
    boolean boolean0 = tarArchiveInputStream0.canReadEntryData(zipArchiveEntry0);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if the current entry is a sparse file.</p>
 */"
"@Override
public int available() throws IOException {
    if (entrySize - entryOffset > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
    }
    return (int) (entrySize - entryOffset);
}","public void test1616() throws Throwable {
    File file0 = MockFile.createTempFile(""^/\""jW {GAaT0/"", ""ZipEightByteInteger value: "");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 679, 679);
    tarArchiveInputStream0.getNextTarEntry();
    tarArchiveInputStream0.getNextTarEntry();
    assertEquals((-1), mockFileInputStream0.available());
}","/**
 * Get the available data that can be read from the current
 * entry in the archive. This does not indicate how much data
 * is left in the entire archive, only in the current entry.
 * This value is determined from the entry's size header field
 * and the amount of data already read from the current entry.
 * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
 * bytes are left in the current entry in the archive.
 *
 * @return The number of available bytes for the current entry.
 * @throws IOException for signature
 */"
"public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
            // Bugzilla: 40334
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
        // Process Pax headers
        paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
        // Process sparse files
        readGNUSparse();
    }
    // If the size of the next element in the archive has changed
    // due to a new size being reported in the posix header
    // information, we update entrySize here so that it contains
    // the correct value.
    entrySize = currEntry.getSize();
    return currEntry;
}","public void test1717() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 7;
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0, 108, (byte) 7);
    // Undeclared exception!
    try {
        tarArchiveInputStream0.getNextTarEntry();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 100
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */"
"@Override
public long skip(long numToSkip) throws IOException {
    // REVIEW
    // This is horribly inefficient, but it ensures that we
    // properly skip over bytes via the TarBuffer...
    //
    byte[] skipBuf = new byte[BUFFER_SIZE];
    long skip = numToSkip;
    while (skip > 0) {
        int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
        int numRead = read(skipBuf, 0, realSkip);
        if (numRead == -1) {
            break;
        }
        skip -= numRead;
    }
    return (numToSkip - skip);
}","public void test1818() throws Throwable {
    byte[] byteArray0 = new byte[4];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(byteArrayInputStream0);
    long long0 = tarArchiveInputStream0.skip(2147483647L);
    assertEquals(0L, long0);
}","/**
 * Skip bytes in the input buffer. This skips bytes in the
 * current entry's data, not the entire archive, and will
 * stop at the end of the current entry's data if the number
 * to skip extends beyond that point.
 *
 * @param numToSkip The number of bytes to skip.
 * @return the number actually skipped
 * @throws IOException on error
 */"
"@Override
public long skip(long numToSkip) throws IOException {
    // REVIEW
    // This is horribly inefficient, but it ensures that we
    // properly skip over bytes via the TarBuffer...
    //
    byte[] skipBuf = new byte[BUFFER_SIZE];
    long skip = numToSkip;
    while (skip > 0) {
        int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
        int numRead = read(skipBuf, 0, realSkip);
        if (numRead == -1) {
            break;
        }
        skip -= numRead;
    }
    return (numToSkip - skip);
}","public void test1919() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    long long0 = tarArchiveInputStream0.skip(1933L);
    assertEquals(0L, long0);
}","/**
 * Skip bytes in the input buffer. This skips bytes in the
 * current entry's data, not the entire archive, and will
 * stop at the end of the current entry's data if the number
 * to skip extends beyond that point.
 *
 * @param numToSkip The number of bytes to skip.
 * @return the number actually skipped
 * @throws IOException on error
 */"
"@Override
public long skip(long numToSkip) throws IOException {
    // REVIEW
    // This is horribly inefficient, but it ensures that we
    // properly skip over bytes via the TarBuffer...
    //
    byte[] skipBuf = new byte[BUFFER_SIZE];
    long skip = numToSkip;
    while (skip > 0) {
        int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
        int numRead = read(skipBuf, 0, realSkip);
        if (numRead == -1) {
            break;
        }
        skip -= numRead;
    }
    return (numToSkip - skip);
}","public void test2020() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(byteArrayInputStream0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(bufferedInputStream0, 715);
    long long0 = tarArchiveInputStream0.skip((byte) (-72));
    assertEquals(0L, long0);
}","/**
 * Skip bytes in the input buffer. This skips bytes in the
 * current entry's data, not the entire archive, and will
 * stop at the end of the current entry's data if the number
 * to skip extends beyond that point.
 *
 * @param numToSkip The number of bytes to skip.
 * @return the number actually skipped
 * @throws IOException on error
 */"
"@Override
public int available() throws IOException {
    if (entrySize - entryOffset > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
    }
    return (int) (entrySize - entryOffset);
}","public void test2121() throws Throwable {
    File file0 = MockFile.createTempFile(""^/\""jW {GAaT0/"", ""ZipEightByteInteger value: "");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 679, 679);
    int int0 = tarArchiveInputStream0.available();
    assertEquals(0, int0);
}","/**
 * Get the available data that can be read from the current
 * entry in the archive. This does not indicate how much data
 * is left in the entire archive, only in the current entry.
 * This value is determined from the entry's size header field
 * and the amount of data already read from the current entry.
 * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
 * bytes are left in the current entry in the archive.
 *
 * @return The number of available bytes for the current entry.
 * @throws IOException for signature
 */"
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextTarEntry();
}","public void test2222() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    tarArchiveInputStream0.setAtEOF(true);
    ArchiveEntry archiveEntry0 = tarArchiveInputStream0.getNextEntry();
    assertNull(archiveEntry0);
}",""
"protected final TarArchiveEntry getCurrentEntry() {
    return currEntry;
}","public void test2323() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) (-126), 1039);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0, 2599);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(bufferedInputStream0, 2599);
    TarArchiveEntry tarArchiveEntry0 = tarArchiveInputStream0.getCurrentEntry();
    assertNull(tarArchiveEntry0);
}",""
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextTarEntry();
}","public void test2424() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    try {
        tarArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // input buffer is closed
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarBuffer"", e);
    }
}",""
"public String getGroupName() {
    return groupName.toString();
}","public void test2525() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(""{LO[+G`'|8EET1"", false);
    tarArchiveInputStream0.setCurrentEntry(tarArchiveEntry0);
    assertEquals("""", tarArchiveEntry0.getGroupName());
}","/**
 * Get this entry's group name.
 *
 * @return This entry's group name.
 */"
"@Override
public int available() throws IOException {
    if (entrySize - entryOffset > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
    }
    return (int) (entrySize - entryOffset);
}","public void test2626() throws Throwable {
    File file0 = MockFile.createTempFile(""^/\""jW {GAaT0/"", ""ZipEightByteInteger value: "");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 679, 679);
    tarArchiveInputStream0.close();
    assertEquals(0, tarArchiveInputStream0.available());
}","/**
 * Get the available data that can be read from the current
 * entry in the archive. This does not indicate how much data
 * is left in the entire archive, only in the current entry.
 * This value is determined from the entry's size header field
 * and the amount of data already read from the current entry.
 * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
 * bytes are left in the current entry in the archive.
 *
 * @return The number of available bytes for the current entry.
 * @throws IOException for signature
 */"
"public int getRecordSize() {
    return buffer.getRecordSize();
}","public void test2727() throws Throwable {
    File file0 = MockFile.createTempFile(""^/\""jW {GAaT0/"", ""ZipEightByteInteger value: "");
    MockFileInputStream mockFileInputStream0 = new MockFileInputStream(file0);
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream(mockFileInputStream0, 679, 679);
    int int0 = tarArchiveInputStream0.getRecordSize();
    assertEquals(679, int0);
}","/**
 * Get the record size being used by this stream's TarBuffer.
 *
 * @return The TarBuffer record size.
 */"
"@Override
public int available() throws IOException {
    if (entrySize - entryOffset > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
    }
    return (int) (entrySize - entryOffset);
}","public void test2828() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    tarArchiveInputStream0.reset();
    assertEquals(0, tarArchiveInputStream0.available());
}","/**
 * Get the available data that can be read from the current
 * entry in the archive. This does not indicate how much data
 * is left in the entire archive, only in the current entry.
 * This value is determined from the entry's size header field
 * and the amount of data already read from the current entry.
 * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
 * bytes are left in the current entry in the archive.
 *
 * @return The number of available bytes for the current entry.
 * @throws IOException for signature
 */"
"protected final boolean isAtEOF() {
    return hasHitEOF;
}","public void test2929() throws Throwable {
    TarArchiveInputStream tarArchiveInputStream0 = new TarArchiveInputStream((InputStream) null);
    boolean boolean0 = tarArchiveInputStream0.isAtEOF();
    assertFalse(boolean0);
}",""
