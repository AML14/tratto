focal_method,test_prefix,docstring
"public byte[] getLocalFileDataData() {
    byte[] uidBytes = uid.toByteArray();
    byte[] gidBytes = gid.toByteArray();
    // BigInteger might prepend a leading-zero to force a positive representation
    // (e.g., so that the sign-bit is set to zero).  We need to remove that
    // before sending the number over the wire.
    uidBytes = trimLeadingZeroesForceMinLength(uidBytes);
    gidBytes = trimLeadingZeroesForceMinLength(gidBytes);
    // Couldn't bring myself to just call getLocalFileDataLength() when we've
    // already got the arrays right here.  Yeah, yeah, I know, premature
    // optimization is the root of all...
    //
    // The 3 comes from:  version=1 + uidsize=1 + gidsize=1
    byte[] data = new byte[3 + uidBytes.length + gidBytes.length];
    // reverse() switches byte array from big-endian to little-endian.
    reverse(uidBytes);
    reverse(gidBytes);
    int pos = 0;
    data[pos++] = unsignedIntToSignedByte(version);
    data[pos++] = unsignedIntToSignedByte(uidBytes.length);
    System.arraycopy(uidBytes, 0, data, pos, uidBytes.length);
    pos += uidBytes.length;
    data[pos++] = unsignedIntToSignedByte(gidBytes.length);
    System.arraycopy(gidBytes, 0, data, pos, gidBytes.length);
    return data;
}","public void test000() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    x7875_NewUnix0.setUID((-2518L));
    byte[] byteArray0 = x7875_NewUnix0.getLocalFileDataData();
    assertArrayEquals(new byte[] { (byte) 1, (byte) 4, (byte) 42, (byte) (-10), (byte) (-1), (byte) (-1), (byte) 2, (byte) (-24), (byte) 3 }, byteArray0);
}","/**
 * The actual data to put into local file data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"@Override
public int hashCode() {
    int hc = -1234567 * version;
    // Since most UID's and GID's are below 65,536, this is (hopefully!)
    // a nice way to make sure typical UID and GID values impact the hash
    // as much as possible.
    hc ^= Integer.rotateLeft(uid.hashCode(), 16);
    hc ^= gid.hashCode();
    return hc;
}","public void test012() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, 1, 1);
    x7875_NewUnix0.hashCode();
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test023() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    Object object0 = x7875_NewUnix0.clone();
    assertTrue(object0.equals((Object) x7875_NewUnix0));
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test024() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    Object object0 = x7875_NewUnix0.clone();
    byteArray0[0] = (byte) (-1);
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 0, (-1285));
    boolean boolean0 = x7875_NewUnix0.equals(object0);
    assertFalse(object0.equals((Object) x7875_NewUnix0));
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test025() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    Object object0 = x7875_NewUnix0.clone();
    byteArray0[0] = (byte) (-1);
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 0, (-1285));
    boolean boolean0 = x7875_NewUnix0.equals(object0);
    assertFalse(boolean0);
}",""
"public int getValue() {
    return value;
}","public void test036() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    x7875_NewUnix0.setUID(0L);
    ZipShort zipShort0 = x7875_NewUnix0.getCentralDirectoryLength();
    assertEquals(6, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"static byte[] trimLeadingZeroesForceMinLength(byte[] array) {
    if (array == null) {
        return array;
    }
    int pos = 0;
    for (byte b : array) {
        if (b == 0) {
            pos++;
        } else {
            break;
        }
    }
    /*

        I agonized over my choice of MIN_LENGTH=1.  Here's the situation:
        InfoZip (the tool I am using to test interop) always sets these
        to length=4.  And so a UID of 0 (typically root) for example is
        encoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just
        as easily be encoded as {1,0} (len=1, 8 bits of zero) according to
        the spec.

        In the end I decided on MIN_LENGTH=1 for four reasons:

        1.)  We are adhering to the spec as far as I can tell, and so
             a consumer that cannot parse this is broken.

        2.)  Fundamentally, zip files are about shrinking things, so
             let's save a few bytes per entry while we can.

        3.)  Of all the people creating zip files using commons-
             compress, how many care about UNIX UID/GID attributes
             of the files they store?   (e.g., I am probably thinking
             way too hard about this and no one cares!)

        4.)  InfoZip's tool, even though it carefully stores every UID/GID
             for every file zipped on a unix machine (by default) currently
             appears unable to ever restore UID/GID.
             unzip -X has no effect on my machine, even when run as root!!!!

        And thus it is decided:  MIN_LENGTH=1.

        If anyone runs into interop problems from this, feel free to set
        it to MIN_LENGTH=4 at some future time, and then we will behave
        exactly like InfoZip (requires changes to unit tests, though).

        And I am sorry that the time you spent reading this comment is now
        gone and you can never have it back.

        */
    final int MIN_LENGTH = 1;
    byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];
    int startPos = trimmedArray.length - (array.length - pos);
    System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);
    return trimmedArray;
}","public void test047() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byte[] byteArray1 = X7875_NewUnix.trimLeadingZeroesForceMinLength(byteArray0);
    assertEquals(1, byteArray1.length);
}","/**
 * Not really for external usage, but marked ""package"" visibility
 * to help us JUnit it.   Trims a byte array of leading zeroes while
 * also enforcing a minimum length, and thus it really trims AND pads
 * at the same time.
 *
 * @param array byte[] array to trim & pad.
 * @return trimmed & padded byte[] array.
 */"
"public long getUID() {
    return ZipUtil.bigToLong(uid);
}","public void test058() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[13];
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 0, (byte) 0);
    long long0 = x7875_NewUnix0.getUID();
    assertEquals(0L, long0);
}","/**
 * Gets the UID as a long.  UID is typically a 32 bit unsigned
 * value on most UNIX systems, so we return a long to avoid
 * integer overflow into the negatives in case values above
 * and including 2^31 are being used.
 *
 * @return the UID value.
 */"
"public long getGID() {
    return ZipUtil.bigToLong(gid);
}","public void test069() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    x7875_NewUnix0.setGID(0L);
    long long0 = x7875_NewUnix0.getGID();
    assertEquals(0L, long0);
}","/**
 * Gets the GID as a long.  GID is typically a 32 bit unsigned
 * value on most UNIX systems, so we return a long to avoid
 * integer overflow into the negatives in case values above
 * and including 2^31 are being used.
 *
 * @return the GID value.
 */"
"public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException {
    reset();
    this.version = signedByteToUnsignedInt(data[offset++]);
    int uidSize = signedByteToUnsignedInt(data[offset++]);
    byte[] uidBytes = new byte[uidSize];
    System.arraycopy(data, offset, uidBytes, 0, uidSize);
    offset += uidSize;
    // sign-bit forced positive
    this.uid = new BigInteger(1, reverse(uidBytes));
    int gidSize = signedByteToUnsignedInt(data[offset++]);
    byte[] gidBytes = new byte[gidSize];
    System.arraycopy(data, offset, gidBytes, 0, gidSize);
    // sign-bit forced positive
    this.gid = new BigInteger(1, reverse(gidBytes));
}","public void test0710() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    // Undeclared exception!
    try {
        x7875_NewUnix0.parseFromLocalFileData((byte[]) null, (-1234567), (byte) (-57));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X7875_NewUnix"", e);
    }
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException {
    reset();
    this.version = signedByteToUnsignedInt(data[offset++]);
    int uidSize = signedByteToUnsignedInt(data[offset++]);
    byte[] uidBytes = new byte[uidSize];
    System.arraycopy(data, offset, uidBytes, 0, uidSize);
    offset += uidSize;
    // sign-bit forced positive
    this.uid = new BigInteger(1, reverse(uidBytes));
    int gidSize = signedByteToUnsignedInt(data[offset++]);
    byte[] gidBytes = new byte[gidSize];
    System.arraycopy(data, offset, gidBytes, 0, gidSize);
    // sign-bit forced positive
    this.gid = new BigInteger(1, reverse(gidBytes));
}","public void test0811() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[9];
    byteArray0[4] = (byte) 3;
    byteArray0[8] = (byte) 117;
    // Undeclared exception!
    try {
        x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 3, (-1174));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"public int getValue() {
    return value;
}","public void test0912() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    ZipShort zipShort0 = x7875_NewUnix0.getLocalFileDataLength();
    assertEquals(7, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"static byte[] trimLeadingZeroesForceMinLength(byte[] array) {
    if (array == null) {
        return array;
    }
    int pos = 0;
    for (byte b : array) {
        if (b == 0) {
            pos++;
        } else {
            break;
        }
    }
    /*

        I agonized over my choice of MIN_LENGTH=1.  Here's the situation:
        InfoZip (the tool I am using to test interop) always sets these
        to length=4.  And so a UID of 0 (typically root) for example is
        encoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just
        as easily be encoded as {1,0} (len=1, 8 bits of zero) according to
        the spec.

        In the end I decided on MIN_LENGTH=1 for four reasons:

        1.)  We are adhering to the spec as far as I can tell, and so
             a consumer that cannot parse this is broken.

        2.)  Fundamentally, zip files are about shrinking things, so
             let's save a few bytes per entry while we can.

        3.)  Of all the people creating zip files using commons-
             compress, how many care about UNIX UID/GID attributes
             of the files they store?   (e.g., I am probably thinking
             way too hard about this and no one cares!)

        4.)  InfoZip's tool, even though it carefully stores every UID/GID
             for every file zipped on a unix machine (by default) currently
             appears unable to ever restore UID/GID.
             unzip -X has no effect on my machine, even when run as root!!!!

        And thus it is decided:  MIN_LENGTH=1.

        If anyone runs into interop problems from this, feel free to set
        it to MIN_LENGTH=4 at some future time, and then we will behave
        exactly like InfoZip (requires changes to unit tests, though).

        And I am sorry that the time you spent reading this comment is now
        gone and you can never have it back.

        */
    final int MIN_LENGTH = 1;
    byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];
    int startPos = trimmedArray.length - (array.length - pos);
    System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);
    return trimmedArray;
}","public void test1013() throws Throwable {
    byte[] byteArray0 = X7875_NewUnix.trimLeadingZeroesForceMinLength((byte[]) null);
    assertNull(byteArray0);
}","/**
 * Not really for external usage, but marked ""package"" visibility
 * to help us JUnit it.   Trims a byte array of leading zeroes while
 * also enforcing a minimum length, and thus it really trims AND pads
 * at the same time.
 *
 * @param array byte[] array to trim & pad.
 * @return trimmed & padded byte[] array.
 */"
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1114() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    X7875_NewUnix x7875_NewUnix1 = new X7875_NewUnix();
    assertTrue(x7875_NewUnix1.equals((Object) x7875_NewUnix0));
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1115() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    X7875_NewUnix x7875_NewUnix1 = new X7875_NewUnix();
    x7875_NewUnix0.setGID((-16L));
    boolean boolean0 = x7875_NewUnix0.equals(x7875_NewUnix1);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1217() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    X7875_NewUnix x7875_NewUnix1 = new X7875_NewUnix();
    x7875_NewUnix1.setUID(1167L);
    boolean boolean0 = x7875_NewUnix0.equals(x7875_NewUnix1);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1319() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    Object object0 = x7875_NewUnix0.clone();
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 0, (-1285));
    boolean boolean0 = x7875_NewUnix0.equals(object0);
    assertFalse(object0.equals((Object) x7875_NewUnix0));
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1320() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[4];
    Object object0 = x7875_NewUnix0.clone();
    x7875_NewUnix0.parseFromLocalFileData(byteArray0, (byte) 0, (-1285));
    boolean boolean0 = x7875_NewUnix0.equals(object0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1421() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    boolean boolean0 = x7875_NewUnix0.equals(x7875_NewUnix0);
    assertTrue(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o instanceof X7875_NewUnix) {
        X7875_NewUnix xf = (X7875_NewUnix) o;
        // We assume uid and gid can never be null.
        return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);
    }
    return false;
}","public void test1522() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    boolean boolean0 = x7875_NewUnix0.equals(""0x7875 Zip Extra Field: UID=1000 GID=0"");
    assertFalse(boolean0);
}",""
"public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {
}","public void test1623() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = new byte[8];
    x7875_NewUnix0.parseFromCentralDirectoryData(byteArray0, 0, (byte) 84);
    assertEquals(8, byteArray0.length);
}","/**
 * Doesn't do anything since this class doesn't store anything
 * inside the central directory.
 */"
"public long getGID() {
    return ZipUtil.bigToLong(gid);
}","public void test1724() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    long long0 = x7875_NewUnix0.getGID();
    assertEquals(1000L, long0);
}","/**
 * Gets the GID as a long.  GID is typically a 32 bit unsigned
 * value on most UNIX systems, so we return a long to avoid
 * integer overflow into the negatives in case values above
 * and including 2^31 are being used.
 *
 * @return the GID value.
 */"
"@Override
public int hashCode() {
    int hc = -1234567 * version;
    // Since most UID's and GID's are below 65,536, this is (hopefully!)
    // a nice way to make sure typical UID and GID values impact the hash
    // as much as possible.
    hc ^= Integer.rotateLeft(uid.hashCode(), 16);
    hc ^= gid.hashCode();
    return hc;
}","public void test1825() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    x7875_NewUnix0.hashCode();
}",""
"public byte[] getCentralDirectoryData() {
    return new byte[0];
}","public void test1926() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    byte[] byteArray0 = x7875_NewUnix0.getCentralDirectoryData();
    assertEquals(0, byteArray0.length);
}","/**
 * The actual data to put into central directory data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"public int getValue() {
    return value;
}","public void test2027() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    ZipShort zipShort0 = x7875_NewUnix0.getHeaderId();
    assertEquals(30837, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public long getUID() {
    return ZipUtil.bigToLong(uid);
}","public void test2128() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    long long0 = x7875_NewUnix0.getUID();
    assertEquals(1000L, long0);
}","/**
 * Gets the UID as a long.  UID is typically a 32 bit unsigned
 * value on most UNIX systems, so we return a long to avoid
 * integer overflow into the negatives in case values above
 * and including 2^31 are being used.
 *
 * @return the UID value.
 */"
"@Override
public String toString() {
    return ""0x7875 Zip Extra Field: UID="" + uid + "" GID="" + gid;
}","public void test2229() throws Throwable {
    X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();
    String string0 = x7875_NewUnix0.toString();
    assertEquals(""0x7875 Zip Extra Field: UID=1000 GID=1000"", string0);
}","/**
 * Returns a String representation of this class useful for
 * debugging purposes.
 *
 * @return A String representation of this class useful for
 *         debugging purposes.
 */"
