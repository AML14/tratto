focal_method,test_prefix,docstring
"public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}","public void test000() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(bigInteger0);
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0);
    byte[] byteArray0 = new byte[4];
    zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 4, 0);
    try {
        zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, true, false, false);
        fail(""Expecting exception: ZipException"");
    } catch (ZipException e) {
        //
        // central directory zip64 extended information extra field's length doesn't match central directory data.  Expected length 16 but is 0
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */"
"public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}","public void test011() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(bigInteger0);
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0);
    byte[] byteArray0 = new byte[4];
    zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 4, 0);
    try {
        zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, true, false);
        fail(""Expecting exception: ZipException"");
    } catch (ZipException e) {
        //
        // central directory zip64 extended information extra field's length doesn't match central directory data.  Expected length 16 but is 0
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */"
"public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {
    if (length == 0) {
        // no local file data at all, may happen if an archive
        // only holds a ZIP64 extended information extra field
        // inside the central directory but not inside the local
        // file header
        return;
    }
    if (length < 2 * DWORD) {
        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
    }
    size = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    compressedSize = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    int remaining = length - 2 * DWORD;
    if (remaining >= DWORD) {
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        remaining -= DWORD;
    }
    if (remaining >= WORD) {
        diskStart = new ZipLong(buffer, offset);
        offset += WORD;
        remaining -= WORD;
    }
}","public void test022() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = new byte[6];
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromLocalFileData(byteArray0, 310, (byte) 16);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 317
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipEightByteInteger"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public ZipEightByteInteger getSize() {
    return size;
}","public void test033() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    ZipEightByteInteger zipEightByteInteger0 = zip64ExtendedInformationExtraField0.getSize();
    assertNull(zipEightByteInteger0);
}","/**
 * The uncompressed size stored in this extra field.
 */"
"public ZipEightByteInteger getRelativeHeaderOffset() {
    return relativeHeaderOffset;
}","public void test044() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    ZipEightByteInteger zipEightByteInteger0 = zip64ExtendedInformationExtraField0.getRelativeHeaderOffset();
    assertNull(zipEightByteInteger0);
}","/**
 * The relative header offset stored in this extra field.
 */"
"public ZipLong getDiskStartNumber() {
    return diskStart;
}","public void test055() throws Throwable {
    BigInteger bigInteger0 = BigInteger.TEN;
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(bigInteger0);
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0);
    ZipLong zipLong0 = zip64ExtendedInformationExtraField0.getDiskStartNumber();
    assertNull(zipLong0);
}","/**
 * The disk start number stored in this extra field.
 */"
"public long getValue() {
    return value;
}","public void test066() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ONE;
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(bigInteger0);
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0);
    ZipLong zipLong0 = new ZipLong(0);
    zip64ExtendedInformationExtraField0.setDiskStartNumber(zipLong0);
    ZipLong zipLong1 = zip64ExtendedInformationExtraField0.getDiskStartNumber();
    assertEquals(0L, zipLong1.getValue());
}","/**
 * Get value as Java long.
 * @return value as a long
 */"
"public ZipEightByteInteger getCompressedSize() {
    return compressedSize;
}","public void test077() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(0L);
    ZipLong zipLong0 = ZipLong.DD_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipEightByteInteger zipEightByteInteger1 = zip64ExtendedInformationExtraField0.getCompressedSize();
    assertSame(zipEightByteInteger0, zipEightByteInteger1);
}","/**
 * The compressed size stored in this extra field.
 */"
"public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {
    if (length == 0) {
        // no local file data at all, may happen if an archive
        // only holds a ZIP64 extended information extra field
        // inside the central directory but not inside the local
        // file header
        return;
    }
    if (length < 2 * DWORD) {
        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
    }
    size = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    compressedSize = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    int remaining = length - 2 * DWORD;
    if (remaining >= DWORD) {
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        remaining -= DWORD;
    }
    if (remaining >= WORD) {
        diskStart = new ZipLong(buffer, offset);
        offset += WORD;
        remaining -= WORD;
    }
}","public void test088() throws Throwable {
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null, (ZipEightByteInteger) null, zipLong0);
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromLocalFileData((byte[]) null, 48, 48);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipEightByteInteger"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {
    // store for processing in reparseCentralDirectoryData
    rawCentralDirectoryData = new byte[length];
    System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);
    // if there is no size information in here, we are screwed and
    // can only hope things will get resolved by LFH data later
    // But there are some cases that can be detected
    // * all data is there
    // * length == 24 -> both sizes and offset
    // * length % 8 == 4 -> at least we can identify the diskStart field
    if (length >= 3 * DWORD + WORD) {
        parseFromLocalFileData(buffer, offset, length);
    } else if (length == 3 * DWORD) {
        size = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        compressedSize = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
    } else if (length % DWORD == WORD) {
        diskStart = new ZipLong(buffer, offset + length - WORD);
    }
}","public void test099() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData((byte[]) null, 0, 65280);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * {@inheritDoc}
 */"
"public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {
    // store for processing in reparseCentralDirectoryData
    rawCentralDirectoryData = new byte[length];
    System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);
    // if there is no size information in here, we are screwed and
    // can only hope things will get resolved by LFH data later
    // But there are some cases that can be detected
    // * all data is there
    // * length == 24 -> both sizes and offset
    // * length % 8 == 4 -> at least we can identify the diskStart field
    if (length >= 3 * DWORD + WORD) {
        parseFromLocalFileData(buffer, offset, length);
    } else if (length == 3 * DWORD) {
        size = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        compressedSize = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
    } else if (length % DWORD == WORD) {
        diskStart = new ZipLong(buffer, offset + length - WORD);
    }
}","public void test1010() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, (-1810), (-1810));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException {
    // store for processing in reparseCentralDirectoryData
    rawCentralDirectoryData = new byte[length];
    System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);
    // if there is no size information in here, we are screwed and
    // can only hope things will get resolved by LFH data later
    // But there are some cases that can be detected
    // * all data is there
    // * length == 24 -> both sizes and offset
    // * length % 8 == 4 -> at least we can identify the diskStart field
    if (length >= 3 * DWORD + WORD) {
        parseFromLocalFileData(buffer, offset, length);
    } else if (length == 3 * DWORD) {
        size = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        compressedSize = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
    } else if (length % DWORD == WORD) {
        diskStart = new ZipLong(buffer, offset + length - WORD);
    }
}","public void test1111() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = new byte[4];
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, (byte) 0, 3160);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * {@inheritDoc}
 */"
"public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}","public void test1212() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(1L);
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, false, true);
}","/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */"
"public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {
    if (length == 0) {
        // no local file data at all, may happen if an archive
        // only holds a ZIP64 extended information extra field
        // inside the central directory but not inside the local
        // file header
        return;
    }
    if (length < 2 * DWORD) {
        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
    }
    size = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    compressedSize = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    int remaining = length - 2 * DWORD;
    if (remaining >= DWORD) {
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        remaining -= DWORD;
    }
    if (remaining >= WORD) {
        diskStart = new ZipLong(buffer, offset);
        offset += WORD;
        remaining -= WORD;
    }
}","public void test1313() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    byte[] byteArray0 = new byte[6];
    try {
        zip64ExtendedInformationExtraField0.parseFromLocalFileData(byteArray0, 0, (-2159));
        fail(""Expecting exception: ZipException"");
    } catch (ZipException e) {
        //
        // Zip64 extended information must contain both size values in the local file header.
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {
    if (length == 0) {
        // no local file data at all, may happen if an archive
        // only holds a ZIP64 extended information extra field
        // inside the central directory but not inside the local
        // file header
        return;
    }
    if (length < 2 * DWORD) {
        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
    }
    size = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    compressedSize = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    int remaining = length - 2 * DWORD;
    if (remaining >= DWORD) {
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        remaining -= DWORD;
    }
    if (remaining >= WORD) {
        diskStart = new ZipLong(buffer, offset);
        offset += WORD;
        remaining -= WORD;
    }
}","public void test1414() throws Throwable {
    BigInteger bigInteger0 = BigInteger.ZERO;
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(bigInteger0);
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0);
    byte[] byteArray0 = new byte[4];
    zip64ExtendedInformationExtraField0.parseFromLocalFileData(byteArray0, (-1809), (byte) 0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * {@inheritDoc}
 */"
"public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException {
    if (length == 0) {
        // no local file data at all, may happen if an archive
        // only holds a ZIP64 extended information extra field
        // inside the central directory but not inside the local
        // file header
        return;
    }
    if (length < 2 * DWORD) {
        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
    }
    size = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    compressedSize = new ZipEightByteInteger(buffer, offset);
    offset += DWORD;
    int remaining = length - 2 * DWORD;
    if (remaining >= DWORD) {
        relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);
        offset += DWORD;
        remaining -= DWORD;
    }
    if (remaining >= WORD) {
        diskStart = new ZipLong(buffer, offset);
        offset += WORD;
        remaining -= WORD;
    }
}","public void test1515() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = new byte[8];
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.parseFromLocalFileData(byteArray0, (byte) 0, 2037);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 15
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipEightByteInteger"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}","public void test1616() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(1L);
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
    zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 4, 4);
    zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, false, false, true);
}","/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */"
"public byte[] getCentralDirectoryData() {
    byte[] data = new byte[getCentralDirectoryLength().getValue()];
    int off = addSizes(data);
    if (relativeHeaderOffset != null) {
        System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);
        off += DWORD;
    }
    if (diskStart != null) {
        System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);
        off += WORD;
    }
    return data;
}","public void test1717() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();
    assertEquals(0, byteArray0.length);
}","/**
 * {@inheritDoc}
 */"
"public byte[] getLocalFileDataData() {
    if (size != null || compressedSize != null) {
        if (size == null || compressedSize == null) {
            throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
        }
        byte[] data = new byte[2 * DWORD];
        addSizes(data);
        return data;
    }
    return EMPTY;
}","public void test1818() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(814L);
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, (ZipEightByteInteger) null, (ZipEightByteInteger) null, zipLong0);
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.getLocalFileDataData();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Zip64 extended information must contain both size values in the local file header.
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public byte[] getLocalFileDataData() {
    if (size != null || compressedSize != null) {
        if (size == null || compressedSize == null) {
            throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
        }
        byte[] data = new byte[2 * DWORD];
        addSizes(data);
        return data;
    }
    return EMPTY;
}","public void test1919() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    ZipEightByteInteger zipEightByteInteger0 = ZipEightByteInteger.ZERO;
    zip64ExtendedInformationExtraField0.setCompressedSize(zipEightByteInteger0);
    // Undeclared exception!
    try {
        zip64ExtendedInformationExtraField0.getLocalFileDataData();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Zip64 extended information must contain both size values in the local file header.
        //
        verifyException(""org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public byte[] getLocalFileDataData() {
    if (size != null || compressedSize != null) {
        if (size == null || compressedSize == null) {
            throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
        }
        byte[] data = new byte[2 * DWORD];
        addSizes(data);
        return data;
    }
    return EMPTY;
}","public void test2020() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    byte[] byteArray0 = zip64ExtendedInformationExtraField0.getLocalFileDataData();
    assertArrayEquals(new byte[] {}, byteArray0);
}","/**
 * {@inheritDoc}
 */"
"public byte[] getLocalFileDataData() {
    if (size != null || compressedSize != null) {
        if (size == null || compressedSize == null) {
            throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);
        }
        byte[] data = new byte[2 * DWORD];
        addSizes(data);
        return data;
    }
    return EMPTY;
}","public void test2121() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = ZipEightByteInteger.ZERO;
    ZipLong zipLong0 = ZipLong.DD_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    byte[] byteArray0 = zip64ExtendedInformationExtraField0.getLocalFileDataData();
    assertEquals(16, byteArray0.length);
}","/**
 * {@inheritDoc}
 */"
"public int getValue() {
    return value;
}","public void test2222() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = ZipEightByteInteger.ZERO;
    ZipLong zipLong0 = ZipLong.DD_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipShort zipShort0 = zip64ExtendedInformationExtraField0.getCentralDirectoryLength();
    assertEquals(28, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public int getValue() {
    return value;
}","public void test2323() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    ZipShort zipShort0 = zip64ExtendedInformationExtraField0.getCentralDirectoryLength();
    assertEquals(0, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public int getValue() {
    return value;
}","public void test2424() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = ZipEightByteInteger.ZERO;
    ZipLong zipLong0 = ZipLong.DD_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipShort zipShort0 = zip64ExtendedInformationExtraField0.getLocalFileDataLength();
    assertEquals(16, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public int getValue() {
    return value;
}","public void test2525() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    ZipShort zipShort0 = zip64ExtendedInformationExtraField0.getLocalFileDataLength();
    assertEquals(0, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public ZipEightByteInteger getSize() {
    return size;
}","public void test2626() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(1L);
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipEightByteInteger zipEightByteInteger1 = zip64ExtendedInformationExtraField0.getSize();
    assertSame(zipEightByteInteger0, zipEightByteInteger1);
}","/**
 * The uncompressed size stored in this extra field.
 */"
"public int getValue() {
    return value;
}","public void test2727() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    ZipShort zipShort0 = zip64ExtendedInformationExtraField0.getHeaderId();
    assertEquals(1, zipShort0.getValue());
}","/**
 * Get value as Java int.
 * @return value as a Java int
 */"
"public ZipEightByteInteger getRelativeHeaderOffset() {
    return relativeHeaderOffset;
}","public void test2828() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = ZipEightByteInteger.ZERO;
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipEightByteInteger zipEightByteInteger1 = zip64ExtendedInformationExtraField0.getRelativeHeaderOffset();
    assertSame(zipEightByteInteger0, zipEightByteInteger1);
}","/**
 * The relative header offset stored in this extra field.
 */"
"public void setRelativeHeaderOffset(ZipEightByteInteger rho) {
    relativeHeaderOffset = rho;
}","public void test2929() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(1L);
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    zip64ExtendedInformationExtraField0.setRelativeHeaderOffset(zipEightByteInteger0);
}","/**
 * The relative header offset stored in this extra field.
 */"
"public ZipLong getDiskStartNumber() {
    return diskStart;
}","public void test3030() throws Throwable {
    ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger(1L);
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);
    ZipLong zipLong1 = zip64ExtendedInformationExtraField0.getDiskStartNumber();
    assertSame(zipLong1, zipLong0);
}","/**
 * The disk start number stored in this extra field.
 */"
"public void setSize(ZipEightByteInteger size) {
    this.size = size;
}","public void test3131() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField((ZipEightByteInteger) null, (ZipEightByteInteger) null);
    zip64ExtendedInformationExtraField0.setSize((ZipEightByteInteger) null);
}","/**
 * The uncompressed size stored in this extra field.
 */"
"public void setCompressedSize(ZipEightByteInteger compressedSize) {
    this.compressedSize = compressedSize;
}","public void test3232() throws Throwable {
    Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();
    ZipEightByteInteger zipEightByteInteger0 = zip64ExtendedInformationExtraField0.getCompressedSize();
    zip64ExtendedInformationExtraField0.setCompressedSize(zipEightByteInteger0);
}","/**
 * The uncompressed size stored in this extra field.
 */"
