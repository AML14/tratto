focal_method,test_prefix,docstring
"public void setFlags(final byte flags) {
    this.flags = flags;
    this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;
    this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;
    this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;
}","public void test000() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.isBit1_accessTimePresent();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 4;
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.equals((Object) null);
    x5455_ExtendedTimestamp0.setFlags((byte) 98);
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
    byte[] byteArray1 = x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.setCreateTime((ZipLong) null);
    x5455_ExtendedTimestamp0.getFlags();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    int int0 = 1219;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray1, 1219, (byte) 1);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.setFlags(byteArray0[2]);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1219
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Sets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @param flags flags byte indicating which of the
 *              three datestamp fields are present.
 */"
"public Date getAccessJavaTime() {
    return zipLongToDate(accessTime);
}","public void test011() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.setFlags((byte) (-24));
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getAccessTime();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    int int0 = 259;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, 259, 259);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getAccessJavaTime();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 259
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Returns the access time as a java.util.Date
 * of this zip entry, or null if no such timestamp exists in the zip entry.
 * The milliseconds are always zeroed out, since the underlying data
 * offers only per-second precision.
 *
 * @return access time as java.util.Date or null.
 */"
"@Override
public void parseFromLocalFileData(final byte[] data, int offset, final int length) throws ZipException {
    reset();
    final int len = offset + length;
    setFlags(data[offset++]);
    if (bit0_modifyTimePresent) {
        modifyTime = new ZipLong(data, offset);
        offset += 4;
    }
    // Notice the extra length check in case we are parsing the shorter
    // central data field (for both access and create timestamps).
    if (bit1_accessTimePresent && offset + 4 <= len) {
        accessTime = new ZipLong(data, offset);
        offset += 4;
    }
    if (bit2_createTimePresent && offset + 4 <= len) {
        createTime = new ZipLong(data, offset);
        // NOSONAR - assignment as documentation
        offset += 4;
    }
}","public void test022() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = new ZipLong((long) (byte) 1);
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    x5455_ExtendedTimestamp0.getAccessTime();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.getCreateTime();
    ZipLong zipLong1 = ZipLong.AED_SIG;
    zipLong1.toString();
    x5455_ExtendedTimestamp0.setAccessTime(zipLong1);
    MockDate mockDate0 = new MockDate((byte) 2, (byte) 4, (byte) 2, (-1), (byte) 1);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 2;
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 1;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 2, (byte) 2);
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"@Override
public String toString() {
    final StringBuilder buf = new StringBuilder();
    buf.append(""0x5455 Zip Extra Field: Flags="");
    buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append("" "");
    if (bit0_modifyTimePresent && modifyTime != null) {
        final Date m = getModifyJavaTime();
        buf.append("" Modify:["").append(m).append(""] "");
    }
    if (bit1_accessTimePresent && accessTime != null) {
        final Date a = getAccessJavaTime();
        buf.append("" Access:["").append(a).append(""] "");
    }
    if (bit2_createTimePresent && createTime != null) {
        final Date c = getCreateJavaTime();
        buf.append("" Create:["").append(c).append(""] "");
    }
    return buf.toString();
}","public void test033() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.CFH_SIG;
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.toString();
}","/**
 * Returns a String representation of this class useful for
 * debugging purposes.
 *
 * @return A String representation of this class useful for
 *         debugging purposes.
 */"
"public boolean isBit0_modifyTimePresent() {
    return bit0_modifyTimePresent;
}","public void test044() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 2;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 2;
    byteArray0[5] = (byte) 2;
    byteArray0[6] = (byte) 1;
    byteArray0[7] = (byte) 2;
    byteArray0[8] = (byte) 4;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (byte) 4, (byte) 4);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
}","/**
 * Returns whether bit0 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a modify timestamp in this particular zip entry.
 *
 * @return true if bit0 of the flags byte is set.
 */"
"public boolean isBit2_createTimePresent() {
    return bit2_createTimePresent;
}","public void test066() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    MockDate mockDate0 = new MockDate((-1282), (byte) 1, 590, (byte) 4, (byte) 2);
    mockDate0.clone();
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.equals(x5455_ExtendedTimestamp1);
    x5455_ExtendedTimestamp1.isBit2_createTimePresent();
}","/**
 * Returns whether bit2 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a create timestamp in this particular zip entry.
 *
 * @return true if bit2 of the flags byte is set.
 */"
"@Override
public ZipShort getLocalFileDataLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent && accessTime != null ? 4 : 0) + (bit2_createTimePresent && createTime != null ? 4 : 0));
}","public void test077() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.equals(""0x5455 Zip Extra Field: Flags=0 "");
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setFlags((byte) (-114));
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = (X5455_ExtendedTimestamp) x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp1.getLocalFileDataLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"@Override
public Object clone() throws CloneNotSupportedException {
    return super.clone();
}","public void test088() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate(1509L);
    ZipLong zipLong0 = new ZipLong(33639248L);
    zipLong0.getBytes();
    ZipLong.getBytes((long) (byte) 4);
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.setCreateJavaTime(mockDate0);
    MockDate mockDate1 = new MockDate(22, (byte) 4, (byte) 1);
    mockDate1.after(mockDate0);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate1);
    x5455_ExtendedTimestamp0.setFlags((byte) (-9));
    byte[] byteArray0 = x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, 22, 4);
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.clone();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 22
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}",""
"@Override
public byte[] getCentralDirectoryData() {
    final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];
    final byte[] localData = getLocalFileDataData();
    // Truncate out create & access time (last 8 bytes) from
    // the copy of the local data we obtained:
    System.arraycopy(localData, 0, centralData, 0, centralData.length);
    return centralData;
}","public void test099() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte byte0 = (byte) 3;
    x5455_ExtendedTimestamp0.setFlags((byte) 3);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getCentralDirectoryData();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * The actual data to put into central directory data - without Header-ID
 * or length specifier.
 *
 * @return the central directory data
 */"
"@Override
public byte[] getLocalFileDataData() {
    final byte[] data = new byte[getLocalFileDataLength().getValue()];
    int pos = 0;
    data[pos++] = 0;
    if (bit0_modifyTimePresent) {
        data[0] |= MODIFY_TIME_BIT;
        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit1_accessTimePresent && accessTime != null) {
        data[0] |= ACCESS_TIME_BIT;
        System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit2_createTimePresent && createTime != null) {
        data[0] |= CREATE_TIME_BIT;
        System.arraycopy(createTime.getBytes(), 0, data, pos, 4);
        // NOSONAR - assignment as documentation
        pos += 4;
    }
    return data;
}","public void test1010() throws Throwable {
    long long0 = 284L;
    System.setCurrentTimeMillis(284L);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    ZipLong zipLong0 = ZipLong.DD_SIG;
    byte[] byteArray0 = new byte[5];
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 1;
    zipLong0.putLong(byteArray0, 741);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getLocalFileDataData();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 741
        //
        verifyException(""org.apache.commons.compress.utils.ByteUtils"", e);
    }
}","/**
 * The actual data to put into local file data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"@Override
public ZipShort getCentralDirectoryLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0));
}","public void test1111() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 1;
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    byteArray0[4] = (byte) 2;
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) 1;
    byteArray0[7] = (byte) (-94);
    byteArray0[8] = (byte) 0;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 1, 1830);
    ZipLong zipLong0 = new ZipLong((-2426));
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * <p>For X5455 the central length is often smaller than the
 * local length, because central cannot contain access or create
 * timestamps.</p>
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"public void setAccessTime(final ZipLong l) {
    bit1_accessTimePresent = l != null;
    flags = (byte) (l != null ? (flags | ACCESS_TIME_BIT) : (flags & ~ACCESS_TIME_BIT));
    this.accessTime = l;
}","public void test1212() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
}","/**
 * <p>
 * Sets the access time (seconds since epoch) of this zip entry
 * using a ZipLong object
 * </p><p>
 * Note: the setters for flags and timestamps are decoupled.
 * Even if the timestamp is not-null, it will only be written
 * out if the corresponding bit in the flags is also set.
 * </p>
 *
 * @param l ZipLong of the access time (seconds per epoch)
 */"
"@Override
public boolean equals(final Object o) {
    if (o instanceof X5455_ExtendedTimestamp) {
        final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;
        // The ZipLong==ZipLong clauses handle the cases where both are null.
        // and only last 3 bits of flags matter.
        return ((flags & 0x07) == (xf.flags & 0x07)) && (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) && (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) && (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));
    }
    return false;
}","public void test1313() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    Object object0 = new Object();
    x5455_ExtendedTimestamp0.equals(object0);
}",""
"public byte getFlags() {
    return flags;
}","public void test1414() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getFlags();
}","/**
 * Gets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @return flags byte indicating which of the
 *         three datestamp fields are present.
 */"
"public boolean isBit0_modifyTimePresent() {
    return bit0_modifyTimePresent;
}","public void test1515() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
}","/**
 * Returns whether bit0 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a modify timestamp in this particular zip entry.
 *
 * @return true if bit0 of the flags byte is set.
 */"
"public boolean isBit0_modifyTimePresent() {
    return bit0_modifyTimePresent;
}","public void test1616() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.setCreateTime((ZipLong) null);
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.isBit1_accessTimePresent();
    byte byte0 = (byte) 0;
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    byte byte1 = (byte) (-94);
    x5455_ExtendedTimestamp0.setFlags((byte) (-94));
    x5455_ExtendedTimestamp0.toString();
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can only convert non-negative integers between [0,255] to byte: [-94]
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipUtil"", e);
    }
}","/**
 * Returns whether bit0 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a modify timestamp in this particular zip entry.
 *
 * @return true if bit0 of the flags byte is set.
 */"
"@Override
public byte[] getLocalFileDataData() {
    final byte[] data = new byte[getLocalFileDataLength().getValue()];
    int pos = 0;
    data[pos++] = 0;
    if (bit0_modifyTimePresent) {
        data[0] |= MODIFY_TIME_BIT;
        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit1_accessTimePresent && accessTime != null) {
        data[0] |= ACCESS_TIME_BIT;
        System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit2_createTimePresent && createTime != null) {
        data[0] |= CREATE_TIME_BIT;
        System.arraycopy(createTime.getBytes(), 0, data, pos, 4);
        // NOSONAR - assignment as documentation
        pos += 4;
    }
    return data;
}","public void test1717() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate((byte) 2, (byte) 4, (-2866), (byte) 4, (-208), (-2866));
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
}","/**
 * The actual data to put into local file data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"@Override
public ZipShort getCentralDirectoryLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0));
}","public void test1818() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * <p>For X5455 the central length is often smaller than the
 * local length, because central cannot contain access or create
 * timestamps.</p>
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"@Override
public void parseFromLocalFileData(final byte[] data, int offset, final int length) throws ZipException {
    reset();
    final int len = offset + length;
    setFlags(data[offset++]);
    if (bit0_modifyTimePresent) {
        modifyTime = new ZipLong(data, offset);
        offset += 4;
    }
    // Notice the extra length check in case we are parsing the shorter
    // central data field (for both access and create timestamps).
    if (bit1_accessTimePresent && offset + 4 <= len) {
        accessTime = new ZipLong(data, offset);
        offset += 4;
    }
    if (bit2_createTimePresent && offset + 4 <= len) {
        createTime = new ZipLong(data, offset);
        // NOSONAR - assignment as documentation
        offset += 4;
    }
}","public void test1919() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 2;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 1, 4);
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"@Override
public int hashCode() {
    // only last 3 bits of flags matter
    int hc = (-123 * (flags & 0x07));
    if (modifyTime != null) {
        hc ^= modifyTime.hashCode();
    }
    if (accessTime != null) {
        // Since accessTime is often same as modifyTime,
        // this prevents them from XOR negating each other.
        hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);
    }
    if (createTime != null) {
        hc ^= Integer.rotateLeft(createTime.hashCode(), 22);
    }
    return hc;
}","public void test2020() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 4;
    byteArray0[1] = (byte) 2;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 2;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (byte) 2, (-3895));
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.hashCode();
}",""
"public static long getValue(final byte[] bytes) {
    return getValue(bytes, 0);
}","public void test2121() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = x5455_ExtendedTimestamp0.getCentralDirectoryData();
    byte[] byteArray1 = x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp2 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp2.getAccessTime();
    x5455_ExtendedTimestamp2.getModifyJavaTime();
    x5455_ExtendedTimestamp2.parseFromCentralDirectoryData(byteArray1, (byte) 1, 3750);
    // Undeclared exception!
    try {
        ZipLong.getValue(byteArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Helper method to get the value as a Java long from a four-byte array
 * @param bytes the array of bytes
 * @return the corresponding Java long value
 */"
"public void setFlags(final byte flags) {
    this.flags = flags;
    this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;
    this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;
    this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;
}","public void test2222() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) (-1);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 1;
    byteArray0[5] = (byte) 4;
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    ZipLong.putLong((-1L), byteArray0, (int) (byte) (-1));
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.getFlags();
    Instant instant0 = MockInstant.ofEpochSecond((long) (byte) 4, (-77L));
    Date date0 = x5455_ExtendedTimestamp0.getAccessJavaTime();
    Date date1 = Date.from(instant0);
    MockDate mockDate0 = new MockDate(0, (byte) (-1), (-1504), (byte) 4, (-3454), (byte) 4);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.setCreateJavaTime(date1);
    x5455_ExtendedTimestamp0.setModifyJavaTime(date1);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.setCreateJavaTime(date1);
    Date date2 = x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime(date2);
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
    x5455_ExtendedTimestamp0.equals(date2);
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.setAccessJavaTime(date0);
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, 1728, 0);
    x5455_ExtendedTimestamp0.setFlags(byteArray0[0]);
}","/**
 * Sets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @param flags flags byte indicating which of the
 *              three datestamp fields are present.
 */"
"@Override
public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {
    reset();
    parseFromLocalFileData(buffer, offset, length);
}","public void test2323() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    byte byte0 = (byte) 0;
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    byte[] byteArray0 = null;
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.parseFromCentralDirectoryData((byte[]) null, (byte) 0, (byte) 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Doesn't do anything special since this class always uses the
 * same parsing logic for both central directory and local file data.
 */"
"@Override
public boolean equals(final Object o) {
    if (o instanceof X5455_ExtendedTimestamp) {
        final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;
        // The ZipLong==ZipLong clauses handle the cases where both are null.
        // and only last 3 bits of flags matter.
        return ((flags & 0x07) == (xf.flags & 0x07)) && (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) && (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) && (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));
    }
    return false;
}","public void test2424() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.setCreateTime((ZipLong) null);
    MockDate mockDate0 = new MockDate(518L);
    x5455_ExtendedTimestamp0.setCreateJavaTime(mockDate0);
    Object object0 = x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.equals(object0);
}",""
"public void setModifyTime(final ZipLong l) {
    bit0_modifyTimePresent = l != null;
    flags = (byte) (l != null ? (flags | MODIFY_TIME_BIT) : (flags & ~MODIFY_TIME_BIT));
    this.modifyTime = l;
}","public void test2525() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
}","/**
 * <p>
 * Sets the modify time (seconds since epoch) of this zip entry
 * using a ZipLong object.
 * </p><p>
 * Note: the setters for flags and timestamps are decoupled.
 * Even if the timestamp is not-null, it will only be written
 * out if the corresponding bit in the flags is also set.
 * </p>
 *
 * @param l ZipLong of the modify time (seconds per epoch)
 */"
"public byte getFlags() {
    return flags;
}","public void test2626() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getFlags();
}","/**
 * Gets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @return flags byte indicating which of the
 *         three datestamp fields are present.
 */"
"public Date getCreateJavaTime() {
    return zipLongToDate(createTime);
}","public void test2727() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.setFlags((byte) 65);
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getCreateJavaTime();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * <p>
 * Returns the create time as a a java.util.Date
 * of this zip entry, or null if no such timestamp exists in the zip entry.
 * The milliseconds are always zeroed out, since the underlying data
 * offers only per-second precision.
 * </p><p>
 * Note: modern linux file systems (e.g., ext2)
 * do not appear to store a ""create time"" value, and so
 * it's usually omitted altogether in the zip extra
 * field.  Perhaps other unix systems track this.
 *
 * @return create time as java.util.Date or null.
 */"
"@Override
public byte[] getLocalFileDataData() {
    final byte[] data = new byte[getLocalFileDataLength().getValue()];
    int pos = 0;
    data[pos++] = 0;
    if (bit0_modifyTimePresent) {
        data[0] |= MODIFY_TIME_BIT;
        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit1_accessTimePresent && accessTime != null) {
        data[0] |= ACCESS_TIME_BIT;
        System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit2_createTimePresent && createTime != null) {
        data[0] |= CREATE_TIME_BIT;
        System.arraycopy(createTime.getBytes(), 0, data, pos, 4);
        // NOSONAR - assignment as documentation
        pos += 4;
    }
    return data;
}","public void test2828() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate();
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
}","/**
 * The actual data to put into local file data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"@Override
public ZipShort getHeaderId() {
    return HEADER_ID;
}","public void test2929() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.equals((Object) null);
    x5455_ExtendedTimestamp0.getHeaderId();
}","/**
 * The Header-ID.
 *
 * @return the value for the header id for this extrafield
 */"
"@Override
public byte[] getLocalFileDataData() {
    final byte[] data = new byte[getLocalFileDataLength().getValue()];
    int pos = 0;
    data[pos++] = 0;
    if (bit0_modifyTimePresent) {
        data[0] |= MODIFY_TIME_BIT;
        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit1_accessTimePresent && accessTime != null) {
        data[0] |= ACCESS_TIME_BIT;
        System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);
        pos += 4;
    }
    if (bit2_createTimePresent && createTime != null) {
        data[0] |= CREATE_TIME_BIT;
        System.arraycopy(createTime.getBytes(), 0, data, pos, 4);
        // NOSONAR - assignment as documentation
        pos += 4;
    }
    return data;
}","public void test3030() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.AED_SIG;
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
}","/**
 * The actual data to put into local file data - without Header-ID
 * or length specifier.
 *
 * @return get the data
 */"
"@Override
public ZipShort getHeaderId() {
    return HEADER_ID;
}","public void test3131() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) (-126);
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 71;
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) 1;
    byteArray0[7] = (byte) 4;
    ZipLong zipLong0 = new ZipLong(byteArray0);
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    zipLong0.getBytes();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.equals(zipLong0);
    x5455_ExtendedTimestamp0.getHeaderId();
}","/**
 * The Header-ID.
 *
 * @return the value for the header id for this extrafield
 */"
"@Override
public String toString() {
    final StringBuilder buf = new StringBuilder();
    buf.append(""0x5455 Zip Extra Field: Flags="");
    buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append("" "");
    if (bit0_modifyTimePresent && modifyTime != null) {
        final Date m = getModifyJavaTime();
        buf.append("" Modify:["").append(m).append(""] "");
    }
    if (bit1_accessTimePresent && accessTime != null) {
        final Date a = getAccessJavaTime();
        buf.append("" Access:["").append(a).append(""] "");
    }
    if (bit2_createTimePresent && createTime != null) {
        final Date c = getCreateJavaTime();
        buf.append("" Create:["").append(c).append(""] "");
    }
    return buf.toString();
}","public void test3232() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 4;
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) 1;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, 0, (-2718));
    x5455_ExtendedTimestamp0.toString();
}","/**
 * Returns a String representation of this class useful for
 * debugging purposes.
 *
 * @return A String representation of this class useful for
 *         debugging purposes.
 */"
"@Override
public ZipShort getCentralDirectoryLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0));
}","public void test3333() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.isBit1_accessTimePresent();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * <p>For X5455 the central length is often smaller than the
 * local length, because central cannot contain access or create
 * timestamps.</p>
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"public Date getModifyJavaTime() {
    return zipLongToDate(modifyTime);
}","public void test3434() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
}","/**
 * Returns the modify time as a java.util.Date
 * of this zip entry, or null if no such timestamp exists in the zip entry.
 * The milliseconds are always zeroed out, since the underlying data
 * offers only per-second precision.
 *
 * @return modify time as java.util.Date or null.
 */"
"public void setFlags(final byte flags) {
    this.flags = flags;
    this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;
    this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;
    this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;
}","public void test3535() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.setAccessTime((ZipLong) null);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.setFlags((byte) (-13));
}","/**
 * Sets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @param flags flags byte indicating which of the
 *              three datestamp fields are present.
 */"
"@Override
public ZipShort getLocalFileDataLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent && accessTime != null ? 4 : 0) + (bit2_createTimePresent && createTime != null ? 4 : 0));
}","public void test3636() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.setFlags((byte) (-76));
    x5455_ExtendedTimestamp0.setFlags((byte) 46);
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"@Override
public int hashCode() {
    // only last 3 bits of flags matter
    int hc = (-123 * (flags & 0x07));
    if (modifyTime != null) {
        hc ^= modifyTime.hashCode();
    }
    if (accessTime != null) {
        // Since accessTime is often same as modifyTime,
        // this prevents them from XOR negating each other.
        hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);
    }
    if (createTime != null) {
        hc ^= Integer.rotateLeft(createTime.hashCode(), 22);
    }
    return hc;
}","public void test3737() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.CFH_SIG;
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.hashCode();
}",""
"@Override
public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {
    reset();
    parseFromLocalFileData(buffer, offset, length);
}","public void test3838() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate((byte) 2, 0, (byte) 1);
    MockDate.UTC((byte) 2, (byte) 2, 11, 310, (byte) 2, (-1515));
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.setFlags((byte) 2);
    x5455_ExtendedTimestamp0.isBit1_accessTimePresent();
    Instant instant0 = mockDate0.toInstant();
    Date date0 = Date.from(instant0);
    x5455_ExtendedTimestamp0.setAccessJavaTime(date0);
    Date date1 = x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime(date1);
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 2;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (-1), 0);
}","/**
 * Doesn't do anything special since this class always uses the
 * same parsing logic for both central directory and local file data.
 */"
"@Override
public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {
    reset();
    parseFromLocalFileData(buffer, offset, length);
}","public void test3939() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    MockDate mockDate0 = new MockDate((byte) 1, 2, 543, 4, 0, 4);
    MockDate mockDate1 = new MockDate((-2342L));
    mockDate1.toInstant();
    mockDate0.before(mockDate1);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    ZipLong zipLong0 = x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.getAccessTime();
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 4;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 1;
    byteArray0[4] = (byte) 4;
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) 2;
    byteArray0[7] = (byte) 2;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, 721, 543);
}","/**
 * Doesn't do anything special since this class always uses the
 * same parsing logic for both central directory and local file data.
 */"
"@Override
public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {
    reset();
    parseFromLocalFileData(buffer, offset, length);
}","public void test4040() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 4;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 1;
    byteArray0[5] = (byte) 4;
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (byte) 4, (byte) 1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 6
        //
        verifyException(""org.apache.commons.compress.utils.ByteUtils"", e);
    }
}","/**
 * Doesn't do anything special since this class always uses the
 * same parsing logic for both central directory and local file data.
 */"
"@Override
public void parseFromLocalFileData(final byte[] data, int offset, final int length) throws ZipException {
    reset();
    final int len = offset + length;
    setFlags(data[offset++]);
    if (bit0_modifyTimePresent) {
        modifyTime = new ZipLong(data, offset);
        offset += 4;
    }
    // Notice the extra length check in case we are parsing the shorter
    // central data field (for both access and create timestamps).
    if (bit1_accessTimePresent && offset + 4 <= len) {
        accessTime = new ZipLong(data, offset);
        offset += 4;
    }
    if (bit2_createTimePresent && offset + 4 <= len) {
        createTime = new ZipLong(data, offset);
        // NOSONAR - assignment as documentation
        offset += 4;
    }
}","public void test4141() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 2;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 1;
    byteArray0[4] = (byte) 2;
    byteArray0[5] = (byte) 1;
    byteArray0[6] = (byte) 2;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 2, 0);
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"public ZipLong getCreateTime() {
    return createTime;
}","public void test4242() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getHeaderId();
    MockDate mockDate0 = new MockDate(1068, (byte) 2, 1068, (byte) 2, (byte) 1, (byte) 2);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getCreateTime();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // X5455 timestamps must fit in a signed 32 bit integer: 31591216862
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * <p>
 * Returns the create time (seconds since epoch) of this zip entry
 * as a ZipLong object, or null if no such timestamp exists in the
 * zip entry.
 * </p><p>
 * Note: modern linux file systems (e.g., ext2)
 * do not appear to store a ""create time"" value, and so
 * it's usually omitted altogether in the zip extra
 * field.  Perhaps other unix systems track this.
 *
 * @return create time (seconds since epoch) or null.
 */"
"@Override
public ZipShort getLocalFileDataLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent && accessTime != null ? 4 : 0) + (bit2_createTimePresent && createTime != null ? 4 : 0));
}","public void test4343() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    Object object0 = x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.equals(object0);
    x5455_ExtendedTimestamp0.setFlags((byte) 4);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp1.hashCode();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"public ZipLong getModifyTime() {
    return modifyTime;
}","public void test4444() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = (X5455_ExtendedTimestamp) x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.equals(x5455_ExtendedTimestamp1);
    x5455_ExtendedTimestamp0.setFlags((byte) 21);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp2 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.equals(x5455_ExtendedTimestamp2);
    x5455_ExtendedTimestamp2.hashCode();
    x5455_ExtendedTimestamp1.getLocalFileDataData();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getModifyTime();
}","/**
 * Returns the modify time (seconds since epoch) of this zip entry
 * as a ZipLong object, or null if no such timestamp exists in the
 * zip entry.
 *
 * @return modify time (seconds since epoch) or null.
 */"
"public boolean isBit2_createTimePresent() {
    return bit2_createTimePresent;
}","public void test4545() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.SINGLE_SEGMENT_SPLIT_MARKER;
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-1);
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 2;
    MockDate mockDate0 = new MockDate(1747, (byte) 4, (-1574), (byte) 2, (-1574), 865);
    MockDate.UTC((byte) (-1), (byte) 1, (-5), 865, 1214, (-5));
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    byteArray0[5] = x5455_ExtendedTimestamp0.MODIFY_TIME_BIT;
    byteArray0[6] = x5455_ExtendedTimestamp0.CREATE_TIME_BIT;
    byteArray0[7] = x5455_ExtendedTimestamp0.MODIFY_TIME_BIT;
    ZipLong.getValue(byteArray0);
    zipLong0.getBytes();
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.isBit2_createTimePresent();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // X5455 timestamps must fit in a signed 32 bit integer: 52795238425
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Returns whether bit2 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a create timestamp in this particular zip entry.
 *
 * @return true if bit2 of the flags byte is set.
 */"
"@Override
public int hashCode() {
    // only last 3 bits of flags matter
    int hc = (-123 * (flags & 0x07));
    if (modifyTime != null) {
        hc ^= modifyTime.hashCode();
    }
    if (accessTime != null) {
        // Since accessTime is often same as modifyTime,
        // this prevents them from XOR negating each other.
        hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);
    }
    if (createTime != null) {
        hc ^= Integer.rotateLeft(createTime.hashCode(), 22);
    }
    return hc;
}","public void test4646() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.hashCode();
}",""
"@Override
public void parseFromCentralDirectoryData(final byte[] buffer, final int offset, final int length) throws ZipException {
    reset();
    parseFromLocalFileData(buffer, offset, length);
}","public void test4747() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.setFlags((byte) 102);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.isBit2_createTimePresent();
    x5455_ExtendedTimestamp0.clone();
    ZipLong zipLong0 = ZipLong.ZIP64_MAGIC;
    zipLong0.getBytes();
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 4;
    byteArray0[1] = (byte) 102;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 4;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (byte) 4, 1);
}","/**
 * Doesn't do anything special since this class always uses the
 * same parsing logic for both central directory and local file data.
 */"
"@Override
public byte[] getCentralDirectoryData() {
    final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];
    final byte[] localData = getLocalFileDataData();
    // Truncate out create & access time (last 8 bytes) from
    // the copy of the local data we obtained:
    System.arraycopy(localData, 0, centralData, 0, centralData.length);
    return centralData;
}","public void test4848() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.toString();
    ZipLong zipLong0 = ZipLong.DD_SIG;
    zipLong0.getBytes();
    ZipLong.getBytes(1L);
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.isBit2_createTimePresent();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
}","/**
 * The actual data to put into central directory data - without Header-ID
 * or length specifier.
 *
 * @return the central directory data
 */"
"public byte getFlags() {
    return flags;
}","public void test4949() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getAccessTime();
    MockDate mockDate0 = new MockDate();
    mockDate0.toInstant();
    MockDate mockDate1 = new MockDate(1144, 197, (-1), (-1), 250, 250);
    mockDate0.after(mockDate1);
    MockDate.UTC((byte) 1, 197, (byte) 2, (byte) 2, (-2468), (-433));
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.getAccessTime();
    x5455_ExtendedTimestamp0.getFlags();
}","/**
 * Gets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @return flags byte indicating which of the
 *         three datestamp fields are present.
 */"
"public byte getFlags() {
    return flags;
}","public void test5050() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 2;
    x5455_ExtendedTimestamp0.setFlags((byte) 1);
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 4;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, (byte) 1, 0);
    x5455_ExtendedTimestamp0.setFlags((byte) 121);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    ZipLong zipLong0 = new ZipLong(11);
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    ZipLong zipLong1 = x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.setAccessTime(zipLong1);
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getFlags();
}","/**
 * Gets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @return flags byte indicating which of the
 *         three datestamp fields are present.
 */"
"public boolean isBit0_modifyTimePresent() {
    return bit0_modifyTimePresent;
}","public void test5151() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 4;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 1;
    byteArray0[4] = (byte) 2;
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) 1;
    byteArray0[7] = (byte) (-94);
    byteArray0[8] = (byte) 0;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 1, 1830);
    ZipLong zipLong0 = new ZipLong((-2426));
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
}","/**
 * Returns whether bit0 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a modify timestamp in this particular zip entry.
 *
 * @return true if bit0 of the flags byte is set.
 */"
"@Override
public Object clone() throws CloneNotSupportedException {
    return super.clone();
}","public void test5252() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp1.getModifyTime();
    x5455_ExtendedTimestamp0.setModifyTime((ZipLong) null);
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.clone();
}",""
"public boolean isBit2_createTimePresent() {
    return bit2_createTimePresent;
}","public void test5353() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 2;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 1;
    byteArray0[4] = (byte) 2;
    byteArray0[5] = (byte) 2;
    byteArray0[6] = (byte) 2;
    byteArray0[7] = (byte) 2;
    byteArray0[8] = (byte) 4;
    ZipLong zipLong0 = new ZipLong(byteArray0);
    byte[] byteArray1 = zipLong0.getBytes();
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray1, (byte) 2, 4);
    ZipShort zipShort0 = x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getAccessTime();
    ZipLong.getBytes(470L);
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    ZipLong.getValue(byteArray0, (int) (byte) 2);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.setAccessTime(zipLong0);
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.equals(zipShort0);
    x5455_ExtendedTimestamp0.setAccessTime((ZipLong) null);
    x5455_ExtendedTimestamp0.isBit0_modifyTimePresent();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.parseFromLocalFileData((byte[]) null, (-1756), (byte) 2);
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.isBit2_createTimePresent();
}","/**
 * Returns whether bit2 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a create timestamp in this particular zip entry.
 *
 * @return true if bit2 of the flags byte is set.
 */"
"@Override
public String toString() {
    final StringBuilder buf = new StringBuilder();
    buf.append(""0x5455 Zip Extra Field: Flags="");
    buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append("" "");
    if (bit0_modifyTimePresent && modifyTime != null) {
        final Date m = getModifyJavaTime();
        buf.append("" Modify:["").append(m).append(""] "");
    }
    if (bit1_accessTimePresent && accessTime != null) {
        final Date a = getAccessJavaTime();
        buf.append("" Access:["").append(a).append(""] "");
    }
    if (bit2_createTimePresent && createTime != null) {
        final Date c = getCreateJavaTime();
        buf.append("" Create:["").append(c).append(""] "");
    }
    return buf.toString();
}","public void test5454() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate((byte) 1, (byte) 2, 1269, 1269, 0, (byte) 2);
    x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);
    MockDate mockDate1 = new MockDate();
    mockDate0.after(mockDate1);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.setCreateJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.setFlags((byte) 0);
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getAccessTime();
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.isBit2_createTimePresent();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.toString();
}","/**
 * Returns a String representation of this class useful for
 * debugging purposes.
 *
 * @return A String representation of this class useful for
 *         debugging purposes.
 */"
"@Override
public boolean equals(final Object o) {
    if (o instanceof X5455_ExtendedTimestamp) {
        final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;
        // The ZipLong==ZipLong clauses handle the cases where both are null.
        // and only last 3 bits of flags matter.
        return ((flags & 0x07) == (xf.flags & 0x07)) && (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) && (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) && (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));
    }
    return false;
}","public void test5555() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.setFlags((byte) (-98));
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.setCreateJavaTime((Date) null);
    x5455_ExtendedTimestamp0.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp0.isBit1_accessTimePresent();
    x5455_ExtendedTimestamp0.setFlags((byte) (-98));
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    x5455_ExtendedTimestamp0.getFlags();
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp1.getLocalFileDataData();
    x5455_ExtendedTimestamp0.equals(x5455_ExtendedTimestamp1);
}",""
"public void setFlags(final byte flags) {
    this.flags = flags;
    this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;
    this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;
    this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;
}","public void test5656() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    x5455_ExtendedTimestamp0.getAccessJavaTime();
    MockDate mockDate0 = new MockDate((-3502L));
    mockDate0.toInstant();
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    byte[] byteArray0 = x5455_ExtendedTimestamp0.getCentralDirectoryData();
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, 0, 938);
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    byte byte0 = (byte) (-69);
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.setFlags(byte0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.compress.utils.ByteUtils"", e);
    }
}","/**
 * Sets flags byte.  The flags byte tells us which of the
 * three datestamp fields are present in the data:
 * <pre>
 * bit0 - modify time
 * bit1 - access time
 * bit2 - create time
 * </pre>
 * Only first 3 bits of flags are used according to the
 * latest version of the spec (December 2012).
 *
 * @param flags flags byte indicating which of the
 *              three datestamp fields are present.
 */"
"@Override
public void parseFromLocalFileData(final byte[] data, int offset, final int length) throws ZipException {
    reset();
    final int len = offset + length;
    setFlags(data[offset++]);
    if (bit0_modifyTimePresent) {
        modifyTime = new ZipLong(data, offset);
        offset += 4;
    }
    // Notice the extra length check in case we are parsing the shorter
    // central data field (for both access and create timestamps).
    if (bit1_accessTimePresent && offset + 4 <= len) {
        accessTime = new ZipLong(data, offset);
        offset += 4;
    }
    if (bit2_createTimePresent && offset + 4 <= len) {
        createTime = new ZipLong(data, offset);
        // NOSONAR - assignment as documentation
        offset += 4;
    }
}","public void test5757() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    Instant instant0 = MockInstant.ofEpochMilli((-5427L));
    LocalDate localDate0 = MockLocalDate.ofEpochDay(2558L);
    Period period0 = Period.between(localDate0, localDate0);
    Instant instant1 = MockInstant.minus(instant0, (TemporalAmount) period0);
    Instant instant2 = MockInstant.plusSeconds(instant1, (-1544L));
    Date date0 = Date.from(instant2);
    x5455_ExtendedTimestamp0.setModifyJavaTime(date0);
    ZipLong zipLong0 = ZipLong.LFH_SIG;
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.getLocalFileDataLength();
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) (-1);
    byteArray0[1] = (byte) 2;
    byteArray0[2] = (byte) 1;
    byteArray0[3] = (byte) 2;
    byteArray0[4] = (byte) 4;
    byteArray0[5] = (byte) (-8);
    byteArray0[6] = (byte) 71;
    byteArray0[7] = (byte) 1;
    byteArray0[8] = (byte) 4;
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 1, (byte) 71);
}","/**
 * Populate data from this array as if it was in local file data.
 *
 * @param data   an array of bytes
 * @param offset the start offset
 * @param length the number of bytes in the array from offset
 * @throws java.util.zip.ZipException on error
 */"
"@Override
public Object clone() throws CloneNotSupportedException {
    return super.clone();
}","public void test5858() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = ZipLong.SINGLE_SEGMENT_SPLIT_MARKER;
    ZipLong.getBytes((long) (byte) 2);
    zipLong0.toString();
    x5455_ExtendedTimestamp0.setCreateTime(zipLong0);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    MockDate mockDate0 = new MockDate((byte) 4, (byte) 4, (-2852), (byte) 2, 806);
    mockDate0.setTime(0L);
    x5455_ExtendedTimestamp0.setCreateJavaTime(mockDate0);
    Date date0 = x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData((byte[]) null, 707, 494);
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp0.setModifyJavaTime(date0);
    x5455_ExtendedTimestamp0.clone();
}",""
"public boolean isBit0_modifyTimePresent() {
    return bit0_modifyTimePresent;
}","public void test5959() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.setFlags((byte) 4);
    byte[] byteArray0 = new byte[8];
    byteArray0[4] = (byte) 4;
    byteArray0[1] = (byte) 2;
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (byte) 4, (byte) 4);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) 1;
    byteArray0[4] = (byte) 4;
    byteArray0[5] = (byte) 2;
    byteArray0[6] = (byte) 52;
    byteArray0[7] = (byte) 1;
    x5455_ExtendedTimestamp0.parseFromCentralDirectoryData(byteArray0, 0, 0);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate((byte) 2);
    x5455_ExtendedTimestamp1.setModifyJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.equals(x5455_ExtendedTimestamp1);
    x5455_ExtendedTimestamp1.setModifyJavaTime((Date) null);
    x5455_ExtendedTimestamp1.setFlags((byte) 0);
    x5455_ExtendedTimestamp1.getAccessTime();
    ZipLong.putLong((-4302L), byteArray0, (int) (byte) (-1));
    ZipLong.getValue(byteArray0);
    x5455_ExtendedTimestamp1.isBit2_createTimePresent();
    x5455_ExtendedTimestamp0.getFlags();
    x5455_ExtendedTimestamp0.setModifyTime((ZipLong) null);
    x5455_ExtendedTimestamp0.parseFromLocalFileData(byteArray0, (-3), (-3));
    x5455_ExtendedTimestamp0.getModifyTime();
    x5455_ExtendedTimestamp1.isBit0_modifyTimePresent();
}","/**
 * Returns whether bit0 of the flags byte is set or not,
 * which should correspond to the presence or absence of
 * a modify timestamp in this particular zip entry.
 *
 * @return true if bit0 of the flags byte is set.
 */"
"public ZipLong getAccessTime() {
    return accessTime;
}","public void test6060() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    MockDate mockDate0 = new MockDate((byte) 1, (byte) 2, 1324);
    Instant instant0 = MockInstant.ofEpochSecond((long) (byte) 4, (long) (byte) 2);
    Date.from(instant0);
    mockDate0.setTime((byte) 2);
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.getFlags();
    x5455_ExtendedTimestamp0.getAccessTime();
}","/**
 * Returns the access time (seconds since epoch) of this zip entry
 * as a ZipLong object, or null if no such timestamp exists in the
 * zip entry.
 *
 * @return access time (seconds since epoch) or null.
 */"
"@Override
public ZipShort getLocalFileDataLength() {
    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent && accessTime != null ? 4 : 0) + (bit2_createTimePresent && createTime != null ? 4 : 0));
}","public void test6161() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    Object object0 = x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.hashCode();
    x5455_ExtendedTimestamp0.equals(object0);
    x5455_ExtendedTimestamp0.setFlags((byte) 21);
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp1 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp1.hashCode();
    x5455_ExtendedTimestamp1.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    // Undeclared exception!
    try {
        x5455_ExtendedTimestamp0.getLocalFileDataLength();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"", e);
    }
}","/**
 * Length of the extra field in the local file data - without
 * Header-ID or length specifier.
 *
 * @return a <code>ZipShort</code> for the length of the data of this extra field
 */"
"@Override
public byte[] getCentralDirectoryData() {
    final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];
    final byte[] localData = getLocalFileDataData();
    // Truncate out create & access time (last 8 bytes) from
    // the copy of the local data we obtained:
    System.arraycopy(localData, 0, centralData, 0, centralData.length);
    return centralData;
}","public void test6262() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
    MockDate mockDate0 = new MockDate((byte) 1);
    x5455_ExtendedTimestamp0.setAccessJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.getModifyJavaTime();
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getLocalFileDataData();
    x5455_ExtendedTimestamp0.equals(""0x5455 Zip Extra Field: Flags=10  Access:[Thu Jan 01 00:00:00 GMT 1970] "");
    x5455_ExtendedTimestamp0.toString();
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setFlags((byte) (-114));
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.setCreateJavaTime(mockDate0);
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.equals(""0x5455 Zip Extra Field: Flags=10  Access:[Thu Jan 01 00:00:00 GMT 1970] "");
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.getAccessTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryData();
}","/**
 * The actual data to put into central directory data - without Header-ID
 * or length specifier.
 *
 * @return the central directory data
 */"
"public ZipLong getModifyTime() {
    return modifyTime;
}","public void test6363() throws Throwable {
    X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();
    ZipLong zipLong0 = new ZipLong(0L);
    x5455_ExtendedTimestamp0.getCreateJavaTime();
    x5455_ExtendedTimestamp0.setAccessJavaTime((Date) null);
    x5455_ExtendedTimestamp0.setModifyTime(zipLong0);
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.clone();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.getCentralDirectoryLength();
    x5455_ExtendedTimestamp0.equals((Object) null);
    x5455_ExtendedTimestamp0.getHeaderId();
    x5455_ExtendedTimestamp0.getCreateTime();
    x5455_ExtendedTimestamp0.getModifyTime();
}","/**
 * Returns the modify time (seconds since epoch) of this zip entry
 * as a ZipLong object, or null if no such timestamp exists in the
 * zip entry.
 *
 * @return modify time (seconds since epoch) or null.
 */"
