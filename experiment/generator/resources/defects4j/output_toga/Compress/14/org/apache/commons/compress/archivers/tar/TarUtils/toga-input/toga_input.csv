focal_method,test_prefix,docstring
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test0000() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[1] = (byte) (-121);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-121);
    byte byte0 = (byte) 86;
    byteArray0[4] = (byte) (-121);
    TarUtils.parseName(byteArray0, (byte) (-46), (byte) 0);
    int int0 = 24;
    TarUtils.parseOctalOrBinary(byteArray0, 1, 24);
    int int1 = (-1);
    TarUtils.formatOctalBytes(byte0, byteArray0, int1, int0);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test0011() throws Throwable {
    byte[] byteArray0 = new byte[1];
    int int0 = 0;
    int int1 = 3872;
    TarUtils.formatLongOctalOrBinaryBytes(36028797018963933L, byteArray0, 0, 0);
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Value 36028797018963933 is too large for 0 byte field.
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test0033() throws Throwable {
    byte[] byteArray0 = new byte[20];
    int int0 = 8;
    TarUtils.formatLongOctalOrBinaryBytes(36028797018963933L, byteArray0, 8, 8);
    int int1 = 0;
    TarUtils.formatNameBytes(""Jr"", byteArray0, 0, 8);
    TarUtils.formatLongOctalOrBinaryBytes(16, byteArray0, 8, 8);
    int int2 = 1396;
    TarUtils.formatLongOctalOrBinaryBytes((-3658L), byteArray0, 1396, 16);
    int int3 = 0;
    int int4 = (-620);
    TarUtils.parseOctal(byteArray0, int3, int4);
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes(int2, byteArray0, int1, int0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test0055() throws Throwable {
    byte[] byteArray0 = new byte[10];
    byteArray0[0] = (byte) 10;
    byteArray0[1] = (byte) 59;
    byteArray0[5] = (byte) 59;
    TarUtils.formatCheckSumOctalBytes(1294L, byteArray0, (byte) 48, (byte) 48);
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test0066() throws Throwable {
    int int0 = 55;
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-103);
    byteArray0[1] = (byte) (-103);
    byteArray0[3] = (byte) (-103);
    byteArray0[4] = (byte) (-103);
    byteArray0[5] = (byte) 4;
    byteArray0[7] = (byte) (-103);
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
    TarUtils.parseOctal(byteArray0, byteArray0[5], int0);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test0077() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[1] = (byte) 1;
    TarUtils.parseBoolean(byteArray0, (byte) 1);
    byte[] byteArray1 = new byte[5];
    byteArray1[2] = (byte) 77;
    byteArray1[3] = (byte) 1;
    byteArray1[4] = (byte) 1;
    TarUtils.parseOctal(byteArray1, (byte) 0, (byte) 0);
    int int0 = 737;
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalBytes(byteArray0[1], byteArray1, int0, byteArray1[4]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Length 0 must be at least 2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test0088() throws Throwable {
    byte[] byteArray0 = new byte[7];
    TarUtils.parseBoolean(byteArray0, 0);
    TarUtils.formatCheckSumOctalBytes(0, byteArray0, 128, (byte) 0);
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test0099() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byteArray0[3] = (byte) 0;
    TarUtils.formatOctalBytes(0, byteArray0, 2, 3);
    TarUtils.computeCheckSum(byteArray0);
    TarUtils.formatLongOctalBytes(80L, byteArray0, 5, 8);
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test01010() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 120;
    byteArray0[1] = (byte) 46;
    byteArray0[2] = (byte) (-2);
    TarUtils.parseName(byteArray0, 0, (byte) 46);
    int int0 = 794;
    TarUtils.parseOctalOrBinary(byteArray0, (byte) 46, 794);
    int int1 = 32;
    TarUtils.parseOctal(byteArray0, int0, int1);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test01111() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 121;
    byteArray0[2] = (byte) 4;
    byteArray0[2] = (byte) 121;
    byteArray0[4] = (byte) 121;
    byteArray0[5] = (byte) 4;
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
    long long0 = 390L;
    int int0 = 128;
    TarUtils.formatUnsignedOctalString(long0, byteArray0, int0, int0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test01212() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[2] = (byte) 4;
    byteArray0[6] = (byte) 4;
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 4);
    long long0 = 414L;
    String string0 = """";
    int int0 = 674;
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(string0, byteArray0, int0, byteArray0[0]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 0 at offset 0 in '{NUL}{NUL}\u0004{NUL}' len=4
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test01313() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-73);
    TarUtils.parseOctalOrBinary(byteArray0, (byte) 0, (byte) (-73));
    TarUtils.formatCheckSumOctalBytes((-22L), byteArray0, (byte) (-73), (byte) 0);
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test01414() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[6] = (byte) (-36);
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 4);
    TarUtils.formatNameBytes("""", byteArray0, 674, (byte) 0);
    TarUtils.formatUnsignedOctalString(0L, byteArray0, (byte) 4, (byte) 4);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    long val = buffer[offset] & 0x7f;
    for (int i = 1; i < length; i++) {
        if (val >= (1L << (63 - 8))) {
            throw new IllegalArgumentException(""At offset "" + offset + "", "" + length + "" byte "" + ""binary number exceeds maximum signed long value"");
        }
        val = (val << 8) + (buffer[offset + i] & 0xff);
    }
    return val;
}","public void test01616() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byte byte0 = (byte) (-55);
    byteArray0[0] = (byte) (-55);
    byte byte1 = (byte) 56;
    byteArray0[1] = (byte) 56;
    byteArray0[0] = (byte) 56;
    byteArray0[3] = (byte) (-26);
    int int0 = 1;
    int int1 = 2;
    TarUtils.parseOctal(byteArray0, 1, 2);
    // Undeclared exception!
    try {
        TarUtils.parseOctalOrBinary(byteArray0, byte0, byteArray0[2]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 56 at offset 0 in '8{NUL}' len=2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since Apache Commons Compress 1.4
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test01717() throws Throwable {
    TarUtils.parseBoolean((byte[]) null, 128);
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test01818() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-34);
    byteArray0[1] = (byte) 120;
    byteArray0[2] = (byte) 102;
    TarUtils.formatNameBytes(""$bG;"", byteArray0, 4195, (byte) (-34));
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test01919() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 120;
    byteArray0[1] = (byte) 46;
    byteArray0[2] = (byte) (-14);
    byteArray0[3] = (byte) 0;
    TarUtils.parseName(byteArray0, 0, (byte) 46);
    TarUtils.formatNameBytes(""="", byteArray0, 0, 255);
    int int0 = (-880);
    TarUtils.parseOctalOrBinary(byteArray0, int0, byteArray0[2]);
    int int1 = 47;
    int int2 = (-1468);
    TarUtils.parseOctal(byteArray0, int1, int2);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test02020() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 1;
    byteArray0[2] = (byte) 68;
    TarUtils.parseOctal(byteArray0, (-1367), (byte) 0);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test02121() throws Throwable {
    byte[] byteArray0 = new byte[0];
    TarUtils.formatUnsignedOctalString((-134L), byteArray0, 2735, 0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    if (value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    long val = value;
    for (int i = offset + length - 1; i >= offset; i--) {
        buf[i] = (byte) val;
        val >>= 8;
    }
    if (val != 0 || (buf[offset] & 0x80) != 0) {
        throw new IllegalArgumentException(""Value "" + value + "" is too large for "" + length + "" byte field."");
    }
    buf[offset] |= 0x80;
    return offset + length;
}","public void test02222() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-105);
    byteArray0[2] = (byte) 1;
    TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte) 0, (byte) 1);
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since Apache Commons Compress 1.4
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test02323() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-1);
    int int0 = 1219;
    TarUtils.formatCheckSumOctalBytes((-3524L), byteArray0, (byte) (-1), 1219);
    int int1 = (-1087);
    // Undeclared exception!
    try {
        TarUtils.parseOctal(byteArray0, int1, int0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1215
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test02525() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = 2028;
    // Undeclared exception!
    try {
        TarUtils.parseBoolean((byte[]) null, 2028);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    if (value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    long val = value;
    for (int i = offset + length - 1; i >= offset; i--) {
        buf[i] = (byte) val;
        val >>= 8;
    }
    if (val != 0 || (buf[offset] & 0x80) != 0) {
        throw new IllegalArgumentException(""Value "" + value + "" is too large for "" + length + "" byte field."");
    }
    buf[offset] |= 0x80;
    return offset + length;
}","public void test02828() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-115);
    byteArray0[2] = (byte) (-128);
    byteArray0[3] = (byte) (-1);
    byteArray0[4] = (byte) 48;
    byteArray0[5] = (byte) 41;
    byteArray0[6] = (byte) 0;
    TarUtils.formatLongOctalOrBinaryBytes(1L, byteArray0, (byte) 0, (byte) (-128));
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since Apache Commons Compress 1.4
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test03131() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-103);
    byteArray0[1] = (byte) (-109);
    byteArray0[2] = (byte) 4;
    int int0 = 32;
    TarUtils.parseName(byteArray0, 32, 0);
    TarUtils.computeCheckSum(byteArray0);
    int int1 = TarUtils.formatLongOctalBytes((byte) 4, byteArray0, (-1972), 0);
    int int2 = 0;
    int int3 = TarUtils.formatOctalBytes(int1, byteArray0, int2, int0);
    int int4 = 2659;
    int int5 = 55;
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString(int3, byteArray0, int4, int5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4=4 will not fit in octal number buffer of length -1
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test03535() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) (-1);
    byteArray0[3] = (byte) (-4);
    byteArray0[4] = (byte) (-1);
    TarUtils.parseOctal(byteArray0, (byte) (-1), 255);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test03636() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) (-1);
    byteArray0[1] = (byte) 12;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 6;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 88;
    TarUtils.parseOctal(byteArray0, 3588, 1281);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test03939() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byte byte0 = (byte) 1;
    byteArray0[0] = (byte) 1;
    int int0 = 32;
    // Undeclared exception!
    try {
        TarUtils.parseBoolean(byteArray0, 32);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 32
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test04040() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 122;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 59;
    byteArray0[3] = (byte) (-94);
    TarUtils.formatNameBytes(""+Bf0iZ5MVW"", byteArray0, (byte) 122, 0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    if (value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    long val = value;
    for (int i = offset + length - 1; i >= offset; i--) {
        buf[i] = (byte) val;
        val >>= 8;
    }
    if (val != 0 || (buf[offset] & 0x80) != 0) {
        throw new IllegalArgumentException(""Value "" + value + "" is too large for "" + length + "" byte field."");
    }
    buf[offset] |= 0x80;
    return offset + length;
}","public void test04141() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 8;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) (-26);
    TarUtils.formatLongOctalOrBinaryBytes(3641L, byteArray0, 784, 784);
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since Apache Commons Compress 1.4
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test04242() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) (-21);
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 1;
    TarUtils.formatNameBytes(""d+!zu~P~HBlRk.&*"", byteArray0, 255, (-1087));
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test04343() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) (-128);
    TarUtils.formatOctalBytes(0L, byteArray0, (byte) (-128), 0);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test04444() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 16;
    byteArray0[2] = (byte) 0;
    TarUtils.formatOctalBytes(3599L, byteArray0, (byte) 16, (byte) 0);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test04747() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 9;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) (-1);
    TarUtils.formatCheckSumOctalBytes((-1L), byteArray0, (byte) (-1), (-718));
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    long val = buffer[offset] & 0x7f;
    for (int i = 1; i < length; i++) {
        if (val >= (1L << (63 - 8))) {
            throw new IllegalArgumentException(""At offset "" + offset + "", "" + length + "" byte "" + ""binary number exceeds maximum signed long value"");
        }
        val = (val << 8) + (buffer[offset + i] & 0xff);
    }
    return val;
}","public void test05151() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byte byte0 = (byte) 0;
    byteArray0[0] = (byte) 0;
    // Undeclared exception!
    try {
        TarUtils.parseOctalOrBinary(byteArray0, (byte) 0, (byte) 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Length 0 must be at least 2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since Apache Commons Compress 1.4
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    long val = buffer[offset] & 0x7f;
    for (int i = 1; i < length; i++) {
        if (val >= (1L << (63 - 8))) {
            throw new IllegalArgumentException(""At offset "" + offset + "", "" + length + "" byte "" + ""binary number exceeds maximum signed long value"");
        }
        val = (val << 8) + (buffer[offset + i] & 0xff);
    }
    return val;
}","public void test05252() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) (-67);
    byteArray0[1] = (byte) (-1);
    byteArray0[2] = (byte) (-55);
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 94;
    byteArray0[6] = (byte) 0;
    byteArray0[7] = (byte) (-120);
    byteArray0[8] = (byte) 89;
    TarUtils.parseOctalOrBinary(byteArray0, (byte) 0, 0);
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since Apache Commons Compress 1.4
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test05353() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byte byte0 = (byte) 56;
    byteArray0[0] = (byte) 56;
    byte byte1 = (byte) 25;
    byteArray0[1] = (byte) 25;
    byte byte2 = (byte) 17;
    byteArray0[2] = (byte) 17;
    byteArray0[3] = (byte) (-6);
    TarUtils.computeCheckSum(byteArray0);
    int int0 = 1;
    TarUtils.parseOctalOrBinary(byteArray0, 1, (byte) (-6));
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Length -6 must be at least 2
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test05454() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 49;
    byteArray0[1] = (byte) (-46);
    byteArray0[2] = (byte) (-104);
    byteArray0[3] = (byte) 0;
    byteArray0[4] = (byte) 0;
    TarUtils.parseOctal(byteArray0, 0, (byte) 49);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test05656() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 0;
    byte byte0 = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 69;
    byteArray0[3] = (byte) 49;
    byteArray0[4] = (byte) 82;
    byteArray0[5] = (byte) (-128);
    byteArray0[6] = (byte) 0;
    TarUtils.parseOctal(byteArray0, 0, 446);
    int int0 = 0;
    TarUtils.parseName(byteArray0, byte0, int0);
    TarUtils.computeCheckSum(byteArray0);
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test05757() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) (-76);
    byteArray0[1] = (byte) 68;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 52;
    TarUtils.parseName(byteArray0, (byte) 52, 733);
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static long parseOctalOrBinary(final byte[] buffer, final int offset, final int length) {
    if ((buffer[offset] & 0x80) == 0) {
        return parseOctal(buffer, offset, length);
    }
    long val = buffer[offset] & 0x7f;
    for (int i = 1; i < length; i++) {
        if (val >= (1L << (63 - 8))) {
            throw new IllegalArgumentException(""At offset "" + offset + "", "" + length + "" byte "" + ""binary number exceeds maximum signed long value"");
        }
        val = (val << 8) + (buffer[offset + i] & 0xff);
    }
    return val;
}","public void test05858() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) (-107);
    byteArray0[1] = (byte) (-97);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 22;
    byteArray0[4] = (byte) (-62);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 100;
    byteArray0[7] = (byte) (-1);
    byteArray0[8] = (byte) 3;
    TarUtils.parseOctalOrBinary(byteArray0, 0, (byte) (-97));
}","/**
 * Compute the value contained in a byte buffer.  If the most
 * significant bit of the first byte in the buffer is set, this
 * bit is ignored and the rest of the buffer is interpreted as a
 * binary number.  Otherwise, the buffer is interpreted as an
 * octal number as per the parseOctal function above.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The long value of the octal or binary string.
 * @throws IllegalArgumentException if the trailing space/NUL is
 * missing or an invalid byte is detected in an octal number, or
 * if a binary number would exceed the size of a signed long
 * 64-bit integer.
 * @since Apache Commons Compress 1.4
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test05959() throws Throwable {
    byte[] byteArray0 = new byte[0];
    TarUtils.computeCheckSum(byteArray0);
    byte[] byteArray1 = new byte[5];
    byteArray1[0] = (byte) 0;
    byteArray1[1] = (byte) 1;
    byteArray1[2] = (byte) 82;
    byteArray1[3] = (byte) (-1);
    byteArray1[4] = (byte) 0;
    TarUtils.parseBoolean(byteArray1, (-1498));
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test06060() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = (-1156);
    int int1 = 1005;
    // Undeclared exception!
    try {
        TarUtils.parseOctal((byte[]) null, (-1156), 1005);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test06161() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) (-99);
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 33;
    byteArray0[3] = (byte) 103;
    byteArray0[4] = (byte) (-23);
    TarUtils.formatUnsignedOctalString(7L, byteArray0, (-1), (byte) 33);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        byte b = buffer[i];
        if (b == 0) {
            // Trailing null
            break;
        }
        // Allow for sign-extension
        result.append((char) (b & 0xFF));
    }
    return result.toString();
}","public void test06262() throws Throwable {
    byte[] byteArray0 = new byte[0];
    int int0 = (-1);
    // Undeclared exception!
    try {
        TarUtils.parseName(byteArray0, (-1), (-1));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test06363() throws Throwable {
    byte[] byteArray0 = new byte[0];
    int int0 = 2;
    TarUtils.formatLongOctalOrBinaryBytes(650L, byteArray0, 2714, 2);
    int int1 = (-5137);
    // Undeclared exception!
    try {
        TarUtils.parseBoolean(byteArray0, int1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2714
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test06464() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) (-10);
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) (-106);
    byteArray0[4] = (byte) (-87);
    byteArray0[5] = (byte) 0;
    byteArray0[6] = (byte) 113;
    TarUtils.parseBoolean(byteArray0, 0);
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test06565() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byte byte0 = (byte) 1;
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) (-121);
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 55;
    byteArray0[4] = (byte) 86;
    byteArray0[5] = (byte) (-46);
    byteArray0[6] = (byte) (-105);
    byteArray0[7] = (byte) 90;
    byteArray0[8] = (byte) 0;
    TarUtils.parseName(byteArray0, (byte) (-46), (byte) 0);
    TarUtils.parseOctalOrBinary(byteArray0, 1, 32);
    int int0 = 2456;
    int int1 = 0;
    TarUtils.parseOctal(byteArray0, int0, int1);
    TarUtils.parseBoolean(byteArray0, byteArray0[0]);
    int int2 = 0;
    int int3 = 0;
    TarUtils.parseOctal(byteArray0, int2, int3);
    long long0 = 1994L;
    int int4 = 0;
    // Undeclared exception!
    try {
        TarUtils.formatCheckSumOctalBytes(long0, byteArray0, byteArray0[3], int4);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // At offset 1, 32 byte binary number exceeds maximum signed long value
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test06767() throws Throwable {
    long long0 = (-159L);
    byte[] byteArray0 = null;
    int int0 = 0;
    int int1 = 533;
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString((-159L), (byte[]) null, 0, 533);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test06868() throws Throwable {
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 88;
    byteArray0[2] = (byte) (-10);
    byteArray0[3] = (byte) 8;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) (-83);
    TarUtils.formatNameBytes("""", byteArray0, (byte) (-10), 2558);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static boolean parseBoolean(final byte[] buffer, final int offset) {
    return buffer[offset] == 1;
}","public void test07070() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = 2922;
    int int1 = 3355;
    TarUtils.formatNameBytes(""[+|5F@V:Eyhv?(a6"", (byte[]) null, 2922, 3355);
    // Undeclared exception!
    try {
        TarUtils.parseBoolean(byteArray0, int0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse a boolean byte from a buffer.
 * Leading spaces and NUL are ignored.
 * The buffer may contain trailing spaces or NULs.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @return The boolean value of the bytes.
 * @throws IllegalArgumentException if an invalid byte is detected.
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test07171() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 0;
    byteArray0[3] = (byte) 104;
    byteArray0[4] = (byte) 93;
    byteArray0[5] = (byte) (-72);
    byteArray0[6] = (byte) (-84);
    byteArray0[7] = (byte) 32;
    byteArray0[8] = (byte) 0;
    TarUtils.formatNameBytes("""", byteArray0, 0, 0);
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test07373() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 0;
    byte byte0 = (byte) 0;
    byteArray0[3] = (byte) 0;
    TarUtils.formatUnsignedOctalString(0L, byteArray0, (byte) 48, 3);
    long long0 = 886L;
    TarUtils.parseName(byteArray0, (-1), 3);
    TarUtils.formatUnsignedOctalString(long0, byteArray0, byteArray0[0], byte0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test07474() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = 2;
    // Undeclared exception!
    try {
        TarUtils.parseOctal((byte[]) null, 2, 2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test07575() throws Throwable {
    byte[] byteArray0 = null;
    int int0 = 630;
    int int1 = TarUtils.formatOctalBytes(722L, (byte[]) null, 630, 630);
    // Undeclared exception!
    try {
        TarUtils.formatUnsignedOctalString(int0, byteArray0, int1, int1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test07676() throws Throwable {
    byte[] byteArray0 = null;
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum((byte[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test07979() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 83;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) (-124);
    byteArray0[3] = (byte) (-17);
    byteArray0[4] = (byte) 16;
    byteArray0[5] = (byte) 2;
    byteArray0[6] = (byte) 27;
    byteArray0[7] = (byte) 122;
    TarUtils.formatLongOctalBytes((-60L), byteArray0, (-13), (byte) 16);
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // for NUL and space
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing null
    buf[offset + idx++] = 0;
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test08282() throws Throwable {
    byte[] byteArray0 = new byte[10];
    byteArray0[0] = (byte) 10;
    byteArray0[1] = (byte) 59;
    byteArray0[5] = (byte) 1;
    TarUtils.formatCheckSumOctalBytes(1294L, byteArray0, (byte) 48, (byte) 48);
}","/**
 * Writes an octal value into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by NUL and then space.
 *
 * @param value The value to convert
 * @param buf The destination buffer
 * @param offset The starting offset into the buffer.
 * @param length The size of the buffer.
 * @return The updated value of offset, i.e. offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test08383() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-109);
    byteArray0[1] = (byte) (-109);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) (-103);
    byteArray0[4] = (byte) (-103);
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) (-36);
    byteArray0[7] = (byte) 127;
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test08585() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-109);
    byteArray0[1] = (byte) (-109);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) (-103);
    byteArray0[4] = (byte) (-103);
    byteArray0[5] = (byte) 4;
    byteArray0[6] = (byte) (-36);
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test08686() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-109);
    byteArray0[1] = (byte) (-109);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) (-103);
    byteArray0[4] = (byte) (-103);
    byteArray0[7] = (byte) 4;
    byteArray0[6] = (byte) (-103);
    byteArray0[7] = (byte) 127;
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 4);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static long computeCheckSum(final byte[] buf) {
    long sum = 0;
    for (int i = 0; i < buf.length; ++i) {
        sum += BYTE_MASK & buf[i];
    }
    return sum;
}","public void test08787() throws Throwable {
    byte[] byteArray0 = null;
    TarUtils.parseName((byte[]) null, 1717986918, 1717986918);
    TarUtils.formatOctalBytes(1717986918, (byte[]) null, 1717986918, (-1));
    TarUtils.computeCheckSum(byteArray0);
    // Undeclared exception!
    try {
        TarUtils.computeCheckSum(byteArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1717986918=14631463146 will not fit in octal number buffer of length -3
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Compute the checksum of a tar entry header.
 *
 * @param buf The tar entry's header buffer.
 * @return The computed checksum.
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test08888() throws Throwable {
    byte byte0 = (byte) (-128);
    byte byte1 = (byte) 1;
    long long0 = 0L;
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 1;
    byteArray0[1] = (byte) 10;
    byteArray0[2] = (byte) (-128);
    TarUtils.parseBoolean(byteArray0, (byte) 1);
    byte[] byteArray1 = new byte[2];
    byteArray1[0] = (byte) (-128);
    byteArray1[1] = (byte) 10;
    TarUtils.parseOctalOrBinary(byteArray1, 0, (byte) (-128));
    TarUtils.formatLongOctalBytes((-521L), byteArray1, (byte) (-128), (-902));
    byte[] byteArray2 = new byte[2];
    byteArray2[0] = byte1;
    byteArray2[1] = byte0;
    int int0 = 836;
    TarUtils.formatLongOctalBytes(long0, byteArray2, byteArray1[1], int0);
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    boolean allNUL = true;
    for (int i = start; i < end; i++) {
        if (buffer[i] != 0) {
            allNUL = false;
            break;
        }
    }
    if (allNUL) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NUL or space
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
        // CheckStyle:MagicNumber ON
    }
    return result;
}","public void test08989() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 0;
    byteArray0[1] = (byte) 0;
    byteArray0[2] = (byte) 49;
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 0;
    TarUtils.parseOctal(byteArray0, 127, Integer.MAX_VALUE);
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */"
"public static int formatLongOctalOrBinaryBytes(final long value, byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    if (value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    long val = value;
    for (int i = offset + length - 1; i >= offset; i--) {
        buf[i] = (byte) val;
        val >>= 8;
    }
    if (val != 0 || (buf[offset] & 0x80) != 0) {
        throw new IllegalArgumentException(""Value "" + value + "" is too large for "" + length + "" byte field."");
    }
    buf[offset] |= 0x80;
    return offset + length;
}","public void test09090() throws Throwable {
    long long0 = (-1338L);
    byte[] byteArray0 = null;
    int int0 = 0;
    int int1 = 3523;
    // Undeclared exception!
    try {
        TarUtils.formatLongOctalOrBinaryBytes((-1338L), (byte[]) null, 0, 3523);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since Apache Commons Compress 1.4
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test09191() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) (-103);
    byteArray0[1] = (byte) (-103);
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) (-103);
    byteArray0[4] = (byte) (-103);
    byteArray0[5] = (byte) 4;
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
    long long0 = 390L;
    int int0 = 128;
    TarUtils.formatUnsignedOctalString(long0, byteArray0, int0, int0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test09292() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 126;
    byteArray0[1] = (byte) 126;
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) 126;
    byteArray0[4] = (byte) 126;
    byteArray0[5] = (byte) 4;
    TarUtils.parseOctal(byteArray0, (byte) 4, (byte) 4);
    long long0 = 390L;
    int int0 = 128;
    TarUtils.formatUnsignedOctalString(long0, byteArray0, int0, int0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test09595() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[6] = (byte) (-36);
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 4);
    TarUtils.formatNameBytes("""", byteArray0, 674, (byte) 0);
    TarUtils.formatUnsignedOctalString(414L, byteArray0, 128, 128);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test09696() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 16;
    byteArray0[1] = (byte) 100;
    byteArray0[2] = (byte) 106;
    byteArray0[3] = (byte) (-108);
    TarUtils.formatOctalBytes(0, byteArray0, 2, 3);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test09999() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byteArray0[0] = (byte) 16;
    byteArray0[1] = (byte) 100;
    byteArray0[2] = (byte) 106;
    byteArray0[3] = (byte) (-108);
    TarUtils.formatOctalBytes(0, byteArray0, 2, 3);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space and trailing null
    int idx = length - 2;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx++] = (byte) ' ';
    // Trailing null
    buf[offset + idx] = 0;
    return offset + length;
}","public void test100100() throws Throwable {
    byte[] byteArray0 = new byte[17];
    byteArray0[0] = (byte) 16;
    byteArray0[1] = (byte) 100;
    byteArray0[2] = (byte) 106;
    byteArray0[3] = (byte) (-108);
    TarUtils.formatOctalBytes(0, byteArray0, 2, 10);
}","/**
 * Write an octal integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by space and NUL
 *
 * @param value The value to write
 * @param buf The buffer to receive the output
 * @param offset The starting offset into the buffer
 * @param length The size of the output buffer
 * @return The updated offset, i.e offset+length
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {
    int i;
    // copy until end of input or output is reached.
    for (i = 0; i < length && i < name.length(); ++i) {
        buf[offset + i] = (byte) name.charAt(i);
    }
    // Pad any remaining output bytes with NUL
    for (; i < length; ++i) {
        buf[offset + i] = 0;
    }
    return offset + length;
}","public void test101101() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[0] = (byte) 32;
    byteArray0[1] = (byte) 74;
    byteArray0[3] = (byte) 32;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 58;
    byteArray0[6] = (byte) 6;
    TarUtils.computeCheckSum(byteArray0);
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 6);
    TarUtils.computeCheckSum(byteArray0);
    int int0 = 2142308988;
    int int1 = 847;
    TarUtils.parseOctalOrBinary(byteArray0, int0, int1);
    String string0 = ""`UmwD*+"";
    int int2 = (-21);
    // Undeclared exception!
    try {
        TarUtils.formatNameBytes(string0, byteArray0, int2, byteArray0[4]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid byte 58 at offset 5 in ' J{NUL} {NUL}:' len=6
        //
        verifyException(""org.apache.commons.compress.archivers.tar.TarUtils"", e);
    }
}","/**
 * Copy a name (StringBuffer) into a buffer.
 * Copies characters from the name into the buffer
 * starting at the specified offset.
 * If the buffer is longer than the name, the buffer
 * is filled with trailing NULs.
 * If the name is longer than the buffer,
 * the output is truncated.
 *
 * @param name The header name from which to copy the characters.
 * @param buf The buffer where the name is to be stored.
 * @param offset The starting offset into the buffer
 * @param length The maximum number of header bytes to copy.
 * @return The updated offset, i.e. offset + length
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test102102() throws Throwable {
    byte byte0 = (byte) 4;
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 4;
    byte byte1 = (byte) 2;
    byteArray0[1] = (byte) 2;
    byteArray0[2] = (byte) 4;
    byteArray0[3] = (byte) 4;
    byteArray0[4] = (byte) 4;
    byteArray0[5] = (byte) 4;
    TarUtils.formatLongOctalOrBinaryBytes(0, byteArray0, 48, (-46));
    TarUtils.formatNameBytes("""", byteArray0, (-2146018787), (byte) 4);
    long long0 = (-286L);
    byte[] byteArray1 = new byte[2];
    byteArray1[0] = byte0;
    byteArray1[1] = byte1;
    int int0 = (-2146896742);
    TarUtils.formatUnsignedOctalString(long0, byteArray1, byteArray0[3], int0);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
"public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {
    // For space
    int idx = length - 1;
    formatUnsignedOctalString(value, buf, offset, idx);
    // Trailing space
    buf[offset + idx] = (byte) ' ';
    return offset + length;
}","public void test104104() throws Throwable {
    byte[] byteArray0 = new byte[20];
    int int0 = 8;
    TarUtils.formatLongOctalOrBinaryBytes(36028797018963933L, byteArray0, 8, 8);
    TarUtils.formatNameBytes("""", byteArray0, 0, 3);
    TarUtils.formatLongOctalOrBinaryBytes(16, byteArray0, 8, 8);
    int int1 = TarUtils.formatLongOctalOrBinaryBytes((-3658L), byteArray0, 1396, 3);
    int int2 = 0;
    int int3 = (-620);
    TarUtils.parseOctal(byteArray0, int2, int3);
    int int4 = 2181;
    TarUtils.formatLongOctalBytes(int0, byteArray0, int4, int1);
}","/**
 * Write an octal long integer into a buffer.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write as octal
 * @param buf The destinationbuffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer
 * @return The updated offset
 * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
 */"
"public static void formatUnsignedOctalString(final long value, byte[] buffer, final int offset, final int length) {
    int remaining = length;
    remaining--;
    if (value == 0) {
        buffer[offset + remaining--] = (byte) '0';
    } else {
        long val = value;
        for (; remaining >= 0 && val != 0; --remaining) {
            // CheckStyle:MagicNumber OFF
            buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));
            val = val >>> 3;
            // CheckStyle:MagicNumber ON
        }
        if (val != 0) {
            throw new IllegalArgumentException(value + ""="" + Long.toOctalString(value) + "" will not fit in octal number buffer of length "" + length);
        }
    }
    for (; remaining >= 0; --remaining) {
        // leading zeros
        buffer[offset + remaining] = (byte) '0';
    }
}","public void test105105() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[6] = (byte) (-36);
    TarUtils.parseOctal(byteArray0, (byte) 0, (byte) 4);
    TarUtils.formatNameBytes("""", byteArray0, 674, (byte) 0);
    TarUtils.formatUnsignedOctalString(414L, byteArray0, (byte) 4, (byte) 4);
}","/**
 * Fill buffer with unsigned octal number, padded with leading zeroes.
 *
 * @param value number to convert to octal - treated as unsigned
 * @param buffer destination buffer
 * @param offset starting offset in buffer
 * @param length length of buffer to fill
 * @throws IllegalArgumentException if the value will not fit in the buffer
 */"
