focal_method,test_prefix,docstring
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test000() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    try {
        zipArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 0, 704);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.getNextZipEntry();
    assertEquals(0, zipArchiveInputStream0.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test022() throws Throwable {
    byte[] byteArray0 = new byte[35];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.getNextZipEntry();
    assertEquals(30, zipArchiveInputStream0.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"@Override
public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test033() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    boolean boolean0 = zipArchiveInputStream0.canReadEntryData((ArchiveEntry) null);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Override
public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test044() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
    boolean boolean0 = zipArchiveInputStream0.canReadEntryData(zipArchiveEntry0);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test055() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream1 = new ZipArchiveInputStream(zipArchiveInputStream0);
    zipArchiveInputStream1.getNextZipEntry();
    assertEquals(0, zipArchiveInputStream1.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test066() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    zipArchiveInputStream0.close();
    try {
        zipArchiveInputStream0.skip(16L);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // The stream is closed
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"public long getBytesRead() {
    return bytesRead;
}","public void test077() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 0, 704);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.close();
    assertEquals(0L, zipArchiveInputStream0.getBytesRead());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @since 1.1
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test088() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    // Undeclared exception!
    try {
        zipArchiveInputStream0.skip((-1167L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test099() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    long long0 = zipArchiveInputStream0.skip(0L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1010() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    long long0 = zipArchiveInputStream0.skip(117853008L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1111() throws Throwable {
    byte[] byteArray0 = new byte[2];
    boolean boolean0 = ZipArchiveInputStream.matches(byteArray0, (byte) 0);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test1212() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) 80;
    boolean boolean0 = ZipArchiveInputStream.matches(byteArray0, (byte) 80);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
