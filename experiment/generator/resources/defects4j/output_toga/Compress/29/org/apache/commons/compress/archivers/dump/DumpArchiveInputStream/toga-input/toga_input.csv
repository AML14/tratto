focal_method,test_prefix,docstring
"// the provided encoding (for unit tests)
/**
 * Constructor using the platform's default encoding for file
 * names.
 *
 * @param is
 * @throws ArchiveException
 */
public DumpArchiveInputStream(InputStream is) throws ArchiveException {
    this(is, null);
}","public void test00() throws Throwable {
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    DumpArchiveInputStream dumpArchiveInputStream0 = null;
    try {
        dumpArchiveInputStream0 = new DumpArchiveInputStream(sequenceInputStream0);
        fail(""Expecting exception: Exception"");
    } catch (Throwable e) {
        //
        // unexpected EOF
        //
        verifyException(""org.apache.commons.compress.archivers.dump.DumpArchiveInputStream"", e);
    }
}",""
"public static boolean matches(byte[] buffer, int length) {
    // do we have enough of the header?
    if (length < 32) {
        return false;
    }
    // this is the best test
    if (length >= DumpArchiveConstants.TP_SIZE) {
        return DumpArchiveUtil.verify(buffer);
    }
    // this will work in a pinch.
    return DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer, 24);
}","public void test11() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        DumpArchiveInputStream.matches(byteArray0, 41);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 27
        //
        verifyException(""org.apache.commons.compress.archivers.dump.DumpArchiveUtil"", e);
    }
}","/**
 * Look at the first few bytes of the file to decide if it's a dump
 * archive. With 32 bytes we can look at the magic value, with a full
 * 1k we can verify the checksum.
 */"
"public static boolean matches(byte[] buffer, int length) {
    // do we have enough of the header?
    if (length < 32) {
        return false;
    }
    // this is the best test
    if (length >= DumpArchiveConstants.TP_SIZE) {
        return DumpArchiveUtil.verify(buffer);
    }
    // this will work in a pinch.
    return DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer, 24);
}","public void test22() throws Throwable {
    byte[] byteArray0 = new byte[6];
    boolean boolean0 = DumpArchiveInputStream.matches(byteArray0, (-242));
    assertFalse(boolean0);
}","/**
 * Look at the first few bytes of the file to decide if it's a dump
 * archive. With 32 bytes we can look at the magic value, with a full
 * 1k we can verify the checksum.
 */"
"public static boolean matches(byte[] buffer, int length) {
    // do we have enough of the header?
    if (length < 32) {
        return false;
    }
    // this is the best test
    if (length >= DumpArchiveConstants.TP_SIZE) {
        return DumpArchiveUtil.verify(buffer);
    }
    // this will work in a pinch.
    return DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer, 24);
}","public void test33() throws Throwable {
    // Undeclared exception!
    try {
        DumpArchiveInputStream.matches((byte[]) null, 9576);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.dump.DumpArchiveUtil"", e);
    }
}","/**
 * Look at the first few bytes of the file to decide if it's a dump
 * archive. With 32 bytes we can look at the magic value, with a full
 * 1k we can verify the checksum.
 */"
