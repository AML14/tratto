focal_method,test_prefix,docstring
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test000() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null, ""w"");
    assertEquals(0, cpioArchiveInputStream0.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"public CpioArchiveEntry getNextCPIOEntry() throws IOException {
    ensureOpen();
    if (this.entry != null) {
        closeEntry();
    }
    readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);
    if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(false);
    } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(true);
    } else {
        System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length);
        readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length);
        String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);
        if (magicString.equals(MAGIC_NEW)) {
            this.entry = readNewEntry(false);
        } else if (magicString.equals(MAGIC_NEW_CRC)) {
            this.entry = readNewEntry(true);
        } else if (magicString.equals(MAGIC_OLD_ASCII)) {
            this.entry = readOldAsciiEntry();
        } else {
            throw new IOException(""Unknown magic ["" + magicString + ""]. Occured at byte: "" + getBytesRead());
        }
    }
    this.entryBytesRead = 0;
    this.entryEOF = false;
    this.crc = 0;
    if (this.entry.getName().equals(CPIO_TRAILER)) {
        this.entryEOF = true;
        skipRemainderOfLastBlock();
        return null;
    }
    return this.entry;
}","public void test011() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream(byteArrayInputStream0);
    cpioArchiveInputStream0.close();
    try {
        cpioArchiveInputStream0.getNextCPIOEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads the next CPIO file entry and positions stream at the beginning of
 * the entry data.
 *
 * @return the CPIOArchiveEntry just read
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public long getBytesRead() {
    return bytesRead;
}","public void test022() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 0, 1364);
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream(sequenceInputStream0, 1439);
    cpioArchiveInputStream0.close();
    cpioArchiveInputStream0.close();
    assertEquals(0L, cpioArchiveInputStream0.getBytesRead());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @since 1.1
 */"
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextCPIOEntry();
}","public void test033() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.utils.IOUtils"", e);
    }
}",""
"@Override
public int available() throws IOException {
    ensureOpen();
    if (this.entryEOF) {
        return 0;
    }
    return 1;
}","public void test044() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null, 1089);
    int int0 = cpioArchiveInputStream0.available();
    assertEquals(1, int0);
}","/**
 * Returns 0 after EOF has reached for the current entry data, otherwise
 * always return 1.
 * <p>
 * Programs should not count on this method to return the actual number of
 * bytes that could be read without blocking.
 *
 * @return 1 before EOF and 0 after EOF has reached for current entry.
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"@Override
public long skip(final long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""negative skip length"");
    }
    ensureOpen();
    int max = (int) Math.min(n, Integer.MAX_VALUE);
    int total = 0;
    while (total < max) {
        int len = max - total;
        if (len > this.tmpbuf.length) {
            len = this.tmpbuf.length;
        }
        len = read(this.tmpbuf, 0, len);
        if (len == -1) {
            this.entryEOF = true;
            break;
        }
        total += len;
    }
    return total;
}","public void test055() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    long long0 = cpioArchiveInputStream0.skip(134630224L);
    assertEquals(0L, long0);
}","/**
 * Skips specified number of bytes in the current CPIO entry.
 *
 * @param n
 *            the number of bytes to skip
 * @return the actual number of bytes skipped
 * @throws IOException
 *             if an I/O error has occurred
 * @throws IllegalArgumentException
 *             if n &lt; 0
 */"
"@Override
public int available() throws IOException {
    ensureOpen();
    if (this.entryEOF) {
        return 0;
    }
    return 1;
}","public void test056() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    long long0 = cpioArchiveInputStream0.skip(134630224L);
    int int0 = cpioArchiveInputStream0.available();
    assertEquals(0, int0);
}","/**
 * Returns 0 after EOF has reached for the current entry data, otherwise
 * always return 1.
 * <p>
 * Programs should not count on this method to return the actual number of
 * bytes that could be read without blocking.
 *
 * @return 1 before EOF and 0 after EOF has reached for current entry.
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public CpioArchiveEntry getNextCPIOEntry() throws IOException {
    ensureOpen();
    if (this.entry != null) {
        closeEntry();
    }
    readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);
    if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(false);
    } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(true);
    } else {
        System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length);
        readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length);
        String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);
        if (magicString.equals(MAGIC_NEW)) {
            this.entry = readNewEntry(false);
        } else if (magicString.equals(MAGIC_NEW_CRC)) {
            this.entry = readNewEntry(true);
        } else if (magicString.equals(MAGIC_OLD_ASCII)) {
            this.entry = readOldAsciiEntry();
        } else {
            throw new IOException(""Unknown magic ["" + magicString + ""]. Occured at byte: "" + getBytesRead());
        }
    }
    this.entryBytesRead = 0;
    this.entryEOF = false;
    this.crc = 0;
    if (this.entry.getName().equals(CPIO_TRAILER)) {
        this.entryEOF = true;
        skipRemainderOfLastBlock();
        return null;
    }
    return this.entry;
}","public void test067() throws Throwable {
    byte[] byteArray0 = new byte[9];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream(byteArrayInputStream0);
    try {
        cpioArchiveInputStream0.getNextCPIOEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unknown magic [\u0000\u0000\u0000\u0000\u0000\u0000]. Occured at byte: 6
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads the next CPIO file entry and positions stream at the beginning of
 * the entry data.
 *
 * @return the CPIOArchiveEntry just read
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"@Override
public int read(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    if (this.entry == null || this.entryEOF) {
        return -1;
    }
    if (this.entryBytesRead == this.entry.getSize()) {
        skip(entry.getDataPadCount());
        this.entryEOF = true;
        if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error. Occured at byte: "" + getBytesRead());
        }
        // EOF for this entry
        return -1;
    }
    int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);
    if (tmplength < 0) {
        return -1;
    }
    int tmpread = readFully(b, off, tmplength);
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < tmpread; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
    this.entryBytesRead += tmpread;
    return tmpread;
}","public void test078() throws Throwable {
    byte[] byteArray0 = new byte[2];
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveInputStream0.read(byteArray0, (-1), 666);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads from the current CPIO entry into an array of bytes. Blocks until
 * some input is available.
 *
 * @param b
 *            the buffer into which the data is read
 * @param off
 *            the start offset of the data
 * @param len
 *            the maximum number of bytes read
 * @return the actual number of bytes read, or -1 if the end of the entry is
 *         reached
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"@Override
public int read(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    if (this.entry == null || this.entryEOF) {
        return -1;
    }
    if (this.entryBytesRead == this.entry.getSize()) {
        skip(entry.getDataPadCount());
        this.entryEOF = true;
        if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error. Occured at byte: "" + getBytesRead());
        }
        // EOF for this entry
        return -1;
    }
    int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);
    if (tmplength < 0) {
        return -1;
    }
    int tmpread = readFully(b, off, tmplength);
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < tmpread; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
    this.entryBytesRead += tmpread;
    return tmpread;
}","public void test089() throws Throwable {
    byte[] byteArray0 = new byte[2];
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null, (byte) 50);
    // Undeclared exception!
    try {
        cpioArchiveInputStream0.read(byteArray0, (int) (byte) 50, (-642));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads from the current CPIO entry into an array of bytes. Blocks until
 * some input is available.
 *
 * @param b
 *            the buffer into which the data is read
 * @param off
 *            the start offset of the data
 * @param len
 *            the maximum number of bytes read
 * @return the actual number of bytes read, or -1 if the end of the entry is
 *         reached
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"@Override
public int read(final byte[] b, final int off, final int len) throws IOException {
    ensureOpen();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    if (this.entry == null || this.entryEOF) {
        return -1;
    }
    if (this.entryBytesRead == this.entry.getSize()) {
        skip(entry.getDataPadCount());
        this.entryEOF = true;
        if (this.entry.getFormat() == FORMAT_NEW_CRC && this.crc != this.entry.getChksum()) {
            throw new IOException(""CRC Error. Occured at byte: "" + getBytesRead());
        }
        // EOF for this entry
        return -1;
    }
    int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);
    if (tmplength < 0) {
        return -1;
    }
    int tmpread = readFully(b, off, tmplength);
    if (this.entry.getFormat() == FORMAT_NEW_CRC) {
        for (int pos = 0; pos < tmpread; pos++) {
            this.crc += b[pos] & 0xFF;
        }
    }
    this.entryBytesRead += tmpread;
    return tmpread;
}","public void test0910() throws Throwable {
    byte[] byteArray0 = new byte[2];
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveInputStream0.read(byteArray0, 4091, 4091);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads from the current CPIO entry into an array of bytes. Blocks until
 * some input is available.
 *
 * @param b
 *            the buffer into which the data is read
 * @param off
 *            the start offset of the data
 * @param len
 *            the maximum number of bytes read
 * @return the actual number of bytes read, or -1 if the end of the entry is
 *         reached
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"public CpioArchiveEntry getNextCPIOEntry() throws IOException {
    ensureOpen();
    if (this.entry != null) {
        closeEntry();
    }
    readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);
    if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(false);
    } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true) == MAGIC_OLD_BINARY) {
        this.entry = readOldBinaryEntry(true);
    } else {
        System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0, TWO_BYTES_BUF.length);
        readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length, FOUR_BYTES_BUF.length);
        String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);
        if (magicString.equals(MAGIC_NEW)) {
            this.entry = readNewEntry(false);
        } else if (magicString.equals(MAGIC_NEW_CRC)) {
            this.entry = readNewEntry(true);
        } else if (magicString.equals(MAGIC_OLD_ASCII)) {
            this.entry = readOldAsciiEntry();
        } else {
            throw new IOException(""Unknown magic ["" + magicString + ""]. Occured at byte: "" + getBytesRead());
        }
    }
    this.entryBytesRead = 0;
    this.entryEOF = false;
    this.crc = 0;
    if (this.entry.getName().equals(CPIO_TRAILER)) {
        this.entryEOF = true;
        skipRemainderOfLastBlock();
        return null;
    }
    return this.entry;
}","public void test1112() throws Throwable {
    byte[] byteArray0 = new byte[2];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream(byteArrayInputStream0);
    try {
        cpioArchiveInputStream0.getNextCPIOEntry();
        fail(""Expecting exception: EOFException"");
    } catch (EOFException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Reads the next CPIO file entry and positions stream at the beginning of
 * the entry data.
 *
 * @return the CPIOArchiveEntry just read
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */"
"@Override
public long skip(final long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""negative skip length"");
    }
    ensureOpen();
    int max = (int) Math.min(n, Integer.MAX_VALUE);
    int total = 0;
    while (total < max) {
        int len = max - total;
        if (len > this.tmpbuf.length) {
            len = this.tmpbuf.length;
        }
        len = read(this.tmpbuf, 0, len);
        if (len == -1) {
            this.entryEOF = true;
            break;
        }
        total += len;
    }
    return total;
}","public void test1213() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    // Undeclared exception!
    try {
        cpioArchiveInputStream0.skip((-3453L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // negative skip length
        //
        verifyException(""org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"", e);
    }
}","/**
 * Skips specified number of bytes in the current CPIO entry.
 *
 * @param n
 *            the number of bytes to skip
 * @return the actual number of bytes skipped
 * @throws IOException
 *             if an I/O error has occurred
 * @throws IllegalArgumentException
 *             if n &lt; 0
 */"
"@Override
public long skip(final long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""negative skip length"");
    }
    ensureOpen();
    int max = (int) Math.min(n, Integer.MAX_VALUE);
    int total = 0;
    while (total < max) {
        int len = max - total;
        if (len > this.tmpbuf.length) {
            len = this.tmpbuf.length;
        }
        len = read(this.tmpbuf, 0, len);
        if (len == -1) {
            this.entryEOF = true;
            break;
        }
        total += len;
    }
    return total;
}","public void test1314() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null);
    long long0 = cpioArchiveInputStream0.skip(0L);
    assertEquals(0L, long0);
}","/**
 * Skips specified number of bytes in the current CPIO entry.
 *
 * @param n
 *            the number of bytes to skip
 * @return the actual number of bytes skipped
 * @throws IOException
 *             if an I/O error has occurred
 * @throws IllegalArgumentException
 *             if n &lt; 0
 */"
"@Override
public long skip(final long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""negative skip length"");
    }
    ensureOpen();
    int max = (int) Math.min(n, Integer.MAX_VALUE);
    int total = 0;
    while (total < max) {
        int len = max - total;
        if (len > this.tmpbuf.length) {
            len = this.tmpbuf.length;
        }
        len = read(this.tmpbuf, 0, len);
        if (len == -1) {
            this.entryEOF = true;
            break;
        }
        total += len;
    }
    return total;
}","public void test1415() throws Throwable {
    CpioArchiveInputStream cpioArchiveInputStream0 = new CpioArchiveInputStream((InputStream) null, (byte) 50);
    long long0 = cpioArchiveInputStream0.skip(3776L);
    assertEquals(0L, long0);
}","/**
 * Skips specified number of bytes in the current CPIO entry.
 *
 * @param n
 *            the number of bytes to skip
 * @return the actual number of bytes skipped
 * @throws IOException
 *             if an I/O error has occurred
 * @throws IllegalArgumentException
 *             if n &lt; 0
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < 6) {
        return false;
    }
    // Check binary values
    if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {
        return true;
    }
    if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {
        return true;
    }
    // Check Ascii (String) values
    // 3037 3037 30nn
    if (signature[0] != 0x30) {
        return false;
    }
    if (signature[1] != 0x37) {
        return false;
    }
    if (signature[2] != 0x30) {
        return false;
    }
    if (signature[3] != 0x37) {
        return false;
    }
    if (signature[4] != 0x30) {
        return false;
    }
    // Check last byte
    if (signature[5] == 0x31) {
        return true;
    }
    if (signature[5] == 0x32) {
        return true;
    }
    if (signature[5] == 0x37) {
        return true;
    }
    return false;
}","public void test1516() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[0] = (byte) 113;
    CpioArchiveInputStream.matches(byteArray0, (byte) 113);
}","/**
 * Checks if the signature matches one of the following magic values:
 *
 * Strings:
 *
 * ""070701"" - MAGIC_NEW
 * ""070702"" - MAGIC_NEW_CRC
 * ""070707"" - MAGIC_OLD_ASCII
 *
 * Octal Binary value:
 *
 * 070707 - MAGIC_OLD_BINARY (held as a short) = 0x71C7 or 0xC771
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < 6) {
        return false;
    }
    // Check binary values
    if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {
        return true;
    }
    if (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {
        return true;
    }
    // Check Ascii (String) values
    // 3037 3037 30nn
    if (signature[0] != 0x30) {
        return false;
    }
    if (signature[1] != 0x37) {
        return false;
    }
    if (signature[2] != 0x30) {
        return false;
    }
    if (signature[3] != 0x37) {
        return false;
    }
    if (signature[4] != 0x30) {
        return false;
    }
    // Check last byte
    if (signature[5] == 0x31) {
        return true;
    }
    if (signature[5] == 0x32) {
        return true;
    }
    if (signature[5] == 0x37) {
        return true;
    }
    return false;
}","public void test1617() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[1] = (byte) 113;
    CpioArchiveInputStream.matches(byteArray0, 204);
}","/**
 * Checks if the signature matches one of the following magic values:
 *
 * Strings:
 *
 * ""070701"" - MAGIC_NEW
 * ""070702"" - MAGIC_NEW_CRC
 * ""070707"" - MAGIC_OLD_ASCII
 *
 * Octal Binary value:
 *
 * 070707 - MAGIC_OLD_BINARY (held as a short) = 0x71C7 or 0xC771
 */"
