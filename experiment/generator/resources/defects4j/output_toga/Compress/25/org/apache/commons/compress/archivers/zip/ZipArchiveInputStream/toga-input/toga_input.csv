focal_method,test_prefix,docstring
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test000() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byteArray0[0] = (byte) 119;
    boolean boolean0 = ZipArchiveInputStream.matches(byteArray0, (byte) 119);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public long getBytesRead() {
    return bytesRead;
}","public void test012() throws Throwable {
    byte[] byteArray0 = new byte[6];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte) 0, (byte) 98);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, ""DIRECTORY"", true, true);
    zipArchiveInputStream0.getNextEntry();
    assertEquals(6L, zipArchiveInputStream0.getBytesRead());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @since 1.1
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test023() throws Throwable {
    // Undeclared exception!
    try {
        ZipArchiveInputStream.matches((byte[]) null, 26);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }
    try {
        if (firstEntry) {
            // split archives have a special signature before the
            // first local file header - look for it and fail with
            // the appropriate error message if this is a split
            // archive.
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (EOFException e) {
        return null;
    }
    ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        return null;
    }
    int off = WORD;
    current = new CurrentEntry();
    int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);
    off += SHORT;
    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;
    long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;
    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;
        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;
        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }
    int fileNameLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);
    byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);
    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }
    processZip64Extra(size, cSize);
    if (current.entry.getCompressedSize() != -1) {
        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }
    entriesRead++;
    return current.entry;
}","public void test034() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    try {
        zipArchiveInputStream0.getNextZipEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}",""
"public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {
    this(inputStream, encoding, useUnicodeExtraFields, false);
}","public void test045() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, ""nQNy!G[`/^,`EY"", false);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // nQNy!G[`/^,`EY
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @param useUnicodeExtraFields whether to use InfoZIP Unicode
 * Extra Fields (if present) to set the file names.
 */"
"public ZipArchiveInputStream(InputStream inputStream, String encoding) {
    this(inputStream, encoding, true);
}","public void test056() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, ""TgUR0lt5}4zQ$$O'="");
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        // TgUR0lt5}4zQ$$O'=
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @since 1.5
 */"
"public long getBytesRead() {
    return bytesRead;
}","public void test067() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream(611);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, (String) null, false);
    assertEquals(0L, zipArchiveInputStream0.getBytesRead());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @since 1.1
 */"
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test079() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.getNextZipEntry();
    assertEquals(5, zipArchiveInputStream0.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test0810() throws Throwable {
    byte[] byteArray0 = new byte[5];
    boolean boolean0 = ZipArchiveInputStream.matches(byteArray0, (byte) 1);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length) {
        return false;
    }
    return // normal file
    checksig(signature, ZipArchiveOutputStream.LFH_SIG) || // empty zip
    checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || // split zip
    checksig(signature, ZipArchiveOutputStream.DD_SIG) || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
}","public void test0911() throws Throwable {
    byte[] byteArray0 = new byte[5];
    boolean boolean0 = ZipArchiveInputStream.matches(byteArray0, 214);
    assertFalse(boolean0);
}","/**
 * Checks if the signature matches what is expected for a zip file.
 * Does not currently handle self-extracting zips which may have arbitrary
 * leading content.
 *
 * @param signature the bytes to check
 * @param length    the number of bytes to check
 * @return true, if this stream is a zip archive stream, false otherwise
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1012() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(dataInputStream0);
    long long0 = zipArchiveInputStream0.skip(1393L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1113() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null);
    long long0 = zipArchiveInputStream0.skip(0L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1214() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0, 1301);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(bufferedInputStream0, (String) null, false, false);
    // Undeclared exception!
    try {
        zipArchiveInputStream0.skip((-1L));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"", e);
    }
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public long skip(long value) throws IOException {
    if (value >= 0) {
        long skipped = 0;
        while (skipped < value) {
            long rem = value - skipped;
            int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));
            if (x == -1) {
                return skipped;
            }
            skipped += x;
        }
        return skipped;
    }
    throw new IllegalArgumentException();
}","public void test1315() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    long long0 = zipArchiveInputStream0.skip(541L);
    assertEquals(0L, long0);
}","/**
 * Skips over and discards value bytes of data from this input
 * stream.
 *
 * <p>This implementation may end up skipping over some smaller
 * number of bytes, possibly 0, if and only if it reaches the end
 * of the underlying stream.</p>
 *
 * <p>The actual number of bytes skipped is returned.</p>
 *
 * @param value the number of bytes to be skipped.
 * @return the actual number of bytes skipped.
 * @throws IOException - if an I/O error occurs.
 * @throws IllegalArgumentException - if value is negative.
 */"
"@Override
public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test1416() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(dataInputStream0);
    ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();
    boolean boolean0 = zipArchiveInputStream0.canReadEntryData(zipArchiveEntry0);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Override
public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","public void test1517() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    DataInputStream dataInputStream0 = new DataInputStream(pipedInputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(dataInputStream0);
    File file0 = MockFile.createTempFile(""]9T7 "", ""org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry"");
    TarArchiveEntry tarArchiveEntry0 = new TarArchiveEntry(file0, ""L<X"");
    boolean boolean0 = zipArchiveInputStream0.canReadEntryData(tarArchiveEntry0);
    assertFalse(boolean0);
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */"
"@Deprecated
public int getCount() {
    return (int) bytesRead;
}","public void test1618() throws Throwable {
    byte[] byteArray0 = new byte[5];
    ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);
    zipArchiveInputStream0.close();
    zipArchiveInputStream0.getNextZipEntry();
    assertEquals(0, zipArchiveInputStream0.getCount());
}","/**
 * Returns the current number of bytes read from this stream.
 * @return the number of read bytes
 * @deprecated this method may yield wrong results for large
 * archives, use #getBytesRead instead
 */"
"@Override
public int read(byte[] buffer, int offset, int length) throws IOException {
    if (closed) {
        throw new IOException(""The stream is closed"");
    }
    if (current == null) {
        return -1;
    }
    // avoid int overflow, check null buffer
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    ZipUtil.checkRequestedFeatures(current.entry);
    if (!supportsDataDescriptorFor(current.entry)) {
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
    }
    int read;
    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
        read = readStored(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
        read = readDeflated(buffer, offset, length);
    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
        read = current.in.read(buffer, offset, length);
    } else {
        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
    }
    if (read >= 0) {
        current.crc.update(buffer, offset, read);
    }
    return read;
}","public void test1719() throws Throwable {
    PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
    PipedInputStream pipedInputStream0 = new PipedInputStream(pipedOutputStream0);
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0);
    int int0 = zipArchiveInputStream0.read((byte[]) null, 26, 3301);
    assertEquals((-1), int0);
}",""
"@Override
public ArchiveEntry getNextEntry() throws IOException {
    return getNextZipEntry();
}","public void test1820() throws Throwable {
    ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream((InputStream) null, (String) null);
    try {
        zipArchiveInputStream0.getNextEntry();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.PushbackInputStream"", e);
    }
}",""
"public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {
    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    in = new PushbackInputStream(inputStream, buf.capacity());
    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;
    // haven't read anything so far
}","public void test1921() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    ZipArchiveInputStream zipArchiveInputStream0 = null;
    try {
        zipArchiveInputStream0 = new ZipArchiveInputStream(pipedInputStream0, """", true, true);
        fail(""Expecting exception: IllegalCharsetNameException"");
    } catch (IllegalCharsetNameException e) {
        //
        //
        //
        verifyException(""java.nio.charset.Charset"", e);
    }
}","/**
 * @param encoding the encoding to use for file names, use null
 * for the platform's default encoding
 * @param useUnicodeExtraFields whether to use InfoZIP Unicode
 * Extra Fields (if present) to set the file names.
 * @param allowStoredEntriesWithDataDescriptor whether the stream
 * will try to read STORED entries that use a data descriptor
 * @since 1.1
 */"
