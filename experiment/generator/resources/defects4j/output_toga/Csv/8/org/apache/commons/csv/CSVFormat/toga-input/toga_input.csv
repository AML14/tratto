focal_method,test_prefix,docstring
"void validate() throws IllegalStateException {
    if (quoteChar != null && delimiter == quoteChar.charValue()) {
        throw new IllegalStateException(""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
    }
    if (escape != null && delimiter == escape.charValue()) {
        throw new IllegalStateException(""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
    }
    if (commentStart != null && delimiter == commentStart.charValue()) {
        throw new IllegalStateException(""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
    }
    if (quoteChar != null && quoteChar.equals(commentStart)) {
        throw new IllegalStateException(""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape != null && escape.equals(commentStart)) {
        throw new IllegalStateException(""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape == null && quotePolicy == Quote.NONE) {
        throw new IllegalStateException(""No quotes mode set but no escape character is set"");
    }
    if (header != null) {
        final Set<String> set = new HashSet<String>(header.length);
        set.addAll(Arrays.asList(header));
        if (set.size() != header.length) {
            throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
        }
    }
}","public void test0000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    try {
        cSVFormat1.validate();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('\""')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.
 *
 * @throws IllegalStateException
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test0011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test0012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test0013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public Character getEscape() {
    return escape;
}","public void test0015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertEquals('5', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test0016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test0017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertEquals(':', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test0018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertTrue(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test0019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter(':');
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test00210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.equals((Object) cSVFormat1));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test00214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('y', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('y');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    cSVFormat0.MYSQL.validate();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getNullString() {
    return nullString;
}","public void test00421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals(""file"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertTrue(cSVFormat3.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertFalse(cSVFormat3.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test00533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertEquals("""", cSVFormat3.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertEquals('\t', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertEquals(""C<!Ss"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test00536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('`');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""C<!Ss"");
    assertEquals('`', (char) cSVFormat3.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test00637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test00643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test00646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals('C', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test00752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00855() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test00856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertEquals(""@"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withRecordSeparator('@');
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00963() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test00964() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00965() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertEquals(""h"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test00967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test00968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('h');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test01071() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertFalse(cSVFormat4.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test01073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertFalse(cSVFormat4.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertFalse(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test01077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertTrue(cSVFormat4.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test01078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertEquals('c', (char) cSVFormat4.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test01080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    assertTrue(cSVFormat4.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test01183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test01184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test01187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test01289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test01290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test01292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Quote quote0 = Quote.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar((Character) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar((Character) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar((Character) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar((Character) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test01399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar((Character) null);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test014100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getNullString() {
    return nullString;
}","public void test014101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertEquals(""Y!6-apl"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test014102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test014103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test014104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test014105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test014106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test014107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Y!6-apl"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test015108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertFalse(cSVFormat3.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test015109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test015110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test015111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test015112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test015113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertFalse(cSVFormat3.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test015114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test015115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('c');
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteChar(character0);
    assertTrue(cSVFormat3.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test016116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test016117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test016118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test016119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test016120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getNullString() {
    return nullString;
}","public void test016121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertEquals(""F0%>FX7T#"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test016122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test016123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertEquals('L', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test016124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString(""F0%>FX7T#"");
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('L');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test017125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test017126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test017127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertTrue(cSVFormat3.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test017128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertEquals(""C"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test017129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean isNullHandling() {
    return nullString != null;
}","public void test017130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test017131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test017132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test017133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertTrue(cSVFormat3.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test017134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertEquals('C', (char) cSVFormat3.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test017135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertEquals('[', (char) cSVFormat3.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test017136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('C');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('[');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('C');
    assertFalse(cSVFormat3.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test018137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test018138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test018139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test018140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test018141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test018142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test018143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test018144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar('4');
    assertEquals('4', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test019145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString((String) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test020146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test020147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test020148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test020149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test020150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test020151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test020152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(""JTw[q9vDLA7X}"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test020153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertEquals('c', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test020154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test020155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test021156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test021157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test021158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test021159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertEquals(""JTw[q9vDLA7X}"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test021160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test021161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test021162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test021163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test021164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test021165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""JTw[q9vDLA7X}"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test022166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test022167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(""\r\n"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test022168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat3.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test022169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test022170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test022171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test022172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertFalse(cSVFormat3.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getNullString() {
    return nullString;
}","public void test022173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertEquals(""JTw[q9vDLA7X}"", cSVFormat3.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test022174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""JTw[q9vDLA7X}"");
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test023175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test024178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat3.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test024179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test024182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test024183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat3.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test024184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertEquals('c', (char) cSVFormat3.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test024185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test024186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('c');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat3.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test025187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test025188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test025189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test025190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test025191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test025192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test025193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test025194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test025195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test026197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test026198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test026199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test026200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test026201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test026202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test026203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test026204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test026205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test027206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test027207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test027208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test027209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test027210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test027211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test027212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test027213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test028214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertEquals(""e"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test028215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertTrue(cSVFormat4.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test028216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test028217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test028218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertFalse(cSVFormat4.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test028219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test028220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertFalse(cSVFormat4.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test028221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test028222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('e');
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(stringArray0);
    assertFalse(cSVFormat3.equals((Object) cSVFormat1));
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test029223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test029224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test029225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test029226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test029227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test029228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test029229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withHeader(stringArray0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test030230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test030231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test030232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""The header contains duplicate names: "", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test030233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test030234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test030235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscape() {
    return escape;
}","public void test030236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('!', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test030237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test030238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""The header contains duplicate names: "");
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test031239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test031240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test031241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertEquals('!', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test031242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test031243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test031244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test031245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test031246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape((Character) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test032247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test032248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test032249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getEscape() {
    return escape;
}","public void test032250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\'', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test032251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test032252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test032253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test032254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('\'');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test033255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public Character getEscape() {
    return escape;
}","public void test033256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('2', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test033257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test033258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test033259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test033260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test033261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test033262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getNullString() {
    return nullString;
}","public void test033263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test034264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test034265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('2', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test034266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test034267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test034268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test034269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test034270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertTrue(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test034271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public Character getEscape() {
    return escape;
}","public void test034272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('2');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('2', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test035273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test035274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test035275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test035276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test035277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test035278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test035279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public Character getEscape() {
    return escape;
}","public void test035280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('2');
    assertEquals('2', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test036281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test036282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertEquals('h', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getEscape() {
    return escape;
}","public void test036283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertEquals('q', (char) cSVFormat2.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test036285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test036286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test036287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test036288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('q');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test037289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertEquals('Q', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test037290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test037291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test037292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test037293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test037294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test037295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test037296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertEquals('\""', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test037297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('\""');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('Q');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test038298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test038299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test038300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test038301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test038302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test038303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertEquals('o', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test038304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('o');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test039305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test039306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test039307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test039308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test039309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test039310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test039311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('e');
    assertEquals('e', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test040312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test040313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test040314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertEquals(""file"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test040315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test040316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test040317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test040318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test040319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test040320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""file"");
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test041321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isEscaping() {
    return escape != null;
}","public void test042322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test042323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test042324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test042325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test042326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test042327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test042328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test042329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test043330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test043331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test043332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test043333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test043334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test043335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test043336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test043337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('<');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test044338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test044339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test044340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test044341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertEquals('4', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test044342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test044343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test044344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test044345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test044346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('4');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test045347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test045348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test045349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test045350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test045351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertEquals('h', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test045352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test045353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test045354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test045355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertTrue(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test045356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuoteChar('h');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart('h');
    assertEquals('h', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test046357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test046358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test046359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test046360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test046361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current line number
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test046362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test046363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test046364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test046365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    StringReader stringReader0 = new StringReader(""R&Q"");
    CSVParser cSVParser0 = cSVFormat2.parse(stringReader0);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test047366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test047367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test047368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test047369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test047370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test047371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test047372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('e');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertEquals('e', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test048373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(':');
    cSVFormat0.getRecordSeparator();
    assertEquals(':', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test048374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(':');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test048375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(':');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test048376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(':');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test049377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test049378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test049379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test049380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test049381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertNotNull(string0);
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test049382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test049383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test049384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test050385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test050386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test050387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test050388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test050389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test050390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test050391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.getQuotePolicy();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test051392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = cSVFormat0.getQuoteChar();
    assertNull(character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test052393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test052394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test052395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test052396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test052397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test052398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test052399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""f)ob"", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test052400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""f)ob"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test053401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test053402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test053403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test053404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test053405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test053406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public String getNullString() {
    return nullString;
}","public void test053407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals("""", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test053408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test054409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertTrue(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test055410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertTrue(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test055411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test055412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test055413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test055414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test055415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test055416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test055417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat1.getIgnoreEmptyLines();
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test056418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test056419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test056420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test056421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test056422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test056423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test056424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test057426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test057427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test057428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test057429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertEquals('\""', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test057430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getEscape() {
    return escape;
}","public void test057431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertEquals('c', (char) character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test057432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('c');
    Character character0 = cSVFormat1.getEscape();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test058433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test058434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test058435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('1', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test058436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test059437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('r');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test059438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('r');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('r', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test059439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('r');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test059440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('r');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test060441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test060442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test060443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test060444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test060445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertNotNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test060446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test060447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test060449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('s');
    Character character0 = cSVFormat1.getCommentStart();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test061450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    // Undeclared exception!
    try {
        cSVFormat0.RFC4180.parse((Reader) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test062451() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    // Undeclared exception!
    try {
        cSVFormat0.format((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test063452() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isQuoting();
    assertTrue(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test064453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isQuoting();
    assertFalse(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test065454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\u2029"");
    boolean boolean0 = cSVFormat1.isNullHandling();
    assertTrue(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test065455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\u2029"");
    boolean boolean0 = cSVFormat1.isNullHandling();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test065456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\u2029"");
    boolean boolean0 = cSVFormat1.isNullHandling();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test065457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\u2029"");
    boolean boolean0 = cSVFormat1.isNullHandling();
    assertEquals('x', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test065458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\u2029"");
    boolean boolean0 = cSVFormat1.isNullHandling();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test066459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isNullHandling();
    assertFalse(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test067460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isEscaping();
    assertTrue(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test068461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isEscaping();
    assertFalse(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test069462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isCommentingEnabled();
    assertFalse(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test070463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test070464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test070465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertEquals('*', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test070466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test070467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test070468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test070469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test070470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test070471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentStart('*');
    boolean boolean0 = cSVFormat1.isCommentingEnabled();
    assertTrue(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test071472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = cSVFormat0.getHeader();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test072473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertFalse(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public Quote getQuotePolicy() {
    return quotePolicy;
}","public void test073474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    cSVFormat0.getQuotePolicy();
}","/**
 * Returns the quote policy output fields.
 *
 * @return the quote policy
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test074475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getQuoteChar();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test075476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getNullString();
    assertNull(string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test076477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getCommentStart();
    assertNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test077478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test078479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getRecordSeparator();
    assertEquals(""\r\n"", string0);
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public Character getEscape() {
    return escape;
}","public void test079480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = cSVFormat0.getEscape();
    assertNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test080481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('\t', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public CSVFormat withCommentStart(final char commentStart) {
    return withCommentStart(Character.valueOf(commentStart));
}","public void test081482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    // Undeclared exception!
    try {
        cSVFormat0.withCommentStart('\r');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character cannot be a line break
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the comment start marker of the format to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentStart
 *            the comment start marker
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test082483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    StringReader stringReader0 = new StringReader(""A"");
    // Undeclared exception!
    try {
        cSVFormat1.parse(stringReader0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No quotes mode set but no escape character is set
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test083484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('5');
    Character character0 = Character.valueOf('5');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
    StringReader stringReader0 = new StringReader("" SurroundingSpaces:ignored"");
    // Undeclared exception!
    try {
        cSVFormat2.parse(stringReader0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The comment start and the escape character cannot be the same ('5')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test084485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    Object[] objectArray0 = new Object[9];
    // Undeclared exception!
    try {
        cSVFormat2.format(objectArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('!')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test085486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    // Undeclared exception!
    try {
        cSVFormat3.format(objectArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The comment start character and the delimiter cannot be the same ('o')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test086487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    assertEquals('\""', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test086488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertEquals('o', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test086489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertEquals(""\""\"","", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test086490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test086491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test086492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test086493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test086494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    Object[] objectArray0 = new Object[2];
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test087495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""qtD`St}}MPE"");
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter('Z');
    Quote quote0 = Quote.ALL;
    CSVFormat cSVFormat4 = cSVFormat3.withQuotePolicy(quote0);
    StringReader stringReader0 = new StringReader(""qtD`St}}MPE"");
    // Undeclared exception!
    try {
        cSVFormat4.parse(stringReader0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The escape character and the delimiter cannot be the same ('Z')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test088496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Character character0 = Character.valueOf('[');
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar(character0);
    StringReader stringReader0 = new StringReader("""");
    // Undeclared exception!
    try {
        cSVFormat1.parse(stringReader0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('[')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscaping()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escape).append('>');
    }
    if (isQuoting()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteChar).append('>');
    }
    if (isCommentingEnabled()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentStart).append('>');
    }
    if (isNullHandling()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test089497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> RecordSeparator=<\n> SkipHeaderRecord:false Header:[]"", string0);
}",""
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscaping()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escape).append('>');
    }
    if (isQuoting()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteChar).append('>');
    }
    if (isCommentingEnabled()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentStart).append('>');
    }
    if (isNullHandling()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test090498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"", string0);
}",""
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscaping()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escape).append('>');
    }
    if (isQuoting()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteChar).append('>');
    }
    if (isCommentingEnabled()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentStart).append('>');
    }
    if (isNullHandling()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test091499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<qU?qMg?^#%W9> RecordSeparator=<\n> SkipHeaderRecord:false"", string0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test092500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    cSVFormat0.hashCode();
    assertEquals('A', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test092501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test092502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test092503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test093504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test093505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test093506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test093507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test094508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    cSVFormat0.TDF.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test094509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    cSVFormat0.TDF.hashCode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test094510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    cSVFormat0.TDF.hashCode();
    assertEquals('[', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test094511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    cSVFormat0.TDF.hashCode();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test095512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""FPE.2"");
    cSVFormat1.hashCode();
    assertEquals(""FPE.2"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test095513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""FPE.2"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test095514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""FPE.2"");
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test095515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""FPE.2"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test095516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""FPE.2"");
    cSVFormat1.hashCode();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test096517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test096518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    cSVFormat1.hashCode();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test096519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test096520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    cSVFormat1.hashCode();
    assertEquals('_', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test096521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test097522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test097523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test097524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test097525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test097526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Quote quote0 = Quote.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test098527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertNotNull(stringArray1);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test098528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test098529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test098530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test098531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test098532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test098533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test098534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test098535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withHeader(stringArray0);
    String[] stringArray1 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test099536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test099537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test099538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test099539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test099540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(""["", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test099541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test099542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('[');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('[', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test100543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test100544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('q', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test100545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test100546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test100547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test101548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test101549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test101550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test101551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test101552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test101553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test101554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test101555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test102556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('W', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test102557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test102558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test102559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test102560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test102561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test102562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('W');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test103563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test103564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test103565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test103566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test103567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test103568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test103569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test103570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test103571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[2];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test104572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test104573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(boolean0);
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test104574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test104575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals(""X"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test104576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test104577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test104578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test104579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertTrue(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test104580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test104581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test104582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat0.MYSQL.withRecordSeparator('X');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test105583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test105584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test105585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public String getNullString() {
    return nullString;
}","public void test105586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals("""", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test105587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test105588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isEscaping() {
    return escape != null;
}","public void test105589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test105590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test105591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test105592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test106593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test106594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test106595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test106596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test106597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals(""qU?qMg?^#%W9"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test106598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat2.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test106599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(boolean0);
}",""
"public boolean isEscaping() {
    return escape != null;
}","public void test106600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertTrue(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test106601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test106602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""qU?qMg?^#%W9"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('<');
    boolean boolean0 = cSVFormat1.equals(cSVFormat2);
    assertEquals(""<"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the line separator delimiting output records.
 *
 * @return the line separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test107603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test107604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test107605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test107606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test107607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test107608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test107609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test107610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test107611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('4');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test108612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test108613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test108614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test108615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test108616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test108617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test108618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test108619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test108620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\""', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getEscape() {
    return escape;
}","public void test108621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('T', (char) cSVFormat1.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test109622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test109623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals('\""', (char) cSVFormat2.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test109624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test109625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertTrue(boolean0);
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test109626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertTrue(cSVFormat2.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test109627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean isEscaping() {
    return escape != null;
}","public void test109628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test109629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals('o', (char) cSVFormat2.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test110630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test110631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test110632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test110633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test110634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test110635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test110636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\""', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test110637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test110638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test110639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('o');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('o', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test111640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test111641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('t', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test111642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test111643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test111644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test111645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test111646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test111647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test111648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test111649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withQuoteChar('t');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test112650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test112651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getEscape() {
    return escape;
}","public void test112652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\\', (char) cSVFormat1.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test112653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test112654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test112655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test112656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentStart() {
    return commentStart;
}","public void test112657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('_', (char) cSVFormat1.getCommentStart());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test112658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test112659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test113660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test114661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test115662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test116663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test116664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test116665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test116666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isEscaping() {
    return escape != null;
}","public void test116667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test116668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test116669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('o', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test116670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test116671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test116672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('o');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public static CSVFormat newFormat(final char delimiter) {
    return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);
}","public void test117673() throws Throwable {
    // Undeclared exception!
    try {
        CSVFormat.newFormat('\r');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The delimiter cannot be a line break
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Creates a new CSV format with the specified delimiter.
 *
 * @param delimiter
 *            the char used for value separation, must not be a line break character
 * @return a new CSV format.
 * @throws IllegalArgumentException if the delimiter is a line break character
 */"
"public CSVFormat withEscape(final char escape) {
    return withEscape(Character.valueOf(escape));
}","public void test118674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    // Undeclared exception!
    try {
        cSVFormat0.DEFAULT.withEscape('\r');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The escape character cannot be a line break
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the escape character of the format to the specified character.
 *
 * @param escape
 *            the escape character
 * @return A new CSVFormat that is equal to his but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"void validate() throws IllegalStateException {
    if (quoteChar != null && delimiter == quoteChar.charValue()) {
        throw new IllegalStateException(""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
    }
    if (escape != null && delimiter == escape.charValue()) {
        throw new IllegalStateException(""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
    }
    if (commentStart != null && delimiter == commentStart.charValue()) {
        throw new IllegalStateException(""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
    }
    if (quoteChar != null && quoteChar.equals(commentStart)) {
        throw new IllegalStateException(""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape != null && escape.equals(commentStart)) {
        throw new IllegalStateException(""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
    }
    if (escape == null && quotePolicy == Quote.NONE) {
        throw new IllegalStateException(""No quotes mode set but no escape character is set"");
    }
    if (header != null) {
        final Set<String> set = new HashSet<String>(header.length);
        set.addAll(Arrays.asList(header));
        if (set.size() != header.length) {
            throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
        }
    }
}","public void test119675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeader(stringArray0);
    try {
        cSVFormat1.validate();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The header contains duplicate names: [null, null, null]
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.
 *
 * @throws IllegalStateException
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test120676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test120677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test120678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test120679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test120680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test120681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test120682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test120683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscaping()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escape).append('>');
    }
    if (isQuoting()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteChar).append('>');
    }
    if (isCommentingEnabled()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentStart).append('>');
    }
    if (isNullHandling()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test121684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('!');
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> CommentStart=<!> RecordSeparator=<\n> SkipHeaderRecord:false"", string0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test122685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test122686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test122687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('[', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test122688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test122689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat1 = cSVFormat0.withQuotePolicy(quote0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test123690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test123691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test123692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getEscape() {
    return escape;
}","public void test123693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\\', (char) cSVFormat1.getEscape());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteChar() {
    return quoteChar;
}","public void test123694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('_', (char) cSVFormat1.getQuoteChar());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test123695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test123696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test123697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test123698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test123699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test123700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('_');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscaping()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escape).append('>');
    }
    if (isQuoting()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteChar).append('>');
    }
    if (isCommentingEnabled()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentStart).append('>');
    }
    if (isNullHandling()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test124701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('[');
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<[> SkipHeaderRecord:false"", string0);
}",""
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test125702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test125703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test125704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the
 *         value.
 */"
"public boolean isNullHandling() {
    return nullString != null;
}","public void test125705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullHandling());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test125706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test125707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty
 *         records.
 */"
"public boolean isCommentingEnabled() {
    return commentStart != null;
}","public void test125708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isCommentingEnabled());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quotePolicy != other.quotePolicy) {
        return false;
    }
    if (quoteChar == null) {
        if (other.quoteChar != null) {
            return false;
        }
    } else if (!quoteChar.equals(other.quoteChar)) {
        return false;
    }
    if (commentStart == null) {
        if (other.commentStart != null) {
            return false;
        }
    } else if (!commentStart.equals(other.commentStart)) {
        return false;
    }
    if (escape == null) {
        if (other.escape != null) {
            return false;
        }
    } else if (!escape.equals(other.escape)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test125709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test126710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat0.getSkipHeaderRecord();
    assertFalse(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoting() {
    return quoteChar != null;
}","public void test127711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    assertFalse(cSVFormat0.isQuoting());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscaping() {
    return escape != null;
}","public void test127712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[2];
    cSVFormat0.format(objectArray0);
    assertTrue(cSVFormat0.isEscaping());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
