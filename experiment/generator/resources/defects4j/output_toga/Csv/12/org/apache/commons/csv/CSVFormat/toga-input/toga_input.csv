focal_method,test_prefix,docstring
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test0000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test0002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test0003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test0004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test0005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test0006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test0007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test0008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('B');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('B', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test0019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test00120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""epV!DihL0*h.t"");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals(""epV!DihL0*h.t"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test00222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals('z', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""|mabLp4"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertEquals(""#"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test00768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertEquals(""y"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""y"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('#');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00871() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00872() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00873() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00874() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertEquals(""Q"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00875() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00876() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00877() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('Q');
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00979() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00980() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00981() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00982() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00983() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00984() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00985() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00986() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertEquals(""K"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00987() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = Character.valueOf('!');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01088() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test01089() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01090() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01091() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test01092() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test01093() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertEquals(""t"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01094() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01095() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01096() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test01097() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test01199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertEquals(""t"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test011100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('t');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test012101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals('z', (char) cSVFormat3.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test012102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test012103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test012104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test012105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test012106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test012107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test012108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test012109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('z');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""format"");
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test013111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test013112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test013113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test013114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test013115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test013116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test013117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test014118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test014119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test015120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getNullString() {
    return nullString;
}","public void test015121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test015122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals('Y', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test015124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test015125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test015126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test015127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test015128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test015130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test015131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('Y');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withNullString(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"");
    Character character0 = Character.valueOf('Y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test016132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test016133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test016134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('7', (char) cSVFormat3.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test016135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test016137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test016138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('X', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test016139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('7');
    Character character0 = new Character('X');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('\t', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test017140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test017141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test017142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test017143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test017144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test017145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test017146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test017147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = new Character('x');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test018148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test018149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test018150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test018151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test018152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test018153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test018154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    Character character0 = new Character('y');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test019155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test019156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test019158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test019159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test019160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test019161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test019162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertEquals('p', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test019163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('p');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test020164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test020165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test020166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test020167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test020168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test020169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test020170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertEquals('<', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test020171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('<');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test021172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test021173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test021174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertEquals(""CommentStart=<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test021175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test021176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test021177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test021178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test021179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""CommentStart=<"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test022180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test022181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test022182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test022183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertEquals(""QJWto;q]bY]?r+,Y"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test022184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test022185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test022186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test022187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test022188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""QJWto;q]bY]?r+,Y"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test023189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    cSVFormat1.withNullString(""mlg\""F"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test023190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    cSVFormat1.withNullString(""mlg\""F"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test024191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test024192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test024195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test024196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test024197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test024198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test025199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test025200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test025201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test026203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(""CommentStart=<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test026204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test026205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test026206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test026207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test026208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test026209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test026210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test027211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test027212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test027213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test027214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test027215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test027216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test027217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines(true);
    assertEquals('U', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test028218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test028219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test028220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test028221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test028222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test028223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test028224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test028225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test028226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test028227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test028228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test029229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test029230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test029231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test029232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test029233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test029234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test029235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test030236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test030237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test030238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test030239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test031240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getNullString() {
    return nullString;
}","public void test031241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(""O{x<Z~@"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test031242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test031243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test031244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test031245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test031246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test031247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withNullString(""O{x<Z~@"");
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test032248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test032249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test032250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test032251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test032252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test032253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test032254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test032255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('*');
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals('*', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test033256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test033257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test033258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test033259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test033260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test033261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test033262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test033263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "":"";
    stringArray0[1] = ""8`0&40-Y^E%,tpsSa"";
    stringArray0[2] = ""~dD/GUYR "";
    stringArray0[3] = ""ON7::V\""j@@DK"";
    stringArray0[4] = ""MINIMAL"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test034264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test034265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator("""");
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test035266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getNullString() {
    return nullString;
}","public void test035267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""Delimiter=<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test035268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test035269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test035270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test035271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test035272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test035273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('R');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test036274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test036275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test036276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test036278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('S', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test036279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test036280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test036281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    Character character0 = Character.valueOf('S');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test037282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = new Character('s');
    cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test037283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = new Character('s');
    cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test038284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals(""\r\n"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test038285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test038286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test038287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals('\""', (char) cSVFormat3.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test038288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals(""Jyv!x"", cSVFormat3.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test038289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test038290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertEquals(' ', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test038291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Jyv!x"");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(' ');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test039292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test039293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test039294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertEquals('6', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test039295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test039296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test039297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test039298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test039299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('6');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('!');
    assertEquals('!', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test040300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test040301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test040302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test040303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test040304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test040305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test040306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test040307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(':');
    assertEquals(':', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test041308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test041309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test041310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test041311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test041312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertEquals('\""', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test041313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape('\""');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test042314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('M');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test042315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('M');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test042316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('M');
    assertEquals('M', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test043317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test043318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test043319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test043320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test043321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertEquals(""CommentStart=<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test043322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertEquals('U', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test043323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test043324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""CommentStart=<"");
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('U');
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test044325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test044326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test044327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test044328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertEquals('S', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test044329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test044330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test044331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withDelimiter('S');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test045332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test045333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(""Delimiter=<"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test045334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test045335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test045336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test045337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test045338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test045339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<"");
    Character character0 = Character.valueOf('W');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test046340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test046341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test046342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test046343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test046344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test046345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test046346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withCommentMarker((Character) null);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test047347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test047348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test047349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test047350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test047351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test047352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test047353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test047354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('N');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test048355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test048356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test048357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test048358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test048359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test048360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test048361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test049362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = Character.valueOf('*');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('L');
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('\""');
    assertEquals('L', (char) cSVFormat4.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test049363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = Character.valueOf('*');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('L');
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('\""');
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test049364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = Character.valueOf('*');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('L');
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('\""');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test049365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    Character character0 = Character.valueOf('*');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('L');
    CSVFormat cSVFormat4 = cSVFormat3.withDelimiter('\""');
    assertEquals('\""', cSVFormat4.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test050366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test050367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertEquals('0', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test050368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test050369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test050370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test050371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test050372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test050373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test050374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('0');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test051375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('|');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test051376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('|');
    assertEquals('|', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test051377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('|');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test052378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test052379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat4.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test052380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat4.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test052381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat4.equals((Object) cSVFormat3));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test052382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat4.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test052383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertEquals(""\r\n"", cSVFormat4.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test052384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test052385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertEquals('B', (char) cSVFormat4.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test052386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test052387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""rcKJs'S9{B9"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker('B');
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(true);
    assertEquals(""rcKJs'S9{B9"", cSVFormat4.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test053388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test053389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertEquals('k', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test053390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test053391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test053392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test053393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test053394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('k');
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test054395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test054396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test054397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test054398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test054399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test054400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test054401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test054402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test055403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertTrue(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test055404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test055405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test055406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertEquals('r', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test055407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test055408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test055409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test055410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    boolean boolean0 = cSVFormat2.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test056411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test056412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    cSVFormat0.getRecordSeparator();
    assertEquals('8', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test056413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test056414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test056415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test057416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test057417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test057419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test057420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test057421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test057422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertNotNull(string0);
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test057423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator("""");
    String string0 = cSVFormat1.getRecordSeparator();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test058424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test058425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test058426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test058427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test058428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test058429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test058430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test059431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertNull(character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test060432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test060433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test060434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test060435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test060436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test060437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test060438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test060439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""QJWto;q]bY]?r+,Y"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""QJWto;q]bY]?r+,Y"", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test061440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test061441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test061442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test061443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getNullString() {
    return nullString;
}","public void test061445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals("""", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test061446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test061447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test062448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test062449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test062450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test062451() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test062452() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test062453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test062454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test063455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test064456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test064457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test064458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test064459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test064460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test064461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test064462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""bapp*>~N]>qej~6vX"";
    stringArray0[1] = ""org.apache.commons.csv.ExtendedBufferedReader"";
    stringArray0[2] = ""The header contains a duplicate entry: '"";
    stringArray0[3] = ""783"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test065463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertEquals('\\', (char) character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test066464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    char char0 = cSVFormat0.getDelimiter();
    assertEquals(',', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test067465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('8', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test067466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test067467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test067469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test068470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test068471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test068472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test068473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test068474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test068475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test068476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test069477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertTrue(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test069478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.getAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public CSVFormat withEscape(final char escape) {
    return withEscape(Character.valueOf(escape));
}","public void test070479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('k');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withEscape('k');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('k')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the escape character of the format to the specified character.
 *
 * @param escape
 *            the escape character
 * @return A new CSVFormat that is equal to his but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withDelimiter(final char delimiter) {
    if (isLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test071480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('T');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withDelimiter('T');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the delimiter cannot be the same ('T')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the delimiter of the format to the specified character.
 *
 * @param delimiter
 *            the delimiter character
 * @return A new CSVFormat that is equal to this with the specified character as delimiter
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test072481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.DEFAULT.print((Appendable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'out' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *        the output
 * @return a printer to an output
 * @throws IOException
 *         thrown if the optional header cannot be printed.
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test073482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.parse((Reader) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test074483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.format((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test075484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuote((Character) null);
    cSVFormat1.isQuoteCharacterSet();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test075485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuote((Character) null);
    cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test075486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuote((Character) null);
    cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test075487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuote((Character) null);
    cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test075488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuote((Character) null);
    cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test076489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test076490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test076491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test076492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test076493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test076494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test076495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.isQuoteCharacterSet();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test077496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test077497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test077498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test077499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test077500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test077501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test077502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test077503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test077504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""$VALUES"");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals(""$VALUES"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test078505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.isNullStringSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test079506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test080507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test080508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test080509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test080510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test080511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test080512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test080513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withEscape(character0);
    boolean boolean0 = cSVFormat1.isEscapeCharacterSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test081514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test081515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test081516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test081517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test081518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test081519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test081520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test081521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('e');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test082522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test082523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test082524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test082525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test082526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test082527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test082528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test083529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = cSVFormat0.getHeader();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test084530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertFalse(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test085531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getCommentMarker();
    assertNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test086532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String string0 = cSVFormat0.getNullString();
    assertNull(string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public QuoteMode getQuoteMode() {
    return quoteMode;
}","public void test087533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    cSVFormat0.getQuoteMode();
}","/**
 * Returns the quote policy output fields.
 *
 * @return the quote policy
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test088534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test089535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertTrue(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test090536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getRecordSeparator();
    assertEquals(""\r\n"", string0);
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test091537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test092538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test092539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('p', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test092540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test092541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test092542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {
    return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test093543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    QuoteMode quoteMode0 = QuoteMode.NONE;
    // Undeclared exception!
    try {
        cSVFormat0.withQuoteMode(quoteMode0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No quotes mode set but no escape character is set
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the output quote policy of the format to the specified value.
 *
 * @param quoteModePolicy
 *            the quote policy to use for output.
 *
 * @return A new CSVFormat that is equal to this but with the specified quote policy
 */"
"public CSVFormat withCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test094544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('r');
    Character character0 = new Character('r');
    // Undeclared exception!
    try {
        cSVFormat1.withCommentMarker(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('r')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the comment start marker of the format to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker, use {@code null} to disable
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final char quoteChar) {
    return withQuote(Character.valueOf(quoteChar));
}","public void test095545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('s');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withQuote('s');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('s')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the quoteChar of the format to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final char commentMarker) {
    return withCommentMarker(Character.valueOf(commentMarker));
}","public void test096546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.EXCEL.withCommentMarker(',');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the delimiter cannot be the same (',')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the comment start marker of the format to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withEscape(final Character escape) {
    if (isLineBreak(escape)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test097547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('U');
    Character character0 = new Character('U');
    // Undeclared exception!
    try {
        cSVFormat0.withEscape(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The escape character and the delimiter cannot be the same ('U')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the escape character of the format to the specified character.
 *
 * @param escape
 *            the escape character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final Character quoteChar) {
    if (isLineBreak(quoteChar)) {
        throw new IllegalArgumentException(""The quoteChar cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test098548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('(');
    Character character0 = new Character('(');
    // Undeclared exception!
    try {
        cSVFormat0.withQuote(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('(')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the quoteChar of the format to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test099549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test099550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false Header:[vE7j|07, ]G7;, w5%hol.RC'kWi, The header contains a duplicate entry: ', 1q#6hb?%~+|gP, (line , \r\n, null]"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test100551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test100552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<p> SkipHeaderRecord:false"", string0);
}",""
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test101553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('r');
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> Escape=<r> QuoteChar=<\""> RecordSeparator=<\r\n> SkipHeaderRecord:false"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test101554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('r');
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test102555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""IUgG1T[MPmf6/yGLlvX"");
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test102556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""IUgG1T[MPmf6/yGLlvX"");
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> QuoteChar=<\""> NullString=<IUgG1T[MPmf6/yGLlvX> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test103557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    assertFalse(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test103558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[7];
    cSVFormat0.format(objectArray0);
    assertTrue(cSVFormat0.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test104559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('1');
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> CommentStart=<1> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test104560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('1');
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test105561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat0.isCommentMarkerSet();
    assertFalse(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test106562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test106563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test106564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test106565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test106566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test107567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    cSVFormat0.TDF.hashCode();
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test108568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('F');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""WL__2JE"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test108569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('F');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""WL__2JE"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test108570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('F');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""WL__2JE"");
    cSVFormat1.hashCode();
    assertEquals('F', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test108571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('F');
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""WL__2JE"");
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test109572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('-');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test109573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('-');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test109574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('-');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test109575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('-');
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test109576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('-');
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test110577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test110578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test110579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test110580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test110581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test110582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test111583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test111584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test111585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test111586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test111587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test111588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test111589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""vE7j|07"";
    stringArray0[1] = ""]G7;"";
    stringArray0[2] = ""w5%hol.RC'kWi"";
    stringArray0[3] = ""The header contains a duplicate entry: '"";
    stringArray0[4] = ""1q#6hb?%~+|gP"";
    stringArray0[5] = ""(line "";
    stringArray0[6] = ""\r\n"";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    cSVFormat1.format(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test112590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test112591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test112592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test112593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test112594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test112595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test112596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test113597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test113598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test113599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test113600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test113601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test113602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test113603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test114604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test115605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test115606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test115607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test115608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test115609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test115610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test115611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test115612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public String getNullString() {
    return nullString;
}","public void test115613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""r,&,Izl?x01`c1z8"");
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(""r,&,Izl?x01`c1z8"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test116614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test116615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test116616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test116617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test116618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public String getNullString() {
    return nullString;
}","public void test116619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""org.apache.commons.csv.ExtendedBufferedReader"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li>
 * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.
 * </li>
 * <li>
 * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test116620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test116621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test116622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""org.apache.commons.csv.ExtendedBufferedReader"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test117623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test117624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test117625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('?', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test117626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test117627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test117628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test117629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test117630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test118631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test118632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test118633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test118634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals('7', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test118635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test118636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test118637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    CSVFormat cSVFormat2 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test119638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test119639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test119640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('?', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test119641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test119642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test119643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test119644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test119645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test119646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('?');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test120647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test120648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test120649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test120650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test120651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('K', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test120652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test120653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test120654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test120655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('K');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test121656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals('5', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test121657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test121658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test121659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test121660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test121661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test121662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test121663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test121664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test121665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('5');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat2.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test122666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test122667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test122668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test122669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test122670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test122671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test122672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test122673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test122674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withQuote(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test123675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = CSVFormat.TDF;
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test124676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test124677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('A', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test124678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test124679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test124680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test125681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test125682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test125683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test125684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test125685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test125686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test125687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test125688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test126689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test126690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test126691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test126692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertEquals('p', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test126693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test126694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    Object object0 = new Object();
    boolean boolean0 = cSVFormat0.equals(object0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test127695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test128696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test128697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test128698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test128699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertEquals('A', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test128700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test128701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public CSVFormat withHeader(final String... header) {
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames);
}","public void test129702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[3];
    // Undeclared exception!
    try {
        cSVFormat0.withHeader(stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The header contains a duplicate entry: 'null' in [null, null, null]
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Sets the header of the format. The header can either be parsed automatically from the input file with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader();</pre>
 *
 * or specified manually with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>
 *
 * @param header
 *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.
 *
 * @return A new CSVFormat that is equal to this but with the specified header
 * @see #withSkipHeaderRecord(boolean)
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test130703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test130704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test131705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test131706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertEquals(""7"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test131707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test131708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test131709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test131710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test131711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test131712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('7');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test132713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test132714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test132715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('7', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test132716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test132717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test132718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test132719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test132720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test132721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test132722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withEscape('7');
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test133723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertFalse(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test134724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString((String) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test134725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test135726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test135727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertEquals('b', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test135728() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test135729() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test135730() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test135731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test135732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test135733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('b');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test136734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test136735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test136736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertEquals('A', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test136737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test136738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test136739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test136740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test136741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test136742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test136743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test136744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('A');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test137745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    MockPrintStream mockPrintStream0 = new MockPrintStream(""GWS,4YX@?"");
    cSVFormat0.print(mockPrintStream0);
    assertEquals('p', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test137746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    MockPrintStream mockPrintStream0 = new MockPrintStream(""GWS,4YX@?"");
    cSVFormat0.print(mockPrintStream0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test137747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    MockPrintStream mockPrintStream0 = new MockPrintStream(""GWS,4YX@?"");
    cSVFormat0.print(mockPrintStream0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test137748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    MockPrintStream mockPrintStream0 = new MockPrintStream(""GWS,4YX@?"");
    cSVFormat0.print(mockPrintStream0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the
 *         value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test137749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('p');
    MockPrintStream mockPrintStream0 = new MockPrintStream(""GWS,4YX@?"");
    cSVFormat0.print(mockPrintStream0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test138750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    boolean boolean0 = cSVFormat0.getSkipHeaderRecord();
    assertFalse(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test139751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    PipedReader pipedReader0 = new PipedReader(1);
    CSVParser cSVParser0 = cSVFormat0.TDF.parse(pipedReader0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current line number
 */"
