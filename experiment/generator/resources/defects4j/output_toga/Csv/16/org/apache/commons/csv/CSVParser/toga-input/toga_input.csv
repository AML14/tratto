focal_method,test_prefix,docstring
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test000() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    Charset charset0 = Charset.defaultCharset();
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVParser cSVParser0 = CSVParser.parse((InputStream) pipedInputStream0, charset0, cSVFormat0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Consumer<CSVRecord> consumer0 = (Consumer<CSVRecord>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    cSVParser0.forEach(consumer0);
    cSVParser0.nextRecord();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test022() throws Throwable {
    EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Escape=</Escape=<0Escape=<"");
    byte[] byteArray0 = new byte[8];
    byteArray0[6] = (byte) 10;
    FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    MockFile mockFile0 = new MockFile(""Escape=<"");
    File file0 = MockFile.createTempFile(""Escape=<"", ""Escape=<"", (File) mockFile0);
    Charset charset0 = Charset.defaultCharset();
    CSVParser cSVParser0 = CSVParser.parse(file0, charset0, cSVFormat0);
    cSVParser0.nextRecord();
    cSVParser0.nextRecord();
    assertEquals(2L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.ORACLE;
    CSVParser cSVParser0 = CSVParser.parse("""", cSVFormat0);
    cSVParser0.iterator();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVParser cSVParser0 = CSVParser.parse(""6Ih"", cSVFormat0);
    cSVParser0.close();
    boolean boolean0 = cSVParser0.isClosed();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public boolean isClosed() {
    return this.lexer.isClosed();
}","public void test045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVParser cSVParser0 = CSVParser.parse(""6Ih"", cSVFormat0);
    cSVParser0.close();
    boolean boolean0 = cSVParser0.isClosed();
    assertTrue(boolean0);
}","/**
 * Gets whether this parser is closed.
 *
 * @return whether this parser is closed.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test056() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Consumer<CSVRecord> consumer0 = (Consumer<CSVRecord>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    cSVParser0.forEach(consumer0);
    cSVParser0.getRecords();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test067() throws Throwable {
    PipedWriter pipedWriter0 = new PipedWriter();
    PipedReader pipedReader0 = new PipedReader(pipedWriter0);
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVParser cSVParser0 = new CSVParser(pipedReader0, cSVFormat0, 0L, (-1L));
    long long0 = cSVParser0.getRecordNumber();
    assertEquals((-2L), long0);
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test078() throws Throwable {
    File file0 = MockFile.createTempFile(""charset"", ""charset"");
    Charset charset0 = Charset.defaultCharset();
    EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""/var/folders/vv/c7q6vm8920vc7d5p_87011w40000gn/T/charset0charset"");
    CSVFormat cSVFormat0 = CSVFormat.newFormat('P');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    FileSystemHandling.appendLineToFile(evoSuiteFile0, ""FORMAT"");
    CSVParser cSVParser0 = CSVParser.parse(file0, charset0, cSVFormat1);
    cSVParser0.getFirstEndOfLine();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(path, ""path"");
    Assertions.notNull(format, ""format"");
    return parse(Files.newBufferedReader(path, charset), format);
}","public void test089() throws Throwable {
    MockFile mockFile0 = new MockFile(""P2494y_M+a~"", ""P2494y_M+a~"");
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    try {
        CSVParser.parse(path0, charset0, cSVFormat0);
        fail(""Expecting exception: NoSuchFileException"");
    } catch (NoSuchFileException e) {
    }
}","/**
 * Creates a parser for the given {@link Path}.
 *
 * @param path
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.5
 */"
"public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(path, ""path"");
    Assertions.notNull(format, ""format"");
    return parse(Files.newBufferedReader(path, charset), format);
}","public void test0910() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    MockFile mockFile0 = new MockFile(""inputStream"");
    Path path0 = mockFile0.toPath();
    // Undeclared exception!
    try {
        CSVParser.parse(path0, (Charset) null, cSVFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.file.Files"", e);
    }
}","/**
 * Creates a parser for the given {@link Path}.
 *
 * @param path
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.5
 */"
"public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(path, ""path"");
    Assertions.notNull(format, ""format"");
    return parse(Files.newBufferedReader(path, charset), format);
}","public void test1011() throws Throwable {
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    // Undeclared exception!
    try {
        CSVParser.parse(path0, (Charset) null, (CSVFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'format' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given {@link Path}.
 *
 * @param path
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.5
 */"
"public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(path, ""path"");
    Assertions.notNull(format, ""format"");
    return parse(Files.newBufferedReader(path, charset), format);
}","public void test1112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.ORACLE;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    MockFile mockFile0 = new MockFile("""", """");
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    try {
        CSVParser.parse(path0, charset0, cSVFormat1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
    }
}","/**
 * Creates a parser for the given {@link Path}.
 *
 * @param path
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.5
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test1213() throws Throwable {
    URL uRL0 = MockURL.getHttpExample();
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        CSVParser.parse(uRL0, (Charset) null, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'charset' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test1314() throws Throwable {
    Charset charset0 = Charset.defaultCharset();
    CSVFormat cSVFormat0 = CSVFormat.ORACLE;
    URL uRL0 = MockURL.getHttpExample();
    try {
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not find: www.someFakeButWellFormedURL.org
        //
        verifyException(""org.evosuite.runtime.mock.java.net.EvoHttpURLConnection"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final String string, final CSVFormat format) throws IOException {
    Assertions.notNull(string, ""string"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new StringReader(string), format);
}","public void test1415() throws Throwable {
    // Undeclared exception!
    try {
        CSVParser.parse("""", (CSVFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'format' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given {@link String}.
 *
 * @param string
 *            a CSV string. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either string or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {
    return new CSVParser(reader, format);
}","public void test1516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    // Undeclared exception!
    try {
        CSVParser.parse((Reader) null, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a CSV parser using the given {@link CSVFormat}
 *
 * <p>
 * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
 * unless you close the {@code reader}.
 * </p>
 *
 * @param reader
 *            a Reader containing CSV-formatted input. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new CSVParser configured with the given reader and format.
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either reader or format are null.
 * @throws IOException
 *             If there is a problem reading the header or skipping the first record
 * @since 1.5
 */"
"public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {
    return new CSVParser(reader, format);
}","public void test1617() throws Throwable {
    PipedReader pipedReader0 = new PipedReader();
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    try {
        CSVParser.parse((Reader) pipedReader0, cSVFormat1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Creates a CSV parser using the given {@link CSVFormat}
 *
 * <p>
 * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
 * unless you close the {@code reader}.
 * </p>
 *
 * @param reader
 *            a Reader containing CSV-formatted input. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new CSVParser configured with the given reader and format.
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either reader or format are null.
 * @throws IOException
 *             If there is a problem reading the header or skipping the first record
 * @since 1.5
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(inputStream, ""inputStream"");
    Assertions.notNull(format, ""format"");
    return parse(new InputStreamReader(inputStream, charset), format);
}","public void test1718() throws Throwable {
    PipedInputStream pipedInputStream0 = new PipedInputStream();
    CSVFormat cSVFormat0 = CSVFormat.ORACLE;
    // Undeclared exception!
    try {
        CSVParser.parse((InputStream) pipedInputStream0, (Charset) null, cSVFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // charset
        //
        verifyException(""java.io.InputStreamReader"", e);
    }
}","/**
 * Creates a CSV parser using the given {@link CSVFormat}.
 *
 * <p>
 * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
 * unless you close the {@code reader}.
 * </p>
 *
 * @param inputStream
 *            an InputStream containing CSV-formatted input. Must not be null.
 * @param charset
 *            a Charset.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new CSVParser configured with the given reader and format.
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either reader or format are null.
 * @throws IOException
 *             If there is a problem reading the header or skipping the first record
 * @since 1.5
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);
}","public void test1819() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    File file0 = MockFile.createTempFile(""No more CSV records available"", ""No more CSV records available"");
    // Undeclared exception!
    try {
        CSVParser.parse(file0, (Charset) null, cSVFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // charset
        //
        verifyException(""java.io.InputStreamReader"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);
}","public void test1920() throws Throwable {
    File file0 = MockFile.createTempFile(""charset"", ""charset"");
    Charset charset0 = Charset.defaultCharset();
    FileSystemHandling.shouldAllThrowIOExceptions();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('P');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    try {
        CSVParser.parse(file0, charset0, cSVFormat1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Simulated IOException
        //
        verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);
}","public void test2021() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    MockFile mockFile0 = new MockFile("""", """");
    Charset charset0 = Charset.defaultCharset();
    try {
        CSVParser.parse((File) mockFile0, charset0, cSVFormat0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"CSVRecord nextRecord() throws IOException {
    CSVRecord result = null;
    this.recordList.clear();
    StringBuilder sb = null;
    final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;
    do {
        this.reusableToken.reset();
        this.lexer.nextToken(this.reusableToken);
        switch(this.reusableToken.type) {
            case TOKEN:
                this.addRecordValue(false);
                break;
            case EORECORD:
                this.addRecordValue(true);
                break;
            case EOF:
                if (this.reusableToken.isReady) {
                    this.addRecordValue(true);
                }
                break;
            case INVALID:
                throw new IOException(""(line "" + this.getCurrentLineNumber() + "") invalid parse sequence"");
            case // Ignored currently
            COMMENT:
                if (sb == null) {
                    // first comment for this record
                    sb = new StringBuilder();
                } else {
                    sb.append(Constants.LF);
                }
                sb.append(this.reusableToken.content);
                // Read another token
                this.reusableToken.type = TOKEN;
                break;
            default:
                throw new IllegalStateException(""Unexpected Token type: "" + this.reusableToken.type);
        }
    } while (this.reusableToken.type == TOKEN);
    if (!this.recordList.isEmpty()) {
        this.recordNumber++;
        final String comment = sb == null ? null : sb.toString();
        result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment, this.recordNumber, startCharPosition);
    }
    return result;
}","public void test2122() throws Throwable {
    PipedReader pipedReader0 = new PipedReader();
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = CSVParser.parse((Reader) pipedReader0, cSVFormat0);
    try {
        cSVParser0.nextRecord();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Parses the next record from the current point in the stream.
 *
 * @return the record as an array of values, or {@code null} if the end of the stream has been reached
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public List<CSVRecord> getRecords() throws IOException {
    CSVRecord rec;
    final List<CSVRecord> records = new ArrayList<>();
    while ((rec = this.nextRecord()) != null) {
        records.add(rec);
    }
    return records;
}","public void test2223() throws Throwable {
    PipedReader pipedReader0 = new PipedReader(1559);
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = new CSVParser(pipedReader0, cSVFormat0, 1559, 509L);
    try {
        cSVParser0.getRecords();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Parses the CSV input according to the given format and returns the content as a list of
 * {@link CSVRecord CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @return list of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2526() throws Throwable {
    StringReader stringReader0 = new StringReader(""inputStream"");
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2627() throws Throwable {
    PipedReader pipedReader0 = new PipedReader();
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[4];
    stringArray0[1] = ""1"";
    stringArray0[2] = ""Unexpected Token type: "";
    stringArray0[3] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = new CSVParser(pipedReader0, cSVFormat1, 0L, 0L);
    assertEquals((-1L), cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2728() throws Throwable {
    File file0 = MockFile.createTempFile(""charset"", ""charset"");
    Charset charset0 = Charset.defaultCharset();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('P');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVParser cSVParser0 = CSVParser.parse(file0, charset0, cSVFormat1);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2930() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.getRecords();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3031() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    StringReader stringReader0 = new StringReader(""P5, ?Y[|*"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.getHeaderMap();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public Map<String, Integer> getHeaderMap() {
    return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);
}","public void test3132() throws Throwable {
    PipedReader pipedReader0 = new PipedReader();
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[4];
    stringArray0[1] = ""1"";
    stringArray0[2] = ""Unexpected Token type: "";
    stringArray0[3] = "" valuels="";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = new CSVParser(pipedReader0, cSVFormat1, 0L, 0L);
    Map<String, Integer> map0 = cSVParser0.getHeaderMap();
    assertNotNull(map0);
}","/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3133() throws Throwable {
    PipedReader pipedReader0 = new PipedReader();
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[4];
    stringArray0[1] = ""1"";
    stringArray0[2] = ""Unexpected Token type: "";
    stringArray0[3] = "" valuels="";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = new CSVParser(pipedReader0, cSVFormat1, 0L, 0L);
    Map<String, Integer> map0 = cSVParser0.getHeaderMap();
    assertEquals((-1L), cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3235() throws Throwable {
    EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile(""Escape=</Escape=<0Escape=<"");
    FileSystemHandling.appendLineToFile(evoSuiteFile0, """");
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    MockFile mockFile0 = new MockFile(""Escape=<"");
    File file0 = MockFile.createTempFile(""Escape=<"", ""Escape=<"", (File) mockFile0);
    Charset charset0 = Charset.defaultCharset();
    CSVParser cSVParser0 = CSVParser.parse(file0, charset0, cSVFormat0);
    cSVParser0.nextRecord();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVParser cSVParser0 = CSVParser.parse(""thk,3Hy3DboF"", cSVFormat0);
    cSVParser0.nextRecord();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVParser cSVParser0 = CSVParser.parse(""@_(Y\""+#u%[i<2A"", cSVFormat1);
    cSVParser0.nextRecord();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVParser cSVParser0 = CSVParser.parse(""\""K>=/L(ei:8HpA.;e"", cSVFormat0);
    long long0 = cSVParser0.getRecordNumber();
    assertEquals(0L, long0);
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVParser cSVParser0 = CSVParser.parse(""6Ih"", cSVFormat0);
    cSVParser0.isClosed();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(inputStream, ""inputStream"");
    Assertions.notNull(format, ""format"");
    return parse(new InputStreamReader(inputStream, charset), format);
}","public void test3740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Charset charset0 = Charset.defaultCharset();
    // Undeclared exception!
    try {
        CSVParser.parse((InputStream) null, charset0, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'inputStream' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a CSV parser using the given {@link CSVFormat}.
 *
 * <p>
 * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
 * unless you close the {@code reader}.
 * </p>
 *
 * @param inputStream
 *            an InputStream containing CSV-formatted input. Must not be null.
 * @param charset
 *            a Charset.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new CSVParser configured with the given reader and format.
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either reader or format are null.
 * @throws IOException
 *             If there is a problem reading the header or skipping the first record
 * @since 1.5
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3841() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    MockFile mockFile0 = new MockFile("""", """");
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    CSVParser cSVParser0 = CSVParser.parse(path0, charset0, cSVFormat0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test3942() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Charset charset0 = Charset.defaultCharset();
    URL uRL0 = MockURL.getFtpExample();
    // Undeclared exception!
    try {
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"@SuppressWarnings(""resource"")
public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);
}","public void test4043() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Charset charset0 = Charset.defaultCharset();
    // Undeclared exception!
    try {
        CSVParser.parse((File) null, charset0, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'file' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param charset
 *            A Charset
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test4144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.getCurrentLineNumber();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test4245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.getFirstEndOfLine();
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test4346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6Ih"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Consumer<CSVRecord> consumer0 = (Consumer<CSVRecord>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    cSVParser0.forEach(consumer0);
    long long0 = cSVParser0.getRecordNumber();
    assertEquals(1L, long0);
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
