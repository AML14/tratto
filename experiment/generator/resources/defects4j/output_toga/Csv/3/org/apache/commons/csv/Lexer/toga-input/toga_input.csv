focal_method,test_prefix,docstring
"boolean isStartOfLine(final int c) {
    return c == LF || c == CR || c == UNDEFINED;
}","public void test000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""h}6Jpv"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isStartOfLine((-989));
    assertFalse(boolean0);
}","/**
 * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.
 *
 * @param c the character to check
 * @return true if the character is at the start of a line.
 */"
"boolean readEndOfLine(int c) throws IOException {
    // check if we have \r\n...
    if (c == CR && in.lookAhead() == LF) {
        // note: does not change c outside of this method!
        c = in.read();
    }
    return c == LF || c == CR;
}","public void test011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    StringReader stringReader0 = new StringReader(""-pxp?M{rZSY@Y"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    Token token0 = new Token();
    cSVLexer0.nextToken(token0);
    boolean boolean0 = cSVLexer0.readEndOfLine(13);
    assertTrue(boolean0);
}","/**
 * Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
 *
 * @return true if the given or next character is a line-terminator
 */"
"@Override
Token nextToken(final Token token) throws IOException {
    // get the last read char (required for empty line detection)
    int lastChar = in.getLastChar();
    // read the next char and set eol
    int c = in.read();
    /*
         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF
         * - they are equivalent here.
         */
    boolean eol = readEndOfLine(c);
    // empty line detection: eol AND (last char was EOL or beginning)
    if (ignoreEmptyLines) {
        while (eol && isStartOfLine(lastChar)) {
            // go on char ahead ...
            lastChar = c;
            c = in.read();
            eol = readEndOfLine(c);
            // reached end of file without any content (empty line at the end)
            if (isEndOfFile(c)) {
                token.type = EOF;
                // don't set tkn.isReady here because no content
                return token;
            }
        }
    }
    // did we reach eof during the last iteration already ? EOF
    if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {
        token.type = EOF;
        // don't set tkn.isReady here because no content
        return token;
    }
    if (isStartOfLine(lastChar) && isCommentStart(c)) {
        final String comment = in.readLine().trim();
        token.content.append(comment);
        token.type = COMMENT;
        return token;
    }
    // important: make sure a new char gets consumed in each iteration
    while (token.type == INVALID) {
        // ignore whitespaces at beginning of a token
        if (ignoreSurroundingSpaces) {
            while (isWhitespace(c) && !eol) {
                c = in.read();
                eol = readEndOfLine(c);
            }
        }
        // ok, start of token reached: encapsulated, or token
        if (isDelimiter(c)) {
            // empty token return TOKEN("""")
            token.type = TOKEN;
        } else if (eol) {
            // empty token return EORECORD("""")
            // noop: tkn.content.append("""");
            token.type = EORECORD;
        } else if (isQuoteChar(c)) {
            // consume encapsulated token
            parseEncapsulatedToken(token);
        } else if (isEndOfFile(c)) {
            // end of file return EOF()
            // noop: tkn.content.append("""");
            token.type = EOF;
            // there is data at EOF
            token.isReady = true;
        } else {
            // next token must be a simple token
            // add removed blanks when not ignoring whitespace chars...
            parseSimpleToken(token, c);
        }
    }
    return token;
}","public void test022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Token token0 = new Token();
    StringReader stringReader0 = new StringReader(""vRs'x#y/G(s~bqbCe "");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    Token token1 = cSVLexer0.nextToken(token0);
    assertSame(token0, token1);
}","/**
 * Returns the next token.
 * <p/>
 * A token corresponds to a term, a record change or an end-of-file indicator.
 *
 * @param token
 *            an existing Token object to reuse. The caller is responsible to initialize the Token.
 * @return the next token found
 * @throws java.io.IOException
 *             on stream access error
 */"
"boolean readEndOfLine(int c) throws IOException {
    // check if we have \r\n...
    if (c == CR && in.lookAhead() == LF) {
        // note: does not change c outside of this method!
        c = in.read();
    }
    return c == LF || c == CR;
}","public void test033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""EOF whilst processing escape sequence"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.readEndOfLine(79);
    assertFalse(boolean0);
}","/**
 * Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
 *
 * @return true if the given or next character is a line-terminator
 */"
"boolean isWhitespace(final int c) {
    return c != format.getDelimiter() && Character.isWhitespace((char) c);
}","public void test044() throws Throwable {
    Character character0 = Character.valueOf('|');
    Quote quote0 = Quote.NONE;
    String[] stringArray0 = new String[6];
    CSVFormat cSVFormat0 = new CSVFormat('|', character0, quote0, character0, character0, true, false, """", ""The escape character cannot be a line break"", stringArray0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, (ExtendedBufferedReader) null);
    boolean boolean0 = cSVLexer0.isWhitespace(13);
    assertTrue(boolean0);
}","/**
 * @return true if the given char is a whitespace character
 */"
"boolean isStartOfLine(final int c) {
    return c == LF || c == CR || c == UNDEFINED;
}","public void test055() throws Throwable {
    Character character0 = Character.valueOf('9');
    Quote quote0 = Quote.NON_NUMERIC;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat(':', character0, quote0, character0, character0, true, true, "" EmptyLines:ignored"", ""$"", stringArray0);
    StringReader stringReader0 = new StringReader("" EmptyLines:ignored"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isStartOfLine(9);
    assertFalse(boolean0);
}","/**
 * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.
 *
 * @param c the character to check
 * @return true if the character is at the start of a line.
 */"
"boolean isQuoteChar(final int c) {
    return c == quoteChar;
}","public void test066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isQuoteChar(102);
    assertFalse(boolean0);
}",""
"boolean isEscape(final int c) {
    return c == escape;
}","public void test077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isEscape(65534);
    assertTrue(boolean0);
}",""
"boolean isEscape(final int c) {
    return c == escape;
}","public void test088() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, (ExtendedBufferedReader) null);
    boolean boolean0 = cSVLexer0.isEscape(326);
    assertFalse(boolean0);
}",""
"boolean isEndOfFile(final int c) {
    return c == END_OF_STREAM;
}","public void test099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isEndOfFile((-1));
    assertTrue(boolean0);
}","/**
 * @return true if the given character indicates end of file
 */"
"boolean isEndOfFile(final int c) {
    return c == END_OF_STREAM;
}","public void test1010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isEndOfFile(0);
    assertFalse(boolean0);
}","/**
 * @return true if the given character indicates end of file
 */"
"boolean isDelimiter(final int c) {
    return c == delimiter;
}","public void test1111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isDelimiter(9);
    assertTrue(boolean0);
}",""
"boolean isDelimiter(final int c) {
    return c == delimiter;
}","public void test1212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader(""org.apache.commons.csv.CSVPrinter$1"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isDelimiter(103);
    assertFalse(boolean0);
}",""
"boolean isCommentStart(final int c) {
    return c == commmentStart;
}","public void test1313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""#f,wJZF4Zt,38p"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isCommentStart(4);
    assertFalse(boolean0);
}",""
"long getLineNumber() {
    return in.getLineNumber();
}","public void test1414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader(""\n"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    long long0 = cSVLexer0.getLineNumber();
    assertEquals(0L, long0);
}",""
"long getLineNumber() {
    return in.getLineNumber();
}","public void test1515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    extendedBufferedReader0.readLine();
    long long0 = cSVLexer0.getLineNumber();
    assertEquals(1L, long0);
}",""
"void trimTrailingSpaces(final StringBuilder buffer) {
    int length = buffer.length();
    while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {
        length = length - 1;
    }
    if (length != buffer.length()) {
        buffer.setLength(length);
    }
}","public void test1616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader(""@LNr`+O6Q$"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    // Undeclared exception!
    try {
        cSVLexer0.trimTrailingSpaces((StringBuilder) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.Lexer"", e);
    }
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test1717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, (ExtendedBufferedReader) null);
    // Undeclared exception!
    try {
        cSVLexer0.readEscape();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.Lexer"", e);
    }
}",""
"boolean readEndOfLine(int c) throws IOException {
    // check if we have \r\n...
    if (c == CR && in.lookAhead() == LF) {
        // note: does not change c outside of this method!
        c = in.read();
    }
    return c == LF || c == CR;
}","public void test1818() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    StringReader stringReader0 = new StringReader(""-pxp?M{rZSY@Y"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    extendedBufferedReader0.close();
    try {
        cSVLexer0.readEndOfLine(13);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
 *
 * @return true if the given or next character is a line-terminator
 */"
"boolean isCommentStart(final int c) {
    return c == commmentStart;
}","public void test1919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isCommentStart(65534);
    assertTrue(boolean0);
}",""
"boolean isQuoteChar(final int c) {
    return c == quoteChar;
}","public void test2020() throws Throwable {
    Character character0 = Character.valueOf(':');
    Quote quote0 = Quote.NON_NUMERIC;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat(':', character0, quote0, character0, character0, true, true, "" EmptyLines:ignored"", "" EmptyLines:ignored"", stringArray0);
    StringReader stringReader0 = new StringReader("" EmptyLines:ignored"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isQuoteChar(':');
    assertTrue(boolean0);
}",""
"boolean isStartOfLine(final int c) {
    return c == LF || c == CR || c == UNDEFINED;
}","public void test2121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader(""org.apache.commons.csv.Lexer"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isStartOfLine(13);
    assertTrue(boolean0);
}","/**
 * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.
 *
 * @param c the character to check
 * @return true if the character is at the start of a line.
 */"
"boolean isStartOfLine(final int c) {
    return c == LF || c == CR || c == UNDEFINED;
}","public void test2222() throws Throwable {
    Character character0 = Character.valueOf(':');
    Quote quote0 = Quote.NON_NUMERIC;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat(':', character0, quote0, character0, character0, true, true, "" EmptyLines:ignored"", "" EmptyLines:ignored"", stringArray0);
    StringReader stringReader0 = new StringReader("" EmptyLines:ignored"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isStartOfLine(10);
    assertTrue(boolean0);
}","/**
 * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.
 *
 * @param c the character to check
 * @return true if the character is at the start of a line.
 */"
"boolean isWhitespace(final int c) {
    return c != format.getDelimiter() && Character.isWhitespace((char) c);
}","public void test2323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.isWhitespace(9);
    assertFalse(boolean0);
}","/**
 * @return true if the given char is a whitespace character
 */"
"boolean readEndOfLine(int c) throws IOException {
    // check if we have \r\n...
    if (c == CR && in.lookAhead() == LF) {
        // note: does not change c outside of this method!
        c = in.read();
    }
    return c == LF || c == CR;
}","public void test2424() throws Throwable {
    StringReader stringReader0 = new StringReader(""\n"");
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.readEndOfLine(13);
    assertTrue(boolean0);
}","/**
 * Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
 *
 * @return true if the given or next character is a line-terminator
 */"
"boolean readEndOfLine(int c) throws IOException {
    // check if we have \r\n...
    if (c == CR && in.lookAhead() == LF) {
        // note: does not change c outside of this method!
        c = in.read();
    }
    return c == LF || c == CR;
}","public void test2525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringReader stringReader0 = new StringReader(""org.apache.commons.csv.Lexer"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    boolean boolean0 = cSVLexer0.readEndOfLine(13);
    assertTrue(boolean0);
}","/**
 * Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
 *
 * @return true if the given or next character is a line-terminator
 */"
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test2727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    StringReader stringReader0 = new StringReader(""gt2cO/DBu"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    stringReader0.read();
    int int0 = cSVLexer0.readEscape();
    assertEquals(9, int0);
}",""
"@Override
Token nextToken(final Token token) throws IOException {
    // get the last read char (required for empty line detection)
    int lastChar = in.getLastChar();
    // read the next char and set eol
    int c = in.read();
    /*
         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF
         * - they are equivalent here.
         */
    boolean eol = readEndOfLine(c);
    // empty line detection: eol AND (last char was EOL or beginning)
    if (ignoreEmptyLines) {
        while (eol && isStartOfLine(lastChar)) {
            // go on char ahead ...
            lastChar = c;
            c = in.read();
            eol = readEndOfLine(c);
            // reached end of file without any content (empty line at the end)
            if (isEndOfFile(c)) {
                token.type = EOF;
                // don't set tkn.isReady here because no content
                return token;
            }
        }
    }
    // did we reach eof during the last iteration already ? EOF
    if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {
        token.type = EOF;
        // don't set tkn.isReady here because no content
        return token;
    }
    if (isStartOfLine(lastChar) && isCommentStart(c)) {
        final String comment = in.readLine().trim();
        token.content.append(comment);
        token.type = COMMENT;
        return token;
    }
    // important: make sure a new char gets consumed in each iteration
    while (token.type == INVALID) {
        // ignore whitespaces at beginning of a token
        if (ignoreSurroundingSpaces) {
            while (isWhitespace(c) && !eol) {
                c = in.read();
                eol = readEndOfLine(c);
            }
        }
        // ok, start of token reached: encapsulated, or token
        if (isDelimiter(c)) {
            // empty token return TOKEN("""")
            token.type = TOKEN;
        } else if (eol) {
            // empty token return EORECORD("""")
            // noop: tkn.content.append("""");
            token.type = EORECORD;
        } else if (isQuoteChar(c)) {
            // consume encapsulated token
            parseEncapsulatedToken(token);
        } else if (isEndOfFile(c)) {
            // end of file return EOF()
            // noop: tkn.content.append("""");
            token.type = EOF;
            // there is data at EOF
            token.isReady = true;
        } else {
            // next token must be a simple token
            // add removed blanks when not ignoring whitespace chars...
            parseSimpleToken(token, c);
        }
    }
    return token;
}","public void test2828() throws Throwable {
    Character character0 = Character.valueOf('a');
    Quote quote0 = Quote.MINIMAL;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat('V', character0, quote0, (Character) '\u0000', character0, true, true, ""org.apache.commons.csv.Leler"", ""org.apache.commons.csv.Leler"", stringArray0);
    StringReader stringReader0 = new StringReader(""Delimiter=<,> QuoteChar=<\"">"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    Token token0 = new Token();
    Token token1 = cSVLexer0.nextToken(token0);
    assertSame(token0, token1);
}","/**
 * Returns the next token.
 * <p/>
 * A token corresponds to a term, a record change or an end-of-file indicator.
 *
 * @param token
 *            an existing Token object to reuse. The caller is responsible to initialize the Token.
 * @return the next token found
 * @throws java.io.IOException
 *             on stream access error
 */"
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test2929() throws Throwable {
    Character character0 = Character.valueOf(':');
    Quote quote0 = Quote.NON_NUMERIC;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat(':', character0, quote0, character0, character0, true, true, "" EmptyLines:ignored"", "" EmptyLines:ignored"", stringArray0);
    StringReader stringReader0 = new StringReader("" EmptyLines:ignored"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    Token token0 = new Token();
    Token token1 = cSVLexer0.nextToken(token0);
    cSVLexer0.nextToken(token1);
    cSVLexer0.nextToken(token1);
    int int0 = cSVLexer0.readEscape();
    assertEquals(10, int0);
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test3030() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    StringReader stringReader0 = new StringReader(""b&:`h!"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    int int0 = cSVLexer0.readEscape();
    assertEquals(8, int0);
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test3131() throws Throwable {
    StringReader stringReader0 = new StringReader(""\n"");
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    int int0 = cSVLexer0.readEscape();
    assertEquals(10, int0);
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test3232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""@f'wJZhwZt,3vp"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    int int0 = cSVLexer0.readEscape();
    assertEquals(64, int0);
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test3233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""@f'wJZhwZt,3vp"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    int int0 = cSVLexer0.readEscape();
    int int1 = cSVLexer0.readEscape();
    assertEquals(12, int1);
}",""
"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","public void test3334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);
    try {
        cSVLexer0.readEscape();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // EOF whilst processing escape sequence
        //
        verifyException(""org.apache.commons.csv.Lexer"", e);
    }
}",""
"long getLineNumber() {
    return in.getLineNumber();
}","public void test3435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, (ExtendedBufferedReader) null);
    // Undeclared exception!
    try {
        cSVLexer0.getLineNumber();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.Lexer"", e);
    }
}",""
