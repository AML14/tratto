focal_method,test_prefix,docstring
"int readAgain() {
    return lastChar;
}","public void test012() throws Throwable {
    StringReader stringReader0 = new StringReader(""#L';"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    extendedBufferedReader0.readLine();
    int int0 = extendedBufferedReader0.readAgain();
    assertEquals(59, int0);
}","/**
 * Returns the last character that was read as an integer (0 to 65535). This
 * will be the last character returned by any of the read methods. This will
 * not include a character read using the {@link #peek()} method. If no
 * character has been read then this will return {@link #UNDEFINED}. If the
 * end of the stream was reached on the last read then this will return
 * {@link #END_OF_STREAM}.
 *
 * @return the last character that was read
 */"
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test023() throws Throwable {
    StringReader stringReader0 = new StringReader(""boZvf?Qd*`9`KeVb"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    char[] charArray0 = new char[4];
    int int0 = extendedBufferedReader0.read(charArray0, 1, 1);
    assertArrayEquals(new char[] { '\u0000', 'b', '\u0000', '\u0000' }, charArray0);
}",""
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test035() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    char[] charArray0 = new char[8];
    int int0 = extendedBufferedReader0.read(charArray0, 1, 1);
    assertEquals((-1), int0);
}",""
"@Override
public int read() throws IOException {
    int current = super.read();
    if (current == '\n') {
        lineCounter++;
    }
    lastChar = current;
    return lastChar;
}","public void test046() throws Throwable {
    StringReader stringReader0 = new StringReader("" &<{#6k<1v"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.read();
    assertEquals(32, int0);
}",""
"int lookAhead() throws IOException {
    super.mark(1);
    int c = super.read();
    super.reset();
    return c;
}","public void test057() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.lookAhead();
    assertEquals((-1), int0);
}","/**
 * Returns the next character in the current reader without consuming it. So
 * the next call to {@link #read()} will still return this value.
 *
 * @return the next character
 *
 * @throws IOException if there is an error in reading
 */"
"int getLineNumber() {
    return lineCounter;
}","public void test068() throws Throwable {
    StringReader stringReader0 = new StringReader(""=}5@\""rMHcw|cN^aFv"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    extendedBufferedReader0.readLine();
    int int0 = extendedBufferedReader0.getLineNumber();
    assertEquals(1, int0);
}","/**
 * Returns the nof line read
 *
 * @return the current-line-number (or -1)
 */"
"@Override
public String readLine() throws IOException {
    String line = super.readLine();
    if (line != null) {
        if (line.length() > 0) {
            lastChar = line.charAt(line.length() - 1);
        }
        lineCounter++;
    } else {
        lastChar = END_OF_STREAM;
    }
    return line;
}","public void test079() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    extendedBufferedReader0.close();
    try {
        extendedBufferedReader0.readLine();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).
 * This method should only be called when processing a comment, otherwise
 * information can be lost.
 * <p>
 * Increments  {@link #lineCounter}
 * <p>
 * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF,
 * otherwise to last character on the line (won't be CR or LF)
 *
 * @return the line that was read, or null if reached EOF.
 */"
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test0810() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    // Undeclared exception!
    try {
        extendedBufferedReader0.read((char[]) null, 13, 2033);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test0911() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    char[] charArray0 = new char[7];
    // Undeclared exception!
    try {
        extendedBufferedReader0.read(charArray0, 3327, (-1));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}",""
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test1012() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    char[] charArray0 = new char[0];
    extendedBufferedReader0.close();
    try {
        extendedBufferedReader0.read(charArray0, 1037, (-2));
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}",""
"@Override
public int read() throws IOException {
    int current = super.read();
    if (current == '\n') {
        lineCounter++;
    }
    lastChar = current;
    return lastChar;
}","public void test1113() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    extendedBufferedReader0.close();
    try {
        extendedBufferedReader0.read();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}",""
"int lookAhead() throws IOException {
    super.mark(1);
    int c = super.read();
    super.reset();
    return c;
}","public void test1214() throws Throwable {
    StringReader stringReader0 = new StringReader(""opSYBLwPTmB1-~!u<W&"");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    extendedBufferedReader0.close();
    try {
        extendedBufferedReader0.lookAhead();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Returns the next character in the current reader without consuming it. So
 * the next call to {@link #read()} will still return this value.
 *
 * @return the next character
 *
 * @throws IOException if there is an error in reading
 */"
"@Override
public String readLine() throws IOException {
    String line = super.readLine();
    if (line != null) {
        if (line.length() > 0) {
            lastChar = line.charAt(line.length() - 1);
        }
        lineCounter++;
    } else {
        lastChar = END_OF_STREAM;
    }
    return line;
}","public void test1315() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    String string0 = extendedBufferedReader0.readLine();
    assertNull(string0);
}","/**
 * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).
 * This method should only be called when processing a comment, otherwise
 * information can be lost.
 * <p>
 * Increments  {@link #lineCounter}
 * <p>
 * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF,
 * otherwise to last character on the line (won't be CR or LF)
 *
 * @return the line that was read, or null if reached EOF.
 */"
"@Override
public int read(char[] buf, int offset, int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            char ch = buf[i];
            if (ch == '\n') {
                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {
                    lineCounter++;
                }
            } else if (ch == '\r') {
                lineCounter++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == -1) {
        lastChar = END_OF_STREAM;
    }
    return len;
}","public void test1416() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    char[] charArray0 = new char[18];
    int int0 = extendedBufferedReader0.read(charArray0, (-1), 0);
    assertEquals(0, int0);
}",""
"@Override
public int read() throws IOException {
    int current = super.read();
    if (current == '\n') {
        lineCounter++;
    }
    lastChar = current;
    return lastChar;
}","public void test1517() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.read();
    assertEquals((-1), int0);
}",""
"int readAgain() {
    return lastChar;
}","public void test1618() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.readAgain();
    assertEquals((-2), int0);
}","/**
 * Returns the last character that was read as an integer (0 to 65535). This
 * will be the last character returned by any of the read methods. This will
 * not include a character read using the {@link #peek()} method. If no
 * character has been read then this will return {@link #UNDEFINED}. If the
 * end of the stream was reached on the last read then this will return
 * {@link #END_OF_STREAM}.
 *
 * @return the last character that was read
 */"
"int lookAhead() throws IOException {
    super.mark(1);
    int c = super.read();
    super.reset();
    return c;
}","public void test1719() throws Throwable {
    StringReader stringReader0 = new StringReader(""."");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.lookAhead();
    assertEquals(46, int0);
}","/**
 * Returns the next character in the current reader without consuming it. So
 * the next call to {@link #read()} will still return this value.
 *
 * @return the next character
 *
 * @throws IOException if there is an error in reading
 */"
"int getLineNumber() {
    return lineCounter;
}","public void test1820() throws Throwable {
    StringReader stringReader0 = new StringReader("""");
    ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);
    int int0 = extendedBufferedReader0.getLineNumber();
    assertEquals(0, int0);
}","/**
 * Returns the nof line read
 *
 * @return the current-line-number (or -1)
 */"
