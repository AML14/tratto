focal_method,test_prefix,docstring
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test0000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = CSVFormat.TDF;
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test0011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test0012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test0013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test0014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test0016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test0017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test0018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test0019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertEquals('~', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test00428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test00434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertEquals('W', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('~');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('W');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertTrue(cSVFormat3.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test00538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test00650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test00754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00758() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00866() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test00867() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertEquals('T', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00868() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    Character character0 = Character.valueOf('?');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00971() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test00972() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00973() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test01076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test01079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test01080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01081() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01082() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test01183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test01185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test01186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test01188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test01189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test01190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test01191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test01192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test01193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test01194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test01195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test01296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test01297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test01298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test01299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test012100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test012101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test012102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test012103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test012104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test013105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals('n', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test013106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test013107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test013109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test013110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test013111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test013112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test013113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test013114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test014116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test014117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test014118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test014119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test014120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test014121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test014122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test014123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test015125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test015126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test015127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test015128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test015129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test015130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test015131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test015132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test015133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test015134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test015136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test015137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test015138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test016139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test016141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test016143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test016144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test016145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test016146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test016147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test017148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test017149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test017150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test017151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test017152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test018153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test018154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertEquals('X', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test018155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test018156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test018157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test018158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test018159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test018160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test019161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test019162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test019163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test019164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test019165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test019167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test019168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test019169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test019170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test019171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test019172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test019173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test019175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test019176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test019177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test020178() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test020179() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test020180() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test020181() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test020182() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test020183() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test021184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test021185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test021186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test021187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test021188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test021189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test022190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test022191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test022192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test022193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test022194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test023195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test023196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test023197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test023198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test023199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test023200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test024201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test024202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test024203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test024205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test024206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test024207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test024208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test024210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test024211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test024212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test024214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test024215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('i');
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test025216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test025219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test025220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test025221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test025222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test025223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test025224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test025225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test025226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test026227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test026229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test026231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test026232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test026233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test027234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test027235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test027236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test027237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test027238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test027239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test027240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test027241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test027242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test027243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test027244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test027245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test028246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test028247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test028248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test028249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withRecordSeparator((String) null);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test028250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withRecordSeparator((String) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test029251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test029252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test029253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test029254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test029255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test029256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test029257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test029258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test029259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test029260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""Y"");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test030261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test030262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test030263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test030264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test030265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test030266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test030267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test030268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test030269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test030270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test030271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""MhFw]fUdY$V{;"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test031272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test031273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals(""|"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test031274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test031275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test031276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test031277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test031278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test031279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals('Q', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test031280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test031281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test031282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test031283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test031284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test032285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test032286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test032287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test032288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test032289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertEquals(""("", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test032290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('(');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test033291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals(""|"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test033292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test033293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test033294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test033295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test033296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test034297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test034298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test034299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertEquals(""|"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test034300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test034301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test034302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('|');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test035303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test035304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test035305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test035306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test035307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test035308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('z');
    assertEquals(""z"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test036309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test036310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test036311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test036312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test036313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test036314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test036315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test036316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test036318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test036319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object[] objectArray0 = new Object[6];
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withHeaderComments(objectArray0);
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test037320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test037321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test037322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test037323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test037324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('=', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test037325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test037326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test037327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test037328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test037329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('=');
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test038330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test038331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test038332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test038333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test038334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.MINIMAL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test039335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test039336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test039337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test039338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test039339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test039340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test039341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test040342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test040343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test040344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test040345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test040346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test040347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test040348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test040349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test040350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test040351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test040352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test041353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test041354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test041355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test041356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test041357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test042358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test042359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test042360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test042361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test042362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    QuoteMode quoteMode0 = QuoteMode.ALL;
    cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test043363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test043364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test043365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test043366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test043367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test044368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test044369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test044370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test044371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test044372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test045373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = new Character(';');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test045374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = new Character(';');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test045375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = new Character(';');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test045376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = new Character(';');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test045377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = new Character(';');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test046378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test046379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test046380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test046381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test046382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test046383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test046384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test046385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test046386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('&');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test047387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test047388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test047389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test047390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test047391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test047392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test047393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test047394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test047395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test047396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test047397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    Character character0 = new Character('m');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test048398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test048399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test048400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test048401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test048402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = new Character('&');
    cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test049403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test049404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test049405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test049406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test049407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test049408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test049409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test049410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertEquals('Z', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test049411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test049412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test049413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('_');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test050414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test050415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test050416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test050417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test050418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertEquals(',', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test050419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(',');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test051420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test051421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test051422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test051423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test051424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertEquals('T', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test051425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test051426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertEquals('M', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test051427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test051428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test051429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('M');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test052430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test052431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test052432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test052433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test052434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test052435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test052436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test052437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test052438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test052439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test052440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('(');
    assertEquals('(', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test053441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test053442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertTrue(cSVFormat4.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test053443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertFalse(cSVFormat4.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test053444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test053445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test053446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertEquals('_', (char) cSVFormat4.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test053447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test053448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test053449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('_');
    CSVFormat cSVFormat4 = cSVFormat3.withSkipHeaderRecord();
    assertFalse(cSVFormat4.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test054450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test054451() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test054452() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test054453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test054454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test054455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test054456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test054457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test054458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test054459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withNullString((String) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test055460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withNullString(""JRzCqQy[GrFn>gH"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test055461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withNullString(""JRzCqQy[GrFn>gH"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test055462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withNullString(""JRzCqQy[GrFn>gH"");
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test055463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withNullString(""JRzCqQy[GrFn>gH"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test055464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withNullString(""JRzCqQy[GrFn>gH"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test056465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withNullString(""Up^n`W:D"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test056466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withNullString(""Up^n`W:D"");
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test056467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withNullString(""Up^n`W:D"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test056468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withNullString(""Up^n`W:D"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test056469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    cSVFormat1.withNullString(""Up^n`W:D"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test057470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test057471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test057472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test057473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertEquals(""url"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test057474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test057475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test057477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test057478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test057479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test057480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""url"");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test058481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withNullString("""");
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test058482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withNullString("""");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test058483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withNullString("""");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test058484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withNullString("""");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test058485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withNullString("""");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test059486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test059487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test059488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test059489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test059490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test059491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test059492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test059493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test059494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test059495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test059496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test060497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test060498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test060499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test060500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test060501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test060502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test060503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test060504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test061505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test061507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test061508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test061510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test061511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test061512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test061513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test061514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test061515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test062516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test062517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test062518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test062519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test062520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test062521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test062522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test062523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test062524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test062525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test062526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test063527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test063528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test063529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test063530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test063531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test063532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test063533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test063534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test063535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test064536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test064537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test064538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test064539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test064540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test065541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test065542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test065543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test065544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test065545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test065546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test065547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test065548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test065549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test065550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test065551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test066552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test066553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test066554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test066555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test066556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test066557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test066558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test066559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test066560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test066561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test066562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test066563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test066564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals('n', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test066565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test066566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test066567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test066568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test067569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test067570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test067571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test067572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test067573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test067574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test067575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test067578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test068579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test068580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test068581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test068582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test068583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test068584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test068585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test068586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test068587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test068588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test068589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test068590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test068591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test068592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test068593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test068594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test069595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test069596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test069597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test069598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test069599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test069600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test069601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test069602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test069603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test070604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test070605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test070606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test070607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test070608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test071609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test071610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test071611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test071612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test071613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test071614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test071615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test071616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test071617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test071618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test071619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""url"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test072620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test072621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertEquals('!', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test072622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test072623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test072624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test072625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test072626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test072627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test072628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test072629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test072630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('!');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test073631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test073632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test073633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test073634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test073635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test074636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test074637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test074638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test074639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test074640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test075641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test075642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test075643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test075644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test075645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test075646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test075647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test075648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test075649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test076650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test076651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test076652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test076653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test076654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test076655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test076656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test076657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test076658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test076659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test076660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test076661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test077662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test077663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test077664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test077665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test077666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test077667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test077668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test077669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test077670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test077671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test077672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertEquals('p', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test077673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test077674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test077675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test077676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test078677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test078678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test078679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test078680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test078681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test078682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test078683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test078684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test078685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test079686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test079687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test079688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test079689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test079690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test079691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test079692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test079693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test079694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test080695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test080696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test080697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test080698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test080699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test080700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test080701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test080702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test080703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test080704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test080705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test080706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test080707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test081708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test081709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test081710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test081711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test081712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test081713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test081714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test081715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test081716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test082717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test082718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test082719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test082720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test082721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test083722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test083723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test083724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test083725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test083726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test083727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test083728() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test083729() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test084730() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test084731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test084732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test084733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test084734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test084735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test084736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test084737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test084738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test084739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test085740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test085741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test085742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test085743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test085744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test085745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test085746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test085747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test085748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test085749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test086750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test086751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test086752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test086753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test086754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test086755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test086756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test086757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character(' ');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test087758() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test087759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test087760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test087761() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test087762() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test087763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test087764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test087765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test087766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test087767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test087768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test088769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test088770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test088771() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test088772() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test088773() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test088774() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test088775() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test088776() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test088777() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test089778() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test089779() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test089780() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test089781() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test089782() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test090783() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test090784() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test090785() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test090786() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test090787() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test090788() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test090789() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test090790() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test090791() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test090792() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test090793() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test091794() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test091795() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test091796() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test091797() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test091798() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test091799() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test091800() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertEquals('$', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test091801() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test091802() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test092803() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""{"");
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test092804() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""{"");
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test092805() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""{"");
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test092806() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""{"");
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test092807() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""{"");
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test093808() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[1];
    cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test093809() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[1];
    cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test093810() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[1];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test093811() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[1];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test093812() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[1];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test094813() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test094814() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test094815() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test094816() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test094817() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test094818() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test094819() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test094820() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test094821() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test094822() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test094823() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Object[] objectArray0 = new Object[8];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test095824() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertEquals(""9"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test095825() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test095826() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test095827() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test095828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test095829() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test095830() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test095831() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test095832() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test095833() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test095834() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('9');
    Object[] objectArray0 = new Object[4];
    CSVFormat cSVFormat3 = cSVFormat2.withHeaderComments(objectArray0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test096835() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[7];
    cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test096836() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[7];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test096837() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[7];
    cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test096838() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[7];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test096839() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Object[] objectArray0 = new Object[7];
    cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test097840() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test097841() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test097842() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test097843() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test097844() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test097845() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test097846() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getNullString() {
    return nullString;
}","public void test097847() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test097848() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test097849() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test097850() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreEmptyLines(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test098851() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test098852() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test098853() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test098854() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test098855() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test098856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test098857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test098858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test098859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test098860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test098861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('n');
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""YH H,"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertEquals('n', (char) cSVFormat3.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test099862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    String[] stringArray0 = new String[0];
    cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test099863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    String[] stringArray0 = new String[0];
    cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test099864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    String[] stringArray0 = new String[0];
    cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test099865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    String[] stringArray0 = new String[0];
    cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test099866() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    String[] stringArray0 = new String[0];
    cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test100867() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test100868() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test100869() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test100870() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test100871() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test100872() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test100873() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test100874() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test100875() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test100876() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test101877() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test101878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test101879() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test101880() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test101881() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test101882() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test101883() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test101884() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test101885() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test102886() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test102887() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test102888() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test102889() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test102890() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test103891() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test103892() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test103893() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test103894() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test103895() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test104896() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test104897() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test104898() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test104899() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test104900() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test105901() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test105902() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test105903() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test105904() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test105905() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test105906() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test105907() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test105908() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test105909() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test105910() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test105911() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test106912() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test106913() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test106914() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test106915() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test106916() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test107917() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test107918() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test107919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test107920() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test107921() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test107922() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test107923() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test107924() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test107925() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('%');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test108926() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test108927() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test108928() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test108929() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test108930() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test109931() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test109932() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test109933() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test109934() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test109935() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test109936() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test109937() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test109938() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test109939() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test109940() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test110941() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test110942() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test110943() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test110944() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test110945() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test111946() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test111947() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertEquals('\t', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test111948() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertEquals("""", cSVFormat4.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test111949() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test111950() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test111951() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test111952() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test111953() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertTrue(cSVFormat4.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test111954() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertEquals(""\n"", cSVFormat4.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test111955() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat4.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test111956() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    Character character0 = new Character('\""');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString("""");
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat4 = cSVFormat3.withHeader(class0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test112957() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test112958() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test112959() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test112960() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test112961() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test113962() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test113963() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test113964() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test113965() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test113966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test114967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test114968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test114969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test114970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test114971() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test114972() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test114973() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test114974() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test115975() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test115976() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test115977() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test115978() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test115979() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test116980() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test116981() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertEquals('[', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test116982() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test116983() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test116984() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test116985() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test116986() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test116987() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test116988() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test116989() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertEquals('b', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test116990() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test116991() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test116992() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test116993() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test116994() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test116995() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test116996() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('b');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withCommentMarker('[');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test117997() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test117998() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test117999() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1171000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1171001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1171002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1171003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1171004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1181005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1181006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1181007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1181008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1181009() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1181010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1181011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1191012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1191013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1191014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1191015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1191016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1191017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1191018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('p', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1191019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1191020() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1191021() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1191022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = new Character('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('p');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1201023() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""r;FMG6%'p`{&g"");
    Character character0 = new Character('M');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1201024() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""r;FMG6%'p`{&g"");
    Character character0 = new Character('M');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1201025() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""r;FMG6%'p`{&g"");
    Character character0 = new Character('M');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1201026() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""r;FMG6%'p`{&g"");
    Character character0 = new Character('M');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1201027() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""r;FMG6%'p`{&g"");
    Character character0 = new Character('M');
    CSVFormat cSVFormat3 = cSVFormat2.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1211028() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1211029() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1211030() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1211031() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1211032() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1211033() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1211034() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1211035() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1211036() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1221037() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1221038() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1221039() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1221040() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1221041() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1221042() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1221043() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1221044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1221045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1221046() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    Character character0 = new Character('l');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1231047() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('j');
    cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1231048() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('j');
    cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1231049() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('j');
    cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1231050() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('j');
    cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1231051() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('j');
    cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1241052() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertEquals('=', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1241053() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1241054() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1241055() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1241056() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1241057() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1241058() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1241059() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1241060() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1241061() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1241062() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = Character.valueOf('=');
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withEscape(character0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test1251063() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1251064() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1251065() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertEquals('I', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1251066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1251067() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1251068() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1251069() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1251070() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1251071() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1251072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1251073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1251074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('I');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1261075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1261076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertEquals('D', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1261077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1261078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1261079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1261080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1261081() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1261082() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1261083() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1261084() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('D');
    assertEquals('$', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1271085() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1271086() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1271087() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1271088() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1271089() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertEquals('L', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1271090() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('L');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1281091() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1281092() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1281093() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1281094() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1281095() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1281096() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    assertEquals('c', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1291097() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1291098() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertEquals('c', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1291099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1291100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1291101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1291102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1291103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1291104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1291105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1291106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1291107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1291108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1291109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('c');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1301110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1301111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1301112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1301113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1301114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertEquals('I', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1301115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('I');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1311116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1311117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1311118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1311119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1311120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1311121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1311122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1311123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1311124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertEquals('.', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1311125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1311126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test1311127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter('.');
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1321128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertEquals('5', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1321129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1321130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1321131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1321132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1321133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1321134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1321135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1321136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1321137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1321138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withDelimiter('5');
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1331139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertEquals('8', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1331140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1331141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1331142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1331143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1331144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1331145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1331146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1331147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1331148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1331149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('O');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('8');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1341150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1341151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1341152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1341153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1341154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1341155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('`');
    assertEquals('`', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1351156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1351157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1351158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1351159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1351160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1351161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1351162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1351163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1351164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertEquals('|', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1351165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1351166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('|');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1361167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1361168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1361169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1361170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1361171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1361172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('M');
    assertEquals('M', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1371173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1371174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1371175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1371176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1371177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1371178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1371179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1371180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1371181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1371182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1371183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1371184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1371185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1381186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf(':');
    cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1381187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf(':');
    cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1381188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf(':');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1381189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf(':');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1381190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf(':');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1391191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    Character character0 = new Character('*');
    cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1391192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    Character character0 = new Character('*');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1391193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    Character character0 = new Character('*');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1391194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    Character character0 = new Character('*');
    cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1391195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    Character character0 = new Character('*');
    cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1401196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker((Character) null);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1401197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker((Character) null);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1401198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker((Character) null);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1401199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker((Character) null);
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1401200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator("""");
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1411201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1411202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertEquals('R', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1411203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1411204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1411205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1411206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('R');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1421207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1421208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1421209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1421210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertEquals('\'', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1421211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1421212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\'');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1431213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1431214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1431215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertEquals('l', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1431216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1431217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrim() {
    return trim;
}","public void test1431218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1431219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1431220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test1431221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1431222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1431223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('l');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1441224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1441225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1441226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1441227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1441228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1441229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('o');
    assertEquals('o', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1451230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1451231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1451232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1451233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1451234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1451235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1451236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1451237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1451238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1461239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1461240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1461241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1461242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1461243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1471244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1471245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1471246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1471247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1471248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1471249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1471250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1471251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1471252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1471253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1471254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1471255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('*');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1481256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1481257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1481258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1481259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1481260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1481261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1481262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1481263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1481264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1481265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1481266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1491267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1491268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1491269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1491270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1491271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1501272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1501273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1501274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1501275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1501276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1501277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1501278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1501279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1501280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = new Character('M');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1511281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1511282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1511283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1511284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1511285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1511286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1521287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1521288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1521289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1521290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1521291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1521292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1521293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1521294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1531295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1531296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1531297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertEquals(""z"", cSVFormat3.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1531298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1531299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1531300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertTrue(cSVFormat3.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1531301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1531302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1531303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1531304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1531305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1531306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator('z');
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1541307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1541308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1541309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1541310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1541311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1541312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1541313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1541314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1541315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1541316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1541317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1551318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1551319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1551320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1551321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1551322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1551323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1551324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1551325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1551326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1561327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat1.getTrim();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1561328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat1.getTrim();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1561329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat1.getTrim();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1561330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat1.getTrim();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1561331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat1.getTrim();
    assertTrue(boolean0);
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1571332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    boolean boolean0 = cSVFormat1.getTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1571333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    boolean boolean0 = cSVFormat1.getTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1571334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    boolean boolean0 = cSVFormat1.getTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1571335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    boolean boolean0 = cSVFormat1.getTrailingDelimiter();
    assertTrue(boolean0);
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1571336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    boolean boolean0 = cSVFormat1.getTrailingDelimiter();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1581337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertNull(character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getNullString() {
    return nullString;
}","public void test1591338() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    String string0 = cSVFormat0.getNullString();
    assertEquals(""\\N"", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1601339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1601340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1601341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1601342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1601343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1601344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1601345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test1601346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1601347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1601348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1601349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1601350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test1601351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    String string0 = cSVFormat2.getNullString();
    assertEquals("""", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1611352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1611353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1611354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1611355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1611356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1611357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1611358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1611359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1611360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1611361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1611362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1621363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1621364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1621365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1621366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1621367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1631368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1631369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertEquals('x', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test1631370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1631371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1631372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1631373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1631374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1631375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1641376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1641377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1641378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1641379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1641380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1641381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1641382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1641383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1641384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1641385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test1651386() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test1651387() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1651388() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1651389() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1651390() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1651391() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1651392() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1651393() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1651394() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1651395() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1651396() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertNotNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1651397() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withIgnoreHeaderCase();
    Character character0 = cSVFormat1.getEscapeCharacter();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1661398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1661399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1661400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1661401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1661402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1661403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1661404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1661405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1661406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1661407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withDelimiter('I');
    char char0 = cSVFormat1.getDelimiter();
    assertEquals('I', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1671408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1671409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1671410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1671411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1671412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1671413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1671414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1671415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1671416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertEquals('Q', (char) character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1671417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1671418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Q');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1681419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertFalse(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test1691420() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Default;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Object[] objectArray0 = new Object[0];
    String string0 = cSVFormat0.format(objectArray0);
    assertEquals("""", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public CSVFormat withQuote(final char quoteChar) {
    return withQuote(Character.valueOf(quoteChar));
}","public void test1701421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('=');
    // Undeclared exception!
    try {
        cSVFormat0.withQuote('=');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('=')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {
    return withHeader(resultSet != null ? resultSet.getMetaData() : null);
}","public void test1711422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ResultSetMetaData resultSetMetaData0 = mock(ResultSetMetaData.class, new ViolatedAssumptionAnswer());
    doReturn((-1575)).when(resultSetMetaData0).getColumnCount();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(resultSetMetaData0).when(resultSet0).getMetaData();
    // Undeclared exception!
    try {
        cSVFormat0.withHeader(resultSet0);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can
 * either be parsed automatically from the input file with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader();
 * </pre>
 *
 * or specified manually with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader(resultSet);
 * </pre>
 * <p>
 * The header is also used by the {@link CSVPrinter}.
 * </p>
 *
 * @param resultSet
 *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified
 *            otherwise.
 *
 * @return A new CSVFormat that is equal to this but with the specified header
 * @throws SQLException
 *             SQLException if a database access error occurs or this method is called on a closed result set.
 * @since 1.1
 */"
"public CSVFormat withEscape(final Character escape) {
    if (isLineBreak(escape)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test1721423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('B');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withEscape(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('B')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.
 *
 * @param escape
 *            the escape character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withDelimiter(final char delimiter) {
    if (isLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test1731424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('^');
    // Undeclared exception!
    try {
        cSVFormat1.withDelimiter('^');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The escape character and the delimiter cannot be the same ('^')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.
 *
 * @param delimiter
 *            the delimiter character
 * @return A new CSVFormat that is equal to this with the specified character as delimiter
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final char commentMarker) {
    return withCommentMarker(Character.valueOf(commentMarker));
}","public void test1741425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('f');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withCommentMarker('f');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('f')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public void println(final Appendable out) throws IOException {
    if (getTrailingDelimiter()) {
        out.append(getDelimiter());
    }
    if (recordSeparator != null) {
        out.append(recordSeparator);
    }
}","public void test1751426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.println((Appendable) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Outputs the record separator.
 *
 * @param out
 *            where to write
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.4
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test1761427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) cSVFormat0;
    Charset charset0 = Charset.defaultCharset();
    ByteBuffer byteBuffer0 = ByteBuffer.allocate(44);
    CharBuffer charBuffer0 = charset0.decode(byteBuffer0);
    // Undeclared exception!
    try {
        cSVFormat0.printRecord(charBuffer0, objectArray0);
        fail(""Expecting exception: BufferOverflowException"");
    } catch (BufferOverflowException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.Buffer"", e);
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test1771428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CharBuffer charBuffer0 = CharBuffer.allocate(53);
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) charBuffer0;
    // Undeclared exception!
    try {
        cSVFormat0.EXCEL.printRecord(charBuffer0, objectArray0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // 53
        //
        verifyException(""java.nio.HeapCharBuffer"", e);
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public CSVPrinter print(final Path out, Charset charset) throws IOException {
    return print(out.toFile(), charset);
}","public void test1781429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Charset charset0 = Charset.defaultCharset();
    // Undeclared exception!
    try {
        cSVFormat0.RFC4180.print((Path) null, charset0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public CSVPrinter print(final Path out, Charset charset) throws IOException {
    return print(out.toFile(), charset);
}","public void test1791430() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    MockFile mockFile0 = new MockFile("""");
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    try {
        cSVFormat0.TDF.print(path0, charset0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        charSequence = nullString == null ? Constants.EMPTY : nullString;
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test1801431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Integer integer0 = new Integer(44);
    CharBuffer charBuffer0 = CharBuffer.allocate(10);
    // Undeclared exception!
    try {
        cSVFormat0.print((Object) integer0, (Appendable) charBuffer0, true);
        fail(""Expecting exception: BufferOverflowException"");
    } catch (BufferOverflowException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.CharBuffer"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        charSequence = nullString == null ? Constants.EMPTY : nullString;
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test1811432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    PipedWriter pipedWriter0 = new PipedWriter();
    try {
        cSVFormat0.EXCEL.print((Object) cSVFormat0, (Appendable) pipedWriter0, true);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedWriter"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test1821433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockFile mockFile0 = new MockFile(""cZ<"", ""cZ<"");
    // Undeclared exception!
    try {
        cSVFormat0.print((File) mockFile0, (Charset) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // charset
        //
        verifyException(""java.io.OutputStreamWriter"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test1831434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockFile mockFile0 = new MockFile("""");
    try {
        cSVFormat0.print((File) mockFile0, (Charset) null);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test1841435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.parse((Reader) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1851436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1851437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1851438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1851439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1851440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1871443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1871444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1871445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertEquals('T', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1871446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1871447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1871448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1871449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    StringWriter stringWriter0 = new StringWriter();
    cSVFormat0.println(stringWriter0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1881450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1156);
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0);
    cSVFormat0.print((Object) cSVFormat0, (Appendable) outputStreamWriter0, true);
    assertTrue(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        charSequence = nullString == null ? Constants.EMPTY : nullString;
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test1901453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.print((Object) null, (Appendable) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1911454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isQuoteCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1921455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isQuoteCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1931456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.isNullStringSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1941457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1951458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1961459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1961460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1961461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1961462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1961463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals('$', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test1961464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1961465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1961466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1961467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1961468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1961469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('$');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test1971470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isCommentMarkerSet();
    assertFalse(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public String[] getHeaderComments() {
    return headerComments != null ? headerComments.clone() : null;
}","public void test1981471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = cSVFormat0.getHeaderComments();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header comment array.
 *
 * @return a copy of the header comment array; {@code null} if disabled.
 */"
"public String getNullString() {
    return nullString;
}","public void test1991472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1991473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1991474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1991475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test1991476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertEquals(0, stringArray0.length);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1991477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1991478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1991479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1991480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1991481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1991482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withFirstRecordAsHeader();
    String[] stringArray0 = cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test2001483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    String[] stringArray0 = cSVFormat0.getHeader();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file
 */"
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test2011484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    MockFile mockFile0 = new MockFile(""00)eAXO"", ""!/mBjw;f#YIuz#"");
    Charset charset0 = Charset.defaultCharset();
    CSVPrinter cSVPrinter0 = cSVFormat0.print((File) mockFile0, charset0);
    assertNotNull(cSVPrinter0);
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public QuoteMode getQuoteMode() {
    return quoteMode;
}","public void test2021485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    cSVFormat0.getQuoteMode();
}","/**
 * Returns the quote policy output fields.
 *
 * @return the quote policy
 */"
"public boolean getTrim() {
    return trim;
}","public void test2031486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.getTrim();
    assertFalse(boolean0);
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2041487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2051488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertFalse(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2061489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""format"");
    cSVFormat1.println(mockPrintStream0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2061490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""format"");
    cSVFormat1.println(mockPrintStream0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2061491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""format"");
    cSVFormat1.println(mockPrintStream0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2061492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""format"");
    cSVFormat1.println(mockPrintStream0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2061493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""format"");
    cSVFormat1.println(mockPrintStream0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2071494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2071495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2071496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2071497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2071498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2071499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2071500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2071501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2071502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2071503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test2081504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = cSVFormat0.getCommentMarker();
    assertNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2091505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2101506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertTrue(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2111507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreHeaderCase();
    assertFalse(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2121508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    boolean boolean0 = cSVFormat0.getTrailingDelimiter();
    assertFalse(boolean0);
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2131509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    char char0 = cSVFormat0.getDelimiter();
    assertEquals(',', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {
    return withHeader(resultSet != null ? resultSet.getMetaData() : null);
}","public void test2141510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    ResultSetMetaData resultSetMetaData0 = mock(ResultSetMetaData.class, new ViolatedAssumptionAnswer());
    doReturn(3248).when(resultSetMetaData0).getColumnCount();
    doReturn((String) null, (String) null, (String) null, (String) null, (String) null).when(resultSetMetaData0).getColumnLabel(anyInt());
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(resultSetMetaData0).when(resultSet0).getMetaData();
    // Undeclared exception!
    try {
        cSVFormat0.withHeader(resultSet0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The header contains a duplicate entry: 'null' in [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can
 * either be parsed automatically from the input file with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader();
 * </pre>
 *
 * or specified manually with:
 *
 * <pre>
 * CSVFormat format = aformat.withHeader(resultSet);
 * </pre>
 * <p>
 * The header is also used by the {@link CSVPrinter}.
 * </p>
 *
 * @param resultSet
 *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified
 *            otherwise.
 *
 * @return A new CSVFormat that is equal to this but with the specified header
 * @throws SQLException
 *             SQLException if a database access error occurs or this method is called on a closed result set.
 * @since 1.1
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2151511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2151512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2151513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2151514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2151515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2151516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2151517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertEquals('8', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2151518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2151519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSet) null);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2161520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2161521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2161522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2161523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2161524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {
    return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test2181526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    QuoteMode quoteMode0 = QuoteMode.NONE;
    // Undeclared exception!
    try {
        cSVFormat0.RFC4180.withQuoteMode(quoteMode0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No quotes mode set but no escape character is set
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.
 *
 * @param quoteModePolicy
 *            the quote policy to use for output.
 *
 * @return A new CSVFormat that is equal to this but with the specified quote policy
 */"
"public CSVFormat withEscape(final char escape) {
    return withEscape(Character.valueOf(escape));
}","public void test2191527() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('m');
    // Undeclared exception!
    try {
        cSVFormat1.withEscape('m');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('m')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.
 *
 * @param escape
 *            the escape character
 * @return A new CSVFormat that is equal to his but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test2201528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('2');
    Character character0 = Character.valueOf('2');
    // Undeclared exception!
    try {
        cSVFormat1.withCommentMarker(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('2')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker, use {@code null} to disable
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test2211529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    Character character0 = new Character('8');
    // Undeclared exception!
    try {
        cSVFormat0.withCommentMarker(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the delimiter cannot be the same ('8')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker, use {@code null} to disable
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final Character quoteChar) {
    if (isLineBreak(quoteChar)) {
        throw new IllegalArgumentException(""The quoteChar cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);
}","public void test2221530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    Character character0 = new Character('9');
    // Undeclared exception!
    try {
        cSVFormat0.withQuote(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('9')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2231531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2231532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2231533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2231534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2231535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2231536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2231537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2231538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2231539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2231540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2231541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2241542() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2241543() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2241544() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\n> EmptyLines:ignored SkipHeaderRecord:true Header:[]"", string0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2241545() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2251546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2251547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2251548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> IgnoreHeaderCase:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2251549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2261550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2261551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2261552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<8> SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2261553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('8');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2271554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2271555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2271556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertEquals('|', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2271557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2271558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2271559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2271560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2271561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    URI uRI0 = MockURI.aFileURI;
    MockFile mockFile0 = new MockFile(uRI0);
    Path path0 = mockFile0.toPath();
    Charset charset0 = Charset.defaultCharset();
    cSVFormat2.print(path0, charset0);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        charSequence = nullString == null ? Constants.EMPTY : nullString;
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test2281562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('[');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withQuote(character0);
    // Undeclared exception!
    try {
        cSVFormat1.print((Object) ""Hc.NK\""] "", (Appendable) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2291563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    String[] stringArray0 = new String[9];
    stringArray0[3] = ""40-Y^E%,tp"";
    String string0 = cSVFormat0.RFC4180.format(stringArray0);
    assertEquals("",,,\""40-Y^E%,tp\"",,,,,"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2301564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[8];
    objectArray0[7] = (Object) ""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false"";
    String string0 = cSVFormat0.format(objectArray0);
    assertEquals(""|||||||\""Delimiter=<,> QuoteChar=<\""\""> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false\"""", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        charSequence = nullString == null ? Constants.EMPTY : nullString;
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test2311565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""TDF"");
    // Undeclared exception!
    try {
        cSVFormat0.print((Object) ""TDF"", (Appendable) charBuffer0, true);
        fail(""Expecting exception: ReadOnlyBufferException"");
    } catch (ReadOnlyBufferException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.CharBuffer"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2321566() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) """";
    String string0 = cSVFormat0.INFORMIX_UNLOAD.format(objectArray0);
    assertEquals(""\""\""|||"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2331567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    String[] stringArray0 = new String[9];
    stringArray0[2] = """";
    String string0 = cSVFormat0.RFC4180.format(stringArray0);
    assertTrue(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2331568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    String[] stringArray0 = new String[9];
    stringArray0[2] = """";
    String string0 = cSVFormat0.RFC4180.format(stringArray0);
    assertEquals("",,,,,,,,"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test2341569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) cSVFormat0;
    // Undeclared exception!
    try {
        cSVFormat1.printRecord((Appendable) null, objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2351570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2351571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2351572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2351573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2351574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2351575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    Object[] objectArray0 = new Object[4];
    objectArray0[1] = (Object) cSVFormat1;
    cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2361576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2361577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertEquals('9', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2361578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2361579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2361580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2361581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2361582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('9');
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Unexpected Quote value: "", true);
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFileWriter0, true);
    cSVFormat0.MYSQL.print((Object) ""org.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\t\torg.apache.commons.csv.CSVFormat@0000000003\torg.apache.commons.csv.CSVFormat@0000000001\torg.apache.commons.csv.CSVFormat@0000000002"", (Appendable) mockPrintWriter0, true);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2371583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrim();
    Object[] objectArray0 = new Object[6];
    String string0 = cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2371584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrim();
    Object[] objectArray0 = new Object[6];
    String string0 = cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2371585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrim();
    Object[] objectArray0 = new Object[6];
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2371586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrim();
    Object[] objectArray0 = new Object[6];
    String string0 = cSVFormat1.format(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2371587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrim();
    Object[] objectArray0 = new Object[6];
    String string0 = cSVFormat1.format(objectArray0);
    assertEquals("",,,,,"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2381588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    assertFalse(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2381589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    assertFalse(cSVFormat0.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2381590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertEquals('m', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2381591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertEquals(""^Hno83gdL/?Brk5"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2381592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2381593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2381594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2381595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""^Hno83gdL/?Brk5"";
    String string0 = cSVFormat0.format(stringArray0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test2391596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals("""", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2391597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2391598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2391599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2391600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2391601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2391602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2391603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals(""\r\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2391604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2391605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2391606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2391607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test2391608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("""");
    boolean boolean0 = cSVFormat1.isNullStringSet();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2401609() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2401610() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2401611() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2401612() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> QuoteChar=<\""> CommentStart=<8> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2411613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2411614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertEquals('X', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2411615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2411616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2411617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2411618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2411619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2411620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2411621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2411622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2411623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2411624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('X');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2421625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2421626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2421627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2421628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2431629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2431630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2431631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2431632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2431633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2431634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test2431635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2431636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2431637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2431638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreHeaderCase ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test2441639() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    cSVFormat0.hashCode();
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2451640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2451641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2451642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2451643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2451644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2451645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = new Character('2');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2461646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertEquals('m', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2461647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2461648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2461649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2461650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2461651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('m');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2471652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    cSVFormat1.print((Appendable) charArrayWriter0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2471653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    cSVFormat1.print((Appendable) charArrayWriter0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2471654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    cSVFormat1.print((Appendable) charArrayWriter0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2471655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    cSVFormat1.print((Appendable) charArrayWriter0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2471656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    cSVFormat1.print((Appendable) charArrayWriter0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2481657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2481658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2481659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2481660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2481661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2481662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2481663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2491664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2491665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2491666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2491667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2491668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2491669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2491670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2491671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2491672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2491673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2501674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2501675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test2501676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2501677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2501678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2501679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2501680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2501681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2501682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2501683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test2501684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""{"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2501685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""{"");
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test2511686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2511687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2511688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2511689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2511690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2511691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2511692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2511693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2511694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    Character character0 = new Character('j');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    cSVFormat1.equals(cSVFormat0);
    assertEquals('j', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2521695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2521696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test2521697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2521698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2521699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2521700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2521701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2521702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2521703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2521704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2521705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('n');
    CSVFormat cSVFormat1 = cSVFormat0.withQuote(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2531706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2531707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2531708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2531709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(boolean0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2531710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(false);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2541711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2541712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2541713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2541714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2541715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2541716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2541717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2541718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2541719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2541720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote((Character) null);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2551721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2551722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2551723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2551724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2551725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2551726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2551727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2551728() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2551729() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2551730() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2561731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2561732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2561733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2561734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2561735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2561736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2561737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2561738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2561739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2561740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2561741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withAllowMissingColumnNames(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2571742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2571743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2571744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2571745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2571746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2571747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2571748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2571749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test2571750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2571751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2581752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2581753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2581754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2581755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertEquals('T', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2581756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2581757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2581758() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2581759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2581760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2591761() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2601762() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Short short0 = new Short((short) (-1575));
    boolean boolean0 = cSVFormat0.equals(short0);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2611763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2611764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2611765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2611766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2611767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2621768() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2621769() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2621770() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2621771() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2621772() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2621773() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2621774() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2621775() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2621776() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2621777() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2621778() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2621779() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    Character character0 = new Character('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test2631780() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getNullString();
    assertNull(string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2641781() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertTrue(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2651782() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2651783() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2651784() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2651785() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2651786() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2651787() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertEquals('c', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2651788() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2651789() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2651790() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2651791() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2651792() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.RFC4180.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('c');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2661793() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String string0 = cSVFormat0.getRecordSeparator();
    assertEquals(""\n"", string0);
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public static CSVFormat valueOf(final String format) {
    return CSVFormat.Predefined.valueOf(format).getFormat();
}","public void test2671794() throws Throwable {
    // Undeclared exception!
    try {
        CSVFormat.valueOf("",c=4hbwO~O5"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No enum constant org.apache.commons.csv.CSVFormat.Predefined.,c=4hbwO~O5
        //
        verifyException(""java.lang.Enum"", e);
    }
}","/**
 * Gets one of the predefined formats from {@link CSVFormat.Predefined}.
 *
 * @param format
 *            name
 * @return one of the predefined formats
 * @since 1.2
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2681795() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2681796() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2681797() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2681798() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2681799() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    cSVFormat1.withHeader(resultSet0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2691800() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test2691801() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2691802() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2691803() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2691804() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2691805() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2691806() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2691807() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.hashCode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2701808() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    // Undeclared exception!
    try {
        cSVFormat1.format((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2711809() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2711810() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2711811() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2711812() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2711813() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2711814() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2711815() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2711816() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2711817() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2711818() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2711819() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2721820() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2721821() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2721822() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2721823() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2721824() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2721825() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2721826() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test2721827() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2721828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2721829() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2721830() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test2731831() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        cSVFormat0.print((Appendable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'out' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2741832() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getSkipHeaderRecord();
    assertFalse(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2751833() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    PipedReader pipedReader0 = new PipedReader(1874);
    CSVParser cSVParser0 = cSVFormat0.parse(pipedReader0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
 * the line number.
 * </p>
 *
 * @return current record number
 */"
