focal_method,test_prefix,docstring
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test011() throws Throwable {
    URL uRL0 = MockURL.getHttpExample();
    Charset charset0 = Charset.defaultCharset();
    EvoSuiteURL evoSuiteURL0 = new EvoSuiteURL(""http://www.someFakeButWellFormedURL.org/fooExample"");
    NetworkHandling.createRemoteTextFile(evoSuiteURL0, ""bzosynjay]c\""<cjji"");
    CSVFormat cSVFormat0 = CSVFormat.newFormat('%');
    CSVParser cSVParser0 = CSVParser.parse(uRL0, charset0, cSVFormat0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"CSVRecord nextRecord() throws IOException {
    CSVRecord result = null;
    this.record.clear();
    StringBuilder sb = null;
    do {
        this.reusableToken.reset();
        this.lexer.nextToken(this.reusableToken);
        switch(this.reusableToken.type) {
            case TOKEN:
                this.addRecordValue();
                break;
            case EORECORD:
                this.addRecordValue();
                break;
            case EOF:
                if (this.reusableToken.isReady) {
                    this.addRecordValue();
                }
                break;
            case INVALID:
                throw new IOException(""(line "" + this.getCurrentLineNumber() + "") invalid parse sequence"");
            case // Ignored currently
            COMMENT:
                if (sb == null) {
                    // first comment for this record
                    sb = new StringBuilder();
                } else {
                    sb.append(Constants.LF);
                }
                sb.append(this.reusableToken.content);
                // Read another token
                this.reusableToken.type = TOKEN;
                break;
            default:
                throw new IllegalStateException(""Unexpected Token type: "" + this.reusableToken.type);
        }
    } while (this.reusableToken.type == TOKEN);
    if (!this.record.isEmpty()) {
        this.recordNumber++;
        final String comment = sb == null ? null : sb.toString();
        result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);
    }
    return result;
}","public void test022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader("""");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    CSVRecord cSVRecord0 = cSVParser0.nextRecord();
    assertNull(cSVRecord0);
}","/**
 * Parses the next record from the current point in the stream.
 *
 * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = CSVParser.parse(""Delimiter=<\t> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SurroundingSpaces:ignored SkipHeaderRecord:false"", cSVFormat1);
    cSVParser0.nextRecord();
    assertEquals(2L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public Iterator<CSVRecord> iterator() {
    return new Iterator<CSVRecord>() {

        private CSVRecord current;

        private CSVRecord getNextRecord() {
            try {
                return CSVParser.this.nextRecord();
            } catch (final IOException e) {
                // TODO: This is not great, throw an ISE instead?
                throw new RuntimeException(e);
            }
        }

        public boolean hasNext() {
            if (CSVParser.this.isClosed()) {
                return false;
            }
            if (this.current == null) {
                this.current = this.getNextRecord();
            }
            return this.current != null;
        }

        public CSVRecord next() {
            if (CSVParser.this.isClosed()) {
                throw new NoSuchElementException(""CSVParser has been closed"");
            }
            CSVRecord next = this.current;
            this.current = null;
            if (next == null) {
                // hasNext() wasn't called before
                next = this.getNextRecord();
                if (next == null) {
                    throw new NoSuchElementException(""No more CSV records available"");
                }
            }
            return next;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","public void test044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""6l'ZbrAb(756"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Iterator<CSVRecord> iterator0 = cSVParser0.iterator();
    assertNotNull(iterator0);
}","/**
 * Returns an iterator on the records.
 *
 * <p>IOExceptions occurring during the iteration are wrapped in a
 * RuntimeException.
 * If the parser is closed a call to {@code next()} will throw a
 * NoSuchElementException.</p>
 */"
"public boolean isClosed() {
    return this.lexer.isClosed();
}","public void test055() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVParser cSVParser0 = CSVParser.parse("";97;ZK9g9W%|~dI.B"", cSVFormat0);
    cSVParser0.close();
    boolean boolean0 = cSVParser0.isClosed();
    assertTrue(boolean0);
}",""
"public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {
    CSVRecord rec;
    while ((rec = this.nextRecord()) != null) {
        records.add(rec);
    }
    return records;
}","public void test066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = CSVParser.parse(""7?5Gy( ^zNH,zj\""c"", cSVFormat0);
    LinkedList<CSVRecord> linkedList0 = new LinkedList<CSVRecord>();
    LinkedList<CSVRecord> linkedList1 = cSVParser0.getRecords(linkedList0);
    assertSame(linkedList0, linkedList1);
}","/**
 * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord
 * CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @param records
 *            The collection to add to.
 * @param <T> the type of collection used.
 * @return a collection of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = CSVParser.parse(""org.apache.commons.csv.CSVParser"", cSVFormat0);
    cSVParser0.nextRecord();
    long long0 = cSVParser0.getRecordNumber();
    assertEquals(1L, long0);
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getCurrentLineNumber() {
    return this.lexer.getCurrentLineNumber();
}","public void test099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('8');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteChar((Character) null);
    StringReader stringReader0 = new StringReader(""8K:uH!LAFS\""L~maJ"");
    CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat2);
    cSVParser0.getRecords();
    long long0 = cSVParser0.getCurrentLineNumber();
    assertEquals(1L, long0);
}","/**
 * Returns the current line number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.
 * </p>
 *
 * @return current line number
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test1010() throws Throwable {
    Charset charset0 = Charset.defaultCharset();
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    // Undeclared exception!
    try {
        CSVParser.parse((URL) null, charset0, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'url' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test1111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('2');
    URL uRL0 = MockURL.getHttpExample();
    Charset charset0 = Charset.defaultCharset();
    try {
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not find: www.someFakeButWellFormedURL.org
        //
        verifyException(""org.evosuite.runtime.mock.java.net.EvoHttpURLConnection"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final String string, final CSVFormat format) throws IOException {
    Assertions.notNull(string, ""string"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new StringReader(string), format);
}","public void test1212() throws Throwable {
    Character character0 = Character.valueOf('f');
    Quote quote0 = Quote.MINIMAL;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat0 = new CSVFormat('d', character0, quote0, character0, character0, false, true, ""C;Sb^XM}1e(abVox2Zo"", (String) null, stringArray0, false);
    // Undeclared exception!
    try {
        CSVParser.parse(""C;Sb^XM}1e(abVox2Zo"", cSVFormat0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('f')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Creates a parser for the given {@link String}.
 *
 * @param string
 *            a CSV string. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either string or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final String string, final CSVFormat format) throws IOException {
    Assertions.notNull(string, ""string"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new StringReader(string), format);
}","public void test1313() throws Throwable {
    // Undeclared exception!
    try {
        CSVParser.parse(""Q$OInPz[|:#B#1.dwn"", (CSVFormat) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'format' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given {@link String}.
 *
 * @param string
 *            a CSV string. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either string or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final String string, final CSVFormat format) throws IOException {
    Assertions.notNull(string, ""string"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new StringReader(string), format);
}","public void test1414() throws Throwable {
    char[] charArray0 = new char[7];
    charArray0[0] = ')';
    Quote quote0 = Quote.ALL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat0 = new CSVFormat('#', (Character) charArray0[1], quote0, (Character) charArray0[0], (Character) charArray0[1], true, true, ""(line "", ""il"", stringArray0, true);
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('g');
    try {
        CSVParser.parse(""g`~"", cSVFormat1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (startline 1) EOF reached before encapsulated token finished
        //
        verifyException(""org.apache.commons.csv.Lexer"", e);
    }
}","/**
 * Creates a parser for the given {@link String}.
 *
 * @param string
 *            a CSV string. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either string or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final File file, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new FileReader(file), format);
}","public void test1515() throws Throwable {
    File file0 = MockFile.createTempFile(""+'9,vz!Fg?*B'"", ""50na="");
    CSVFormat cSVFormat0 = CSVFormat.newFormat('T');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('T');
    // Undeclared exception!
    try {
        CSVParser.parse(file0, cSVFormat1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The escape character and the delimiter cannot be the same ('T')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final File file, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new FileReader(file), format);
}","public void test1616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    // Undeclared exception!
    try {
        CSVParser.parse((File) null, cSVFormat0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'file' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final File file, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new FileReader(file), format);
}","public void test1717() throws Throwable {
    File file0 = MockFile.createTempFile("") invalid char between encapsulated token and delimiter"", "") invalid char between encapsulated token and delimiter"");
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    FileSystemHandling.shouldAllThrowIOExceptions();
    try {
        CSVParser.parse(file0, cSVFormat1);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Simulated IOException
        //
        verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public static CSVParser parse(final File file, final CSVFormat format) throws IOException {
    Assertions.notNull(file, ""file"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new FileReader(file), format);
}","public void test1818() throws Throwable {
    MockFile mockFile0 = new MockFile("""");
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    try {
        CSVParser.parse((File) mockFile0, cSVFormat0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Creates a parser for the given {@link File}.
 *
 * @param file
 *            a CSV file. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either file or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"CSVRecord nextRecord() throws IOException {
    CSVRecord result = null;
    this.record.clear();
    StringBuilder sb = null;
    do {
        this.reusableToken.reset();
        this.lexer.nextToken(this.reusableToken);
        switch(this.reusableToken.type) {
            case TOKEN:
                this.addRecordValue();
                break;
            case EORECORD:
                this.addRecordValue();
                break;
            case EOF:
                if (this.reusableToken.isReady) {
                    this.addRecordValue();
                }
                break;
            case INVALID:
                throw new IOException(""(line "" + this.getCurrentLineNumber() + "") invalid parse sequence"");
            case // Ignored currently
            COMMENT:
                if (sb == null) {
                    // first comment for this record
                    sb = new StringBuilder();
                } else {
                    sb.append(Constants.LF);
                }
                sb.append(this.reusableToken.content);
                // Read another token
                this.reusableToken.type = TOKEN;
                break;
            default:
                throw new IllegalStateException(""Unexpected Token type: "" + this.reusableToken.type);
        }
    } while (this.reusableToken.type == TOKEN);
    if (!this.record.isEmpty()) {
        this.recordNumber++;
        final String comment = sb == null ? null : sb.toString();
        result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);
    }
    return result;
}","public void test1919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVParser cSVParser0 = CSVParser.parse("";97;ZK9g9W%|~dI.B"", cSVFormat0);
    cSVParser0.close();
    try {
        cSVParser0.nextRecord();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Parses the next record from the current point in the stream.
 *
 * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public List<CSVRecord> getRecords() throws IOException {
    return getRecords(new ArrayList<CSVRecord>());
}","public void test2020() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""5_`>{"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.close();
    try {
        cSVParser0.getRecords();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Parses the CSV input according to the given format and returns the content as a list of
 * {@link CSVRecord CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @return list of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public void close() throws IOException {
    if (this.lexer != null) {
        this.lexer.close();
    }
}","public void test2121() throws Throwable {
    MockFile mockFile0 = new MockFile(""Parameter '"", ""MINIMAL"");
    File file0 = MockFile.createTempFile("" ?g"", "" ?g"", (File) mockFile0);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVParser cSVParser0 = CSVParser.parse(file0, cSVFormat0);
    FileSystemHandling.shouldAllThrowIOExceptions();
    try {
        cSVParser0.close();
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Simulated IOException
        //
        verifyException(""org.evosuite.runtime.vfs.VirtualFileSystem"", e);
    }
}","/**
 * Closes resources.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {
    CSVRecord rec;
    while ((rec = this.nextRecord()) != null) {
        records.add(rec);
    }
    return records;
}","public void test2525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVParser cSVParser0 = CSVParser.parse(""CbX0>ls{(uW\""U(3Kh"", cSVFormat0);
    // Undeclared exception!
    try {
        cSVParser0.getRecords((LinkedList<CSVRecord>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVParser"", e);
    }
}","/**
 * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord
 * CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @param records
 *            The collection to add to.
 * @param <T> the type of collection used.
 * @return a collection of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {
    CSVRecord rec;
    while ((rec = this.nextRecord()) != null) {
        records.add(rec);
    }
    return records;
}","public void test2626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVParser cSVParser0 = CSVParser.parse("""", cSVFormat0);
    Collection<CSVRecord> collection0 = cSVParser0.getRecords((Collection<CSVRecord>) null);
    assertNull(collection0);
}","/**
 * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord
 * CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @param records
 *            The collection to add to.
 * @param <T> the type of collection used.
 * @return a collection of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public boolean isClosed() {
    return this.lexer.isClosed();
}","public void test2727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""bO"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    boolean boolean0 = cSVParser0.isClosed();
    assertFalse(boolean0);
}",""
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""bO"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    cSVParser0.close();
    cSVParser0.forEach(consumer0);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test2929() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = CSVParser.parse("";97;ZK9g9W%|~dI.B"", cSVFormat1);
    assertEquals(0L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3030() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    CSVParser cSVParser0 = CSVParser.parse(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> EmptyLines:ignored SkipHeaderRecord:false"", cSVFormat1);
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public Map<String, Integer> getHeaderMap() {
    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);
}","public void test3131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = CSVParser.parse(""c79\nYt$6%kn."", cSVFormat0);
    Map<String, Integer> map0 = cSVParser0.getHeaderMap();
    assertNull(map0);
}","/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */"
"public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {
    CSVRecord rec;
    while ((rec = this.nextRecord()) != null) {
        records.add(rec);
    }
    return records;
}","public void test3232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""bO"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    cSVParser0.close();
    try {
        cSVParser0.getRecords((LinkedList<CSVRecord>) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Stream closed
        //
        verifyException(""java.io.BufferedReader"", e);
    }
}","/**
 * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord
 * CSVRecords}.
 *
 * <p>
 * The returned content starts at the current parse-position in the stream.
 * </p>
 *
 * @param records
 *            The collection to add to.
 * @param <T> the type of collection used.
 * @return a collection of {@link CSVRecord CSVRecords}, may be empty
 * @throws IOException
 *             on parse error or input read-failure
 */"
"public Map<String, Integer> getHeaderMap() {
    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);
}","public void test3334() throws Throwable {
    StringReader stringReader0 = new StringReader(""bO"");
    Character character0 = Character.valueOf('*');
    Quote quote0 = Quote.ALL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, (Character) '\u0000', character0, true, true, ""bO"", ""Bl"", stringArray0, true);
    CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
    Map<String, Integer> map0 = cSVParser0.getHeaderMap();
    assertNotNull(map0);
}","/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3335() throws Throwable {
    StringReader stringReader0 = new StringReader(""bO"");
    Character character0 = Character.valueOf('*');
    Quote quote0 = Quote.ALL;
    String[] stringArray0 = new String[1];
    CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, (Character) '\u0000', character0, true, true, ""bO"", ""Bl"", stringArray0, true);
    CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
    Map<String, Integer> map0 = cSVParser0.getHeaderMap();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3436() throws Throwable {
    Character character0 = new Character('d');
    Quote quote0 = Quote.NONE;
    CSVFormat cSVFormat0 = new CSVFormat('s', character0, quote0, (Character) null, character0, true, true, ""R3XhkI<Ri}R{/A1Kq"", ""R3XhkI<Ri}R{/A1Kq"", (String[]) null, true);
    CSVParser cSVParser0 = CSVParser.parse(""R3XhkI<Ri}R{/A1Kq"", cSVFormat0);
    cSVParser0.getRecords();
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVParser cSVParser0 = CSVParser.parse(""c79\nYt$6%kn."", cSVFormat0);
    long long0 = cSVParser0.getRecordNumber();
    assertEquals(0L, long0);
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
"public long getCurrentLineNumber() {
    return this.lexer.getCurrentLineNumber();
}","public void test3638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    StringReader stringReader0 = new StringReader(""charset"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    long long0 = cSVParser0.getCurrentLineNumber();
    assertEquals(0L, long0);
}","/**
 * Returns the current line number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.
 * </p>
 *
 * @return current line number
 */"
"public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Assertions.notNull(url, ""url"");
    Assertions.notNull(charset, ""charset"");
    Assertions.notNull(format, ""format"");
    return new CSVParser(new InputStreamReader(url.openStream(), charset), format);
}","public void test3739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    File file0 = MockFile.createTempFile(""c79\nYt$6%kn."", ""c79\nYt$6%kn."");
    URL uRL0 = file0.toURL();
    Charset charset0 = Charset.defaultCharset();
    // Undeclared exception!
    try {
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}","/**
 * Creates a parser for the given URL.
 *
 * <p>
 * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
 * you close the {@code url}.
 * </p>
 *
 * @param url
 *            a URL. Must not be null.
 * @param charset
 *            the charset for the resource. Must not be null.
 * @param format
 *            the CSVFormat used for CSV parsing. Must not be null.
 * @return a new parser
 * @throws IllegalArgumentException
 *             If the parameters of the format are inconsistent or if either url, charset or format are null.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public long getRecordNumber() {
    return this.recordNumber;
}","public void test3840() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    StringReader stringReader0 = new StringReader(""bO"");
    CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    cSVParser0.forEach(consumer0);
    assertEquals(1L, cSVParser0.getRecordNumber());
}","/**
 * Returns the current record number in the input stream.
 *
 * <p>
 * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.
 * </p>
 *
 * @return current line number
 */"
