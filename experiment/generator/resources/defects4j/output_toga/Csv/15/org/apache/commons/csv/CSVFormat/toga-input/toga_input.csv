focal_method,test_prefix,docstring
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test0000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test0001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test0002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test0003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test0004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test0005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test0006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test0007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test0008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test0009() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public String getNullString() {
    return nullString;
}","public void test00112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test00122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withTrim(false);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test00224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test00229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test00333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test00336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test00444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test00659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test00664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test00767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertEquals('{', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00771() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00772() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00773() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00774() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00775() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00776() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00777() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00879() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00880() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00881() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test00882() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test00883() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00884() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00885() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00886() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00887() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00888() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test00989() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test00990() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test00991() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test00992() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test00993() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test00994() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test00995() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test00996() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test00997() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test00998() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test00999() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test010100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test010101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test010102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test010103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test010104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test010105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test010106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test010107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test010108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test011109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test011110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test011111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test011112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test011113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test011114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test011115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test011116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test011117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test011118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test012119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test012120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test012121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test012122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test012123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test012124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test012125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test012126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test012127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test012128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test012129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test012130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test012131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test012132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test012133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test013134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test013135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test013137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test013138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public String getNullString() {
    return nullString;
}","public void test013139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test013140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test013141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test013142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test014143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test014144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test014145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test014146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test014147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test014148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test014149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test014150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test014151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test015152() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test015153() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test015154() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test015155() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test015156() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test015157() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test015158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test015159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test015160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test015161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test015162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test015163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test016164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test016165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test016167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test016168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test016169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test016170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test016171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test016172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test016173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withTrailingDelimiter();
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test017174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test017175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test017176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test017177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test017178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test017179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test017180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test017181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test017182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test017183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test017184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test018185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test018186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test018187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test018188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test018189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test018190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test018191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test019192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test019193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test019194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test019195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test019197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test019198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test019199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test019200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test019201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test019202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test020203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test020204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test020205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test020206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test020207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test020208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test020209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test020210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test020211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test020212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test020213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test020214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withSkipHeaderRecord(true);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test021215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test021216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test021217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test021218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test021219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test021220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test021221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test021222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test021223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test021224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test021225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test021226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test022227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test022228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test022229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test022230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test022231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test022232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withSkipHeaderRecord(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test023233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test023234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test023235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test023236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test023237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test023238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test023239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test023240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test024242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test024243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test024244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test024245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test024246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test024247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test024248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test024249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test024250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test024251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test024252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test024253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test024254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test024255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025256() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test025257() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test025258() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test025259() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test025260() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test025261() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test025262() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test025263() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test026265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test026266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test026267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test026268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test026269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test026270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test026271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    CSVFormat cSVFormat3 = cSVFormat2.withRecordSeparator(""F&X"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test027272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test027273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test027274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test027275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test027276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test027277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test028278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test028279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test028280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test028281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test028282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test028283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test028284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test028285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test028286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertEquals('|', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test028287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test028288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test028289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""InformixUnload"");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test029290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test029291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test029292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test029293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test029294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test029295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test029296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test029297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test029298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test029299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""8B*TG]t!VT"");
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test030300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test030301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test030302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test030303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test030304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test030305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""(u1"");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test031306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test031307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test031308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test031309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test031310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test031311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""UGzGr]f"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test032312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertEquals(""A"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public String getNullString() {
    return nullString;
}","public void test032313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test032314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test032315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test032316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test032317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test032318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test032319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test032320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withRecordSeparator('A');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test033321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertEquals(""x"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test033322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test033323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test033324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test033325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test033326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test033327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test033328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test033329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test033330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test033331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test033332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test033333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('x');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test034334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test034335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test034336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test034337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test034338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test034339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test034340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertEquals(""K"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test035341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test035342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test035343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test035344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test035345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test035346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test035347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('K');
    assertEquals(""K"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrim() {
    return trim;
}","public void test036348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test036349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test036350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test036351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test036352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test036353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test036354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertEquals(""_"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test036355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test036356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test036357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test036358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test036359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('_');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test037360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test037361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test037362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test037363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test037364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test037365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test037366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test037367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test037368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test037369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test037370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test037371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test037372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test037373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertEquals(""^"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrim() {
    return trim;
}","public void test038374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test038375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test038376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertEquals(""^"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test038377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test038378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test038379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('^');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test039380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test039381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test039382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test039383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test039384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test039385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test040386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test040387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test040388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test040389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test040390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test040391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test040392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test040393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String getNullString() {
    return nullString;
}","public void test040394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test040395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test040396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test041397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test041398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test041399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test041400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test041401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test041402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test041403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test041404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test041405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test041406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test041407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test042408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test042409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test042410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test042411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test042412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test042413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    QuoteMode quoteMode0 = QuoteMode.NONE;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test043414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test043415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test043416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test043417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test043418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test043419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test043420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test043421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test043422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test043423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test043424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test044425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test044426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test044427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test044428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test044429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test044430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test044431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test044432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = new Character('c');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    CSVFormat cSVFormat3 = cSVFormat2.withSkipHeaderRecord();
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test045433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test045434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test045435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test045436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test045437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('x', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test045438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test045439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('x');
    Character character0 = new Character('x');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test046440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test046441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test046442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('|', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test046443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test046444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test046445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('\\', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test046446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test046447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test046448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertEquals('i', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test046449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test046450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('i');
    Character character0 = new Character('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote(character0);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test047451() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test047452() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test047453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test047454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test047455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test047456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test047457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test047458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test047459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test047460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote((Character) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test048461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals('\""', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test048462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test048463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test048464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test048465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertEquals('q', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test048466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test048467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test048468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    Character character0 = Character.valueOf('q');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test049469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test049470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test049471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test049472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test049473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test049474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withQuote(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test050475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test050476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test050477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test050478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test050479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test050480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test051481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test051482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test051483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test051484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test051485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test051486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test051487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test051488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test051489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test051490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test051491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withQuote('e');
    assertEquals('e', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test052492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test052493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test052494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test052495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test052496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertEquals('E', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test052497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test052498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('E');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test053499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""VV0P[AFUSpAi`"");
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test053500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test053501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""VV0P[AFUSpAi`"");
    assertEquals(""VV0P[AFUSpAi`"", cSVFormat3.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test053502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    QuoteMode quoteMode0 = QuoteMode.ALL_NON_NULL;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test054503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test054504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test054505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test054506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test054507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test054508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test055509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test055510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test055511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test055512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test055513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test055514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""VV0P[AFUSpAi`"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test056515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test056516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test056517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test056518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test056519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test056520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertEquals(""Unexpected Token type: "", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test056521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test056522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertEquals(""\r\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test056523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test056524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test056525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test056526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test056527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""Unexpected Token type: "");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test057528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test057529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test057530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test057531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test057532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test057533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test057534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test057535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""D-4!vHa1G]gN3*="");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test058536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test058537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test058538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test058539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test058540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test058541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withNullString((String) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test059542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test059543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test059544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test059545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertEquals(""z5kU"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test059546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test059547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test059548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test059549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test059550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test059551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test059552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test059553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(""z5kU"");
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test060554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test060555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public String getNullString() {
    return nullString;
}","public void test060556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test060557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test060558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test060559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test060560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test060561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test061562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test061564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test061565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test061566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test061567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test061568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test061569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test061570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test062571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test062572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test062573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test062574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test062575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test062576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test062577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test062578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test062579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test062580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test062581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test063582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test063583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test063584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test063585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test063586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test063587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test063588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test064589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test064590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test064591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test064592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test064593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test064594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test064595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test064596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test064597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test064598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test064599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test064600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test065601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test065602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test065603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test065604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test065605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test065606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test065607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test065608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test065609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test066610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat5.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test066611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat5.equals((Object) cSVFormat4));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test066612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat4.equals((Object) cSVFormat3));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test066613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertEquals('9', (char) cSVFormat5.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test066614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat5.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test066615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat5.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test066616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat5.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test066617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat5.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test066618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVFormat cSVFormat3 = cSVFormat2.withEscape('9');
    CSVFormat cSVFormat4 = cSVFormat3.withIgnoreEmptyLines();
    CSVFormat cSVFormat5 = cSVFormat4.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test067619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test067620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test067621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test067622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test067623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test067624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test067625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test067627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test067628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test067629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test067630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test067631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test067632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test067633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test067634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test068635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test068636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test068637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test068638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test068639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test068640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test068641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test068642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test068643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test069644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test069645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test069646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test069647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test069648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test069649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test069650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test069651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test069652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test069653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test070654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertEquals('|', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test070655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test070656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test070657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test070658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertEquals('W', (char) cSVFormat3.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test070659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test070660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test070661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test070662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test070663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test070664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test070665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test071666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test071667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test071668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test071669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test071670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test071671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test072672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test072673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test072674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test072675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test072676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test072677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(false);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test073678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test073679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test073680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test073681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test073682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test073683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test073684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test073685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test073686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test073687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test073688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test073689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test073690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test074691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test074692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test074693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test074694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test074695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test074696() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test074697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test074698() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test074699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test074700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test075701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test075702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test075703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test075704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test075705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test075706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test075707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test075708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test075709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test075710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test075711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertEquals('{', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test075712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test075713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test075714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test076715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test076716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test076717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test076718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test076719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test076720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test076721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test076722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test077723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test077724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test077725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test077726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test077727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test077728() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test077729() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test077730() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test077731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test078732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test078733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test078734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test078735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test078736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test078737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test078738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test078739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test078740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test078741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test078742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test079743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test079744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test079745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test079746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test079747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test079748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test079749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test079750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test079751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test079752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test079753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test080754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test080755() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test080756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test080757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test080758() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test080759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test080760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test080761() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreHeaderCase();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test081762() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test081763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test081764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test081765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test081766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test081767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test081768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test081769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test081770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test081771() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test081772() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test081773() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('D');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test082774() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test082775() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test082776() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test082777() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test082778() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test082779() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test083780() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test083781() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test083782() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test083783() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test083784() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test083785() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test083786() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test083787() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test083788() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test083789() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test083790() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test083791() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test084792() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test084793() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test084794() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test084795() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test084796() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test084797() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test084798() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test084799() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test084800() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test084801() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test084802() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test084803() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test085804() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test085805() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test085806() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test085807() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test085808() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test085809() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test085810() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test085811() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test085812() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test085813() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test085814() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test085815() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withIgnoreHeaderCase(false);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test086816() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test086817() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test086818() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test086819() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test086820() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test086821() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test087822() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test087823() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test087824() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test087825() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test087826() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test087827() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test088828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test088829() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test088830() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test088831() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test088832() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test088833() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test088834() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test088835() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test088836() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test088837() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test088838() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test088839() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test088840() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test088841() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test088842() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test088843() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = new Character('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test089844() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test089845() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test089846() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test089847() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test089848() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test089849() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test089850() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test089851() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test089852() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test089853() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test090854() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test090855() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test090856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test090857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test090858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test090859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public String getNullString() {
    return nullString;
}","public void test090860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test090861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test090862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test090863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test091864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test091865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test091866() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test091867() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test091868() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test091869() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test091870() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreEmptyLines();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test092871() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test092872() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test092873() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test092874() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test092875() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test092876() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test092877() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test092878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test092879() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test092880() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test093881() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test093882() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test093883() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test093884() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test093885() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test093886() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = new Character('6');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test094887() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test094888() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test094889() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test094890() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test094891() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments((Object[]) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test095892() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test095893() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test095894() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test095895() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test095896() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test095897() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Object[] objectArray0 = new Object[2];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test096898() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test096899() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test096900() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test096901() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test096902() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test096903() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test096904() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test096905() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test096906() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    String[] stringArray0 = new String[4];
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test097907() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test097908() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test097909() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test097910() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test097911() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test097912() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test097913() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test097914() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test097915() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test097916() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test098917() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test098918() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test098919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test098920() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test098921() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test098922() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test098923() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test098924() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test098925() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test098926() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withIgnoreHeaderCase();
    String[] stringArray0 = new String[0];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(stringArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test099927() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test099928() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test099929() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test099930() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test099931() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test099932() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Object[] objectArray0 = new Object[5];
    CSVFormat cSVFormat2 = cSVFormat1.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getNullString() {
    return nullString;
}","public void test100933() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test100934() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test100935() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test100936() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test100937() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test100938() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test100939() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test100940() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test101941() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test101942() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test101943() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test101944() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test101945() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test101946() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((String[]) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test102947() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test102948() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test102949() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test102950() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test102951() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test102952() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""TOKEN"";
    stringArray0[1] = ""VV0P[AFUSpAi`"";
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test103953() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test103954() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test103955() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test103956() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test103957() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test103958() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test103959() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test103960() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test103961() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test103962() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test103963() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test104964() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test104965() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test104966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test104967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test104968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test104969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""1"";
    stringArray0[1] = ""' in "";
    stringArray0[2] = ""org.apache.commons.csv.CSVPrinter"";
    stringArray0[3] = ""string"";
    stringArray0[4] = """";
    stringArray0[5] = ""\u2029"";
    stringArray0[6] = ""Qad|CpVro7(+/%G<ei"";
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test105970() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test105971() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test105972() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test105973() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test105974() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test105975() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test105976() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test105977() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test105978() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals('Y', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test105979() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test105980() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.MySQL;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('Y');
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test106981() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test106982() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test106983() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test106984() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test106985() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test106986() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test107987() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test107988() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test107989() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test107990() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test107991() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test107992() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test107993() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test107994() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test107995() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.InformixUnloadCsv;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test108996() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test108997() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test108998() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test108999() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1081000() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1081001() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1091002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1091003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1091004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1091005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1091006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1091007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1101008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1101009() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1101010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1101011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertEquals('\\', (char) cSVFormat3.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1101012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertEquals('W', (char) cSVFormat3.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1101013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1101014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertTrue(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1101015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withQuote('W');
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(resultSet0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1111016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1111017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertTrue(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1111018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1111019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1111020() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1111021() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat3 = cSVFormat2.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1121022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1121023() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1121024() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1121025() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1121026() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1121027() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1121028() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1121029() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1121030() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1121031() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1121032() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1131033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1131034() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test1131035() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1131036() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1131037() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1131038() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1131039() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1131040() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1131041() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1131042() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1141043() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1141044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1141045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1141046() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1141047() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1141048() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1151049() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1151050() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1151051() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1151052() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertEquals('(', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1151053() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1151054() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1151055() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1151056() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1151057() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test1151058() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1161059() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1161060() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1161061() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1161062() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1161063() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1161064() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1171065() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1171066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1171067() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1171068() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1171069() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1171070() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1171071() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1181072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1181073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1181074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1181075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1181076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1181077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1181078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1181079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1181080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1181081() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1181082() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1181083() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Class<QuoteMode> class0 = QuoteMode.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1191084() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1191085() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1191086() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1191087() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1191088() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1191089() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1191090() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(class0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1201091() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1201092() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1201093() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1201094() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1201095() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1201096() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1201097() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1201098() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertEquals('J', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1201099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1211100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1211101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1211102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1211103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1211104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1211105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1211106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1211107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1211108() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1211109() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1211110() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('Z');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withSkipHeaderRecord();
    CSVFormat cSVFormat3 = cSVFormat2.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1221111() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1221112() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1221113() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1221114() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1221115() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1221116() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1221117() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1221118() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1221119() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1221120() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1221121() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1221122() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1231123() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1231124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1231125() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1231126() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1231127() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1231128() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1231129() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1231130() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1241131() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1241132() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1241133() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1241134() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1241135() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test1241136() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertEquals("""", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1241137() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1241138() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1241139() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1241140() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1241141() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1251142() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1251143() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1251144() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1251145() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1251146() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('>', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1251147() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1251148() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('a', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1251149() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1251150() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1251151() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withCommentMarker('>');
    Character character0 = new Character('a');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1261152() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1261153() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1261154() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1261155() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1261156() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1261157() throws Throwable {
    Character character0 = new Character('C');
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1271158() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('f', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1271159() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1271160() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1271161() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1271162() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1271163() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1271164() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1271165() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test1281166() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1281167() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1281168() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1281169() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1281170() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1281171() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1281172() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1281173() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1281174() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals(""\n"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1281175() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1281176() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1281177() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('{');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1291178() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1291179() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertEquals('a', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1291180() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1291181() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1291182() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1291183() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1291184() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1291185() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1291186() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1291187() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = new Character('a');
    CSVFormat cSVFormat1 = cSVFormat0.TDF.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1301188() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1301189() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1301190() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1301191() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1301192() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1301193() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf(')');
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1311194() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1311195() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1311196() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1311197() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1311198() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1311199() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('^');
    CSVFormat cSVFormat2 = cSVFormat1.withEscape(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1321200() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1321201() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1321202() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1321203() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1321204() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1321205() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1321206() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1321207() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1321208() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1321209() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('`');
    CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1331210() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1331211() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1331212() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertEquals('@', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1331213() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1331214() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1331215() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1331216() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1331217() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1331218() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('@');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1341219() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1341220() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1341221() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1341222() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1341223() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertEquals('u', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1341224() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1341225() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public String getNullString() {
    return nullString;
}","public void test1341226() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertEquals(""\"" in "", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1341227() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1341228() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""\"" in "");
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('u');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1351229() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1351230() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1351231() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1351232() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1351233() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1351234() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1351235() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1351236() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertEquals('', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1351237() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1351238() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1351239() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1361240() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1361241() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1361242() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1361243() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1361244() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1361245() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1371246() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1371247() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1371248() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1371249() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1371250() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertEquals('K', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1371251() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1371252() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1371253() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1371254() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1371255() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1371256() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('K');
    assertEquals('\t', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1381257() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1381258() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1381259() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1381260() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1381261() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1381262() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1391263() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('E');
    assertTrue(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1391264() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('E');
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1391265() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('E');
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1391266() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('E');
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1391267() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withEscape('E');
    CSVFormat cSVFormat3 = cSVFormat2.withQuote('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1401268() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertEquals('+', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1401269() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1401270() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1401271() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1401272() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1401273() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1401274() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1401275() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1401276() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1401277() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('+');
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1411278() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1411279() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1411280() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1411281() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1411282() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1411283() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertEquals('r', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1411284() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1411285() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1411286() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1411287() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('P');
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('r');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1421288() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1421289() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1421290() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1421291() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertEquals('X', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1421292() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1421293() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('X');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1431294() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1431295() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1431296() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1431297() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1431298() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1431299() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1431300() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1431301() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1431302() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1431303() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertEquals('^', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1431304() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1431305() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1441306() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1441307() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1441308() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1441309() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertEquals('F', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1441310() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1441311() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1441312() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('F');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1451313() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1451314() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1451315() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1451316() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertTrue(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1451317() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertEquals('^', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1451318() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1451319() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withDelimiter('^');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1461320() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1461321() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1461322() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1461323() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1461324() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1461325() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertEquals(':', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1461326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1461327() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test1461328() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withDelimiter(':');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1471329() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1471330() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1471331() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1471332() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1471333() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1471334() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    Character character0 = Character.valueOf('t');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1481335() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1481336() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1481337() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1481338() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1481339() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1481340() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withNullString(""\"" in "");
    Character character0 = Character.valueOf('0');
    CSVFormat cSVFormat3 = cSVFormat2.withCommentMarker(character0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1491341() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1491342() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1491343() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertEquals('\""', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1491344() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1491345() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1491346() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1491347() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('\""');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1501348() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1501349() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1501350() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1501351() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1501352() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertEquals('E', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1501353() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1511354() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1511355() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertEquals('7', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1511356() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1511357() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1511358() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1511359() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1511360() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1511361() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertEquals('|', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1511362() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1511363() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1511364() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('7');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1521365() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1521366() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1521367() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1521368() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertEquals('E', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1521369() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1521370() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1521371() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('E');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1531372() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1531373() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1531374() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1531375() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1531376() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1531377() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1531378() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertEquals('t', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1541379() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1541380() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1541381() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1541382() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertTrue(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1541383() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1541384() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    Character character0 = new Character('6');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1551385() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1551386() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1551387() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1551388() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1551389() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1551390() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1551391() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1551392() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertFalse(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1551393() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(true);
    Class<Token.Type> class0 = Token.Type.class;
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(class0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1561394() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1561395() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1561396() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1561397() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1561398() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1561399() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1561400() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1561401() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1561402() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1561403() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertEquals('{', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1561404() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1561405() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1561406() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1561407() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1561408() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('{');
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1571409() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1571410() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1571411() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1571412() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1571413() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1571414() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1581415() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1581416() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1581417() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1581418() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1581419() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1581420() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1581421() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1581422() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1581423() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1581424() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1581425() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1581426() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1581427() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1581428() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1581429() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1591430() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1591431() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertEquals('E', (char) cSVFormat5.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1591432() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertFalse(cSVFormat5.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1591433() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertTrue(cSVFormat3.equals((Object) cSVFormat0));
}",""
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1591434() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertTrue(cSVFormat5.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1591435() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1591436() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertFalse(cSVFormat5.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1591437() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertTrue(cSVFormat4.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1591438() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1591439() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAutoFlush(true);
    CSVFormat cSVFormat3 = cSVFormat2.withTrim();
    CSVFormat cSVFormat4 = cSVFormat3.withEscape('E');
    CSVFormat cSVFormat5 = cSVFormat4.withFirstRecordAsHeader();
    assertTrue(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1601440() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1601441() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1601442() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertEquals('*', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1601443() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1601444() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1601445() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1601446() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1601447() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1601448() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1601449() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    CSVFormat cSVFormat1 = cSVFormat0.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1611450() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1611451() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public String getNullString() {
    return nullString;
}","public void test1611452() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertEquals("""", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1611453() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1611454() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1611455() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1611456() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1611457() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('f');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1621458() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1621459() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1621460() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1621461() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1621462() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1621463() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1631464() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1631465() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1631466() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1631467() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1631468() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1631469() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1631470() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1631471() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1631472() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1631473() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1631474() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1641475() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1641476() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1641477() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat4.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1641478() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1641479() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat4.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1641480() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1641481() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat4.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1641482() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1641483() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertFalse(cSVFormat4.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1641484() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1641485() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withTrim();
    CSVFormat cSVFormat3 = cSVFormat2.withAutoFlush(false);
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames(false);
    assertTrue(cSVFormat4.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1651486() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1651487() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1651488() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1651489() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1651490() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1651491() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1651492() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1651493() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1651494() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1651495() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1661496() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1661497() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1661498() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1661499() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1661500() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1661501() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1661502() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1661503() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1661504() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1661505() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames(true);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1671506() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1671507() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1671508() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1671509() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1671510() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1671511() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1671512() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1671513() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1671514() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1671515() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1671516() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1671517() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1671518() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1671519() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1671520() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    Character character0 = Character.valueOf('E');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1681521() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1681522() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1681523() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1681524() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1681525() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1681526() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1681527() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1681528() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1681529() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1681530() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1691531() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1691532() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1691533() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1691534() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1691535() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1691536() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1701537() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1701538() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1701539() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1701540() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1701541() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1701542() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1701543() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1701544() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1701545() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1701546() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1701547() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1701548() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertEquals('\\', (char) cSVFormat2.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1701549() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test1701550() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertEquals('\""', (char) cSVFormat2.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1711551() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1711552() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1711553() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1711554() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1711555() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public String getNullString() {
    return nullString;
}","public void test1711556() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertEquals(""\\N"", cSVFormat2.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test1711557() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1711558() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1711559() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1711560() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1711561() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1711562() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1721563() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1721564() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat4.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1721565() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1721566() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat4.equals((Object) cSVFormat2));
}",""
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1721567() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertEquals(""W"", cSVFormat4.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getTrim() {
    return trim;
}","public void test1721568() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1721569() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat4.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1721570() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test1721571() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat4.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1721572() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('W');
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreEmptyLines();
    CSVFormat cSVFormat4 = cSVFormat3.withAllowMissingColumnNames();
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1731573() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1731574() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1731575() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test1731576() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1731577() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1731578() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1731579() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1731580() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1731581() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1731582() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withAutoFlush(true);
    CSVFormat cSVFormat2 = cSVFormat1.withAllowMissingColumnNames();
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1741583() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""TDF"");
    assertFalse(cSVFormat0.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1751584() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.valueOf(""InformixUnload"");
    assertEquals(""\n"", cSVFormat0.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, final Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test1761585() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    MockFile mockFile0 = new MockFile(""$VALUES"", ""Escape=<"");
    Charset charset0 = Charset.defaultCharset();
    CSVPrinter cSVPrinter0 = cSVFormat0.print((File) mockFile0, charset0);
    assertNotNull(cSVPrinter0);
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1771586() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1771587() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1771588() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1771589() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1771590() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1771591() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1771592() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1771593() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1771594() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    boolean boolean0 = cSVFormat1.getSkipHeaderRecord();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test1781595() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    String string0 = cSVFormat0.getRecordSeparator();
    assertEquals(""\r\n"", string0);
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1791596() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1791597() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1791598() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1791599() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1791600() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1791601() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1791602() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrim() {
    return trim;
}","public void test1791603() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1791604() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1791605() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1791606() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    cSVFormat1.getQuoteMode();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1801607() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1801608() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1801609() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertEquals('o', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1801610() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1801611() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1801612() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1801613() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1801614() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('o');
    cSVFormat0.getQuoteCharacter();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1811615() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1811616() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1811617() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1811618() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String getNullString() {
    return nullString;
}","public void test1811619() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(""INVALID"", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1811620() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1811621() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1811622() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1811623() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""INVALID"");
    String string0 = cSVFormat1.getNullString();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public String getNullString() {
    return nullString;
}","public void test1821624() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    String string0 = cSVFormat0.getNullString();
    assertEquals("""", string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1831625() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1831626() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1831627() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1831628() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1831629() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1831630() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test1831631() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1831632() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1831633() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1831634() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertTrue(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1831635() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1831636() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat1.getIgnoreSurroundingSpaces();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1841637() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1841638() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertTrue(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1841639() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test1841640() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1841641() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1841642() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.getIgnoreHeaderCase();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1851643() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertFalse(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test1861644() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1871645() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    char char0 = cSVFormat0.getDelimiter();
    assertEquals(',', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1881646() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1881647() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1881648() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1881649() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1881650() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('6', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1881651() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1881652() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1881653() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test1891654() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1891655() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1891656() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1891657() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test1891658() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test1891659() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrim() {
    return trim;
}","public void test1891660() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1891661() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test1891662() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test1891663() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test1891664() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertEquals('W', (char) character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test1891665() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test1891666() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker('W');
    Character character0 = cSVFormat1.getCommentMarker();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test1901667() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1901668() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test1901669() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test1901670() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test1901671() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertTrue(boolean0);
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test1901672() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withAutoFlush(true);
    boolean boolean0 = cSVFormat1.getAutoFlush();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test1911673() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertTrue(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public CSVFormat withQuote(final char quoteChar) {
    return withQuote(Character.valueOf(quoteChar));
}","public void test1921674() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = Character.valueOf('o');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withQuote('o');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('o')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withEscape(final Character escape) {
    if (isLineBreak(escape)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test1931675() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withEscape(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('r')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.
 *
 * @param escape
 *            the escape character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withDelimiter(final char delimiter) {
    if (isLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test1941676() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    Character character0 = Character.valueOf('r');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withDelimiter('r');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the delimiter cannot be the same ('r')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.
 *
 * @param delimiter
 *            the delimiter character
 * @return A new CSVFormat that is equal to this with the specified character as delimiter
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test1951677() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    Charset charset0 = Charset.defaultCharset();
    byte[] byteArray0 = new byte[3];
    ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);
    CharBuffer charBuffer0 = charset0.decode(byteBuffer0);
    // Undeclared exception!
    try {
        cSVFormat0.printRecord(charBuffer0, objectArray0);
        fail(""Expecting exception: BufferOverflowException"");
    } catch (BufferOverflowException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.CharBuffer"", e);
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test1961678() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    CharArrayWriter charArrayWriter0 = new CharArrayWriter();
    // Undeclared exception!
    try {
        cSVFormat0.DEFAULT.printRecord(charArrayWriter0, (Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void printRecord(final Appendable out, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], out, i == 0);
    }
    println(out);
}","public void test1971679() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    PipedWriter pipedWriter0 = new PipedWriter();
    Object[] objectArray0 = new Object[2];
    try {
        cSVFormat0.printRecord(pipedWriter0, objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedWriter"", e);
    }
}","/**
 * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the
 * record separator.
 *
 * <p>
 * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record
 * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.
 * </p>
 *
 * @param out
 *            where to write.
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        // https://issues.apache.org/jira/browse/CSV-203
        if (null == nullString) {
            charSequence = EMPTY;
        } else {
            if (QuoteMode.ALL == quoteMode) {
                charSequence = quoteCharacter + nullString + quoteCharacter;
            } else {
                charSequence = nullString;
            }
        }
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test1981680() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    char[] charArray0 = new char[3];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0);
    // Undeclared exception!
    try {
        cSVFormat0.print((Object) cSVFormat0, (Appendable) charBuffer1, false);
        fail(""Expecting exception: ReadOnlyBufferException"");
    } catch (ReadOnlyBufferException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.StringCharBuffer"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        // https://issues.apache.org/jira/browse/CSV-203
        if (null == nullString) {
            charSequence = EMPTY;
        } else {
            if (QuoteMode.ALL == quoteMode) {
                charSequence = quoteCharacter + nullString + quoteCharacter;
            } else {
                charSequence = nullString;
            }
        }
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test1991681() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Object object0 = new Object();
    // Undeclared exception!
    try {
        cSVFormat0.print(object0, (Appendable) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test2001682() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    // Undeclared exception!
    try {
        cSVFormat0.TDF.print((Appendable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'out' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 */"
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, final Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test2011683() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Charset charset0 = Charset.defaultCharset();
    // Undeclared exception!
    try {
        cSVFormat0.INFORMIX_UNLOAD_CSV.print((File) null, charset0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.File"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test2021684() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    // Undeclared exception!
    try {
        cSVFormat0.TDF.parse((Reader) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Parameter 'reader' must not be null!
        //
        verifyException(""org.apache.commons.csv.Assertions"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public CSVFormat withQuote(final Character quoteChar) {
    if (isLineBreak(quoteChar)) {
        throw new IllegalArgumentException(""The quoteChar cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test2031685() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_TEXT;
    Character character0 = new Character('}');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    // Undeclared exception!
    try {
        cSVFormat1.withQuote(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('}')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2041686() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2041687() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertEquals('*', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2041688() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2041689() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2041690() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2041691() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2041692() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2041693() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2041694() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    cSVFormat0.println((Appendable) null);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public void println(final Appendable out) throws IOException {
    if (getTrailingDelimiter()) {
        out.append(getDelimiter());
    }
    if (recordSeparator != null) {
        out.append(recordSeparator);
    }
}","public void test2051695() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    // Undeclared exception!
    try {
        cSVFormat0.println((Appendable) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Outputs the trailing delimiter (if set) followed by the record separator (if set).
 *
 * @param out
 *            where to write
 * @throws IOException
 *             If an I/O error occurs
 * @since 1.4
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2061697() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter(true);
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    CSVFormat cSVFormat3 = cSVFormat2.withDelimiter('H');
    CharBuffer charBuffer0 = CharBuffer.allocate(124);
    cSVFormat3.println(charBuffer0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2081699() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2081700() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2081701() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2081702() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2081703() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2081704() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2081705() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2081706() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2081707() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('x');
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(1295);
    Charset charset0 = Charset.defaultCharset();
    CharsetEncoder charsetEncoder0 = charset0.newEncoder();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charsetEncoder0);
    cSVFormat0.MYSQL.print((Object) null, (Appendable) outputStreamWriter0, false);
    assertEquals('x', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2091708() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    StringWriter stringWriter0 = new StringWriter();
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(stringWriter0);
    BufferedWriter bufferedWriter0 = new BufferedWriter(mockPrintWriter0);
    cSVFormat0.INFORMIX_UNLOAD_CSV.print((Object) null, (Appendable) bufferedWriter0, true);
    assertEquals(""\r\n"", cSVFormat0.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2101709() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isQuoteCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2111710() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isQuoteCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2121711() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.isNullStringSet();
    assertTrue(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2131712() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.isNullStringSet();
    assertFalse(boolean0);
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2141713() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertTrue(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2151714() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.isEscapeCharacterSet();
    assertFalse(boolean0);
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test2161715() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.isCommentMarkerSet();
    assertFalse(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public String[] getHeaderComments() {
    return headerComments != null ? headerComments.clone() : null;
}","public void test2171716() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    String[] stringArray0 = cSVFormat0.getHeaderComments();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header comment array.
 *
 * @return a copy of the header comment array; {@code null} if disabled.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2181717() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2181718() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2181719() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test2181720() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2181721() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2181722() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2181723() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2181724() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2181725() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2181726() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2181727() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2181728() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withFirstRecordAsHeader();
    cSVFormat1.getHeader();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public String[] getHeader() {
    return header != null ? header.clone() : null;
}","public void test2191729() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    String[] stringArray0 = cSVFormat0.getHeader();
    assertNull(stringArray0);
}","/**
 * Returns a copy of the header array.
 *
 * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file
 */"
"public QuoteMode getQuoteMode() {
    return quoteMode;
}","public void test2201730() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    cSVFormat0.getQuoteMode();
}","/**
 * Returns the quote policy output fields.
 *
 * @return the quote policy
 */"
"public boolean getTrim() {
    return trim;
}","public void test2211731() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getTrim();
    assertFalse(boolean0);
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2221732() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    Character character0 = cSVFormat0.getQuoteCharacter();
    assertEquals('\""', (char) character0);
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2231733() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getIgnoreSurroundingSpaces();
    assertFalse(boolean0);
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test2241734() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getCommentMarker();
    assertNull(character0);
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2251735() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    Character character0 = cSVFormat0.getEscapeCharacter();
    assertNull(character0);
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2261736() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    boolean boolean0 = cSVFormat0.getIgnoreEmptyLines();
    assertTrue(boolean0);
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2271737() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getIgnoreHeaderCase();
    assertFalse(boolean0);
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2281738() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getTrailingDelimiter();
    assertFalse(boolean0);
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2291739() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    boolean boolean0 = cSVFormat0.getAutoFlush();
    assertFalse(boolean0);
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2301740() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2301741() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2301742() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2301743() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2301744() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2301745() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2301746() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2301747() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertEquals('J', char0);
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2301748() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('J');
    char char0 = cSVFormat0.getDelimiter();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2311749() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2311750() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2311751() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2311752() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2311753() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2311754() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((Class<? extends Enum<?>>) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {
    return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test2331756() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    QuoteMode quoteMode0 = QuoteMode.NONE;
    // Undeclared exception!
    try {
        cSVFormat0.withQuoteMode(quoteMode0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // No quotes mode set but no escape character is set
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.
 *
 * @param quoteModePolicy
 *            the quote policy to use for output.
 *
 * @return A new CSVFormat that is equal to this but with the specified quote policy
 */"
"public CSVFormat withCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test2341757() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('K');
    Character character0 = Character.valueOf('K');
    // Undeclared exception!
    try {
        cSVFormat1.withCommentMarker(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start and the escape character cannot be the same ('K')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker, use {@code null} to disable
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withCommentMarker(final char commentMarker) {
    return withCommentMarker(Character.valueOf(commentMarker));
}","public void test2351758() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.RFC4180;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('%');
    CSVFormat cSVFormat2 = cSVFormat1.withFirstRecordAsHeader();
    // Undeclared exception!
    try {
        cSVFormat2.withCommentMarker('%');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The comment start character and the quoteChar cannot be the same ('%')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
 *
 * Note that the comment start character is only recognized at the start of a line.
 *
 * @param commentMarker
 *            the comment start marker
 * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withEscape(final char escape) {
    return withEscape(Character.valueOf(escape));
}","public void test2361759() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('v');
    // Undeclared exception!
    try {
        cSVFormat0.withEscape('v');
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The escape character and the delimiter cannot be the same ('v')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.
 *
 * @param escape
 *            the escape character
 * @return A new CSVFormat that is equal to his but with the specified character as the escape character
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public CSVFormat withQuote(final Character quoteChar) {
    if (isLineBreak(quoteChar)) {
        throw new IllegalArgumentException(""The quoteChar cannot be a line break"");
    }
    return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);
}","public void test2371760() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(' ');
    Character character0 = Character.valueOf(' ');
    // Undeclared exception!
    try {
        cSVFormat0.withQuote(character0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The quoteChar character and the delimiter cannot be the same (' ')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
 *
 * @param quoteChar
 *            the quoteChar character, use {@code null} to disable
 * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
 * @throws IllegalArgumentException
 *             thrown if the specified character is a line break
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2381761() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2381762() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2381763() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2381764() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2381765() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2381766() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2391767() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2391768() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2391769() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> SkipHeaderRecord:false Header:[]"", string0);
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2391770() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat1 = cSVFormat0.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2401771() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2401772() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> SkipHeaderRecord:false HeaderComments:[null, null, null, null, null, null, null, null, null]"", string0);
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2401773() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2401774() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Object[] objectArray0 = new Object[9];
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2411775() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<\t> Escape=<\\> NullString=<\\N> RecordSeparator=<\n> SurroundingSpaces:ignored SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2411776() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2411777() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2411778() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2421779() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('I');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2421780() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('I');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2421781() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('I');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2421782() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('I');
    String string0 = cSVFormat0.toString();
    assertEquals(""Delimiter=<I> SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2421783() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('I');
    String string0 = cSVFormat0.toString();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2431784() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('t');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> CommentStart=<t> RecordSeparator=<\r\n> SkipHeaderRecord:false"", string0);
}",""
"public boolean getTrim() {
    return trim;
}","public void test2431785() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('t');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2431786() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('t');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2431787() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('t');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2431788() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = new Character('t');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    String string0 = cSVFormat1.toString();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2441789() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2441790() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2441791() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2441792() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2441793() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2441794() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.TDF;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrailingDelimiter();
    String[] stringArray0 = new String[2];
    cSVFormat1.format(stringArray0);
    assertTrue(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2451795() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String[] stringArray0 = new String[8];
    stringArray0[1] = ""' in "";
    String string0 = cSVFormat0.format(stringArray0);
    assertEquals("",\""' in \"",,,,,,"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2461796() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    MockFile mockFile0 = new MockFile(""wdL3,"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    objectArray0[5] = (Object) ""wdL3,"";
    cSVFormat0.printRecord(mockPrintWriter0, objectArray0);
    assertTrue(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2471797() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2471798() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2471799() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2471800() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertEquals("",,,,,-?NQFsN1r T~3cg--`$L---,"", string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2471801() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2471802() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('-');
    Object[] objectArray0 = new Object[7];
    objectArray0[5] = (Object) ""?NQFsN1r T~3cg-`$L-"";
    String string0 = cSVFormat1.format(objectArray0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2501807() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[18];
    objectArray0[0] = (Object) cSVFormat0;
    cSVFormat0.POSTGRESQL_CSV.format(objectArray0);
    assertTrue(cSVFormat0.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2511808() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2511809() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2511810() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2511811() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertEquals('6', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2511812() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2511813() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2511814() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2511815() throws Throwable {
    CSVFormat.Predefined[] cSVFormat_PredefinedArray0 = CSVFormat.Predefined.values();
    CSVFormat cSVFormat0 = CSVFormat.newFormat('6');
    cSVFormat0.format(cSVFormat_PredefinedArray0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2521816() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2521817() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertFalse(cSVFormat2.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2521818() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2521819() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertFalse(cSVFormat2.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2521820() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertTrue(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2521821() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    MockFile mockFile0 = new MockFile(""[5u7'?-.Ckp?^KopS"", ""\"" in "");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    Object[] objectArray0 = new Object[8];
    cSVFormat2.printRecord(mockPrintWriter0, objectArray0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2531822() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    cSVFormat0.MYSQL.format(objectArray0);
    assertFalse(cSVFormat0.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test2541823() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals('(', (char) cSVFormat1.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2541824() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2541825() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2541826() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2541827() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test2541828() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2541829() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2541830() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2541831() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test2541832() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(boolean0);
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2541833() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2541834() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2541835() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2541836() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('(');
    boolean boolean0 = cSVFormat1.isCommentMarkerSet();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2551837() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('@');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2551838() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('@');
    cSVFormat0.hashCode();
    assertEquals('@', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2551839() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('@');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2551840() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('@');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2551841() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('@');
    cSVFormat0.hashCode();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2561842() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2561843() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2561844() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2561845() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2561846() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2561847() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2561848() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2561849() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord(true);
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2571850() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2571851() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2571852() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test2571853() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2571854() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2571855() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    cSVFormat1.hashCode();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreHeaderCase ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test2581856() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    cSVFormat0.TDF.hashCode();
}",""
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + delimiter;
    result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());
    result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());
    result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());
    result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());
    result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());
    result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);
    result = prime * result + (ignoreHeaderCase ? 1231 : 1237);
    result = prime * result + (ignoreEmptyLines ? 1231 : 1237);
    result = prime * result + (skipHeaderRecord ? 1231 : 1237);
    result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());
    result = prime * result + Arrays.hashCode(header);
    return result;
}","public void test2591857() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    cSVFormat0.MYSQL.hashCode();
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2601858() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2601859() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2601860() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2601861() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2601862() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2601863() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2601864() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2601865() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2601866() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2601867() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2601868() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    Object[] objectArray0 = new Object[0];
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withHeaderComments(objectArray0);
    cSVFormat1.printer();
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2611869() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    assertFalse(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2611870() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2611871() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2611872() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.equals((Object) cSVFormat2));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test2611873() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2611874() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2611875() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2611876() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getTrim() {
    return trim;
}","public void test2611877() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2611878() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2611879() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2611880() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Class<CSVFormat.Predefined> class0 = CSVFormat.Predefined.class;
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(class0);
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat2 = cSVFormat1.withQuoteMode(quoteMode0);
    CSVFormat cSVFormat3 = cSVFormat2.withIgnoreSurroundingSpaces(true);
    PipedReader pipedReader0 = new PipedReader(126);
    cSVFormat3.parse(pipedReader0);
    assertFalse(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test2621881() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    // Undeclared exception!
    try {
        cSVFormat0.format((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2631882() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2631883() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2631884() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2631885() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2631886() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2631887() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2631888() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2631889() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2631890() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator(""InformixUnload"");
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2641891() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2641892() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2641893() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2641894() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2641895() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2641896() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2641897() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(boolean0);
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2641898() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2641899() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2641900() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('V');
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('V', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public String getNullString() {
    return nullString;
}","public void test2651901() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2651902() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2651903() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2651904() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2651905() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2651906() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2651907() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2651908() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2651909() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2651910() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2651911() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2651912() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2661913() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2661914() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('\\', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2661915() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2661916() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2661917() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2661918() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2661919() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2661920() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2661921() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2661922() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2671923() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2671924() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2671925() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2671926() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2671927() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2671928() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2671929() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2671930() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertEquals('$', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2671931() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD;
    CSVFormat cSVFormat1 = cSVFormat0.withEscape('$');
    cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2681932() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2681933() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2681934() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getTrim() {
    return trim;
}","public void test2681935() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2681936() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2681937() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2681938() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2681939() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2681940() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2681941() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2681942() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2681943() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""org.apache.commons.csv.Token$Type"";
    stringArray0[1] = """";
    CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2691944() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat0.equals((Object) cSVFormat1));
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test2691945() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2691946() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2691947() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2691948() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2691949() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2691950() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2691951() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2691952() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2691953() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2691954() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2691955() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVFormat cSVFormat1 = cSVFormat0.withQuote('i');
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2701956() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = CSVFormat.POSTGRESQL_TEXT;
    boolean boolean0 = cSVFormat0.equals(cSVFormat1);
    assertFalse(boolean0);
}",""
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2711957() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2711958() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2711959() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2711960() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2711961() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase(false);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2721962() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = CSVFormat.TDF;
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2731963() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2731964() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2731965() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2731966() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2731967() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2731968() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2731969() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2731970() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2731971() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2731972() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2731973() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2731974() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    Character character0 = Character.valueOf('@');
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withCommentMarker(character0);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2741975() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2741976() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2741977() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2741978() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2741979() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(boolean0);
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2741980() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2741981() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertEquals('K', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2741982() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2741983() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2741984() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('K');
    Double double0 = new Double((-1.0));
    boolean boolean0 = cSVFormat0.equals(double0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2751985() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.POSTGRESQL_CSV;
    boolean boolean0 = cSVFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2761986() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.equals(cSVFormat0);
    assertTrue(boolean0);
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2771987() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2771988() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('\""', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2771989() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2771990() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2771991() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(boolean0);
}",""
"public char getDelimiter() {
    return delimiter;
}","public void test2771992() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertEquals('|', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2771993() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2771994() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2771995() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2771996() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test2771997() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2771998() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD.withIgnoreHeaderCase(true);
    boolean boolean0 = cSVFormat1.equals(cSVFormat0);
    assertFalse(cSVFormat1.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2781999() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2782000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2782001() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2782002() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2782003() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2782004() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2782005() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2782006() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2782007() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2782008() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.DEFAULT.withCommentMarker((Character) null);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public String getNullString() {
    return nullString;
}","public void test2792009() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    String string0 = cSVFormat0.getNullString();
    assertNull(string0);
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2802010() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    boolean boolean0 = cSVFormat0.getAllowMissingColumnNames();
    assertFalse(boolean0);
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2812011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2812012() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2812013() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertTrue(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2812014() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2812015() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertTrue(cSVFormat3.equals((Object) cSVFormat0));
}",""
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2812016() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withTrim();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader(resultSet0);
    CSVFormat cSVFormat3 = cSVFormat2.withTrailingDelimiter(false);
    assertTrue(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2822017() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2822018() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2822019() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2822020() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2822021() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getQuoteCharacter() {
    return quoteCharacter;
}","public void test2822022() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertEquals('=', (char) cSVFormat1.getQuoteCharacter());
}","/**
 * Returns the character used to encapsulate values containing special characters.
 *
 * @return the quoteChar character, may be {@code null}
 */"
"public Character getEscapeCharacter() {
    return escapeCharacter;
}","public void test2822023() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertEquals('\""', (char) cSVFormat1.getEscapeCharacter());
}","/**
 * Returns the escape character.
 *
 * @return the escape character, may be {@code null}
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2822024() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2822025() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertEquals(',', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2822026() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2822027() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.POSTGRESQL_CSV.withQuote('=');
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (header != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(header));
    }
    return sb.toString();
}","public void test2832028() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    String string0 = cSVFormat0.INFORMIX_UNLOAD_CSV.toString();
    assertEquals(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\n> EmptyLines:ignored SkipHeaderRecord:false"", string0);
}",""
"@SuppressWarnings(""resource"")
public CSVPrinter print(final File out, final Charset charset) throws IOException {
    // The writer will be closed when close() is called.
    return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);
}","public void test2842029() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    MockFile mockFile0 = new MockFile("""", """");
    Charset charset0 = Charset.defaultCharset();
    try {
        cSVFormat0.print((File) mockFile0, charset0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public CSVParser parse(final Reader in) throws IOException {
    return new CSVParser(in, this);
}","public void test2852030() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.INFORMIX_UNLOAD_CSV.withFirstRecordAsHeader();
    PipedReader pipedReader0 = new PipedReader();
    try {
        cSVFormat1.parse(pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Parses the specified content.
 *
 * <p>
 * See also the various static parse methods on {@link CSVParser}.
 * </p>
 *
 * @param in
 *            the input stream
 * @return a parser over a stream of {@link CSVRecord}s.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2862031() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertEquals(""L"", cSVFormat2.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2862032() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2862033() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat2.equals((Object) cSVFormat1));
}",""
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2862034() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat2.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2862035() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2862036() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2862037() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2862038() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2862039() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2862040() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2862041() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat2.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2862042() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test2862043() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertEquals(':', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2862044() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withCommentMarker(':');
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator('L');
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2872045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2872046() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrim() {
    return trim;
}","public void test2872047() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2872048() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2872049() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2872050() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2872051() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2872052() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertEquals('1', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2872053() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('1');
    cSVFormat0.getRecordSeparator();
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    if (delimiter != other.delimiter) {
        return false;
    }
    if (quoteMode != other.quoteMode) {
        return false;
    }
    if (quoteCharacter == null) {
        if (other.quoteCharacter != null) {
            return false;
        }
    } else if (!quoteCharacter.equals(other.quoteCharacter)) {
        return false;
    }
    if (commentMarker == null) {
        if (other.commentMarker != null) {
            return false;
        }
    } else if (!commentMarker.equals(other.commentMarker)) {
        return false;
    }
    if (escapeCharacter == null) {
        if (other.escapeCharacter != null) {
            return false;
        }
    } else if (!escapeCharacter.equals(other.escapeCharacter)) {
        return false;
    }
    if (nullString == null) {
        if (other.nullString != null) {
            return false;
        }
    } else if (!nullString.equals(other.nullString)) {
        return false;
    }
    if (!Arrays.equals(header, other.header)) {
        return false;
    }
    if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {
        return false;
    }
    if (ignoreEmptyLines != other.ignoreEmptyLines) {
        return false;
    }
    if (skipHeaderRecord != other.skipHeaderRecord) {
        return false;
    }
    if (recordSeparator == null) {
        if (other.recordSeparator != null) {
            return false;
        }
    } else if (!recordSeparator.equals(other.recordSeparator)) {
        return false;
    }
    return true;
}","public void test2882054() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.equals((Object) cSVFormat0));
}",""
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2882055() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2882056() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2882057() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2882058() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertTrue(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2882059() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreHeaderCase();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSet) null);
    assertFalse(cSVFormat2.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public String getNullString() {
    return nullString;
}","public void test2892060() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertEquals(""\\N"", cSVFormat1.getNullString());
}","/**
 * Gets the String to convert to and from {@code null}.
 * <ul>
 * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading
 * records.</li>
 * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
 * </ul>
 *
 * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}
 */"
"public boolean getTrim() {
    return trim;
}","public void test2892061() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2892062() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2892063() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2892064() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2892065() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2892066() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2892067() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertFalse(cSVFormat1.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public String getRecordSeparator() {
    return recordSeparator;
}","public void test2892068() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertEquals(""\n"", cSVFormat1.getRecordSeparator());
}","/**
 * Returns the record separator delimiting output records.
 *
 * @return the record separator
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2892069() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.MYSQL.withQuoteMode(quoteMode0);
    assertEquals('\t', cSVFormat1.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2902070() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean getTrim() {
    return trim;
}","public void test2902071() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public Character getCommentMarker() {
    return commentMarker;
}","public void test2902072() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertEquals('t', (char) cSVFormat2.getCommentMarker());
}","/**
 * Returns the character marking the start of a line comment.
 *
 * @return the comment start marker, may be {@code null}
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2902073() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat2.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2902074() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test2902075() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat2.isCommentMarkerSet());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2902076() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat1.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2902077() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat2.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2902078() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertEquals(',', cSVFormat2.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2902079() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat1.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2902080() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat2.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2902081() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertTrue(cSVFormat1.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2902082() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withIgnoreSurroundingSpaces();
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker('t');
    assertFalse(cSVFormat2.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2912083() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","public void test2912084() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat1.isQuoteCharacterSet());
}","/**
 * Returns whether a quoteChar has been defined.
 *
 * @return {@code true} if a quoteChar is defined
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2912085() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2912086() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2912087() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat3.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2912088() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2912089() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat3.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean isNullStringSet() {
    return nullString != null;
}","public void test2912090() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.isNullStringSet());
}","/**
 * Returns whether a nullString has been defined.
 *
 * @return {@code true} if a nullString is defined
 */"
"public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","public void test2912091() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.isEscapeCharacterSet());
}","/**
 * Returns whether escape are being processed.
 *
 * @return {@code true} if escapes are processed
 */"
"public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","public void test2912092() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertTrue(cSVFormat3.isCommentMarkerSet());
}","/**
 * Specifies whether comments are supported by this format.
 *
 * Note that the comment introducer character is only recognized at the start of a line.
 *
 * @return {@code true} is comments are supported, {@code false} otherwise
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2912093() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2912094() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertEquals(',', cSVFormat3.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2912095() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.INFORMIX_UNLOAD_CSV;
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    Character character0 = Character.valueOf('y');
    CSVFormat cSVFormat2 = cSVFormat1.withCommentMarker(character0);
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    stringArray0[1] = ""?+b"";
    CSVFormat cSVFormat3 = cSVFormat2.withHeader(stringArray0);
    assertFalse(cSVFormat3.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public CSVPrinter print(final Path out, final Charset charset) throws IOException {
    return print(Files.newBufferedWriter(out, charset));
}","public void test2922096() throws Throwable {
    CSVFormat.Predefined cSVFormat_Predefined0 = CSVFormat.Predefined.Excel;
    CSVFormat cSVFormat0 = cSVFormat_Predefined0.getFormat();
    MockFile mockFile0 = new MockFile("""");
    Path path0 = mockFile0.toPath();
    // Undeclared exception!
    try {
        cSVFormat0.MYSQL.print(path0, (Charset) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.file.Files"", e);
    }
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output.
 * @param charset
 *            A charset.
 * @return a printer to an output.
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 * @since 1.5
 */"
"public boolean getAutoFlush() {
    return autoFlush;
}","public void test2932097() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getAutoFlush());
}","/**
 * Returns whether to flush on close.
 *
 * @return whether to flush on close.
 * @since 1.6
 */"
"public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","public void test2932098() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getIgnoreSurroundingSpaces());
}","/**
 * Specifies whether spaces around values are ignored when parsing input.
 *
 * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.
 */"
"public boolean getTrim() {
    return trim;
}","public void test2932099() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getTrim());
}","/**
 * Returns whether to trim leading and trailing blanks.
 *
 * @return whether to trim leading and trailing blanks.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2932100() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getSkipHeaderRecord());
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","public void test2932101() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getAllowMissingColumnNames());
}","/**
 * Specifies whether missing column names are allowed when parsing the header line.
 *
 * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an
 *         {@link IllegalArgumentException}.
 */"
"public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","public void test2932102() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getTrailingDelimiter());
}","/**
 * Returns whether to add a trailing delimiter.
 *
 * @return whether to add a trailing delimiter.
 * @since 1.3
 */"
"public char getDelimiter() {
    return delimiter;
}","public void test2932103() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertEquals('*', cSVFormat0.getDelimiter());
}","/**
 * Returns the character delimiting the values (typically ';', ',' or '\t').
 *
 * @return the delimiter character
 */"
"public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","public void test2932104() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getIgnoreHeaderCase());
}","/**
 * Specifies whether header names will be accessed ignoring case.
 *
 * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.
 * @since 1.3
 */"
"public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","public void test2932105() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('*');
    MockFileWriter mockFileWriter0 = new MockFileWriter("" SkipHeaderRecord:"", false);
    cSVFormat0.POSTGRESQL_CSV.print((Appendable) mockFileWriter0);
    assertFalse(cSVFormat0.getIgnoreEmptyLines());
}","/**
 * Specifies whether empty lines between records are ignored when parsing input.
 *
 * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty
 *         records.
 */"
"public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","public void test2942106() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    boolean boolean0 = cSVFormat0.getSkipHeaderRecord();
    assertFalse(boolean0);
}","/**
 * Returns whether to skip the header record.
 *
 * @return whether to skip the header record.
 */"
"public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        // https://issues.apache.org/jira/browse/CSV-203
        if (null == nullString) {
            charSequence = EMPTY;
        } else {
            if (QuoteMode.ALL == quoteMode) {
                charSequence = quoteCharacter + nullString + quoteCharacter;
            } else {
                charSequence = nullString;
            }
        }
    } else {
        charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    this.print(value, charSequence, 0, charSequence.length(), out, newRecord);
}","public void test2952107() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    char[] charArray0 = new char[2];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    // Undeclared exception!
    try {
        cSVFormat0.print((Object) charBuffer0, (Appendable) charBuffer0, false);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""java.nio.HeapCharBuffer"", e);
    }
}","/**
 * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated
 * as needed. Useful when one wants to avoid creating CSVPrinters.
 *
 * @param value
 *            value to output.
 * @param out
 *            where to print the value.
 * @param newRecord
 *            if this a new record.
 * @throws IOException
 *             If an I/O error occurs.
 * @since 1.4
 */"
