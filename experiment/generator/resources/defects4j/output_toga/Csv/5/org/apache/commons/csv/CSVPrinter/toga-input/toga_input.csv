focal_method,test_prefix,docstring
"public String format(final Object... values) {
    final StringWriter out = new StringWriter();
    try {
        new CSVPrinter(out, this).printRecord(values);
        return out.toString().trim();
    } catch (final IOException e) {
        // should not happen because a StringWriter does not do IO.
        throw new IllegalStateException(e);
    }
}","public void test011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat(']');
    Object[] objectArray0 = new Object[7];
    objectArray0[4] = (Object) cSVFormat0;
    String string0 = cSVFormat0.format(objectArray0);
    assertNotNull(string0);
}","/**
 * Formats the specified values.
 *
 * @param values
 *            the values to format
 * @return the formatted values
 */"
"public void printRecords(final Object[] values) throws IOException {
    for (final Object value : values) {
        if (value instanceof Object[]) {
            this.printRecord((Object[]) value);
        } else if (value instanceof Iterable) {
            this.printRecord((Iterable<?>) value);
        } else {
            this.printRecord(value);
        }
    }
}","public void test022() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""NONE"", true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    // Undeclared exception!
    try {
        cSVPrinter0.printRecords((Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Prints all the objects in the given array.
 *
 * @param values
 *            the values to print.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
    final int columnCount = resultSet.getMetaData().getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i <= columnCount; i++) {
            print(resultSet.getString(i));
        }
        println();
    }
}","public void test033() throws Throwable {
    File file0 = MockFile.createTempFile(""url"", ""org.apache.commons.csv.CSVPrinter$1"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn((ResultSetMetaData) null).when(resultSet0).getMetaData();
    // Undeclared exception!
    try {
        cSVPrinter0.printRecords(resultSet0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Prints all the objects in the given JDBC result set.
 *
 * @param resultSet result set
 *            the values to print.
 * @throws IOException
 *             If an I/O error occurs
 * @throws SQLException if a database access error occurs
 */"
"public void printRecords(final Iterable<?> values) throws IOException {
    for (final Object value : values) {
        if (value instanceof Object[]) {
            this.printRecord((Object[]) value);
        } else if (value instanceof Iterable) {
            this.printRecord((Iterable<?>) value);
        } else {
            this.printRecord(value);
        }
    }
}","public void test044() throws Throwable {
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) stringBuffer0);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat0);
    // Undeclared exception!
    try {
        cSVPrinter0.printRecords((Iterable<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Prints all the objects in the given collection.
 *
 * @param values
 *            the values to print.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printRecord(final Iterable<?> values) throws IOException {
    for (final Object value : values) {
        print(value);
    }
    println();
}","public void test088() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(""out"");
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(mockFileOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.RFC4180;
    CSVPrinter cSVPrinter0 = new CSVPrinter(outputStreamWriter0, cSVFormat0);
    // Undeclared exception!
    try {
        cSVPrinter0.printRecord((Iterable<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.csv.CSVPrinter"", e);
    }
}","/**
 * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine
 * characters will be escaped.
 *
 * @param values
 *            values to output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentingEnabled()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentStart().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentStart().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test099() throws Throwable {
    Charset charset0 = Charset.defaultCharset();
    ByteBuffer byteBuffer0 = ByteBuffer.allocate(1161);
    CharBuffer charBuffer0 = charset0.decode(byteBuffer0);
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('&');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart(character0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer1, cSVFormat1);
    // Undeclared exception!
    try {
        cSVPrinter0.printComment(""S:p0sP_!"");
        fail(""Expecting exception: ReadOnlyBufferException"");
    } catch (ReadOnlyBufferException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.StringCharBuffer"", e);
    }
}","/**
 * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line
 * and occupy a least one full line. The character specified to start comments and a space will be inserted at the
 * beginning of each new line in the comment.
 * <p/>
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentingEnabled()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentStart().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentStart().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test1010() throws Throwable {
    char[] charArray0 = new char[6];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('P');
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat1);
    // Undeclared exception!
    try {
        cSVPrinter0.printComment(""FYGb0TDj"");
        fail(""Expecting exception: BufferOverflowException"");
    } catch (BufferOverflowException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.Buffer"", e);
    }
}","/**
 * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line
 * and occupy a least one full line. The character specified to start comments and a space will be inserted at the
 * beginning of each new line in the comment.
 * <p/>
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1111() throws Throwable {
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat0);
    Float float0 = new Float((-594.9592F));
    // Undeclared exception!
    try {
        cSVPrinter0.print(float0);
        fail(""Expecting exception: BufferOverflowException"");
    } catch (BufferOverflowException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.CharBuffer"", e);
    }
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1212() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""k`.3en(twdW3W"", false);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockFileWriter0, cSVFormat0);
    cSVPrinter0.close();
    Double double0 = new Double(0.0);
    try {
        cSVPrinter0.print(double0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
    }
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public CSVPrinter(final Appendable out, final CSVFormat format) {
    Assertions.notNull(out, ""out"");
    Assertions.notNull(format, ""format"");
    this.out = out;
    this.format = format;
    this.format.validate();
}","public void test1313() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""Tv/A*$"", true);
    Character character0 = new Character('/');
    Quote quote0 = Quote.NONE;
    String[] stringArray0 = new String[5];
    CSVFormat cSVFormat0 = new CSVFormat('/', character0, quote0, character0, character0, false, true, """", """", stringArray0, true);
    CSVPrinter cSVPrinter0 = null;
    try {
        cSVPrinter0 = new CSVPrinter(mockFileWriter0, cSVFormat0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // The quoteChar character and the delimiter cannot be the same ('/')
        //
        verifyException(""org.apache.commons.csv.CSVFormat"", e);
    }
}","/**
 * Creates a printer that will print values to the given stream following the CSVFormat.
 * <p/>
 * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats
 * (encapsulation and escaping with a different character) are not supported.
 *
 * @param out
 *            stream to which to print. Must not be null.
 * @param format
 *            the CSV format. Must not be null.
 * @throws IllegalArgumentException
 *             thrown if the parameters of the format are inconsistent or if either out or format are null.
 */"
"public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}","public void test1616() throws Throwable {
    File file0 = MockFile.createTempFile(""The comment start and the escape character cannot be the same ('"", ""The comment start and the escape character cannot be the same ('"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    cSVPrinter0.println();
}","/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
    final int columnCount = resultSet.getMetaData().getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i <= columnCount; i++) {
            print(resultSet.getString(i));
        }
        println();
    }
}","public void test1717() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""G=SE(HGw-"");
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    ResultSetMetaData resultSetMetaData0 = mock(ResultSetMetaData.class, new ViolatedAssumptionAnswer());
    doReturn(16).when(resultSetMetaData0).getColumnCount();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(resultSetMetaData0).when(resultSet0).getMetaData();
    doReturn((String) null, (String) null, (String) null, (String) null, (String) null).when(resultSet0).getString(anyInt());
    doReturn(true, false).when(resultSet0).next();
    cSVPrinter0.printRecords(resultSet0);
}","/**
 * Prints all the objects in the given JDBC result set.
 *
 * @param resultSet result set
 *            the values to print.
 * @throws IOException
 *             If an I/O error occurs
 * @throws SQLException if a database access error occurs
 */"
"public void printRecords(final Object[] values) throws IOException {
    for (final Object value : values) {
        if (value instanceof Object[]) {
            this.printRecord((Object[]) value);
        } else if (value instanceof Iterable) {
            this.printRecord((Iterable<?>) value);
        } else {
            this.printRecord(value);
        }
    }
}","public void test1818() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""[{"", false);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockFileWriter0, cSVFormat0);
    SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException("""");
    Object[] objectArray0 = new Object[9];
    objectArray0[5] = (Object) sQLTransactionRollbackException0;
    cSVPrinter0.printRecords(objectArray0);
    assertEquals(9, objectArray0.length);
}","/**
 * Prints all the objects in the given array.
 *
 * @param values
 *            the values to print.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentingEnabled()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentStart().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentStart().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test1919() throws Throwable {
    MockFile mockFile0 = new MockFile(""QuoteChar=<"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withCommentStart('w');
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintWriter0, cSVFormat1);
    cSVPrinter0.print(mockFile0);
    cSVPrinter0.printComment(""QuoteChar=<"");
}","/**
 * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line
 * and occupy a least one full line. The character specified to start comments and a space will be inserted at the
 * beginning of each new line in the comment.
 * <p/>
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentingEnabled()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentStart().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentStart().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test2020() throws Throwable {
    File file0 = MockFile.createTempFile(""The comment start and the escape character cannot be the same ('"", ""The comment start and the escape character cannot be the same ('"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    cSVPrinter0.printComment(""The quoteChar cannot be a line break"");
}","/**
 * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line
 * and occupy a least one full line. The character specified to start comments and a space will be inserted at the
 * beginning of each new line in the comment.
 * <p/>
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test2222() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(0);
    Charset charset0 = Charset.defaultCharset();
    OutputStreamWriter outputStreamWriter0 = new OutputStreamWriter(byteArrayOutputStream0, charset0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteChar('o');
    CSVPrinter cSVPrinter0 = new CSVPrinter(outputStreamWriter0, cSVFormat1);
    cSVPrinter0.print(outputStreamWriter0);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void flush() throws IOException {
    if (out instanceof Flushable) {
        ((Flushable) out).flush();
    }
}","public void test2727() throws Throwable {
    MockFile mockFile0 = new MockFile(""QuoteChar=<"");
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintWriter0, cSVFormat0);
    cSVPrinter0.flush();
}","/**
 * Flushes the underlying stream.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void flush() throws IOException {
    if (out instanceof Flushable) {
        ((Flushable) out).flush();
    }
}","public void test2828() throws Throwable {
    char[] charArray0 = new char[7];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0, 0, 0);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat0);
    cSVPrinter0.flush();
}","/**
 * Flushes the underlying stream.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"// ======================================================
// printing implementation
// ======================================================
public void close() throws IOException {
    if (out instanceof Closeable) {
        ((Closeable) out).close();
    }
}","public void test2929() throws Throwable {
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVPrinter cSVPrinter0 = new CSVPrinter(stringBuffer0, cSVFormat0);
    cSVPrinter0.close();
}",""
"public Appendable getOut() {
    return this.out;
}","public void test3030() throws Throwable {
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    CSVPrinter cSVPrinter0 = new CSVPrinter(stringBuffer0, cSVFormat0);
    Appendable appendable0 = cSVPrinter0.getOut();
    assertSame(appendable0, stringBuffer0);
}","/**
 * Gets the target Appendable.
 *
 * @return the target Appendable.
 */"
