focal_method,test_prefix,docstring
"public Appendable getOut() {
    return this.out;
}","public void test000() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockPrintStream mockPrintStream0 = new MockPrintStream(""x_XctZ;Lm1%Yo"");
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    Appendable appendable0 = cSVPrinter0.getOut();
    assertSame(appendable0, mockPrintStream0);
}","/**
 * Gets the target Appendable.
 *
 * @return the target Appendable.
 */"
"public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","public void test011() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.newFormat('f');
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) cSVFormat0;
    CSVFormat cSVFormat1 = cSVFormat0.withHeaderComments(objectArray0);
    StringWriter stringWriter0 = new StringWriter(23);
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    CSVPrinter cSVPrinter0 = cSVFormat1.print(stringBuffer0);
    assertNotNull(cSVPrinter0);
}","/**
 * Prints to the specified output.
 *
 * <p>
 * See also {@link CSVPrinter}.
 * </p>
 *
 * @param out
 *            the output
 * @return a printer to an output
 * @throws IOException
 *             thrown if the optional header cannot be printed.
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test034() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.newFormat('q');
    CSVFormat cSVFormat1 = cSVFormat0.withSkipHeaderRecord();
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    CSVFormat cSVFormat2 = cSVFormat1.withHeader((ResultSetMetaData) rowSetMetaDataImpl0);
    CSVPrinter cSVPrinter0 = cSVFormat2.print(mockPrintStream0);
    assertNotNull(cSVPrinter0);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"// ======================================================
// printing implementation
// ======================================================
@Override
public void close() throws IOException {
    if (out instanceof Closeable) {
        ((Closeable) out).close();
    }
}","public void test045() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    char[] charArray0 = new char[10];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat0);
    cSVPrinter0.close();
}",""
"// ======================================================
// printing implementation
// ======================================================
@Override
public void close() throws IOException {
    if (out instanceof Closeable) {
        ((Closeable) out).close();
    }
}","public void test056() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    cSVPrinter0.close();
}",""
"@Override
public void flush() throws IOException {
    if (out instanceof Flushable) {
        ((Flushable) out).flush();
    }
}","public void test067() throws Throwable {
    char[] charArray0 = new char[2];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(charBuffer0, cSVFormat0);
    cSVPrinter0.flush();
}","/**
 * Flushes the underlying stream.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"@Override
public void flush() throws IOException {
    if (out instanceof Flushable) {
        ((Flushable) out).flush();
    }
}","public void test078() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""org.apache.commons.csv.CSVPrinter$1"");
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    cSVPrinter0.flush();
}","/**
 * Flushes the underlying stream.
 *
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test089() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockPrintStream mockPrintStream0 = new MockPrintStream(""x_XctZ;Lm1%Yo"");
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> SkipHeaderRecord:false"");
    CSVFormat cSVFormat2 = cSVFormat1.withIgnoreSurroundingSpaces(false);
    CSVPrinter cSVPrinter0 = cSVFormat2.print(mockPrintStream0);
    cSVPrinter0.print((Object) null);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test0910() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""sh [P#W6*\""H%0y-"", true);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockFileWriter0, cSVFormat0);
    cSVPrinter0.print(quoteMode0);
    cSVPrinter0.print((Object) null);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1315() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("" ydzoB%YeeDd@"");
    CSVPrinter cSVPrinter0 = cSVFormat1.print(mockPrintStream0);
    cSVPrinter0.print((Object) null);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1416() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""sh [P#W6*\""H%0y-"", true);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.ALL;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockFileWriter0, cSVFormat1);
    cSVPrinter0.print(quoteMode0);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1517() throws Throwable {
    MockFileWriter mockFileWriter0 = new MockFileWriter(""sh [P#W6*\""H%0y-"", true);
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    QuoteMode quoteMode0 = QuoteMode.NON_NUMERIC;
    CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);
    CSVPrinter cSVPrinter0 = cSVFormat1.print(mockFileWriter0);
    long[] longArray0 = new long[6];
    cSVPrinter0.print(longArray0[5]);
    assertArrayEquals(new long[] { 0L, 0L, 0L, 0L, 0L, 0L }, longArray0);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test1820() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.TDF;
    MockPrintStream mockPrintStream0 = new MockPrintStream(""x_XctZ;Lm1%Yo"");
    CSVFormat cSVFormat1 = cSVFormat0.withNullString("" ydzoB%YeeDd@"");
    CSVPrinter cSVPrinter0 = cSVFormat1.print(mockPrintStream0);
    cSVPrinter0.print((Object) null);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void print(final Object value) throws IOException {
    // null values are considered empty
    String strValue;
    if (value == null) {
        final String nullString = format.getNullString();
        strValue = nullString == null ? Constants.EMPTY : nullString;
    } else {
        strValue = value.toString();
    }
    this.print(value, strValue, 0, strValue.length());
}","public void test2023() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    CSVFormat cSVFormat1 = cSVFormat0.withNullString(""t5\""rk\""pdWV,5B{aB6"");
    CSVFormat cSVFormat2 = cSVFormat1.withRecordSeparator(""t5\""rk\""pdWV,5B{aB6"");
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat2);
    cSVPrinter0.print((Object) null);
}","/**
 * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
 *
 * @param value
 *            value to be output.
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentMarkerSet()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentMarker().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentMarker().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test2124() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockPrintStream mockPrintStream0 = new MockPrintStream(""x_XctZ;Lm1%Yo"");
    Character character0 = Character.valueOf('m');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat1);
    cSVPrinter0.print(mockPrintStream0);
    cSVPrinter0.printComment(""x_XctZ;Lm1%Yo"");
}","/**
 * Prints a comment on a new line among the delimiter separated values.
 *
 * <p>
 * Comments will always begin on a new line and occupy a least one full line. The character specified to start
 * comments and a space will be inserted at the beginning of each new line in the comment.
 * </p>
 *
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentMarkerSet()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentMarker().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentMarker().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test2225() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""m-dDQ^z+5=W)v/r}4*"");
    CSVFormat cSVFormat0 = CSVFormat.MYSQL;
    Character character0 = Character.valueOf('>');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat1);
    cSVPrinter0.printComment(""Delimiter=<\t> Escape=<> RecordSeparator=<\n> EmptyLines:ignored SkipHeaderRecord:false"");
}","/**
 * Prints a comment on a new line among the delimiter separated values.
 *
 * <p>
 * Comments will always begin on a new line and occupy a least one full line. The character specified to start
 * comments and a space will be inserted at the beginning of each new line in the comment.
 * </p>
 *
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printComment(final String comment) throws IOException {
    if (!format.isCommentMarkerSet()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    out.append(format.getCommentMarker().charValue());
    out.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            //$FALL-THROUGH$ break intentionally excluded.
            case LF:
                println();
                out.append(format.getCommentMarker().charValue());
                out.append(SP);
                break;
            default:
                out.append(c);
                break;
        }
    }
    println();
}","public void test2326() throws Throwable {
    CSVFormat cSVFormat0 = CSVFormat.EXCEL;
    MockPrintStream mockPrintStream0 = new MockPrintStream(""x_XctZ;Lm1%Yo"");
    Character character0 = Character.valueOf('m');
    CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat1);
    cSVPrinter0.printComment(""Delimiter=<,> QuoteChar=<\""> RecordSeparator=<\r\n> SkipHeaderRecord:false"");
}","/**
 * Prints a comment on a new line among the delimiter separated values.
 *
 * <p>
 * Comments will always begin on a new line and occupy a least one full line. The character specified to start
 * comments and a space will be inserted at the beginning of each new line in the comment.
 * </p>
 *
 * If comments are disabled in the current CSV format this method does nothing.
 *
 * @param comment
 *            the comment to output
 * @throws IOException
 *             If an I/O error occurs
 */"
"public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
    final int columnCount = resultSet.getMetaData().getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i <= columnCount; i++) {
            print(resultSet.getObject(i));
        }
        println();
    }
}","public void test2731() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    doReturn(false).when(resultSet0).next();
    cSVPrinter0.printRecords(resultSet0);
}","/**
 * Prints all the objects in the given JDBC result set.
 *
 * @param resultSet
 *            result set the values to print.
 * @throws IOException
 *             If an I/O error occurs
 * @throws SQLException
 *             if a database access error occurs
 */"
"public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
    final int columnCount = resultSet.getMetaData().getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i <= columnCount; i++) {
            print(resultSet.getObject(i));
        }
        println();
    }
}","public void test2832() throws Throwable {
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(byteArrayOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
    CSVPrinter cSVPrinter0 = new CSVPrinter(mockPrintStream0, cSVFormat0);
    RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl();
    ResultSet resultSet0 = mock(ResultSet.class, new ViolatedAssumptionAnswer());
    doReturn(rowSetMetaDataImpl0).when(resultSet0).getMetaData();
    doReturn(true, true, true, true, true).when(resultSet0).next();
    // Undeclared exception!
    cSVPrinter0.printRecords(resultSet0);
}","/**
 * Prints all the objects in the given JDBC result set.
 *
 * @param resultSet
 *            result set the values to print.
 * @throws IOException
 *             If an I/O error occurs
 * @throws SQLException
 *             if a database access error occurs
 */"
